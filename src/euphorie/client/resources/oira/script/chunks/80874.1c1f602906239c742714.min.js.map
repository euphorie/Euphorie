{"version":3,"file":"chunks/80874.1c1f602906239c742714.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/embed.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","// From: tiptap/demos/src/Experiments/GenericFigure/Vue/figure.ts\nimport { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { log } from \"../tiptap\";\nimport { Node, mergeAttributes } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nlet context_menu_instance;\n\nfunction pattern_embed_context_menu({ app: app }) {\n    class Pattern extends BasePattern {\n        static name = \"tiptap-embed-context-menu\";\n        static trigger = \".tiptap-embed-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_edit = this.el.querySelector(\".tiptap-edit-embed\");\n            const btn_remove = this.el.querySelector(\".tiptap-remove-embed\");\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", () => {\n                    app.toolbar.embed.click();\n                });\n\n            btn_remove &&\n                btn_remove.addEventListener(\"click\", () => {\n                    app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n                    app.editor.commands.deleteSelection();\n                    app.editor.commands.focus();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction embed_panel({ app }) {\n    return {\n        name: \"tiptap-embed-panel\",\n        trigger: app.options.embed?.panel,\n\n        init(embed_panel) {\n            const embed_src = embed_panel.querySelector(\"[name=tiptap-src]\");\n            if (!embed_src) {\n                log.warn(\"No src input in embed panel found.\");\n                return;\n            }\n\n            const embed_title = embed_panel.querySelector(\"[name=tiptap-title]\");\n            const embed_caption = embed_panel.querySelector(\"[name=tiptap-caption]\");\n            const embed_confirm = embed_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n\n            focus_handler(embed_panel);\n\n            // Get embed node\n            const node_embed = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n\n            // Get figcaption node, if it exists\n            app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n            const node_figure = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            const node_figcaption = node_figure?.content.content.filter(\n                (it) => it.type.name === \"figcaption\"\n            )?.[0];\n\n            // Populate form fields\n            if (node_embed) {\n                embed_src.value = node_embed.attrs?.src || \"\";\n                if (embed_title) {\n                    embed_title.value = node_embed.attrs?.title || \"\";\n                }\n            }\n            if (node_figcaption && embed_caption) {\n                embed_caption.value = node_figcaption.textContent || \"\";\n            }\n\n            const update_callback = (set_focus) => {\n                app.editor.commands.insertContent({\n                    type: \"figure\",\n                    content: [\n                        {\n                            type: \"embed\",\n                            attrs: {\n                                src: embed_src.value,\n                                ...(embed_title?.value && { title: embed_title.value }),\n                            },\n                        },\n                        // Conditionally add a figcaption\n                        ...(embed_caption?.value\n                            ? [\n                                  {\n                                      type: \"figcaption\",\n                                      content: [\n                                          {\n                                              type: \"text\",\n                                              text: embed_caption.value,\n                                          },\n                                      ],\n                                  },\n                              ]\n                            : []),\n                    ],\n                });\n                if (set_focus === true) {\n                    // set cursor after the embed, otherwise embed is\n                    // selected and right away deleted when starting typing.\n                    app.editor.commands.selectParentNode();\n                    app.editor.commands.focus(app.editor.state.selection.to);\n                    //app.editor.commands.blur();\n                }\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(embed_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_embed_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (embed_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    embed_confirm,\n                    \"click\",\n                    \"tiptap_embed_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                events.add_event_listener(\n                    embed_src,\n                    \"change\",\n                    \"tiptap_embed_src\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    embed_title,\n                    \"change\",\n                    \"tiptap_embed_title\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    embed_caption,\n                    \"change\",\n                    \"tiptap_embed_caption\",\n                    update_callback\n                );\n            }\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the embed-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's embed button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const embed_panel_pattern = embed_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                embed_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    embed_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"embed\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setEmbed()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (!app.options.embed.menu) {\n            // Nothing to do, return.\n            return;\n        }\n\n        // Open the context menu with a small delay.\n        utils.debounce(async () => {\n            if (!app.editor.isActive(\"embed\")) {\n                // Embed not active anymore. Return.\n                if (context_menu_instance) {\n                    // If open, close.\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-embed-context-menu\",\n                    });\n                    context_menu_instance = null;\n                }\n                return;\n            }\n\n            // Initialize the context menu\n            context_menu_instance = await context_menu({\n                url: app.options.embed.menu,\n                editor: app.editor,\n                instance: context_menu_instance,\n                pattern: pattern_embed_context_menu({ app: app }),\n                extra_class: \"tiptap-embed-menu\",\n            });\n        }, 50)();\n    });\n}\n\nexport const factory = () => {\n    const is_youtube = (src) => src.indexOf(\"youtube.com\") > -1;\n    const is_vimeo = (src) => src.indexOf(\"vimeo.com\") > -1;\n\n    return Node.create({\n        name: \"embed\",\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n            };\n        },\n\n        group: \"block\",\n\n        allowGapCursor: false,\n        draggable: false,\n        isolating: true,\n        selectable: true,\n\n        addAttributes() {\n            return {\n                src: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            };\n        },\n\n        parseHTML() {\n            return [\n                {\n                    tag: `iframe[src*=\"youtube.com\"]`,\n                    getAttrs: (node) =>\n                        (is_youtube(node.getAttribute(\"src\")) ||\n                            is_vimeo(node.getAttribute(\"src\")) > -1) &&\n                        null,\n                },\n            ];\n        },\n\n        renderHTML({ HTMLAttributes }) {\n            const attributes_youtube = {\n                width: \"560\",\n                height: \"315\",\n                allowfullscreen: \"\",\n                frameborder: \"0\",\n            };\n            const attributes_vimeo = {\n                width: \"640\",\n                height: \"360\",\n                allowfullscreen: \"\",\n                frameborder: \"0\",\n            };\n\n            let attrs;\n            if (is_youtube(HTMLAttributes.src)) {\n                attrs = {\n                    ...HTMLAttributes,\n                    ...attributes_youtube,\n                };\n                const vid = attrs.src.match(/watch.*v\\=(?<vid>[^&]*)/)?.groups?.vid;\n                if (vid) {\n                    attrs.src = `https://www.youtube.com/embed/${vid}`;\n                }\n            }\n            if (is_vimeo(HTMLAttributes.src)) {\n                attrs = {\n                    ...HTMLAttributes,\n                    ...attributes_vimeo,\n                };\n                const vid = attrs.src.match(/vimeo.com\\/(?<vid>[0-9]*)/)?.groups?.vid;\n                if (vid) {\n                    attrs.src = `https://player.vimeo.com/video/${vid}`;\n                }\n            }\n\n            return [\"iframe\", mergeAttributes(this.options.HTMLAttributes, attrs)];\n        },\n\n        addCommands() {\n            return {\n                setEmbed:\n                    (options) =>\n                    ({ commands }) => {\n                        return commands.insertContent({\n                            type: this.name,\n                            attrs: options,\n                        });\n                    },\n            };\n        },\n\n        addProseMirrorPlugins() {\n            return [\n                new Plugin({\n                    props: {\n                        handleDOMEvents: {\n                            // prevent dragging nodes out of the figure\n                            dragstart: (view, event) => {\n                                if (!event.target) {\n                                    return false;\n                                }\n\n                                const pos = view.posAtDOM(event.target, 0);\n                                const $pos = view.state.doc.resolve(pos);\n\n                                if ($pos.parent.type === this.type) {\n                                    event.preventDefault();\n                                }\n\n                                return false;\n                            },\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["PREV_NODE","async","context_menu","_ref","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","patterns","editor_element","options","element","patTooltip","events","await_pattern_init","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","add_event_listener","document","e","target","dom","get_parents","includes","popper","key","show","_ref2","hide","destroy","remove_event_listener","context_menu_instance","pattern_embed_context_menu","app","Pattern","BasePattern","static","init","focus_handler","this","el","btn_edit","querySelector","btn_remove","addEventListener","toolbar","embed","click","commands","selectParentNode","deleteSelection","focus","_ref3","button","get_data","toolbar_el","embed_panel_pattern","trigger","panel","embed_panel","embed_src","log","warn","embed_title","embed_caption","embed_confirm","node_embed","node_figure","node_figcaption","content","filter","it","type","value","attrs","src","title","textContent","update_callback","set_focus","insertContent","text","form","querySelectorAllAndMe","preventDefault","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","setEmbed","menu","utils","debounce","factory","is_youtube","indexOf","is_vimeo","Node","create","addOptions","HTMLAttributes","group","allowGapCursor","draggable","isolating","selectable","addAttributes","default","parseHTML","tag","getAttrs","node","getAttribute","renderHTML","_ref4","attributes_youtube","width","height","allowfullscreen","frameborder","attributes_vimeo","vid","match","groups","mergeAttributes","addCommands","_ref5","addProseMirrorPlugins","Plugin","props","handleDOMEvents","dragstart","event","pos","posAtDOM","resolve","parent","TARGETS","setAttribute","timeout","map"],"sourceRoot":""}