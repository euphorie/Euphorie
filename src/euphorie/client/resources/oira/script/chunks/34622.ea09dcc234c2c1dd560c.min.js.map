{"version":3,"file":"chunks/34622.ea09dcc234c2c1dd560c.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/linkifyjs/dist/linkify.es.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-link/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/link.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/utils.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */\nconst assign = (target, properties) => {\n  for (const key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token) {\n  if (token === void 0) {\n    token = null;\n  }\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly) {\n    if (exactOnly === void 0) {\n      exactOnly = false;\n    }\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL$1 = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = 'OPENBRACE'; // {\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tWORD: WORD,\n\tUWORD: UWORD,\n\tLOCALHOST: LOCALHOST,\n\tTLD: TLD,\n\tUTLD: UTLD,\n\tSCHEME: SCHEME,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tNUM: NUM,\n\tWS: WS,\n\tNL: NL$1,\n\tOPENBRACE: OPENBRACE,\n\tCLOSEBRACE: CLOSEBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tCLOSEPAREN: CLOSEPAREN,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tFULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n\tFULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n\tLEFTCORNERBRACKET: LEFTCORNERBRACKET,\n\tRIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n\tLEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n\tRIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n\tFULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n\tFULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tHYPHEN: HYPHEN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tTILDE: TILDE,\n\tUNDERSCORE: UNDERSCORE,\n\tEMOJI: EMOJI$1,\n\tSYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tLETTER: LETTER,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tDIGIT: DIGIT,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\nconst NL = '\\n'; // New line character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes) {\n  if (customSchemes === void 0) {\n    customSchemes = [];\n  }\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\n  tt(Start, '「', LEFTCORNERBRACKET);\n  tt(Start, '」', RIGHTCORNERBRACKET);\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, ASCII_LETTER, Word);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, LETTER, UWord);\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, NL, NL$1, {\n    [whitespace]: true\n  });\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender) {\n  if (defaultRender === void 0) {\n    defaultRender = null;\n  }\n  let o = assign({}, defaults);\n  if (opts) {\n    o = assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefaults: defaults,\n\tOptions: Options,\n\tassign: assign\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol) {\n    if (protocol === void 0) {\n      protocol = defaults.defaultProtocol;\n    }\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme) {\n    if (scheme === void 0) {\n      scheme = defaults.defaultProtocol;\n    }\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMultiToken: MultiToken,\n\tBase: MultiToken,\n\tcreateTokenClass: createTokenClass,\n\tEmail: Email,\n\tText: Text,\n\tNl: Nl,\n\tUrl: Url\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1(_ref) {\n  let {\n    groups\n  } = _ref;\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // （）\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // 「」\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // 『』\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\n  ];\n\n  for (let i = 0; i < bracketPairs.length; i++) {\n    const [OPEN, CLOSE] = bracketPairs[i];\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    const UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL$1, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\n  if (optionalSlashSlash === void 0) {\n    optionalSlashSlash = false;\n  }\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str, type, opts) {\n  if (type === void 0) {\n    type = null;\n  }\n  if (opts === void 0) {\n    opts = null;\n  }\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type) {\n  if (type === void 0) {\n    type = null;\n  }\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };\n","import { combineTransactionSteps, getChangedRanges, findChildrenInRange, getMarksBetween, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { tokenize, find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n    return new Plugin({\n        key: new PluginKey('autolink'),\n        appendTransaction: (transactions, oldState, newState) => {\n            /**\n             * Does the transaction change the document?\n             */\n            const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            /**\n             * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n             */\n            const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n            /**\n             * Prevent autolink if the transaction is not a document change\n             * or if the transaction has the meta `preventAutolink`.\n             */\n            if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n            const changes = getChangedRanges(transform);\n            changes.forEach(({ newRange }) => {\n                // Now let’s see if we can add new links.\n                const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n                }\n                else if (nodesInChangedRanges.length\n                    // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n                    && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace\n                        .filter(link => link.isLink)\n                        // Calculate link position.\n                        .map(link => ({\n                        ...link,\n                        from: lastWordAndBlockOffset + link.start + 1,\n                        to: lastWordAndBlockOffset + link.end + 1,\n                    }))\n                        // ignore link inside code mark\n                        .filter(link => {\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    })\n                        // validate link\n                        .filter(link => options.validate(link.value))\n                        // Add link mark.\n                        .forEach(link => {\n                        if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href,\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        },\n    });\n}\n\nfunction clickHandler(options) {\n    return new Plugin({\n        key: new PluginKey('handleClickLink'),\n        props: {\n            handleClick: (view, pos, event) => {\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let a = event.target;\n                const els = [];\n                while (a.nodeName !== 'DIV') {\n                    els.push(a);\n                    a = a.parentNode;\n                }\n                if (!els.find(value => value.nodeName === 'A')) {\n                    return false;\n                }\n                const attrs = getAttributes(view.state, options.type.name);\n                const link = event.target;\n                const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n                const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n                if (link && href) {\n                    window.open(href, target);\n                    return true;\n                }\n                return false;\n            },\n        },\n    });\n}\n\nfunction pasteHandler(options) {\n    return new Plugin({\n        key: new PluginKey('handlePasteLink'),\n        props: {\n            handlePaste: (view, event, slice) => {\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = '';\n                slice.content.forEach(node => {\n                    textContent += node.textContent;\n                });\n                const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent);\n                if (!textContent || !link) {\n                    return false;\n                }\n                options.editor.commands.setMark(options.type, {\n                    href: link.href,\n                });\n                return true;\n            },\n        },\n    });\n}\n\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];\n    if (protocols) {\n        protocols.forEach(protocol => {\n            const nextProtocol = (typeof protocol === 'string' ? protocol : protocol.scheme);\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    // eslint-disable-next-line no-useless-escape\n    return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(`^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = Mark.create({\n    name: 'link',\n    priority: 1000,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate() {\n        this.options.protocols.forEach(protocol => {\n            if (typeof protocol === 'string') {\n                registerCustomProtocol(protocol);\n                return;\n            }\n            registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy() {\n        reset();\n    },\n    inclusive() {\n        return this.options.autolink;\n    },\n    addOptions() {\n        return {\n            openOnClick: true,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: 'http',\n            HTMLAttributes: {\n                target: '_blank',\n                rel: 'noopener noreferrer nofollow',\n                class: null,\n            },\n            validate: url => !!url,\n        };\n    },\n    addAttributes() {\n        return {\n            href: {\n                default: null,\n                parseHTML(element) {\n                    return element.getAttribute('href');\n                },\n            },\n            target: {\n                default: this.options.HTMLAttributes.target,\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel,\n            },\n            class: {\n                default: this.options.HTMLAttributes.class,\n            },\n        };\n    },\n    parseHTML() {\n        return [{\n                tag: 'a[href]',\n                getAttrs: dom => {\n                    const href = dom.getAttribute('href');\n                    // prevent XSS attacks\n                    if (!href || !isAllowedUri(href, this.options.protocols)) {\n                        return false;\n                    }\n                    return null;\n                },\n            }];\n    },\n    renderHTML({ HTMLAttributes }) {\n        // prevent XSS attacks\n        if (!isAllowedUri(HTMLAttributes.href, this.options.protocols)) {\n            // strip out the href\n            return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0];\n        }\n        return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setLink: attributes => ({ chain }) => {\n                return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n            },\n            toggleLink: attributes => ({ chain }) => {\n                return chain()\n                    .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n            unsetLink: () => ({ chain }) => {\n                return chain()\n                    .unsetMark(this.name, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n        };\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: text => {\n                    const foundLinks = [];\n                    if (text) {\n                        const { validate } = this.options;\n                        const links = find(text).filter(item => item.isLink && validate(item.value));\n                        if (links.length) {\n                            links.forEach(link => (foundLinks.push({\n                                text: link.value,\n                                data: {\n                                    href: link.href,\n                                },\n                                index: link.start,\n                            })));\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: match => {\n                    var _a;\n                    return {\n                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href,\n                    };\n                },\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        const plugins = [];\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: this.options.validate,\n            }));\n        }\n        if (this.options.openOnClick === true) {\n            plugins.push(clickHandler({\n                type: this.type,\n            }));\n        }\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type,\n            }));\n        }\n        return plugins;\n    },\n});\n\nexport { Link, Link as default, pasteRegex };\n//# sourceMappingURL=index.js.map\n","import { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { log } from \"../tiptap\";\nimport LinkExtension from \"@tiptap/extension-link\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\nimport tiptap_utils from \"../utils\";\n\nlet context_menu_instance;\nlet dont_open_context_menu = false;\n\nfunction pattern_link_context_menu({ app }) {\n    // Dynamic pattern for the link context menu\n\n    class Pattern extends BasePattern {\n        static name = \"tiptap-link-context-menu\";\n        static trigger = \".tiptap-link-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_open = this.el.querySelector(\".tiptap-open-new-link\");\n            const btn_edit = this.el.querySelector(\".tiptap-edit-link\");\n            const btn_unlink = this.el.querySelector(\".tiptap-unlink\");\n\n            if (btn_open) {\n                const attrs = app.editor.getAttributes(\"link\");\n                if (attrs?.href) {\n                    btn_open.setAttribute(\"href\", attrs.href);\n                }\n                btn_open.addEventListener(\"click\", async () => {\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: this.name,\n                    });\n                    context_menu_instance = null;\n                });\n            }\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", async () => {\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: this.name,\n                    });\n                    context_menu_instance = null;\n                    app.toolbar.link.click();\n                });\n\n            btn_unlink &&\n                btn_unlink.addEventListener(\"click\", async () => {\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: this.name,\n                    });\n                    context_menu_instance = null;\n                    app.editor.chain().focus().unsetLink().run();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction link_panel({ app }) {\n    return {\n        name: \"tiptap-link-panel\",\n        trigger: app.options.link?.panel,\n\n        init(link_panel) {\n            // Close eventual opened link context menus.\n            //context_menu_close({\n            //    instance: context_menu_instance,\n            //    pattern_name: \"tiptap-link-context-menu\",\n            //});\n            //context_menu_instance = null;\n\n            const link_href = link_panel.querySelector(\"[name=tiptap-href]\");\n            if (!link_href) {\n                log.warn(\"No href input in link panel found.\");\n                return;\n            }\n\n            const link_text = link_panel.querySelector(\"[name=tiptap-text]\");\n            const link_target = link_panel.querySelector(\"[name=tiptap-target]\");\n            const link_confirm = link_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n            const link_remove = link_panel.querySelector(\"[name=tiptap-remove]\");\n\n            focus_handler(link_panel);\n\n            // Store the current cursor position.\n            // While extending the selection below the cursor position is changed and\n            // we want it back where we left.\n            const last_cursor_position = app.editor.state.selection.$head.pos;\n\n            const selection_from = app.editor.state.selection.from;\n            const selection_to = app.editor.state.selection.to;\n\n            const node = app.editor.state.doc.nodeAt(selection_from);\n            const attrs = app.editor.getAttributes(\"link\");\n            const is_link = attrs.href !== undefined;\n\n            if (is_link) {\n                // Extend the selection to whole link.\n                // Necessary to get the whole link scope and the correct text.\n                dont_open_context_menu = true; // setting a selection on a link would open the context menu.\n                app.editor.commands.extendMarkRange(\"link\");\n                dont_open_context_menu = false;\n            }\n\n            // FORM INITIALIZATION\n            if (attrs?.href) {\n                link_href.value = attrs.href;\n                link_href.dispatchEvent(new Event(\"input\"));\n            }\n            if (attrs?.target && link_target) {\n                link_target.checked = true;\n                link_target.dispatchEvent(new Event(\"input\"));\n            }\n\n            let text_content = null;\n            if (selection_from !== selection_to) {\n                text_content = app.editor.state.doc.textBetween(\n                    selection_from,\n                    selection_to\n                );\n            } else if (is_link) {\n                text_content = node.text;\n            }\n            if (link_text && text_content) {\n                link_text.value = text_content;\n                link_text.dispatchEvent(new Event(\"input\"));\n            }\n\n            const update_callback = (set_focus) => {\n                const cmd = app.editor.chain();\n                const link_text_value =\n                    (link_text ? link_text.value : text_content) || \"\";\n                cmd.command(async ({ tr }) => {\n                    if (!tiptap_utils.is_url(link_href.value)) {\n                        // Correct the link href if it's not a valid url.\n                        if (tiptap_utils.is_mail(link_href.value)) {\n                            // Add `mailto:` if it's an email.\n                            // `is_email` matches for valid e-mail addresses\n                            // with `mailto:` and without, but the previous\n                            // check `is_url` would have already passed for\n                            // `mailto:` links.\n                            link_href.value = `mailto:${link_href.value}`;\n                        } else {\n                            link_href.value = `https://${link_href.value}`;\n                        }\n                    }\n                    // create = update\n                    // create prosemirror tree mark and node\n                    const mark = app.editor.state.schema.marks.link.create({\n                        href: link_href.value,\n                        target:\n                            link_target && link_target.checked\n                                ? link_target?.value\n                                : null,\n                    });\n                    const link_node = app.editor.state.schema\n                        .text(link_text_value)\n                        .mark([mark]);\n                    tr.replaceSelectionWith(link_node, false);\n                    if (set_focus === true) {\n                        // Set the cursor back to the position where we left.\n                        cmd.focus().setTextSelection(last_cursor_position);\n                    }\n                    return true;\n                });\n                cmd.run();\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(link_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_link_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (link_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    link_confirm,\n                    \"click\",\n                    \"tiptap_link_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                events.add_event_listener(\n                    link_href,\n                    \"input\",\n                    \"tiptap_link_href\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    link_text,\n                    \"input\",\n                    \"tiptap_link_text\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    link_target,\n                    \"change\",\n                    \"tiptap_link_target\",\n                    update_callback\n                );\n            }\n\n            events.add_event_listener(link_remove, \"click\", \"tiptap_link_remove\", () =>\n                app.editor.chain().focus().unsetLink().run()\n            );\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the link-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's link button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const link_panel_pattern = link_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                link_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    link_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"link\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setLink()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (dont_open_context_menu) {\n            // Temporarily don't open the context menu.\n            return;\n        }\n\n        if (!app.options.link.menu) {\n            // Nothing to do, return.\n            return;\n        }\n\n        // Open the context menu with a small delay.\n        utils.debounce(async () => {\n            if (!app.editor.isActive(\"link\")) {\n                // Link not active anymore. Return.\n                if (context_menu_instance) {\n                    // If open, close.\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-link-context-menu\",\n                    });\n                    context_menu_instance = null;\n                }\n                return;\n            }\n            // Initialize the context menu\n            context_menu_instance = await context_menu({\n                url: app.options.link.menu,\n                editor: app.editor,\n                instance: context_menu_instance,\n                pattern: pattern_link_context_menu({ app: app }),\n                extra_class: \"tiptap-link-menu\",\n            });\n        }, 50)();\n    });\n}\n\nexport const factory = () => {\n    return LinkExtension.extend({\n        parseHTML() {\n            return [\n                {\n                    tag: 'a[href]:not([href *= \"javascript:\" i]):not([contenteditable=\"false\"]):not([data-mention]):not([data-tag])',\n                },\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n","export const add_search_params = (url, params = {}) => {\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams#examples\n    const url_obj = new URL(url, window.location.href);\n    return `${url_obj.origin}${url_obj.pathname}?${new URLSearchParams([\n        ...Array.from(url_obj.searchParams.entries()),\n        ...Object.entries(params),\n    ]).toString()}`;\n};\n\n// Export a list of WAI attributes.\nexport const accessibility_attributes = [\n    \"aria-activedescendant\",\n    \"aria-atomic\",\n    \"aria-autocomplete\",\n    \"aria-busy\",\n    \"aria-checked\",\n    \"aria-controls\",\n    \"aria-describedby\",\n    \"aria-disabled\",\n    \"aria-dropeffect\",\n    \"aria-expanded\",\n    \"aria-flowto\",\n    \"aria-grabbed\",\n    \"aria-haspopup\",\n    \"aria-hidden\",\n    \"aria-invalid\",\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-level\",\n    \"aria-live\",\n    \"aria-multiline\",\n    \"aria-multiselectable\",\n    \"aria-orientation\",\n    \"aria-owns\",\n    \"aria-posinset\",\n    \"aria-pressed\",\n    \"aria-readonly\",\n    \"aria-relevant\",\n    \"aria-required\",\n    \"aria-selected\",\n    \"aria-setsize\",\n    \"aria-sort\",\n    \"aria-valuemax\",\n    \"aria-valuemin\",\n    \"aria-valuenow\",\n    \"aria-valuetext\",\n    \"role\",\n];\n\n/**\n * Test, if a given string is a absolute or relative URL.\n *\n * @param {string} value - The URL to test.\n * @returns {boolean} True, if the value is a absolute or relative URL.\n */\nexport const is_url = (value) => {\n    // Search for relative or absolute URLs (e.g. `/`, `./`, `../`) or for\n    // any URL with a protocol (e.g. `http://`, `https://`, `mailto:`).\n    const re_url = /(^\\.?\\.?\\/|^[^\\.]+:)/;\n    return re_url.test(value);\n};\n\n/**\n * Test, if a given string is a valid e-mail address.\n *\n * @param {string} value - The e-mail to test.\n * @returns {boolean} True, if the value is a valid e-mail.\n */\nexport const is_mail = (value) => {\n    const re_mail = /[^@\\s]+@[^@\\s]+\\.[^@\\s]+/;\n    return re_mail.test(value);\n};\n\nexport default {\n    add_search_params: add_search_params,\n    accessibility_attributes: accessibility_attributes,\n    is_url: is_url,\n    is_mail: is_mail,\n};\n"],"names":["PREV_NODE","async","context_menu","_ref","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","patterns","editor_element","options","element","patTooltip","events","await_pattern_init","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","add_event_listener","document","e","target","dom","get_parents","includes","popper","key","show","_ref2","hide","destroy","remove_event_listener","encodedTlds","encodedUtlds","properties","numeric","ascii","alpha","asciinumeric","alphanumeric","domain","emoji","scheme","slashscheme","whitespace","registerGroup","groups","addToGroups","t","flags","k","group","indexOf","push","State","token","this","j","jr","jd","prototype","accepts","go","input","nextState","i","length","regex","test","has","exactOnly","ta","inputs","next","tt","tr","regexp","ts","len","templateState","apply","allFlags","result","c","flagsForToken","WORD","UWORD","LOCALHOST","TLD","UTLD","SCHEME","SLASH_SCHEME","NUM","WS","NL$1","OPENBRACE","CLOSEBRACE","OPENBRACKET","CLOSEBRACKET","OPENPAREN","CLOSEPAREN","OPENANGLEBRACKET","CLOSEANGLEBRACKET","FULLWIDTHLEFTPAREN","FULLWIDTHRIGHTPAREN","LEFTCORNERBRACKET","RIGHTCORNERBRACKET","LEFTWHITECORNERBRACKET","RIGHTWHITECORNERBRACKET","FULLWIDTHLESSTHAN","FULLWIDTHGREATERTHAN","AMPERSAND","APOSTROPHE","ASTERISK","AT","BACKSLASH","BACKTICK","CARET","COLON","COMMA","DOLLAR","DOT","EQUALS","EXCLAMATION","HYPHEN","PERCENT","PIPE","PLUS","POUND","QUERY","QUOTE","SEMI","SLASH","TILDE","UNDERSCORE","EMOJI$1","SYM","tk","Object","freeze","__proto__","NL","EMOJI","ASCII_LETTER","LETTER","DIGIT","SPACE","EMOJI_VARIATION","EMOJI_JOINER","tlds","utlds","fastts","defaultt","char","slice","decodeTlds","encoded","words","stack","popDigitCount","join","popCount","parseInt","substring","pop","defaults","defaultProtocol","format","noop","formatHref","nl2br","tagName","rel","validate","truncate","Infinity","className","attributes","ignoreTags","render","Options","opts","defaultRender","o","ignoredTags","uppercaseIgnoredTags","toUpperCase","val","ir","check","get","toString","operator","isCallable","option","getObj","obj","MultiToken","value","tokens","v","createTokenClass","type","props","Token","constructor","super","p","isLink","toHref","toFormattedString","formatted","toFormattedHref","startIndex","s","endIndex","toObject","protocol","href","start","end","toFormattedObject","formattedHref","content","attrs","eventListeners","class","Email","Text","Nl","Url","hasProtocol","makeState","arg","initMultiToken","Multi","startIdx","endIdx","warn","console","warnAdvice","INIT","scanner","parser","tokenQueue","pluginQueue","customSchemes","initialized","registerCustomProtocol","optionalSlashSlash","Error","init","Start","Num","Word","UWord","Ws","Emoji","EmojiJoiner","wordjr","uwordjr","tld","utld","sort","a","b","sch","init$2","qsAccepting","concat","qsNonAccepting","localpartAccepting","Localpart","Domain","Scheme","SlashScheme","LocalpartAt","LocalpartDot","EmailDomain","EmailDomainDot","Email$1","EmailDomainHyphen","EmailColon","DomainHyphen","DomainDot","DomainDotTld","DomainDotTldColon","DomainDotTldColonPort","Url$1","UrlNonaccept","SchemeColon","SlashSchemeColon","SlashSchemeColonSlash","UriPrefix","bracketPairs","OPEN","CLOSE","UrlOpen","UrlOpenQ","UrlOpenSyms","init$1","tokenize","str","cursor","multis","textTokens","secondState","multiLength","latestAccepting","sinceAccepts","subtokens","run","iterable","index","second","first","charCodeAt","stringToArray","replace","toLowerCase","charCount","charCursor","tokenLength","charsSinceAccepts","run$1","find","filtered","ATTR_WHITESPACE","isAllowedUri","uri","protocols","allowedProtocols","forEach","nextProtocol","match","RegExp","Link","Mark","create","priority","keepOnSplit","exitable","onCreate","optionalSlashes","onDestroy","inclusive","autolink","addOptions","openOnClick","linkOnPaste","HTMLAttributes","addAttributes","default","parseHTML","getAttribute","tag","getAttrs","renderHTML","mergeAttributes","addCommands","setLink","chain","setMark","setMeta","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","text","foundLinks","links","filter","item","link","data","getAttributes","_a","addProseMirrorPlugins","plugins","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","eq","preventAutolink","getMeta","transform","combineTransactionSteps","getChangedRanges","newRange","nodesInChangedRanges","findChildrenInRange","node","isTextblock","textBlock","textBeforeWhitespace","textBetween","pos","nodeSize","undefined","endsWith","wordsBeforeWhitespace","split","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","map","schema","marks","code","rangeHasMark","getMarksBetween","mark","addMark","steps","handleClick","event","_b","button","editable","els","nodeName","parentNode","window","open","clickHandler","handlePaste","empty","textContent","commands","pasteHandler","context_menu_instance","dont_open_context_menu","pattern_link_context_menu","app","Pattern","BasePattern","static","focus_handler","el","btn_open","querySelector","btn_edit","btn_unlink","setAttribute","addEventListener","toolbar","click","focus","_ref4","get_data","toolbar_el","link_panel_pattern","trigger","panel","link_panel","link_href","log","link_text","link_target","link_confirm","link_remove","last_cursor_position","$head","selection_from","selection_to","is_link","extendMarkRange","dispatchEvent","Event","checked","text_content","update_callback","set_focus","cmd","link_text_value","command","_ref3","tiptap_utils","link_node","replaceSelectionWith","setTextSelection","form","querySelectorAllAndMe","preventDefault","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","menu","utils","debounce","factory","LinkExtension","extend","TARGETS","timeout","it","add_search_params","params","arguments","url_obj","URL","location","origin","pathname","URLSearchParams","Array","searchParams","entries","accessibility_attributes","is_url","is_mail"],"sourceRoot":""}