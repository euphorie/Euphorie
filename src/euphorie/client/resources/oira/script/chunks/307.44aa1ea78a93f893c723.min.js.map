{"version":3,"file":"chunks/307.44aa1ea78a93f893c723.min.js","mappings":"gOAKA,IAAIA,EAAY,KAETC,eAAeC,GAAa,IAC/BC,EAAG,OACHC,EAAM,SACNC,EAAW,KAAI,QACfC,EAAU,KAAI,YACdC,EAAc,OAEd,MAAMC,EAAYR,EACZS,EAAYT,EAAYI,EAAOM,MAAMC,IAAIC,OAAOR,EAAOM,MAAMG,UAAUC,MAU7E,GARiB,OAAbT,GAAqBI,IAAaD,IAElCH,EAAWU,EAAmB,CAC1BV,SAAUA,EACVW,aAAcV,EAAQW,QAIzBZ,EAoCDA,EAASa,YAAYf,OApCV,CAOPG,IACA,aAAkBA,EAAQW,MAAQX,GAItC,MAAMa,EAAiBf,EAAOgB,QAAQC,QACtChB,QAAiB,IAAI,IAAWc,EAAgB,CAC5C,OAAU,OACV,IAAOhB,EACP,QAAW,OACX,MAASI,EACT,gBAAiB,CAAC,cAGhB,uBAA0BF,GAEhC,MAAMiB,GAAqB,IAAAC,cACvBnB,EAAOoB,KACPpB,EAAOM,MAAMG,UAAUC,KACvBV,EAAOM,MAAMG,UAAUY,IAG3BpB,EAASqB,OAAOC,SAAS,CAErBC,uBAAwB,IAAMN,IAGlCjB,EAASwB,OAKb,OAAOxB,EAGJ,SAASU,GAAmB,SAAEV,EAAQ,aAAEW,IAY3C,OAVIX,IACAA,EAASyB,OACTzB,EAAS0B,UACT1B,EAAW,MAIXW,UACO,aAAkBA,GAEtB,O,wGC3BX,MAAMgB,EAAsB,IAAI,KAAU,cAC1C,SAASC,GAAW,UAAEC,EAAYF,EAAmB,OAAE5B,EAAM,KAAE+B,EAAO,IAAG,YAAEC,GAAc,EAAK,YAAEC,GAAc,EAAI,YAAEC,GAAc,EAAK,cAAEC,EAAgB,OAAM,gBAAEC,EAAkB,aAAY,QAAEC,EAAU,KAAM,MAAI,MAAEC,EAAQ,KAAM,IAAE,OAAEC,EAAS,MAAM,KAAI,MAAEC,EAAQ,MAAM,KACxQ,IAAIC,EACJ,MAAMC,EAAWH,MAAAA,OAAuC,EAASA,IACjE,OAAO,IAAI,KAAO,CACdI,IAAKb,EACLV,OACI,MAAO,CACHwB,OAAQ/C,MAAOuB,EAAMyB,KACjB,IAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EACpB,MAAMC,EAA2B,QAAnBL,EAAKM,KAAKT,WAAwB,IAAPG,OAAgB,EAASA,EAAGO,SAASR,GACxES,EAA2B,QAAnBP,EAAKK,KAAKT,WAAwB,IAAPI,OAAgB,EAASA,EAAGM,SAASjC,EAAKd,OAE7EiD,EAAQJ,EAAKK,QAAUF,EAAKE,QAAUL,EAAKM,MAAM/C,OAAS4C,EAAKG,MAAM/C,KACrEgD,GAAWP,EAAKK,QAAUF,EAAKE,OAC/BG,EAAUR,EAAKK,SAAWF,EAAKE,OAE/BI,EAAcF,GAAWH,EACzBM,GAFWH,IAAYC,GAAWR,EAAKW,QAAUR,EAAKQ,QAE3BP,EAC3BQ,EAAaJ,GAAWJ,EAE9B,IAAKK,IAAgBC,IAAiBE,EAClC,OAEJ,MAAMzD,EAAQyD,IAAeH,EACvBT,EACAG,EACAU,EAAiBC,SAASC,cAAc,wBAAwB5D,EAAM6D,kBAC5E1B,EAAQ,CACJzC,OAAAA,EACAyD,MAAOnD,EAAMmD,MACbK,MAAOxD,EAAMwD,MACbM,KAAM9D,EAAM8D,KACZ9B,MAAQuB,GAAgBD,QACZtB,EAAM,CACVtC,OAAAA,EACA8D,MAAOxD,EAAMwD,QAEf,GACNzB,QAASgC,IACLhC,EAAQ,CACJrC,OAAAA,EACAyD,MAAOnD,EAAMmD,MACbhB,MAAO4B,KAGfL,eAAAA,EAGAM,WAAYN,EACN,KACE,IAAIlB,EAEJ,MAAM,aAAEqB,GAAqC,QAAnBrB,EAAKM,KAAKT,WAAwB,IAAPG,OAAgB,EAASA,EAAGO,SAASrD,EAAOM,OAGjG,OAF8B2D,SAASC,cAAc,wBAAwBC,OAEhDI,yBAE/B,MAENR,IAC+E,QAA9Ef,EAAKN,MAAAA,OAA2C,EAASA,EAAS8B,cAA2B,IAAPxB,GAAyBA,EAAGyB,KAAK/B,EAAUD,IAElIoB,IACiF,QAAhFZ,EAAKP,MAAAA,OAA2C,EAASA,EAASgC,gBAA6B,IAAPzB,GAAyBA,EAAGwB,KAAK/B,EAAUD,IAEpImB,IACgF,QAA/EV,EAAKR,MAAAA,OAA2C,EAASA,EAASiC,eAA4B,IAAPzB,GAAyBA,EAAGuB,KAAK/B,EAAUD,KAG3Id,QAAS,KACL,IAAImB,EACCL,IAG0E,QAA9EK,EAAKJ,MAAAA,OAA2C,EAASA,EAAS8B,cAA2B,IAAP1B,GAAyBA,EAAG2B,KAAK/B,EAAUD,OAI9InC,MAAO,CAEHsE,KAAI,KACO,CACHpB,QAAQ,EACRC,MAAO,GACPK,MAAO,KACPM,KAAM,KACNS,WAAW,IAInBC,MAAMC,EAAa5B,EAAM6B,EAAU1E,GAC/B,MAAM,UAAEuE,GAAc7E,EAAOoB,MACvB,UAAEX,GAAcsE,GAChB,MAAEE,EAAK,KAAEvE,GAASD,EAClB6C,EAAO,IAAKH,GAIlB,GAHAG,EAAKuB,UAAYA,EAGbI,GAASjF,EAAOoB,KAAKyD,UAAW,GAE3BnE,EAAOyC,EAAKM,MAAM/C,MAAQA,EAAOyC,EAAKM,MAAMpC,KACzCwD,GACA1B,EAAK0B,YACTvB,EAAKE,QAAS,GAGlB,MAAM0B,EA3J1B,SAA6BC,GACzB,MAAM,KAAEpD,EAAI,YAAEC,EAAW,YAAEC,EAAW,YAAEC,EAAW,UAAEkD,GAAeD,EAC9DE,GAAc,IAAAC,gBAAevD,GAC7BwD,EAAS,IAAIC,OAAO,MAAMH,MAC1BI,EAASvD,EAAc,IAAM,GAC7BwD,EAAS1D,EACT,IAAIwD,OAAO,GAAGC,IAASJ,aAAuBA,OAAkB,MAChE,IAAIG,OAAO,GAAGC,UAAeJ,SAAmBA,MAAiB,MAEjEM,EADiBP,EAAUQ,OAAS,EAEpC,EACAR,EAAUS,SACVC,EAASV,EAAUW,IACnB3B,EAAOgB,EAAU7E,IAAIyF,YAAYL,EAAUG,EAAQ,KAAM,MACzDZ,EAAQe,MAAMvF,KAAK0D,EAAK8B,SAASR,IAASS,MAChD,IAAKjB,QAAyBkB,IAAhBlB,EAAMmB,YAAuCD,IAAhBlB,EAAMoB,MAC7C,OAAO,KAIX,MAAMC,EAAcrB,EAAMmB,MAAMG,MAAMC,KAAKC,IAAI,EAAGxB,EAAMoB,MAAQ,GAAIpB,EAAMoB,OACpEK,EAAqB,YAAYC,KAAKL,GAC5C,GAAItE,IAAgB0E,EAChB,OAAO,KAGX,MAAMjG,EAAOwE,EAAMoB,MAAQlB,EAAUyB,QACrC,IAAIxF,EAAKX,EAAOwE,EAAM,GAAG4B,OAQzB,OALI9E,GAAeuD,EAAOqB,KAAKxC,EAAKoC,MAAMnF,EAAK,EAAGA,EAAK,MACnD6D,EAAM,IAAM,IACZ7D,GAAM,GAGNX,EAAO0E,EAAUW,KAAO1E,GAAM+D,EAAUW,IACjC,CACHtC,MAAO,CACH/C,KAAAA,EACAW,GAAAA,GAEJyC,MAAOoB,EAAM,GAAGsB,MAAMzE,EAAK+E,QAC3B1C,KAAMc,EAAM,IAGb,KA8GuB6B,CAAoB,CAC9BhF,KAAAA,EACAC,YAAAA,EACAC,YAAAA,EACAC,YAAAA,EACAkD,UAAW3E,EAAUuG,QAEnB7C,EAAe,MAAMsC,KAAKQ,MAAsB,WAAhBR,KAAKS,YAEvChC,GAAS1C,EAAM,CAAExC,OAAAA,EAAQM,MAAAA,EAAOmD,MAAOyB,EAAMzB,SAC7CH,EAAKE,QAAS,EACdF,EAAKa,aAAehB,EAAKgB,aAAehB,EAAKgB,aAAeA,EAC5Db,EAAKG,MAAQyB,EAAMzB,MACnBH,EAAKQ,MAAQoB,EAAMpB,MACnBR,EAAKc,KAAOc,EAAMd,MAGlBd,EAAKE,QAAS,OAIlBF,EAAKE,QAAS,EASlB,OANKF,EAAKE,SACNF,EAAKa,aAAe,KACpBb,EAAKG,MAAQ,GACbH,EAAKQ,MAAQ,KACbR,EAAKc,KAAO,MAETd,IAGfb,MAAO,CAEH0E,cAAc/F,EAAMgG,GAChB,IAAItE,EACJ,MAAM,OAAEU,EAAM,MAAEC,GAAUL,KAAKC,SAASjC,EAAKd,OAC7C,OAAKkD,IAGqF,QAAjFV,EAAKJ,MAAAA,OAA2C,EAASA,EAAS2E,iBAA8B,IAAPvE,OAAgB,EAASA,EAAG2B,KAAK/B,EAAU,CAAEtB,KAAAA,EAAMgG,MAAAA,EAAO3D,MAAAA,OAFjJ,GAKf6D,YAAYhH,GACR,MAAM,OAAEkD,EAAM,MAAEC,EAAK,aAAEU,GAAiBf,KAAKC,SAAS/C,GACtD,OAAKkD,EAGE,YAAqBlD,EAAMC,IAAK,CACnC,WAAkBkD,EAAM/C,KAAM+C,EAAMpC,GAAI,CACpCkG,SAAUpF,EACVqF,MAAOpF,EACP,qBAAsB+B,MANnB,S,2DC7J3B,MAvCwC,CACpC,wBACA,cACA,oBACA,YACA,eACA,gBACA,mBACA,gBACA,kBACA,gBACA,cACA,eACA,gBACA,cACA,eACA,aACA,kBACA,aACA,YACA,iBACA,uBACA,mBACA,YACA,gBACA,eACA,gBACA,gBACA,gBACA,gBACA,eACA,YACA,gBACA,gBACA,gBACA,iBACA,QCpCJ,IAAIsD,EAEJ,SAASC,EAAmBC,EAAKlF,GAE7B,MAAO,CACH5B,KAAM,oBACN+G,QAAS,gBACT/H,WAAWgI,IACP,EAAAC,EAAAA,eAAcD,EAAI,IAElBzE,KAAK2E,GAAKF,EAAI,GAEdzE,KAAKI,OAASJ,KAAKd,MAAM,GAGzB0F,EAAA,qBACI5E,KAAK2E,GACL,UACA,6BACCE,IAIG,GAHAA,EAAEC,iBACFD,EAAEE,kBAEa,cAAXF,EAAEG,KAEF,GAAKhF,KAAKI,OAEH,CACH,IAAIF,EAAOF,KAAKI,OACVJ,KAAKd,MAAM+F,QAAQjF,KAAKI,QAAU,EAClC,EACFF,GAAQF,KAAKd,MAAMwE,SAEnBxD,EAAO,GAGXF,KAAKI,OAASJ,KAAKd,MAAMgB,QAVzBF,KAAKI,OAASJ,KAAKd,MAAM,QAY1B,GAAe,YAAX2F,EAAEG,KAET,GAAKhF,KAAKI,OAEH,CACH,IAAIL,EAAOC,KAAKI,OACVJ,KAAKd,MAAM+F,QAAQjF,KAAKI,QAAU,EAClC,EACFL,EAAO,IAEPA,EAAOC,KAAKd,MAAMwE,OAAS,GAG/B1D,KAAKI,OAASJ,KAAKd,MAAMa,QAVzBC,KAAKI,OAASJ,KAAKd,MAAM,QAY1B,GAAe,UAAX2F,EAAEG,KAAkB,CAE3B,MAAME,EAAQlF,KAAKI,QAAQ+E,SAASC,YACpC,IAAKF,EAED,OAGJ,MAAMP,EAAK3E,KAAKI,OAAOU,cAAc,KACrCd,KAAKf,QAAQ0F,EAAIO,OAM7BN,EAAA,qBACI5E,KAAK2E,GACL,QACA,2BACCE,IACG,MAAMF,EAAKE,EAAEQ,OAAOC,QAAQ,KACtBJ,EAAQK,EAAA,oBAAsBZ,EAAI,qBACnCO,IAKLL,EAAEC,iBACF9E,KAAKf,QAAQ0F,EAAIO,QAK7BjG,QAAQ0F,EAAIO,GACR,MAAMM,EAAaC,OAAOC,YACtB,IAAIf,EAAGa,YAAYG,KAAKC,GAAO,CAACA,EAAGnI,KAAMmI,EAAGV,UAEhD7F,EAAMJ,QAAQ,CACV,aAAciG,KACXM,KAIPpF,aAEA,OAAOJ,KAAK2E,GAAG7D,cAAc,wBAG7BV,WAAOuE,GACFA,IAKL3E,KAAKI,QAAQyF,UAAUC,OAAO,UAC9BnB,EAAGkB,UAAUE,IAAI,YAGjB7G,YAEA,MAAO,IAAIc,KAAK2E,GAAGqB,iBAAiB,mBAKzC,MAAMC,EAAU,EAAG1B,IAAAA,EAAK9G,KAAAA,EAAMkB,KAAAA,EAAMuH,OAAAA,KAChC,EAAAC,KAAA,OAAY,CACf1I,KAAMA,EACN2I,MAAO,SACPC,QAAQ,EACRC,YAAY,EACZC,MAAM,EAENC,WAAU,KACC,CACHC,eAAgB,GAChB9J,IAAK,KACL+J,YAAW,EAAC,QAAE9I,EAAO,KAAE+I,KACZ,GAAG/I,EAAQgJ,WAAWjI,OAAOgI,EAAKE,MAAM,gBAEnDD,WAAY,CACRjI,KAAMA,EACND,UAAW,IAAI,KAAUjB,MAKrCqJ,gBACI,MAAMtB,EAAa,CACf,MAAS,GACT,KAAQ,GACR,OAAU,GACV,MAAS,GACT,UAAW,GACX,aAAc,GAEd,kBAAmB,GACnB,mBAAoB,GACpB,iBAAkB,GAClB,kBAAmB,GACnB,kBAAmB,GACnB,mBAAoB,IAIxBA,EAAW,QAAQxF,KAAKvC,QAAU,CAAEsJ,QAAS,IAE7C,IAAK,MAAMC,KAAQ,EAEfxB,EAAWwB,GAAQ,GAGvB,OAAOxB,GAGXyB,YACI,MAAO,CACH,CACIC,IAAK,UAAUlH,KAAKvC,WAKhC0J,YAAW,KAAER,EAAI,eAAEF,IACf,MAAO,CACH,KACA,IAAAW,iBAAgBpH,KAAKpC,QAAQ6I,eAAgBA,GAC7CzG,KAAKpC,QAAQ8I,YAAY,CACrB9I,QAASoC,KAAKpC,QACd+I,KAAAA,MAKZU,YAAW,KAAEV,IACT,OAAO3G,KAAKpC,QAAQ8I,YAAY,CAC5B9I,QAASoC,KAAKpC,QACd+I,KAAAA,KAIRW,uBACI,MAAO,CACHC,MAAO,MACClD,IAMAA,EAAsBnG,OAAOsJ,QACvB1G,cAAc,kBACd2G,cACE,IAAIC,cAAc,UAAW,CACzB1C,KAAM,YAIX,GAMf2C,UAAW,EAAG/K,OAAAA,KACVA,EAAOgL,SAAS3I,SAAQ,EAAG4I,GAAAA,EAAI3K,MAAAA,MAC3B,IAAI4K,GAAgB,EACpB,MAAM,UAAEzK,GAAcH,GAChB,MAAE2E,EAAK,OAAEkG,GAAW1K,EAE1B,QAAKwE,IAIL3E,EAAMC,IAAI6K,aAAaD,EAAS,EAAGA,GAAQ,CAACpB,EAAMhE,KAC9C,GAAIgE,EAAKsB,KAAKxK,OAASuC,KAAKvC,KAQxB,OAPAqK,GAAgB,EAChBD,EAAGK,WACClI,KAAKpC,QAAQgJ,WAAWjI,MAAQ,GAChCgE,EACAA,EAAMgE,EAAKwB,WAGR,KAIRL,QAKvBM,wBA0HI,OAxHApI,KAAKpC,QAAQgJ,WAAW3H,QAAU,EAAGrC,OAAAA,EAAQyD,MAAAA,EAAOhB,MAAAA,MAEhDgB,EAAMpC,GAAKrB,EAAOM,MAAMG,UAAUgL,MAAM1F,IACxC/F,EACK0L,QACAC,QACAC,gBAAgBnI,EAAO,CACpB,CACI4H,KAAMjI,KAAKvC,KACXoJ,MAAOxH,GAEX,CACI4I,KAAM,OACNjH,KAAM,OAGbyH,OAITzI,KAAKpC,QAAQgJ,WAAWzH,OAAS,KAC7B,IAAIuJ,EACJ,MAAO,CACHnH,QAAS9E,MAAO4C,IACZ,MAAMsJ,EAAgBlM,OAChBkF,YAAAA,GAAgB,CAAEA,YAAa,SAIjC,IAAIhF,EAAMqD,KAAKpC,QAAQjB,IASnBW,EAAO+B,EAAMgB,MAAM/C,KAAO,EAC1BW,EAAK0D,EACHA,EAAYiH,aAAaP,MAAM1F,IAC/BtD,EAAMgB,MAAMpC,GAClB,MAAM+C,EAAOhB,KAAKpD,OAAOM,MAAMC,IAAIyF,YAAYtF,EAAMW,EAAI,IAMzD,OAFAtB,EAAMqE,EAAOrE,EAAMqE,EAAOrE,QAEb,EAAAD,EAAA,GAAa,CACtBC,IAAKA,EACLC,OAAQoD,KAAKpD,OACbC,SAAUwH,EACVvH,QAASwH,EAAmBC,EAAKlF,GACjCtC,YAAa,UAAUmJ,GAAUlG,KAAKvC,UAG9CiL,EAA0BG,EAAA,YAAepM,MAAOkF,IAC5C0C,QAA8BsE,EAAchH,KAC7C,KAGH0C,QAA8BsE,IAG9B3I,KAAKpD,OAAOkM,GAAG,kBAAmBJ,IAEtCzE,UAAY5E,IACR,GAAKgF,EAAL,CAKA,GAAwB,WAApBhF,EAAM2E,MAAMzE,IAMZ,OALA8E,GAAwB,EAAA3H,EAAA,GAAmB,CACvCG,SAAUwH,EACV7G,aAAc,sBAElBwC,KAAKpD,OAAOmM,IAAI,kBAAmBL,IAC5B,EAEX,GACwB,cAApBrJ,EAAM2E,MAAMzE,KACQ,YAApBF,EAAM2E,MAAMzE,KACQ,UAApBF,EAAM2E,MAAMzE,IACd,CACEF,EAAM2E,MAAMc,iBACZzF,EAAM2E,MAAMe,kBACZ,MAAMiE,EAAMnI,SAASC,cAAc,iBACnC,IAAKkI,EACD,OAKJA,EAAIvB,cACA,IAAIC,cAAc,UAAW,CACzB1C,KAAM3F,EAAM2E,MAAMzE,UAKlC6B,OAAQ,KACJiD,GAAwB,EAAA3H,EAAA,GAAmB,CACvCG,SAAUwH,EACV7G,aAAc,sBAElBwC,KAAKpD,OAAOmM,IAAI,kBAAmBL,MAM/C1I,KAAKpC,QAAQgJ,WAAWxH,MAAQ,EAAGlC,MAAAA,EAAOmD,MAAAA,MACtC,MAAMuD,EAAQ1G,EAAMC,IAAI8L,QAAQ5I,EAAM/C,MAChC2K,EAAO/K,EAAMgM,OAAOC,MAAMnJ,KAAKvC,MAGrC,QAFgBmG,EAAMwF,OAAOnB,KAAKoB,aAAaC,UAAUrB,IAKtD,CACH,EAAsB,CAClBrL,OAAQoD,KAAKpD,UACVoD,KAAKpC,QAAQgJ,kB,gICzX7B,MAAM2C,EAAU,GAEhB,SAAS7E,EAAcC,GAG1BA,EAAG6E,aAAa,WAAY,MAC5B,uBACI7E,EACA,QACA,kBACAlI,UACI,YAAc,GACd8M,EAAQ5D,KAAKC,GAAOA,GAAIC,UAAUE,IAAI,qBAE1C,GAEJ,uBACIpB,EACA,OACA,mBACA,KACI4E,EAAQ5D,KAAKC,GAAOA,GAAIC,UAAUC,OAAO,qBAE7C","sources":["webpack://oira.prototype/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://oira.prototype/./node_modules/@tiptap/suggestion/dist/tiptap-suggestion.esm.js","webpack://oira.prototype/./node_modules/@patternslib/pat-tiptap/src/utils.js","webpack://oira.prototype/./node_modules/@patternslib/pat-tiptap/src/extensions/suggestion.js","webpack://oira.prototype/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import Registry from \"@patternslib/patternslib/src/core/registry\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (instance !== null && cur_node !== prev_node) {\n        // Close context menu, when new node is selected.\n        instance = context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n    }\n\n    if (!instance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            Registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = await new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete Registry.patterns[pattern_name];\n    }\n    return null;\n}\n","import { PluginKey, Plugin } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { escapeForRegEx } from '@tiptap/core';\n\nfunction findSuggestionMatch(config) {\r\n    const { char, allowSpaces, prefixSpace, startOfLine, $position, } = config;\r\n    const escapedChar = escapeForRegEx(char);\r\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\r\n    const prefix = startOfLine ? '^' : '';\r\n    const regexp = allowSpaces\r\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\r\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm');\r\n    const isTopLevelNode = $position.depth <= 0;\r\n    const textFrom = isTopLevelNode\r\n        ? 0\r\n        : $position.before();\r\n    const textTo = $position.pos;\r\n    const text = $position.doc.textBetween(textFrom, textTo, '\\0', '\\0');\r\n    const match = Array.from(text.matchAll(regexp)).pop();\r\n    if (!match || match.input === undefined || match.index === undefined) {\r\n        return null;\r\n    }\r\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\r\n    // is a space or the start of the line\r\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\r\n    const matchPrefixIsSpace = /^[\\s\\0]?$/.test(matchPrefix);\r\n    if (prefixSpace && !matchPrefixIsSpace) {\r\n        return null;\r\n    }\r\n    // The absolute position of the match in the document\r\n    const from = match.index + $position.start();\r\n    let to = from + match[0].length;\r\n    // Edge case handling; if spaces are allowed and we're directly in between\r\n    // two triggers\r\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\r\n        match[0] += ' ';\r\n        to += 1;\r\n    }\r\n    // If the $position is located within the matched substring, return that range\r\n    if (from < $position.pos && to >= $position.pos) {\r\n        return {\r\n            range: {\r\n                from,\r\n                to,\r\n            },\r\n            query: match[0].slice(char.length),\r\n            text: match[0],\r\n        };\r\n    }\r\n    return null;\r\n}\n\nconst SuggestionPluginKey = new PluginKey('suggestion');\r\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, prefixSpace = true, startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, }) {\r\n    let props;\r\n    const renderer = render === null || render === void 0 ? void 0 : render();\r\n    return new Plugin({\r\n        key: pluginKey,\r\n        view() {\r\n            return {\r\n                update: async (view, prevState) => {\r\n                    var _a, _b, _c, _d, _e;\r\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\r\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\r\n                    // See how the state changed\r\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\r\n                    const started = !prev.active && next.active;\r\n                    const stopped = prev.active && !next.active;\r\n                    const changed = !started && !stopped && prev.query !== next.query;\r\n                    const handleStart = started || moved;\r\n                    const handleChange = changed && !moved;\r\n                    const handleExit = stopped || moved;\r\n                    // Cancel when suggestion isn't active\r\n                    if (!handleStart && !handleChange && !handleExit) {\r\n                        return;\r\n                    }\r\n                    const state = handleExit && !handleStart\r\n                        ? prev\r\n                        : next;\r\n                    const decorationNode = document.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\r\n                    props = {\r\n                        editor,\r\n                        range: state.range,\r\n                        query: state.query,\r\n                        text: state.text,\r\n                        items: (handleChange || handleStart)\r\n                            ? await items({\r\n                                editor,\r\n                                query: state.query,\r\n                            })\r\n                            : [],\r\n                        command: commandProps => {\r\n                            command({\r\n                                editor,\r\n                                range: state.range,\r\n                                props: commandProps,\r\n                            });\r\n                        },\r\n                        decorationNode,\r\n                        // virtual node for popper.js or tippy.js\r\n                        // this can be used for building popups without a DOM node\r\n                        clientRect: decorationNode\r\n                            ? () => {\r\n                                var _a;\r\n                                // because of `items` can be asynchrounous weâ€™ll search for the current docoration node\r\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state);\r\n                                const currentDecorationNode = document.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\r\n                                // @ts-ignore-error\r\n                                return currentDecorationNode.getBoundingClientRect();\r\n                            }\r\n                            : null,\r\n                    };\r\n                    if (handleExit) {\r\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\r\n                    }\r\n                    if (handleChange) {\r\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\r\n                    }\r\n                    if (handleStart) {\r\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\r\n                    }\r\n                },\r\n                destroy: () => {\r\n                    var _a;\r\n                    if (!props) {\r\n                        return;\r\n                    }\r\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\r\n                },\r\n            };\r\n        },\r\n        state: {\r\n            // Initialize the plugin's internal state.\r\n            init() {\r\n                return {\r\n                    active: false,\r\n                    range: {},\r\n                    query: null,\r\n                    text: null,\r\n                    composing: false,\r\n                };\r\n            },\r\n            // Apply changes to the plugin state from a view transaction.\r\n            apply(transaction, prev, oldState, state) {\r\n                const { composing } = editor.view;\r\n                const { selection } = transaction;\r\n                const { empty, from } = selection;\r\n                const next = { ...prev };\r\n                next.composing = composing;\r\n                // We can only be suggesting if there is no selection\r\n                // or a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\r\n                if (empty || editor.view.composing) {\r\n                    // Reset active state if we just left the previous suggestion range\r\n                    if ((from < prev.range.from || from > prev.range.to)\r\n                        && !composing\r\n                        && !prev.composing) {\r\n                        next.active = false;\r\n                    }\r\n                    // Try to match against where our cursor currently is\r\n                    const match = findSuggestionMatch({\r\n                        char,\r\n                        allowSpaces,\r\n                        prefixSpace,\r\n                        startOfLine,\r\n                        $position: selection.$from,\r\n                    });\r\n                    const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`;\r\n                    // If we found a match, update the current state to show it\r\n                    if (match && allow({ editor, state, range: match.range })) {\r\n                        next.active = true;\r\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\r\n                        next.range = match.range;\r\n                        next.query = match.query;\r\n                        next.text = match.text;\r\n                    }\r\n                    else {\r\n                        next.active = false;\r\n                    }\r\n                }\r\n                else {\r\n                    next.active = false;\r\n                }\r\n                // Make sure to empty the range if suggestion is inactive\r\n                if (!next.active) {\r\n                    next.decorationId = null;\r\n                    next.range = {};\r\n                    next.query = null;\r\n                    next.text = null;\r\n                }\r\n                return next;\r\n            },\r\n        },\r\n        props: {\r\n            // Call the keydown hook if suggestion is active.\r\n            handleKeyDown(view, event) {\r\n                var _a;\r\n                const { active, range } = this.getState(view.state);\r\n                if (!active) {\r\n                    return false;\r\n                }\r\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\r\n            },\r\n            // Setup decorator on the currently active suggestion.\r\n            decorations(state) {\r\n                const { active, range, decorationId } = this.getState(state);\r\n                if (!active) {\r\n                    return null;\r\n                }\r\n                return DecorationSet.create(state.doc, [\r\n                    Decoration.inline(range.from, range.to, {\r\n                        nodeName: decorationTag,\r\n                        class: decorationClass,\r\n                        'data-decoration-id': decorationId,\r\n                    }),\r\n                ]);\r\n            },\r\n        },\r\n    });\r\n}\n\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=tiptap-suggestion.esm.js.map\n","export const add_search_params = (url, params = {}) => {\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams#examples\n    const url_obj = new URL(url, window.location.href);\n    return `${url_obj.origin}${url_obj.pathname}?${new URLSearchParams([\n        ...Array.from(url_obj.searchParams.entries()),\n        ...Object.entries(params),\n    ]).toString()}`;\n};\n\n// Export a list of WAI attributes.\nexport const accessibility_attributes = [\n    \"aria-activedescendant\",\n    \"aria-atomic\",\n    \"aria-autocomplete\",\n    \"aria-busy\",\n    \"aria-checked\",\n    \"aria-controls\",\n    \"aria-describedby\",\n    \"aria-disabled\",\n    \"aria-dropeffect\",\n    \"aria-expanded\",\n    \"aria-flowto\",\n    \"aria-grabbed\",\n    \"aria-haspopup\",\n    \"aria-hidden\",\n    \"aria-invalid\",\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-level\",\n    \"aria-live\",\n    \"aria-multiline\",\n    \"aria-multiselectable\",\n    \"aria-orientation\",\n    \"aria-owns\",\n    \"aria-posinset\",\n    \"aria-pressed\",\n    \"aria-readonly\",\n    \"aria-relevant\",\n    \"aria-required\",\n    \"aria-selected\",\n    \"aria-setsize\",\n    \"aria-sort\",\n    \"aria-valuemax\",\n    \"aria-valuemin\",\n    \"aria-valuenow\",\n    \"aria-valuetext\",\n    \"role\",\n];\n\nexport default {\n    add_search_params: add_search_params,\n    accessibility_attributes: accessibility_attributes,\n};\n","import { Node, mergeAttributes } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { Suggestion as ProseMirrorSuggestion } from \"@tiptap/suggestion\";\nimport { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\nimport tiptap_utils from \"../utils\";\n\nlet context_menu_instance;\n\nfunction pattern_suggestion(app, props) {\n    // Dynamic pattern for the suggestion context menu\n    return {\n        name: \"tiptap-suggestion\",\n        trigger: \".tiptap-items\",\n        async init($el) {\n            focus_handler($el[0]);\n\n            this.el = $el[0];\n\n            this.active = this.items[0];\n\n            // Support selections via keyboard navigation.\n            events.add_event_listener(\n                this.el,\n                \"keydown\",\n                \"tiptap-suggestion-keydown\",\n                (e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    if (e.code === \"ArrowDown\") {\n                        // Select next or first.\n                        if (!this.active) {\n                            this.active = this.items[0];\n                        } else {\n                            let next = this.active\n                                ? this.items.indexOf(this.active) + 1\n                                : 0;\n                            if (next >= this.items.length) {\n                                // circular selection mode, start with first.\n                                next = 0;\n                                // TODO: should we load the next batch?\n                            }\n                            this.active = this.items[next];\n                        }\n                    } else if (e.code === \"ArrowUp\") {\n                        // Select previous or last.\n                        if (!this.active) {\n                            this.active = this.items[0];\n                        } else {\n                            let prev = this.active\n                                ? this.items.indexOf(this.active) - 1\n                                : 0;\n                            if (prev < 0) {\n                                // back to first\n                                prev = this.items.length - 1;\n                                // TODO: should we load the previous batch?\n                            }\n                            this.active = this.items[prev];\n                        }\n                    } else if (e.code === \"Enter\") {\n                        // Use selected to insert in text area.\n                        const value = this.active?.dataset?.tiptapValue;\n                        if (!value) {\n                            // nothing selected.\n                            return;\n                        }\n\n                        const el = this.active.querySelector(\"a\");\n                        this.command(el, value);\n                    }\n                }\n            );\n\n            // Select and insert to text area by clicking.\n            events.add_event_listener(\n                this.el,\n                \"click\",\n                \"tiptap-suggestion-click\",\n                (e) => {\n                    const el = e.target.closest(\"a\");\n                    const value = dom.acquire_attribute(el, \"data-tiptap-value\");\n                    if (!value) {\n                        // clicked anywhere, but not on a selection item\n                        return;\n                    }\n\n                    e.preventDefault();\n                    this.command(el, value);\n                }\n            );\n        },\n\n        command(el, value) {\n            const attributes = Object.fromEntries(\n                [...el.attributes].map((it) => [it.name, it.value])\n            );\n            props.command({\n                \"data-title\": value,\n                ...attributes,\n            });\n        },\n\n        get active() {\n            // Get the currently selected item.\n            return this.el.querySelector(\".tiptap-item.active\");\n        },\n\n        set active(el) {\n            if (!el) {\n                // No item available, e.g. no search results and thus not this.items.\n                return;\n            }\n            // Set an item to be selected.\n            this.active?.classList.remove(\"active\");\n            el.classList.add(\"active\");\n        },\n\n        get items() {\n            // Get all items.\n            return [...this.el.querySelectorAll(\".tiptap-item\")];\n        },\n    };\n}\n\nexport const factory = ({ app, name, char, plural }) => {\n    return Node.create({\n        name: name,\n        group: \"inline\",\n        inline: true,\n        selectable: false,\n        atom: true,\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n                url: null,\n                renderLabel({ options, node }) {\n                    return `${options.suggestion.char}${node.attrs[\"data-title\"]}`;\n                },\n                suggestion: {\n                    char: char,\n                    pluginKey: new PluginKey(name),\n                },\n            };\n        },\n\n        addAttributes() {\n            const attributes = {\n                \"class\": {},\n                \"href\": {},\n                \"target\": {},\n                \"title\": {},\n                \"data-id\": {},\n                \"data-title\": {},\n                // add a lot of patterns data attributes...\n                \"data-pat-inject\": {},\n                \"data-pat-forward\": {},\n                \"data-pat-modal\": {},\n                \"data-pat-switch\": {},\n                \"data-pat-toggle\": {},\n                \"data-pat-tooltip\": {},\n            };\n\n            // Needs to be always included. A default of \"\" makes sure it is.\n            attributes[`data-${this.name}`] = { default: \"\" };\n\n            for (const attr of tiptap_utils.accessibility_attributes) {\n                // Add a bunch of accessibility attributes\n                attributes[attr] = {};\n            }\n\n            return attributes;\n        },\n\n        parseHTML() {\n            return [\n                {\n                    tag: `a[data-${this.name}]`,\n                },\n            ];\n        },\n\n        renderHTML({ node, HTMLAttributes }) {\n            return [\n                \"a\",\n                mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                this.options.renderLabel({\n                    options: this.options,\n                    node,\n                }),\n            ];\n        },\n\n        renderText({ node }) {\n            return this.options.renderLabel({\n                options: this.options,\n                node,\n            });\n        },\n\n        addKeyboardShortcuts() {\n            return {\n                Enter: () => {\n                    if (context_menu_instance) {\n                        // While suggestion menu is open, do not add a line-break to the text.\n                        // Handle the ``Enter`` key as early as possible to prevent a line-break to happen.\n\n                        // Dispatch the event to the context menu pattern\n                        // while still keeping the focus in the textarea.\n                        context_menu_instance.tippy?.popper\n                            ?.querySelector(\".tiptap-items\")\n                            ?.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: \"Enter\",\n                                })\n                            );\n\n                        return true;\n                    }\n                    // Normal case, do not prevent the Enter key to add a line break.\n                    return false;\n                },\n\n                Backspace: ({ editor }) =>\n                    editor.commands.command(({ tr, state }) => {\n                        let is_suggestion = false;\n                        const { selection } = state;\n                        const { empty, anchor } = selection;\n\n                        if (!empty) {\n                            return false;\n                        }\n\n                        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n                            if (node.type.name === this.name) {\n                                is_suggestion = true;\n                                tr.insertText(\n                                    this.options.suggestion.char || \"\",\n                                    pos,\n                                    pos + node.nodeSize\n                                );\n\n                                return false;\n                            }\n                        });\n\n                        return is_suggestion;\n                    }),\n            };\n        },\n\n        addProseMirrorPlugins() {\n            // Suggestion command\n            this.options.suggestion.command = ({ editor, range, props }) => {\n                // Extend range until current cursor position.\n                range.to = editor.state.selection.$head.pos;\n                editor\n                    .chain()\n                    .focus()\n                    .insertContentAt(range, [\n                        {\n                            type: this.name,\n                            attrs: props,\n                        },\n                        {\n                            type: \"text\",\n                            text: \" \",\n                        },\n                    ])\n                    .run();\n            };\n\n            // Suggestion render\n            this.options.suggestion.render = () => {\n                let _debounced_context_menu;\n                return {\n                    onStart: async (props) => {\n                        const _context_menu = async (\n                            { transaction } = { transaction: null } // optional destructuring\n                        ) => {\n                            // If the transaction parameter is given then this\n                            // is a ``selectionUpdate``.\n                            let url = this.options.url;\n\n                            // Now get the text and pass it to the backend to\n                            // query for the filter value.\n                            //\n                            // Get the text input between the suggestion\n                            // character and the cursor.\n                            // This is then used to filter items and submitted\n                            // as query string to the server.\n                            let from = props.range.from + 1; // start w/out suggestion character.\n                            let to = transaction\n                                ? transaction.curSelection.$head.pos\n                                : props.range.to;\n                            const text = this.editor.state.doc.textBetween(from, to, \"\"); // prettier-ignore\n\n                            // Add query string filter value.\n                            // The query string filter key must be already present on the URL.\n                            url = text ? url + text : url;\n\n                            return await context_menu({\n                                url: url,\n                                editor: this.editor,\n                                instance: context_menu_instance,\n                                pattern: pattern_suggestion(app, props),\n                                extra_class: `tiptap-${plural || this.name}`, // plural form\n                            });\n                        };\n                        _debounced_context_menu = utils.debounce(async (transaction) => {\n                            context_menu_instance = await _context_menu(transaction);\n                        }, 200);\n\n                        // Immediately open the suggestion context menu.\n                        context_menu_instance = await _context_menu();\n\n                        // ... and reload it after text input after a short timeout.\n                        this.editor.on(\"selectionUpdate\", _debounced_context_menu);\n                    },\n                    onKeyDown: (props) => {\n                        if (!context_menu_instance) {\n                            //No context menu open, return.\n                            return;\n                        }\n\n                        if (props.event.key === \"Escape\") {\n                            context_menu_instance = context_menu_close({\n                                instance: context_menu_instance,\n                                pattern_name: \"tiptap-suggestion\",\n                            });\n                            this.editor.off(\"selectionUpdate\", _debounced_context_menu);\n                            return true;\n                        }\n                        if (\n                            props.event.key === \"ArrowDown\" ||\n                            props.event.key === \"ArrowUp\" ||\n                            props.event.key === \"Enter\"\n                        ) {\n                            props.event.preventDefault();\n                            props.event.stopPropagation();\n                            const ctx = document.querySelector(\".tiptap-items\");\n                            if (!ctx) {\n                                return;\n                            }\n\n                            // Dispatch the event to the context menu pattern\n                            // while still keeping the focus in the textarea.\n                            ctx.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: props.event.key,\n                                })\n                            );\n                        }\n                    },\n                    onExit: () => {\n                        context_menu_instance = context_menu_close({\n                            instance: context_menu_instance,\n                            pattern_name: \"tiptap-suggestion\",\n                        });\n                        this.editor.off(\"selectionUpdate\", _debounced_context_menu);\n                    },\n                };\n            };\n\n            // Suggestion allow\n            this.options.suggestion.allow = ({ state, range }) => {\n                const $from = state.doc.resolve(range.from);\n                const type = state.schema.nodes[this.name];\n                const allow = !!$from.parent.type.contentMatch.matchType(type);\n\n                return allow;\n            };\n\n            return [\n                ProseMirrorSuggestion({\n                    editor: this.editor,\n                    ...this.options.suggestion,\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["PREV_NODE","async","context_menu","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","context_menu_close","pattern_name","name","get_content","editor_element","options","element","reference_position","posToDOMRect","view","to","tippy","setProps","getReferenceClientRect","show","hide","destroy","SuggestionPluginKey","Suggestion","pluginKey","char","allowSpaces","prefixSpace","startOfLine","decorationTag","decorationClass","command","items","render","allow","props","renderer","key","update","prevState","_a","_b","_c","_d","_e","prev","this","getState","next","moved","active","range","started","stopped","handleStart","handleChange","query","handleExit","decorationNode","document","querySelector","decorationId","text","commandProps","clientRect","getBoundingClientRect","onExit","call","onUpdate","onStart","init","composing","apply","transaction","oldState","empty","match","config","$position","escapedChar","escapeForRegEx","suffix","RegExp","prefix","regexp","textFrom","depth","before","textTo","pos","textBetween","Array","matchAll","pop","undefined","input","index","matchPrefix","slice","Math","max","matchPrefixIsSpace","test","start","length","findSuggestionMatch","$from","floor","random","handleKeyDown","event","onKeyDown","decorations","nodeName","class","context_menu_instance","pattern_suggestion","app","trigger","$el","focus_handler","el","events","e","preventDefault","stopPropagation","code","indexOf","value","dataset","tiptapValue","target","closest","dom","attributes","Object","fromEntries","map","it","classList","remove","add","querySelectorAll","factory","plural","Node","group","inline","selectable","atom","addOptions","HTMLAttributes","renderLabel","node","suggestion","attrs","addAttributes","default","attr","parseHTML","tag","renderHTML","mergeAttributes","renderText","addKeyboardShortcuts","Enter","popper","dispatchEvent","KeyboardEvent","Backspace","commands","tr","is_suggestion","anchor","nodesBetween","type","insertText","nodeSize","addProseMirrorPlugins","$head","chain","focus","insertContentAt","run","_debounced_context_menu","_context_menu","curSelection","utils","on","off","ctx","resolve","schema","nodes","parent","contentMatch","matchType","TARGETS","setAttribute"],"sourceRoot":""}