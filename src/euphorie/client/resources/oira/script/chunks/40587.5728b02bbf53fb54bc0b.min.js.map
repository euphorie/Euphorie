{"version":3,"file":"chunks/40587.5728b02bbf53fb54bc0b.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/suggestion/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/suggestion.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/utils.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","import { PluginKey, Plugin } from '@tiptap/pm/state';\nimport { DecorationSet, Decoration } from '@tiptap/pm/view';\nimport { escapeForRegEx } from '@tiptap/core';\n\nfunction findSuggestionMatch(config) {\n    var _a;\n    const { char, allowSpaces, allowedPrefixes, startOfLine, $position, } = config;\n    const escapedChar = escapeForRegEx(char);\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const regexp = allowSpaces\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm');\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n    if (!text) {\n        return null;\n    }\n    const textFrom = $position.pos - text.length;\n    const match = Array.from(text.matchAll(regexp)).pop();\n    if (!match || match.input === undefined || match.index === undefined) {\n        return null;\n    }\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\n    // is a space or the start of the line\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n        return null;\n    }\n    // The absolute position of the match in the document\n    const from = textFrom + match.index;\n    let to = from + match[0].length;\n    // Edge case handling; if spaces are allowed and we're directly in between\n    // two triggers\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n        match[0] += ' ';\n        to += 1;\n    }\n    // If the $position is located within the matched substring, return that range\n    if (from < $position.pos && to >= $position.pos) {\n        return {\n            range: {\n                from,\n                to,\n            },\n            query: match[0].slice(char.length),\n            text: match[0],\n        };\n    }\n    return null;\n}\n\nconst SuggestionPluginKey = new PluginKey('suggestion');\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, allowedPrefixes = [' '], startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch, }) {\n    let props;\n    const renderer = render === null || render === void 0 ? void 0 : render();\n    const plugin = new Plugin({\n        key: pluginKey,\n        view() {\n            return {\n                update: async (view, prevState) => {\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n                    // See how the state changed\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\n                    const started = !prev.active && next.active;\n                    const stopped = prev.active && !next.active;\n                    const changed = !started && !stopped && prev.query !== next.query;\n                    const handleStart = started || (moved && changed);\n                    const handleChange = changed || moved;\n                    const handleExit = stopped;\n                    // Cancel when suggestion isn't active\n                    if (!handleStart && !handleChange && !handleExit) {\n                        return;\n                    }\n                    const state = handleExit && !handleStart ? prev : next;\n                    const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n                    props = {\n                        editor,\n                        range: state.range,\n                        query: state.query,\n                        text: state.text,\n                        items: [],\n                        command: commandProps => {\n                            return command({\n                                editor,\n                                range: state.range,\n                                props: commandProps,\n                            });\n                        },\n                        decorationNode,\n                        // virtual node for popper.js or tippy.js\n                        // this can be used for building popups without a DOM node\n                        clientRect: decorationNode\n                            ? () => {\n                                var _a;\n                                // because of `items` can be asynchrounous we’ll search for the current decoration node\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n                                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n                                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                            }\n                            : null,\n                    };\n                    if (handleStart) {\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                    }\n                    if (handleChange || handleStart) {\n                        props.items = await items({\n                            editor,\n                            query: state.query,\n                        });\n                    }\n                    if (handleExit) {\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                    }\n                    if (handleStart) {\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                    }\n                },\n                destroy: () => {\n                    var _a;\n                    if (!props) {\n                        return;\n                    }\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n                },\n            };\n        },\n        state: {\n            // Initialize the plugin's internal state.\n            init() {\n                const state = {\n                    active: false,\n                    range: {\n                        from: 0,\n                        to: 0,\n                    },\n                    query: null,\n                    text: null,\n                    composing: false,\n                };\n                return state;\n            },\n            // Apply changes to the plugin state from a view transaction.\n            apply(transaction, prev, _oldState, state) {\n                const { isEditable } = editor;\n                const { composing } = editor.view;\n                const { selection } = transaction;\n                const { empty, from } = selection;\n                const next = { ...prev };\n                next.composing = composing;\n                // We can only be suggesting if the view is editable, and:\n                //   * there is no selection, or\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n                if (isEditable && (empty || editor.view.composing)) {\n                    // Reset active state if we just left the previous suggestion range\n                    if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n                        next.active = false;\n                    }\n                    // Try to match against where our cursor currently is\n                    const match = findSuggestionMatch$1({\n                        char,\n                        allowSpaces,\n                        allowedPrefixes,\n                        startOfLine,\n                        $position: selection.$from,\n                    });\n                    const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n                    // If we found a match, update the current state to show it\n                    if (match && allow({\n                        editor, state, range: match.range, isActive: prev.active,\n                    })) {\n                        next.active = true;\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n                        next.range = match.range;\n                        next.query = match.query;\n                        next.text = match.text;\n                    }\n                    else {\n                        next.active = false;\n                    }\n                }\n                else {\n                    next.active = false;\n                }\n                // Make sure to empty the range if suggestion is inactive\n                if (!next.active) {\n                    next.decorationId = null;\n                    next.range = { from: 0, to: 0 };\n                    next.query = null;\n                    next.text = null;\n                }\n                return next;\n            },\n        },\n        props: {\n            // Call the keydown hook if suggestion is active.\n            handleKeyDown(view, event) {\n                var _a;\n                const { active, range } = plugin.getState(view.state);\n                if (!active) {\n                    return false;\n                }\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\n            },\n            // Setup decorator on the currently active suggestion.\n            decorations(state) {\n                const { active, range, decorationId } = plugin.getState(state);\n                if (!active) {\n                    return null;\n                }\n                return DecorationSet.create(state.doc, [\n                    Decoration.inline(range.from, range.to, {\n                        nodeName: decorationTag,\n                        class: decorationClass,\n                        'data-decoration-id': decorationId,\n                    }),\n                ]);\n            },\n        },\n    });\n    return plugin;\n}\n\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=index.js.map\n","import { Node, mergeAttributes } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { Suggestion as ProseMirrorSuggestion } from \"@tiptap/suggestion\";\nimport { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\nimport tiptap_utils from \"../utils\";\n\nlet context_menu_instance;\n\nfunction pattern_suggestion(app, props) {\n    // Dynamic pattern for the suggestion context menu\n\n    class Pattern extends BasePattern {\n        static name = \"tiptap-suggestion\";\n        static trigger = \".tiptap-items\";\n\n        init() {\n            focus_handler(this.el);\n\n            this.active = this.items[0];\n\n            // Support selections via keyboard navigation.\n            events.add_event_listener(\n                this.el,\n                \"keydown\",\n                \"tiptap-suggestion-keydown\",\n                (e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    const items = this.items;\n                    const active = this.active;\n                    if (e.code === \"ArrowDown\") {\n                        // Select next or first.\n                        if (!active) {\n                            this.active = items[0];\n                        } else {\n                            let next = active ? items.indexOf(active) + 1 : 0;\n                            if (next >= items.length) {\n                                // circular selection mode, start with first.\n                                next = 0;\n                                // TODO: should we load the next batch?\n                            }\n                            this.active = items[next];\n                        }\n                    } else if (e.code === \"ArrowUp\") {\n                        // Select previous or last.\n                        if (!active) {\n                            this.active = items[0];\n                        } else {\n                            let prev = active ? items.indexOf(active) - 1 : 0;\n                            if (prev < 0) {\n                                // back to first\n                                prev = items.length - 1;\n                                // TODO: should we load the previous batch?\n                            }\n                            this.active = items[prev];\n                        }\n                    } else if (e.code === \"Enter\") {\n                        // Use selected to insert in text area.\n                        const value = active?.dataset?.tiptapValue;\n                        if (!value) {\n                            // nothing selected.\n                            return;\n                        }\n\n                        const el = active.querySelector(\"a\");\n                        this.command(el, value);\n                    }\n                }\n            );\n\n            // Select and insert to text area by clicking.\n            events.add_event_listener(\n                this.el,\n                \"click\",\n                \"tiptap-suggestion-click\",\n                (e) => {\n                    const el = e.target.closest(\"a\");\n                    const value = dom.acquire_attribute(el, \"data-tiptap-value\");\n                    if (!value) {\n                        // clicked anywhere, but not on a selection item\n                        return;\n                    }\n\n                    e.preventDefault();\n                    this.command(el, value);\n                }\n            );\n        }\n\n        command(el, value) {\n            const attributes = Object.fromEntries(\n                [...el.attributes].map((it) => [it.name, it.value])\n            );\n            props.command({\n                \"data-title\": value,\n                ...attributes,\n            });\n        }\n\n        get active() {\n            // Get the currently selected item.\n            return this.el.querySelector(\".tiptap-item.active\");\n        }\n\n        set active(el) {\n            if (!el) {\n                // No item available, e.g. no search results and thus not this.items.\n                return;\n            }\n            // Set an item to be selected.\n            this.active?.classList.remove(\"active\");\n            el.classList.add(\"active\");\n        }\n\n        get items() {\n            // Get all items.\n            return [...this.el.querySelectorAll(\".tiptap-item\")];\n        }\n    }\n\n    return Pattern;\n}\n\nexport const factory = ({ app, name, char, plural }) => {\n    return Node.create({\n        name: name,\n        content: \"inline*\",\n        group: \"inline\",\n        inline: true,\n        selectable: false,\n        atom: true,\n        isolating: true,\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n                url: null,\n                renderLabel({ options, node }) {\n                    // Prefer text from data-title attribute to the node's text\n                    // content. The node's text content (e.g. from the\n                    // suggestion overlay) could include some other text or\n                    // markup not suitable for rendering the suggestion.\n                    // Replace any existing suggestion char from the text.\n                    const text = (\n                        node.attrs[\"data-title\"] ||\n                        node.content?.content?.[0]?.text ||\n                        \"\"\n                    ).replace(new RegExp(`^${options.suggestion.char}`), \"\");\n                    return `${options.suggestion.char}${text}`;\n                },\n                suggestion: {\n                    char: char,\n                    pluginKey: new PluginKey(name),\n                },\n            };\n        },\n\n        addAttributes() {\n            const attributes = {\n                \"class\": {},\n                \"contenteditable\": {},\n                \"href\": {},\n                \"target\": {},\n                \"title\": {},\n                \"data-id\": {},\n                \"data-title\": {},\n                // add a lot of patterns data attributes...\n                \"data-pat-inject\": {},\n                \"data-pat-forward\": {},\n                \"data-pat-modal\": {},\n                \"data-pat-switch\": {},\n                \"data-pat-toggle\": {},\n                \"data-pat-tooltip\": {},\n            };\n\n            // Needs to be always included. A default of \"\" makes sure it is.\n            attributes[`data-${this.name}`] = { default: \"\" };\n\n            for (const attr of tiptap_utils.accessibility_attributes) {\n                // Add a bunch of accessibility attributes\n                attributes[attr] = {};\n            }\n\n            return attributes;\n        },\n\n        parseHTML() {\n            return [\n                {\n                    tag: `a[data-${this.name}]`,\n                },\n            ];\n        },\n\n        renderHTML({ node, HTMLAttributes }) {\n            return [\n                \"a\",\n                mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                this.options.renderLabel({\n                    options: this.options,\n                    node,\n                }),\n            ];\n        },\n\n        renderText({ node }) {\n            return this.options.renderLabel({\n                options: this.options,\n                node,\n            });\n        },\n\n        addKeyboardShortcuts() {\n            return {\n                Enter: () => {\n                    if (context_menu_instance) {\n                        // While suggestion menu is open, do not add a line-break to the text.\n                        // Handle the ``Enter`` key as early as possible to prevent a line-break to happen.\n\n                        // Dispatch the event to the context menu pattern\n                        // while still keeping the focus in the textarea.\n                        context_menu_instance.tippy?.popper\n                            ?.querySelector(\".tiptap-items\")\n                            ?.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: \"Enter\",\n                                })\n                            );\n\n                        return true;\n                    }\n                    // Normal case, do not prevent the Enter key to add a line break.\n                    return false;\n                },\n\n                Backspace: ({ editor }) =>\n                    editor.commands.command(({ tr, state }) => {\n                        let is_suggestion = false;\n                        const { selection } = state;\n                        const { empty, anchor } = selection;\n\n                        if (!empty) {\n                            return false;\n                        }\n\n                        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n                            if (node.type.name === this.name) {\n                                is_suggestion = true;\n                                tr.insertText(\n                                    this.options.suggestion.char || \"\",\n                                    pos,\n                                    pos + node.nodeSize\n                                );\n\n                                return false;\n                            }\n                        });\n\n                        return is_suggestion;\n                    }),\n            };\n        },\n\n        addProseMirrorPlugins() {\n            // Suggestion command\n            this.options.suggestion.command = ({ editor, range, props }) => {\n                // Extend range until current cursor position.\n                range.to = editor.state.selection.$head.pos;\n                editor\n                    .chain()\n                    .focus()\n                    .insertContentAt(range, [\n                        {\n                            type: this.name,\n                            attrs: props,\n                        },\n                        {\n                            type: \"text\",\n                            text: \" \",\n                        },\n                    ])\n                    .run();\n            };\n\n            // Suggestion menu rendering\n            this.options.suggestion.render = () => {\n                let _debounced_context_menu;\n\n                const ctx_close = async () => {\n                    this.editor.off(\"selectionUpdate\", _debounced_context_menu);\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-suggestion\",\n                    });\n                    context_menu_instance = null;\n                };\n\n                return {\n                    onStart: async (props) => {\n                        const _context_menu = async (\n                            { transaction } = { transaction: null } // optional destructuring\n                        ) => {\n                            // If the transaction parameter is given then this\n                            // is a ``selectionUpdate``.\n                            let url = this.options.url;\n\n                            // Now get the text and pass it to the backend to\n                            // query for the filter value.\n                            //\n                            // Get the text input between the suggestion\n                            // character and the cursor.\n                            // This is then used to filter items and submitted\n                            // as query string to the server.\n                            let from = props.range.from + 1; // start w/out suggestion character.\n                            let to = transaction\n                                ? transaction.curSelection.$head.pos\n                                : props.range.to;\n                            const text = this.editor.state.doc.textBetween(from, to, \"\"); // prettier-ignore\n\n                            // Add query string filter value.\n                            // The query string filter key must be already present on the URL.\n                            url = text ? url + text : url;\n\n                            const ctx_menu = await context_menu({\n                                url: url,\n                                editor: this.editor,\n                                instance: context_menu_instance,\n                                pattern: pattern_suggestion(app, props),\n                                extra_class: `tiptap-${plural || this.name}`, // plural form\n                            });\n\n                            return ctx_menu;\n                        };\n                        _debounced_context_menu = utils.debounce(async (transaction) => {\n                            context_menu_instance = await _context_menu(transaction);\n                        }, 200);\n\n                        // Immediately open the suggestion context menu.\n                        context_menu_instance = await _context_menu();\n\n                        // ... and reload it after text input after a short timeout.\n                        this.editor.on(\"selectionUpdate\", _debounced_context_menu);\n                    },\n                    onKeyDown: (props) => {\n                        if (!context_menu_instance) {\n                            //No context menu open, return.\n                            return;\n                        }\n\n                        if (\n                            props.event.key === \"ArrowDown\" ||\n                            props.event.key === \"ArrowUp\" ||\n                            props.event.key === \"Enter\"\n                        ) {\n                            props.event.preventDefault();\n                            props.event.stopPropagation();\n                            const ctx = document.querySelector(\".tiptap-items\");\n                            if (!ctx) {\n                                return;\n                            }\n\n                            // Dispatch the event to the context menu pattern\n                            // while still keeping the focus in the textarea.\n                            ctx.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: props.event.key,\n                                })\n                            );\n                        }\n                    },\n                    onExit: () => {\n                        ctx_close();\n                    },\n                };\n            };\n\n            // Suggestion allow\n            this.options.suggestion.allow = ({ state, range }) => {\n                const $from = state.doc.resolve(range.from);\n                const type = state.schema.nodes[this.name];\n                const allow = !!$from.parent.type.contentMatch.matchType(type);\n\n                return allow;\n            };\n\n            return [\n                ProseMirrorSuggestion({\n                    editor: this.editor,\n                    ...this.options.suggestion,\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n","export const add_search_params = (url, params = {}) => {\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams#examples\n    const url_obj = new URL(url, window.location.href);\n    return `${url_obj.origin}${url_obj.pathname}?${new URLSearchParams([\n        ...Array.from(url_obj.searchParams.entries()),\n        ...Object.entries(params),\n    ]).toString()}`;\n};\n\n// Export a list of WAI attributes.\nexport const accessibility_attributes = [\n    \"aria-activedescendant\",\n    \"aria-atomic\",\n    \"aria-autocomplete\",\n    \"aria-busy\",\n    \"aria-checked\",\n    \"aria-controls\",\n    \"aria-describedby\",\n    \"aria-disabled\",\n    \"aria-dropeffect\",\n    \"aria-expanded\",\n    \"aria-flowto\",\n    \"aria-grabbed\",\n    \"aria-haspopup\",\n    \"aria-hidden\",\n    \"aria-invalid\",\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-level\",\n    \"aria-live\",\n    \"aria-multiline\",\n    \"aria-multiselectable\",\n    \"aria-orientation\",\n    \"aria-owns\",\n    \"aria-posinset\",\n    \"aria-pressed\",\n    \"aria-readonly\",\n    \"aria-relevant\",\n    \"aria-required\",\n    \"aria-selected\",\n    \"aria-setsize\",\n    \"aria-sort\",\n    \"aria-valuemax\",\n    \"aria-valuemin\",\n    \"aria-valuenow\",\n    \"aria-valuetext\",\n    \"role\",\n];\n\n/**\n * Test, if a given string is a absolute or relative URL.\n *\n * @param {string} value - The URL to test.\n * @returns {boolean} True, if the value is a absolute or relative URL.\n */\nexport const is_url = (value) => {\n    // Search for relative or absolute URLs (e.g. `/`, `./`, `../`) or for\n    // any URL with a protocol (e.g. `http://`, `https://`, `mailto:`).\n    const re_url = /(^\\.?\\.?\\/|^[^\\.]+:)/;\n    return re_url.test(value);\n};\n\n/**\n * Test, if a given string is a valid e-mail address.\n *\n * @param {string} value - The e-mail to test.\n * @returns {boolean} True, if the value is a valid e-mail.\n */\nexport const is_mail = (value) => {\n    const re_mail = /[^@\\s]+@[^@\\s]+\\.[^@\\s]+/;\n    return re_mail.test(value);\n};\n\nexport default {\n    add_search_params: add_search_params,\n    accessibility_attributes: accessibility_attributes,\n    is_url: is_url,\n    is_mail: is_mail,\n};\n"],"names":["PREV_NODE","async","context_menu","_ref","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","patterns","editor_element","options","element","patTooltip","events","await_pattern_init","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","add_event_listener","document","e","target","dom","get_parents","includes","popper","key","show","_ref2","hide","destroy","remove_event_listener","findSuggestionMatch","config","_a","char","allowSpaces","allowedPrefixes","startOfLine","$position","escapedChar","escapeForRegEx","suffix","RegExp","prefix","regexp","text","nodeBefore","isText","textFrom","pos","length","match","Array","matchAll","pop","undefined","input","index","matchPrefix","slice","Math","max","matchPrefixIsAllowed","join","test","range","query","SuggestionPluginKey","Suggestion","pluginKey","decorationTag","decorationClass","command","items","render","allow","findSuggestionMatch$1","props","renderer","plugin","update","prevState","_b","_c","_d","_e","_f","_g","prev","this","getState","next","moved","active","started","stopped","changed","handleStart","handleChange","handleExit","decorationNode","querySelector","decorationId","commandProps","clientRect","currentDecorationNode","getBoundingClientRect","onBeforeStart","call","onBeforeUpdate","onExit","onUpdate","onStart","init","composing","apply","transaction","_oldState","isEditable","empty","$from","floor","random","isActive","handleKeyDown","event","onKeyDown","decorations","create","inline","nodeName","class","context_menu_instance","pattern_suggestion","app","Pattern","BasePattern","static","focus_handler","el","preventDefault","stopPropagation","code","indexOf","value","dataset","tiptapValue","closest","acquire_attribute","attributes","Object","fromEntries","map","it","classList","remove","add","querySelectorAll","factory","plural","Node","content","group","selectable","atom","isolating","addOptions","HTMLAttributes","renderLabel","node","attrs","replace","suggestion","PluginKey","addAttributes","default","attr","tiptap_utils","parseHTML","tag","renderHTML","_ref3","mergeAttributes","renderText","_ref4","addKeyboardShortcuts","Enter","dispatchEvent","KeyboardEvent","Backspace","_ref5","commands","_ref6","tr","is_suggestion","anchor","nodesBetween","type","insertText","nodeSize","addProseMirrorPlugins","_this","_ref7","$head","chain","focus","insertContentAt","run","_debounced_context_menu","ctx_close","off","_context_menu","arguments","curSelection","textBetween","utils","debounce","on","ctx","_ref8","resolve","schema","nodes","parent","contentMatch","matchType","ProseMirrorSuggestion","TARGETS","setAttribute","timeout","add_search_params","params","url_obj","URL","window","location","href","origin","pathname","URLSearchParams","searchParams","entries","toString","accessibility_attributes","is_url","is_mail"],"sourceRoot":""}