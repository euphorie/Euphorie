{"version":3,"file":"chunks/6798.e178f7c7489c89004b94.min.js","mappings":"ohEAMA,SAASA,EAAgBC,EAAOC,GAC9B,OAAID,EAAME,UAAUC,QAChBF,GAAYA,EAASD,EAAMI,GAAGL,kBAAkBM,mBAC7C,GAWT,SAASC,EAAaN,EAAOC,EAAUM,GACrC,IACIC,EADMR,EAAME,UACEM,QAClB,IAAKA,IAAYD,GAAQA,EAAKE,eAAe,WAAYT,GACjCQ,EAAQE,aAAe,GAC3C,OAAO,EAEX,IAAIC,EAAOC,EAAcJ,GAGzB,IAAKG,EAAM,CACT,IAAIE,EAAQL,EAAQM,aAAcC,EAASF,IAAS,QAAWA,GAC/D,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GAGT,IAAIY,EAASN,EAAKO,WAElB,IAAKD,EAAOE,KAAKC,KAAKC,WAAaC,EAActB,EAAOW,EAAMV,GAC1D,OAAO,EAIX,GAAmC,GAA/BO,EAAQe,OAAOC,QAAQC,OACtBC,EAAYT,EAAQ,QAAU,kBAA2BA,IAAU,CACtE,IAAIU,GAAU,QAAY3B,EAAM4B,IAAKpB,EAAQS,SAAUT,EAAQqB,QAAS,YACxE,GAAIF,EAAQG,MAAML,KAAOE,EAAQI,GAAKJ,EAAQK,KAAM,CAClD,GAAI/B,EAAU,CACZ,IAAIG,EAAKJ,EAAMI,GAAG6B,KAAKN,GACvBvB,EAAG8B,aAAaR,EAAYT,EAAQ,OAAS,cAAmBb,EAAGwB,IAAIO,QAAQ/B,EAAGgC,QAAQC,IAAI1B,EAAK2B,KAAM,KAAM,GAC7F,YAAqBlC,EAAGwB,IAAKjB,EAAK2B,IAAMrB,EAAOsB,WACjEtC,EAASG,EAAGC,kBAEd,OAAO,GAKX,SAAIY,EAAOuB,QAAU7B,EAAK8B,OAASjC,EAAQiC,MAAQ,KAC7CxC,GAAYA,EAASD,EAAMI,GAAGsC,OAAO/B,EAAK2B,IAAMrB,EAAOsB,SAAU5B,EAAK2B,KAAKjC,mBACxE,GAMX,SAASqB,EAAYiB,EAAMC,EAAMC,GAC/B,KAAOF,EAAMA,EAAgB,SAARC,EAAkBD,EAAKG,WAAaH,EAAKI,UAAY,CACxE,GAAIJ,EAAKK,YAAe,OAAO,EAC/B,GAAIH,GAA2B,GAAnBF,EAAKM,WAAmB,OAAO,EAE7C,OAAO,EAUT,SAASC,EAAmBlD,EAAOC,EAAUM,GAC3C,IAAI4C,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MAEZzC,EAAOyC,EACX,IAFYD,EAAIhD,MAEF,OAAO,EAErB,GAAIiD,EAAM7B,OAAOyB,YAAa,CAC5B,GAAIzC,GAAQA,EAAKE,eAAe,WAAYT,GAASoD,EAAM1C,aAAe,EAAK,OAAO,EACtFC,EAAOC,EAAcwC,GAEvB,IAAIT,EAAOhC,GAAQA,EAAKO,WACxB,SAAKyB,IAAS,kBAA2BA,MACrC1C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKjB,EAAK2B,IAAMK,EAAKJ,WAAWlC,mBACvF,GAGT,SAASO,EAAcyC,GACrB,IAAKA,EAAK9B,OAAOJ,KAAKC,KAAKC,UAAa,IAAK,IAAIiC,EAAID,EAAKZ,MAAQ,EAAGa,GAAK,EAAGA,IAAK,CAChF,GAAID,EAAKE,MAAMD,GAAK,EAAK,OAAOD,EAAKzB,IAAIO,QAAQkB,EAAKpC,OAAOqC,EAAI,IACjE,GAAID,EAAKV,KAAKW,GAAGnC,KAAKC,KAAKC,UAAa,MAE1C,OAAO,KAST,SAASmC,EAAYxD,EAAOC,EAAUM,GACpC,IACIC,EADMR,EAAME,UACEM,QAClB,IAAKA,IAAYD,GAAQA,EAAKE,eAAe,UAAWT,GAChCQ,EAAQE,aAAeF,EAAQe,OAAOC,QAAQC,MAClE,OAAO,EAEX,IAAId,EAAO8C,EAAajD,GAGxB,IAAKG,EAAQ,OAAO,EAEpB,IAAIkB,EAAQlB,EAAK+C,UAEjB,GAAIpC,EAActB,EAAOW,EAAMV,GAAa,OAAO,EAInD,GAAmC,GAA/BO,EAAQe,OAAOC,QAAQC,OACtBC,EAAYG,EAAO,UAAY,kBAA2BA,IAAS,CACtE,IAAIF,GAAU,QAAY3B,EAAM4B,IAAKpB,EAAQS,SAAUT,EAAQqB,QAAS,YACxE,GAAIF,EAAQG,MAAML,KAAOE,EAAQI,GAAKJ,EAAQK,KAAM,CAClD,GAAI/B,EAAU,CACZ,IAAIG,EAAKJ,EAAMI,GAAG6B,KAAKN,GACvBvB,EAAG8B,aAAaR,EAAYG,EAAO,SAAW,cAAmBzB,EAAGwB,IAAIO,QAAQ/B,EAAGgC,QAAQC,IAAI1B,EAAK2B,MAAO,GACzF,YAAqBlC,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI1B,EAAK2B,OACnErC,EAASG,EAAGC,kBAEd,OAAO,GAKX,SAAIwB,EAAMW,QAAU7B,EAAK8B,OAASjC,EAAQiC,MAAQ,KAC5CxC,GAAYA,EAASD,EAAMI,GAAGsC,OAAO/B,EAAK2B,IAAK3B,EAAK2B,IAAMT,EAAMU,UAAUlC,mBACvE,GAaX,SAASsD,EAAkB3D,EAAOC,EAAUM,GAC1C,IAAI4C,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MAEZzC,EAAOyC,EACX,IAFYD,EAAIhD,MAEF,OAAO,EACrB,GAAIiD,EAAM7B,OAAOyB,YAAa,CAC5B,GAAIzC,GAAQA,EAAKE,eAAe,UAAWT,GAASoD,EAAM1C,aAAe0C,EAAM7B,OAAOC,QAAQC,KAC1F,OAAO,EACXd,EAAO8C,EAAaL,GAEtB,IAAIT,EAAOhC,GAAQA,EAAK+C,UACxB,SAAKf,IAAS,kBAA2BA,MACrC1C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKjB,EAAK2B,MAAMjC,mBACvE,GAGT,SAASoD,EAAaJ,GACpB,IAAKA,EAAK9B,OAAOJ,KAAKC,KAAKC,UAAa,IAAK,IAAIiC,EAAID,EAAKZ,MAAQ,EAAGa,GAAK,EAAGA,IAAK,CAChF,IAAI/B,EAAS8B,EAAKV,KAAKW,GACvB,GAAID,EAAKE,MAAMD,GAAK,EAAI/B,EAAO0B,WAAc,OAAOI,EAAKzB,IAAIO,QAAQkB,EAAKxB,MAAMyB,EAAI,IACpF,GAAI/B,EAAOJ,KAAKC,KAAKC,UAAa,MAEpC,OAAO,KA0DT,SAASuC,EAAc5D,EAAOC,GAC5B,IAAIkD,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QAClB,SAAKT,EAAM7B,OAAOJ,KAAKC,KAAK0C,OAASV,EAAMW,WAAWF,MAClD5D,GAAYA,EAASD,EAAMI,GAAG4D,WAAW,MAAM3D,mBAC5C,GAGT,SAAS4D,EAAeC,GACtB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,IAAK,CACxC,IACInC,EADM+C,EAAME,KAAKd,GACNnC,KACf,GAAIA,EAAK6B,cAAgB7B,EAAKkD,mBAAsB,OAAOlD,EAE7D,OAAO,KAOT,SAASmD,EAAStE,EAAOC,GACvB,IAAIkD,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QAClB,IAAKT,EAAM7B,OAAOJ,KAAKC,KAAK0C,OAASV,EAAMW,WAAWF,GAAY,OAAO,EACzE,IAAIU,EAAQnB,EAAMT,MAAM,GAAId,EAAQuB,EAAMoB,YAAY,GAAIrD,EAAO8C,EAAeM,EAAME,eAAe5C,IACrG,IAAK0C,EAAMG,eAAe7C,EAAOA,EAAOV,GAAS,OAAO,EACxD,GAAIlB,EAAU,CACZ,IAAIqC,EAAMc,EAAMvB,QAASzB,EAAKJ,EAAMI,GAAGuE,YAAYrC,EAAKA,EAAKnB,EAAKyD,iBAClExE,EAAG8B,aAAa,UAAe9B,EAAGwB,IAAIO,QAAQG,GAAM,IACpDrC,EAASG,EAAGC,kBAEd,OAAO,EAMT,SAASwE,EAAoB7E,EAAOC,GAClC,IAAI6E,EAAM9E,EAAME,UACZ6E,EAAQD,EAAIC,MACZC,EAAMF,EAAIE,IACd,GAAIF,aAAe,MAAgBC,EAAMxD,OAAO0D,eAAiBD,EAAIzD,OAAO0D,cAAiB,OAAO,EACpG,IAAI9D,EAAO8C,EAAee,EAAIzD,OAAOkD,eAAeO,EAAIR,eACxD,IAAKrD,IAASA,EAAK6B,YAAe,OAAO,EACzC,GAAI/C,EAAU,CACZ,IAAI2C,IAASmC,EAAMrE,cAAgBsE,EAAIzB,QAAUyB,EAAIzD,OAAO0B,WAAa8B,EAAQC,GAAK1C,IAClFlC,EAAKJ,EAAMI,GAAG8E,OAAOtC,EAAMzB,EAAKyD,iBACpCxE,EAAG8B,aAAa,YAAqB9B,EAAGwB,IAAKgB,EAAO,IACpD3C,EAASG,EAAGC,kBAEd,OAAO,EAMT,SAAS8E,EAAenF,EAAOC,GAC7B,IACIO,EADMR,EAAME,UACEM,QAClB,IAAKA,GAAWA,EAAQe,OAAOC,QAAQC,KAAQ,OAAO,EACtD,GAAIjB,EAAQiC,MAAQ,GAAKjC,EAAQqB,SAAWrB,EAAQ4E,KAAK,GAAI,CAC3D,IAAInE,EAAST,EAAQS,SACrB,IAAI,QAASjB,EAAM4B,IAAKX,GAEtB,OADIhB,GAAYA,EAASD,EAAMI,GAAGiF,MAAMpE,GAAQZ,mBACzC,EAGX,IAAIQ,EAAQL,EAAQM,aAAcC,EAASF,IAAS,QAAWA,GAC/D,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GAMT,SAASiF,EAAWtF,EAAOC,GACzB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACd,GAAIhF,EAAME,qBAAqB,MAAiBF,EAAME,UAAUyC,KAAK4C,QACnE,SAAKR,EAAMrE,gBAAiB,QAASV,EAAM4B,IAAKmD,EAAMzC,QAClDrC,GAAYA,EAASD,EAAMI,GAAGiF,MAAMN,EAAMzC,KAAKjC,mBAC5C,GAGT,IAAK0E,EAAMxD,OAAOgE,QAAW,OAAO,EAEpC,GAAItF,EAAU,CACZ,IAAIuF,EAAQR,EAAItE,cAAgBsE,EAAIzD,OAAOC,QAAQC,KAC/CrB,EAAKJ,EAAMI,IACXJ,EAAME,qBAAqB,MAAiBF,EAAME,qBAAqB,OAAgBE,EAAGL,kBAC9F,IAAI0F,EAAuB,GAAfV,EAAMtC,MAAa,KAAOwB,EAAec,EAAMpC,MAAM,GAAG8B,eAAeM,EAAMP,YAAY,KACjGkB,EAAQF,GAASC,EAAQ,CAAC,CAACtE,KAAMsE,IAAU,KAC3CE,GAAM,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GAKzD,GAJKA,GAAUC,KAAO,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGmD,GAAS,CAAC,CAACtE,KAAMsE,OACpFC,EAAQ,CAAC,CAACvE,KAAMsE,IAChBE,GAAM,GAEJA,IACFvF,EAAGiF,MAAMjF,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,IAClCF,IAAUT,EAAMrE,cAAgBqE,EAAMxD,OAAOJ,MAAQsE,GAAO,CAC/D,IAAIG,EAAQxF,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAW4E,EAASzF,EAAGwB,IAAIO,QAAQyD,GAChEb,EAAMpC,MAAM,GAAG+B,eAAemB,EAAOtC,QAASsC,EAAOtC,QAAU,EAAGkC,IAClErF,EAAG0F,cAAc1F,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAWwE,GAGzDxF,EAASG,EAAGC,kBAEd,OAAO,EAqDT,SAASiB,EAActB,EAAOW,EAAMV,GAClC,IAAsD8F,EAAM7B,EAAxDjD,EAASN,EAAKO,WAAYW,EAAQlB,EAAK+C,UAC3C,GAAIzC,EAAOE,KAAKC,KAAKC,WAAaQ,EAAMV,KAAKC,KAAKC,UAAa,OAAO,EACtE,GApBF,SAAwBrB,EAAOqD,EAAMpD,GACnC,IAAIgB,EAASoC,EAAKnC,WAAYW,EAAQwB,EAAKK,UAAWH,EAAQF,EAAKE,QACnE,UAAKtC,GAAWY,GAAUZ,EAAOE,KAAK6E,kBAAkBnE,EAAMV,UACzDF,EAAOO,QAAQC,MAAQ4B,EAAK9B,OAAO0E,WAAW1C,EAAQ,EAAGA,IACxDtD,GAAYA,EAASD,EAAMI,GAAGsC,OAAOW,EAAKf,IAAMrB,EAAOsB,SAAUc,EAAKf,KAAKjC,kBACxE,IAEJgD,EAAK9B,OAAO0E,WAAW1C,EAAOA,EAAQ,KAAQ1B,EAAMmB,eAAe,QAAQhD,EAAM4B,IAAKyB,EAAKf,OAE5FrC,GACAA,EAASD,EAAMI,GACP8F,kBAAkB7C,EAAKf,IAAKrB,EAAOE,KAAMF,EAAOwD,eAAexD,EAAOgC,aACtEkD,KAAK9C,EAAKf,KACVjC,kBACL,KAMH+F,CAAepG,EAAOW,EAAMV,GAAa,OAAO,EAEpD,IAAIoG,EAAc1F,EAAKY,OAAO0E,WAAWtF,EAAK4C,QAAS5C,EAAK4C,QAAU,GACtE,GAAI8C,IACCN,GAAQ7B,EAAQjD,EAAOwD,eAAexD,EAAOgC,aAAaqD,aAAazE,EAAMV,QAC9E+C,EAAMqC,UAAUR,EAAK,IAAMlE,EAAMV,MAAMqF,SAAU,CACnD,GAAIvG,EAAU,CAEZ,IADA,IAAImF,EAAMzE,EAAK2B,IAAMT,EAAMU,SAAUkE,EAAO,WACnCnD,EAAIyC,EAAKW,OAAS,EAAGpD,GAAK,EAAGA,IAClCmD,EAAO,UAAcV,EAAKzC,GAAGqD,OAAO,KAAMF,IAC9CA,EAAO,UAAcxF,EAAO2F,KAAKH,IACjC,IAAIrG,EAAKJ,EAAMI,GAAG6B,KAAK,IAAI,KAAkBtB,EAAK2B,IAAM,EAAG8C,EAAKzE,EAAK2B,IAAK8C,EAAK,IAAI,KAAMqB,EAAM,EAAG,GAAIV,EAAKW,QAAQ,IAC/GG,EAASzB,EAAM,EAAIW,EAAKW,QACxB,QAAQtG,EAAGwB,IAAKiF,IAAWzG,EAAG+F,KAAKU,GACvC5G,EAASG,EAAGC,kBAEd,OAAO,EAGT,IAAIyG,EAAW,cAAmBnG,EAAM,GACpCE,EAAQiG,GAAYA,EAAS/B,MAAMjE,WAAWgG,EAAS9B,KAAMjE,EAASF,IAAS,QAAWA,GAC9F,GAAc,MAAVE,GAAkBA,GAAUJ,EAAK8B,MAEnC,OADIxC,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,EAGT,GAAIgG,GAAe3E,EAAYG,EAAO,SAAS,IAASH,EAAYT,EAAQ,OAAQ,CAElF,IADA,IAAI8F,EAAK9F,EAAQ+F,EAAS,GAExBA,EAAOC,KAAKF,IACRA,EAAG/D,aACP+D,EAAKA,EAAGhE,UAGV,IADA,IAAImE,EAAYrF,EAAOsF,EAAa,GAC5BD,EAAUlE,YAAakE,EAAYA,EAAUpE,WAAcqE,IACnE,GAAIJ,EAAGd,WAAWc,EAAG9D,WAAY8D,EAAG9D,WAAYiE,EAAU1F,SAAU,CAClE,GAAIvB,EAAU,CAEZ,IADA,IAAImH,EAAQ,WACHC,EAAML,EAAON,OAAS,EAAGW,GAAO,EAAGA,IAASD,EAAQ,UAAcJ,EAAOK,GAAKT,KAAKQ,IAI5FnH,EAHWD,EAAMI,GAAG6B,KAAK,IAAI,KAAkBtB,EAAK2B,IAAM0E,EAAON,OAAQ/F,EAAK2B,IAAMT,EAAMU,SAC7C5B,EAAK2B,IAAM6E,EAAYxG,EAAK2B,IAAMT,EAAMU,SAAW4E,EACnD,IAAI,KAAMC,EAAOJ,EAAON,OAAQ,GAAI,GAAG,IACtErG,kBAEhB,OAAO,GAIX,OAAO,EAGT,SAASiH,EAAoB1E,GAC3B,OAAO,SAAS5C,EAAOC,GAGrB,IAFA,IAAI6E,EAAM9E,EAAME,UAAWmD,EAAOT,EAAO,EAAIkC,EAAIC,MAAQD,EAAIE,IACzDvC,EAAQY,EAAKZ,MACVY,EAAKV,KAAKF,GAAO8E,UAAU,CAChC,IAAK9E,EAAS,OAAO,EACrBA,IAEF,QAAKY,EAAKV,KAAKF,GAAOO,cAClB/C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAC/BlC,EAAM4B,IAAKgB,EAAO,EAAIS,EAAKmE,MAAM/E,GAASY,EAAK+B,IAAI3C,OAChD,IAMX,IAAIgF,EAAuBH,GAAqB,GAI5CI,EAAqBJ,EAAoB,GAsB7C,SAASK,EAAaC,EAAUC,GAC9B,OAAO,SAAS7H,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ8B,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GACT+F,GAAa,EAWjB,OAVA9H,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC/C,GAAIwF,EAAc,OAAO,EACzB,GAAKnF,EAAKK,cAAeL,EAAKqF,UAAUJ,EAAUC,GAClD,GAAIlF,EAAKxB,MAAQyG,EACfE,GAAa,MACR,CACL,IAAIzE,EAAOrD,EAAM4B,IAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAChDuE,EAAazE,EAAK9B,OAAOmD,eAAenB,EAAOA,EAAQ,EAAGqE,SAGzDE,IACD7H,GAAYA,EAASD,EAAMI,GAAGuH,aAAa3F,EAAMD,EAAI6F,EAAUC,GAAOxH,mBACnE,IAmIX,SAAS4H,IAEP,IADA,IAAIC,EAAW,GAAIC,EAAMC,UAAU1B,OAC3ByB,KAAQD,EAAUC,GAAQC,UAAWD,GAE7C,OAAO,SAASnI,EAAOC,EAAUM,GAC/B,IAAK,IAAI+C,EAAI,EAAGA,EAAI4E,EAASxB,OAAQpD,IACjC,GAAI4E,EAAS5E,GAAGtD,EAAOC,EAAUM,GAAS,OAAO,EACrD,OAAO,GAIX,IAAI8H,EAAYJ,EAAclI,EAAiBO,EAAc4C,GACzDoF,EAAML,EAAclI,EAAiByD,EAAaG,GAalD4E,EAAe,CACjB,MAASN,EAAcrE,EAAeiB,EAAqBM,EAAgBG,GAC3E,YAAahB,EACb,UAAa+D,EACb,gBAAiBA,EACjB,kBAAmBA,EACnB,OAAUC,EACV,aAAcA,EACd,QA9SF,SAAmBtI,EAAOC,GAExB,OADIA,GAAYA,EAASD,EAAMI,GAAG8B,aAAa,IAAI,KAAalC,EAAM4B,QAC/D,IAoTL4G,EAAgB,CAClB,SAAUD,EAAwB,UAClC,gBAAiBA,EAAa,iBAC9B,SAAUA,EAAqB,OAC/B,qBAAsBA,EAAa,cACnC,aAAcA,EAAa,cAC3B,QAASA,EAAa,cACtB,SAAUd,EACV,SAAUC,GAEZ,IAAK,IAAIe,KAAOF,EAAgBC,EAAcC,GAAOF,EAAaE,GAElEF,EAAaG,KAAOjB,EACpBc,EAAaI,IAAMjB,EAGW,oBAAbkB,UAA2B,qBAAqBC,KAAKD,UAAUE,UACvD,oBAANC,IAAoBA,GAAGD,WCtoB1C,SAASE,EAAWC,EAAUpB,GAC5B,OAAO,SAAS7H,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAMkE,GAAS,EAAOC,EAAatI,EAChE,IAAKA,EAAS,OAAO,EAErB,GAAIA,EAAM4B,OAAS,GAAKsC,EAAMpC,KAAK9B,EAAM4B,MAAQ,GAAGtB,KAAK6E,kBAAkBiD,IAAiC,GAApBpI,EAAMuI,WAAiB,CAE7G,GAAoC,GAAhCrE,EAAMxB,MAAM1C,EAAM4B,MAAQ,GAAW,OAAO,EAChD,IAAI4G,EAAUrJ,EAAM4B,IAAIO,QAAQtB,EAAM2G,MAAQ,GAC9C2B,EAAa,IAAI,KAAUE,EAASA,EAASxI,EAAM4B,OAC/C5B,EAAMyI,SAAWzI,EAAMU,OAAO0B,aAC9BpC,EAAQ,IAAI,KAAUkE,EAAO/E,EAAM4B,IAAIO,QAAQ6C,EAAII,IAAIvE,EAAM4B,QAAS5B,EAAM4B,QAChFyG,GAAS,EAEX,IAAIzC,GAAO,QAAa0C,EAAYF,EAAUpB,EAAOhH,GACrD,QAAK4F,IACDxG,GAAYA,EAKpB,SAAsBG,EAAIS,EAAO0I,EAAUC,EAAYP,GAErD,IADA,IAAIzH,EAAU,WACL8B,EAAIiG,EAAS7C,OAAS,EAAGpD,GAAK,EAAGA,IACtC9B,EAAU,UAAc+H,EAASjG,GAAGnC,KAAKwF,OAAO4C,EAASjG,GAAGuE,MAAOrG,IAEvEpB,EAAG6B,KAAK,IAAI,KAAkBpB,EAAM2G,OAASgC,EAAa,EAAI,GAAI3I,EAAMuE,IAAKvE,EAAM2G,MAAO3G,EAAMuE,IAClE,IAAI,KAAM5D,EAAS,EAAG,GAAI+H,EAAS7C,QAAQ,IAGzE,IADA,IAAI+C,EAAQ,EACHpC,EAAM,EAAGA,EAAMkC,EAAS7C,OAAQW,IAAakC,EAASlC,GAAKlG,MAAQ8H,IAAYQ,EAAQpC,EAAM,GAItG,IAHA,IAAIqC,EAAaH,EAAS7C,OAAS+C,EAE/BE,EAAW9I,EAAM2G,MAAQ+B,EAAS7C,QAAU8C,EAAa,EAAI,GAAIjI,EAASV,EAAMU,OAC3EqI,EAAM/I,EAAMuI,WAAYS,EAAIhJ,EAAMyI,SAAU1D,GAAQ,EAAMgE,EAAMC,EAAGD,IAAOhE,GAAQ,GACpFA,IAAS,QAASxF,EAAGwB,IAAK+H,EAAUD,KACvCtJ,EAAGiF,MAAMsE,EAAUD,GACnBC,GAAY,EAAID,GAElBC,GAAYpI,EAAOuI,MAAMF,GAAKrH,SAEhC,OAAOnC,EAzBoB2J,CAAa/J,EAAMI,GAAIS,EAAO4F,EAAMyC,EAAQD,GAAU5I,mBACxE,IAgFX,SAAS2J,EAAaC,GACpB,OAAO,SAASjK,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAK,SAAUrC,GAAQ,OAAOA,EAAKM,YAAcN,EAAKG,WAAW3B,MAAQ8I,KACtG,QAAKpJ,KACAZ,IACD8E,EAAMpC,KAAK9B,EAAM4B,MAAQ,GAAGtB,MAAQ8I,EAO5C,SAAyBjK,EAAOC,EAAUgK,EAAUpJ,GAClD,IAAIT,EAAKJ,EAAMI,GAAIgF,EAAMvE,EAAMuE,IAAK8E,EAAYrJ,EAAMmE,IAAII,IAAIvE,EAAM4B,OAChE2C,EAAM8E,IAGR9J,EAAG6B,KAAK,IAAI,KAAkBmD,EAAM,EAAG8E,EAAW9E,EAAK8E,EACzB,IAAI,KAAM,UAAcD,EAAStD,OAAO,KAAM9F,EAAMU,OAAOqF,SAAU,EAAG,GAAI,GAAG,IAC7G/F,EAAQ,IAAI,KAAUT,EAAGwB,IAAIO,QAAQtB,EAAMkE,MAAMzC,KAAMlC,EAAGwB,IAAIO,QAAQ+H,GAAYrJ,EAAM4B,QAG1F,OADAxC,EAASG,EAAGY,KAAKH,GAAO,QAAWA,IAAQR,mBACpC,EAhBM8J,CAAgBnK,EAAOC,EAAUgK,EAAUpJ,GAmB1D,SAAuBb,EAAOC,EAAUY,GAGtC,IAFA,IAAIT,EAAKJ,EAAMI,GAAIgK,EAAOvJ,EAAMU,OAEvBe,EAAMzB,EAAMuE,IAAK9B,EAAIzC,EAAMyI,SAAW,EAAGO,EAAIhJ,EAAMuI,WAAY9F,EAAIuG,EAAGvG,IAC7EhB,GAAO8H,EAAKN,MAAMxG,GAAGf,SACrBnC,EAAGsC,OAAOJ,EAAM,EAAGA,EAAM,GAE3B,IAAI+H,EAASjK,EAAGwB,IAAIO,QAAQtB,EAAM2G,OAAQ8C,EAAOD,EAAO3G,UACxD,GAAItD,EAAGgC,QAAQC,IAAIxB,EAAMuE,MAAQvE,EAAM2G,MAAQ6C,EAAO3G,UAAUnB,SAAY,OAAO,EACnF,IAAIgI,EAA8B,GAApB1J,EAAMuI,WAAiB5D,EAAQ3E,EAAMyI,UAAYc,EAAKnH,WAChE1B,EAAS8I,EAAO1H,MAAM,GAAI6H,EAAcH,EAAO9G,OAAO,GAC1D,IAAKhC,EAAO0E,WAAWuE,GAAeD,EAAU,EAAI,GAAIC,EAAc,EAC/CF,EAAK9I,QAAQiJ,OAAOjF,EAAQ,WAAiB,UAAc4E,KAC9E,OAAO,EACX,IAAI5C,EAAQ6C,EAAO/H,IAAK8C,EAAMoC,EAAQ8C,EAAK/H,SAS3C,OALAnC,EAAG6B,KAAK,IAAI,KAAkBuF,GAAS+C,EAAU,EAAI,GAAInF,GAAOI,EAAQ,EAAI,GAAIgC,EAAQ,EAAGpC,EAAM,EACnE,IAAI,MAAOmF,EAAU,WAAiB,UAAcH,EAAKxD,KAAK,cACnD6D,OAAOjF,EAAQ,WAAiB,UAAc4E,EAAKxD,KAAK,cACzD2D,EAAU,EAAI,EAAG/E,EAAQ,EAAI,GAAI+E,EAAU,EAAI,IACvFtK,EAASG,EAAGC,mBACL,EAxCMqK,CAAc1K,EAAOC,EAAUY,M,0BCvK9C,SAAS8J,EAAcC,GACnB,MAAuB,WAJ3B,SAAiBA,GACb,OAAOC,OAAOC,UAAUC,SAASC,KAAKJ,GAAO9I,MAAM,GAAI,GAGnDmJ,CAAQL,KAGLA,EAAMM,cAAgBL,QAAUA,OAAOM,eAAeP,KAAWC,OAAOC,WAGnF,SAASM,EAAUrK,EAAQsK,GACvB,MAAMC,EAAS,IAAKvK,GAgBpB,OAfI4J,EAAc5J,IAAW4J,EAAcU,IACvCR,OAAOU,KAAKF,GAAQG,SAAQ/C,IACpBkC,EAAcU,EAAO5C,IACfA,KAAO1H,EAITuK,EAAO7C,GAAO2C,EAAUrK,EAAO0H,GAAM4C,EAAO5C,IAH5CoC,OAAOY,OAAOH,EAAQ,CAAE,CAAC7C,GAAM4C,EAAO5C,KAO1CoC,OAAOY,OAAOH,EAAQ,CAAE,CAAC7C,GAAM4C,EAAO5C,QAI3C6C,EAGX,SAASI,EAAWd,GAChB,MAAwB,mBAAVA,EAUlB,SAASe,EAAaf,EAAOgB,KAAwBC,GACjD,OAAIH,EAAWd,GACPgB,EACOhB,EAAMkB,KAAKF,EAAXhB,IAAuBiB,GAE3BjB,KAASiB,GAEbjB,EAGX,SAASmB,EAAkBC,EAAWC,EAAOL,GACzC,QAAgCM,IAA5BF,EAAUG,OAAOF,IAAwBD,EAAUzK,OACnD,OAAOwK,EAAkBC,EAAUzK,OAAQ0K,EAAOL,GAEtD,GAAuC,mBAA5BI,EAAUG,OAAOF,GAAuB,CAO/C,OANcD,EAAUG,OAAOF,GAAOH,KAAK,IACpCF,EACHrK,OAAQyK,EAAUzK,OACZwK,EAAkBC,EAAUzK,OAAQ0K,EAAOL,GAC3C,OAId,OAAOI,EAAUG,OAAOF,GAG5B,MAAMG,EACFlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,YACZkL,KAAKC,KAAO,YACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIC,EAAUD,GAEzBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAII,EAAUY,GAgBhC,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,SAASiB,EAAeC,EAAWrM,EAAO6L,GACtC,MAAM,KAAE1K,EAAI,GAAED,GAAOlB,GACf,eAAEsM,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GACtE,IAAIW,EAAO,GACPC,GAAY,EAyBhB,OAxBAJ,EAAUnF,aAAa/F,EAAMD,GAAI,CAACY,EAAML,EAAKf,EAAQgC,KACjD,IAAIgK,EACJ,MAAMC,EAAiBJ,MAAAA,OAAyD,EAASA,EAAgBzK,EAAKxB,KAAKmL,MAC/GkB,GACI7K,EAAK4C,UAAY+H,IACjBD,GAAQF,EACRG,GAAY,GAEhBD,GAAQG,EAAe,CACnB7K,KAAAA,EACAL,IAAAA,EACAf,OAAAA,EACAgC,MAAAA,KAGCZ,EAAK8K,QACVJ,GAAyE,QAAhEE,EAAK5K,MAAAA,OAAmC,EAASA,EAAK0K,YAAyB,IAAPE,OAAgB,EAASA,EAAGzL,MAAM4L,KAAKC,IAAI3L,EAAMM,GAAOA,EAAKP,EAAKO,GACnJgL,GAAY,GAEP3K,EAAK4C,UAAY+H,IACtBD,GAAQF,EACRG,GAAY,MAGbD,EAGX,SAASO,EAA4BC,GACjC,OAAOhD,OAAOiD,YAAYjD,OACrBkD,QAAQF,EAAOG,OACfC,QAAO,EAAE,CAAEtL,KAAUA,EAAKvB,KAAK8M,SAC/B7L,KAAI,EAAEiK,EAAM3J,KAAU,CAAC2J,EAAM3J,EAAKvB,KAAK8M,WAGhD,MAAMC,EAA0B/B,EAAUzF,OAAO,CAC7C2F,KAAM,0BACN8B,wBACI,MAAO,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,2BACnBoD,MAAO,CACHwC,wBAAyB,KACrB,MAAM,OAAEC,GAAWjC,MACb,MAAErM,EAAK,OAAE6N,GAAWS,GACpB,IAAE1M,EAAG,UAAE1B,GAAcF,GACrB,OAAEuO,GAAWrO,EACb8B,EAAO0L,KAAKc,OAAOD,EAAOlM,KAAIxB,GAASA,EAAMkE,MAAMzC,OACnDP,EAAK2L,KAAKC,OAAOY,EAAOlM,KAAIxB,GAASA,EAAMmE,IAAI1C,OAGrD,OAAO2K,EAAerL,EADR,CAAEI,KAAAA,EAAMD,GAAAA,GACY,CAC9BqL,gBAHoBQ,EAA4BC,aAyB5E,IAAIY,EAAsB5D,OAAO6D,OAAO,CACtCC,UAAW,KACXC,KAfW,IAAM,EAAGN,OAAAA,EAAQ/N,KAAAA,MAC1BsO,uBAAsB,KAClB,IAAItB,EACCe,EAAOQ,cACRvO,EAAKwO,IAAIH,OAGwE,QAAhFrB,EAAgB,OAAXyB,aAA8B,IAAXA,YAAoB,EAASA,OAAOC,sBAAmC,IAAP1B,GAAyBA,EAAG2B,uBAGtH,KAYX,IAAIC,EAA8BtE,OAAO6D,OAAO,CAC9CC,UAAW,KACXS,aANmB,CAACC,GAAa,IAAU,EAAGnH,SAAAA,KACrCA,EAASoH,WAAW,GAAID,KAuCnC,IAAIE,EAA4B1E,OAAO6D,OAAO,CAC5CC,UAAW,KACXa,WAjCiB,IAAM,EAAGxP,MAAAA,EAAOI,GAAAA,EAAIH,SAAAA,MACnC,MAAM,UAAEC,GAAcE,GAChB,OAAEmO,GAAWrO,EACnB,OAAKD,IAGLsO,EAAO/C,SAAQ,EAAGzG,MAAAA,EAAOC,IAAAA,MACrBhF,EAAM4B,IAAImG,aAAahD,EAAMzC,IAAK0C,EAAI1C,KAAK,CAACK,EAAML,KAC9C,GAAIK,EAAKxB,KAAKsM,OACV,OAEJ,MAAM,IAAE7L,EAAG,QAAEQ,GAAYhC,EACnBqP,EAAc7N,EAAIO,QAAQC,EAAQC,IAAIC,IACtCoN,EAAY9N,EAAIO,QAAQC,EAAQC,IAAIC,EAAMK,EAAKJ,WAC/CoN,EAAYF,EAAY3O,WAAW4O,GACzC,IAAKC,EACD,OAEJ,MAAMC,GAAkB,QAAWD,GACnC,GAAIhN,EAAKxB,KAAK6B,YAAa,CACvB,MAAM,YAAE6M,GAAgBJ,EAAYlO,OAAOkD,eAAegL,EAAYlM,SACtEnD,EAAG0F,cAAc6J,EAAUnI,MAAOqI,IAElCD,GAAuC,IAApBA,IACnBxP,EAAGY,KAAK2O,EAAWC,UAIxB,MAYX,IAAIE,EAAyBjF,OAAO6D,OAAO,CACzCC,UAAW,KACXoB,QANcC,GAAMnE,GACXmE,EAAGnE,KAYd,IAAIoE,EAAqCpF,OAAO6D,OAAO,CACrDC,UAAW,KACX9J,oBAN0B,IAAM,EAAG7E,MAAAA,EAAOC,SAAAA,KACjC4E,EAAsB7E,EAAOC,KAQxC,SAASiQ,EAAYC,EAAYtC,GAC7B,GAA0B,iBAAfsC,EAAyB,CAChC,IAAKtC,EAAOG,MAAMmC,GACd,MAAMC,MAAM,gCAAgCD,8CAEhD,OAAOtC,EAAOG,MAAMmC,GAExB,OAAOA,EAoBX,IAAIE,EAA4BxF,OAAO6D,OAAO,CAC5CC,UAAW,KACX2B,WAnBiBC,GAAc,EAAGnQ,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC3C,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QACrCxK,EAAOjD,EAAGF,UAAU2D,QAC1B,IAAK,IAAIpB,EAAQY,EAAKZ,MAAOA,EAAQ,EAAGA,GAAS,EAAG,CAEhD,GADaY,EAAKV,KAAKF,GACdtB,OAASA,EAAM,CACpB,GAAIlB,EAAU,CACV,MAAM+B,EAAOqB,EAAKpC,OAAOwB,GACnBV,EAAKsB,EAAKxB,MAAMY,GACtBrC,EAAGsC,OAAOV,EAAMD,GAAI1B,iBAExB,OAAO,GAGf,OAAO,KAgBX,IAAImQ,EAA6B3F,OAAO6D,OAAO,CAC7CC,UAAW,KACX8B,YAVkB5P,GAAS,EAAGT,GAAAA,EAAIH,SAAAA,MAChC,MAAM,KAAE+B,EAAI,GAAED,GAAOlB,EAIrB,OAHIZ,GACAG,EAAGsC,OAAOV,EAAMD,IAEb,KAYX,IAAI2O,EAAiC7F,OAAO6D,OAAO,CACjDC,UAAW,KACX5O,gBANsB,IAAM,EAAGC,MAAAA,EAAOC,SAAAA,KAC7BF,EAAkBC,EAAOC,KAYpC,IAAI0Q,EAAuB9F,OAAO6D,OAAO,CACvCC,UAAW,KACXiC,MANY,IAAM,EAAG1I,SAAAA,KACZA,EAAS2I,iBAAiB,WAYrC,IAAIC,GAA0BjG,OAAO6D,OAAO,CAC1CC,UAAW,KACXrK,SANe,IAAM,EAAGtE,MAAAA,EAAOC,SAAAA,KACtBqE,EAAWtE,EAAOC,KAQ7B,SAAS8Q,GAAYZ,EAAYtC,GAC7B,GAA0B,iBAAfsC,EAAyB,CAChC,IAAKtC,EAAOmD,MAAMb,GACd,MAAMC,MAAM,gCAAgCD,8CAEhD,OAAOtC,EAAOmD,MAAMb,GAExB,OAAOA,EAGX,SAASc,GAASrG,GACd,MAAiD,oBAA1CC,OAAOC,UAAUC,SAASC,KAAKJ,GAQ1C,SAASsG,GAAeC,EAASC,EAAS1E,EAAU,CAAE2E,QAAQ,IAC1D,MAAM9F,EAAOV,OAAOU,KAAK6F,GACzB,OAAK7F,EAAK7E,QAGH6E,EAAK+F,OAAM7I,GACViE,EAAQ2E,OACDD,EAAQ3I,KAAS0I,EAAQ1I,GAEhCwI,GAASG,EAAQ3I,IACV2I,EAAQ3I,GAAKI,KAAKsI,EAAQ1I,IAE9B2I,EAAQ3I,KAAS0I,EAAQ1I,KAIxC,SAAS8I,GAAcP,EAAO7P,EAAMqQ,EAAa,IAC7C,OAAOR,EAAMS,MAAKnH,GACPA,EAAKnJ,OAASA,GAAQ+P,GAAe5G,EAAKzC,MAAO2J,KAGhE,SAASE,GAAYV,EAAO7P,EAAMqQ,EAAa,IAC3C,QAASD,GAAcP,EAAO7P,EAAMqQ,GAExC,SAASG,GAAatO,EAAMlC,EAAMqQ,EAAa,IAC3C,IAAKnO,IAASlC,EACV,OAEJ,MAAMqG,EAAQnE,EAAK9B,OAAOqQ,WAAWvO,EAAK3C,cAC1C,IAAK8G,EAAM7E,KACP,OAEJ,MAAMkP,EAAON,GAAc/J,EAAM7E,KAAKqO,MAAO7P,EAAMqQ,GACnD,IAAKK,EACD,OAEJ,IAAIzI,EAAa/F,EAAKE,QAClBuO,EAAWzO,EAAKmE,QAAUA,EAAMuK,OAChCzI,EAAWF,EAAa,EACxB4I,EAASF,EAAWtK,EAAM7E,KAAKJ,SAEnC,IADAgP,GAAc/J,EAAM7E,KAAKqO,MAAO7P,EAAMqQ,GAC/BpI,EAAa,GAAKyI,EAAKI,QAAQ5O,EAAK9B,OAAOuI,MAAMV,EAAa,GAAG4H,QACpE5H,GAAc,EACd0I,GAAYzO,EAAK9B,OAAOuI,MAAMV,GAAY7G,SAE9C,KAAO+G,EAAWjG,EAAK9B,OAAO0B,YACvByO,GAAYrO,EAAK9B,OAAOuI,MAAMR,GAAU0H,MAAO7P,EAAMqQ,IACxDQ,GAAU3O,EAAK9B,OAAOuI,MAAMR,GAAU/G,SACtC+G,GAAY,EAEhB,MAAO,CACHtH,KAAM8P,EACN/P,GAAIiQ,GAkBZ,IAAIE,GAAiCrH,OAAO6D,OAAO,CACjDC,UAAW,KACXwD,gBAhBsB,CAAC5B,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MACnE,MAAMkB,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,IAAEjM,EAAG,UAAE1B,GAAcE,GACrB,MAAE2E,EAAK,KAAE/C,EAAI,GAAED,GAAO7B,EAC5B,GAAID,EAAU,CACV,MAAMY,EAAQ8Q,GAAa5M,EAAO5D,EAAMqQ,GACxC,GAAI3Q,GAASA,EAAMmB,MAAQA,GAAQnB,EAAMkB,IAAMA,EAAI,CAC/C,MAAMqQ,EAAe,YAAqBxQ,EAAKf,EAAMmB,KAAMnB,EAAMkB,IACjE3B,EAAG8B,aAAakQ,IAGxB,OAAO,KAoBX,IAAIC,GAAuBxH,OAAO6D,OAAO,CACvCC,UAAW,KACX/I,MAdYsC,GAAY2D,IACtB,MAAMyG,EAA4B,mBAAbpK,EACfA,EAAS2D,GACT3D,EACN,IAAK,IAAI5E,EAAI,EAAGA,EAAIgP,EAAM5L,OAAQpD,GAAK,EACnC,GAAIgP,EAAMhP,GAAGuI,GACT,OAAO,EAGf,OAAO,KAgBX,SAAS0G,GAAS3H,GACd,OAAQA,GACgB,iBAAVA,IACN4H,MAAMC,QAAQ7H,KAX1B,SAAiBA,GACb,IAAI2C,EACJ,MAAsG,WAApE,QAA5BA,EAAK3C,EAAMM,mBAAgC,IAAPqC,OAAgB,EAASA,EAAGxC,WAAW2H,UAAU,EAAG,IAUtFC,CAAQ/H,GAGpB,SAASgI,GAAgBhI,GACrB,OAAO2H,GAAS3H,IAAUA,aAAiB,KAG/C,SAASiI,KACL,MAAO,CACH,iBACA,mBACA,iBACA,OACA,SACA,QACFC,SAASlK,UAAUE,WAEbF,UAAUmK,UAAUD,SAAS,QAAU,eAAgBE,SAGnE,SAASC,GAAOrI,EAAQ,EAAG4D,EAAM,EAAGb,EAAM,GACtC,OAAOD,KAAKc,IAAId,KAAKC,IAAI/C,EAAO4D,GAAMb,GAG1C,SAASuF,GAAqBtR,EAAKuR,EAAW,MAC1C,IAAKA,EACD,OAAO,KAEX,MAAMC,EAAmB,aAAkBxR,GACrCyR,EAAiB,WAAgBzR,GACvC,GAAiB,UAAbuR,IAAqC,IAAbA,EACxB,OAAOC,EAEX,GAAiB,QAAbD,EACA,OAAOE,EAEX,MAAMC,EAASF,EAAiBpR,KAC1BuR,EAASF,EAAetR,GAC9B,MAAiB,QAAboR,EACO,YAAqBvR,EAAKqR,GAAO,EAAGK,EAAQC,GAASN,GAAOrR,EAAIJ,QAAQC,KAAM6R,EAAQC,IAE1F,YAAqB3R,EAAKqR,GAAOE,EAAUG,EAAQC,GAASN,GAAOE,EAAUG,EAAQC,IAiDhG,IAAIC,GAAuB3I,OAAO6D,OAAO,CACvCC,UAAW,KACX8E,MAhDY,CAACN,EAAW,KAAMzG,IAAY,EAAG4B,OAAAA,EAAQ/N,KAAAA,EAAMH,GAAAA,EAAIH,SAAAA,MAC7DyM,EAAU,CACNrM,gBAAgB,KACbqM,GAEP,MAAMgH,EAAe,KAGbb,MACAtS,EAAKwO,IAAI0E,QAIb5E,uBAAsB,KACbP,EAAOQ,cACRvO,EAAKkT,SACD/G,MAAAA,OAAyC,EAASA,EAAQrM,iBAC1DiO,EAAOpG,SAAS7H,sBAKhC,GAAKE,EAAKoT,YAA2B,OAAbR,IAAmC,IAAbA,EAC1C,OAAO,EAGX,GAAIlT,GAAyB,OAAbkT,IAAsBP,GAAgBtE,EAAOtO,MAAME,WAE/D,OADAwT,KACO,EAEX,MAAMxT,EAAYgT,GAAqB5E,EAAOtO,MAAM4B,IAAKuR,IAAa7E,EAAOtO,MAAME,UAC7E0T,EAAkBtF,EAAOtO,MAAME,UAAU2T,GAAG3T,GAYlD,OAXID,IACK2T,GACDxT,EAAG8B,aAAahC,GAIhB0T,GAAmBxT,EAAG0T,aACtB1T,EAAG2T,eAAe3T,EAAG0T,aAEzBJ,MAEG,KAYX,IAAIM,GAAyBnJ,OAAO6D,OAAO,CACzCC,UAAW,KACXnD,QANc,CAAC8G,EAAOtC,IAAOnE,GACpByG,EAAMhB,OAAM,CAAChH,EAAM/G,IAAUyM,EAAG1F,EAAM,IAAKuB,EAAOtI,MAAAA,QAY7D,IAAI0Q,GAA+BpJ,OAAO6D,OAAO,CAC/CC,UAAW,KACXuF,cANoB,CAACtJ,EAAO8B,IAAY,EAAGtM,GAAAA,EAAI8H,SAAAA,KACtCA,EAASiM,gBAAgB,CAAEnS,KAAM5B,EAAGF,UAAU8B,KAAMD,GAAI3B,EAAGF,UAAU6B,IAAM6I,EAAO8B,KAQ7F,SAAS0H,GAAkBxJ,GAEvB,MAAMyJ,EAAe,SAASzJ,WAC9B,OAAO,IAAIoE,OAAOsF,WAAYC,gBAAgBF,EAAc,aAAaG,KAG7E,SAASC,GAAsBjT,EAASqM,EAAQnB,GAM5C,GALAA,EAAU,CACN5K,OAAO,EACP4S,aAAc,MACXhI,GAEgB,iBAAZlL,GAAoC,OAAZA,EAC/B,IACI,OAAIgR,MAAMC,QAAQjR,GACP,eAAmBA,EAAQa,KAAIiI,GAAQuD,EAAO8G,aAAarK,MAE/DuD,EAAO8G,aAAanT,GAE/B,MAAOoT,GAEH,OADApI,QAAQC,KAAK,kCAAmC,gBAAiBjL,EAAS,SAAUoT,GAC7EH,GAAsB,GAAI5G,EAAQnB,GAGjD,GAAuB,iBAAZlL,EAAsB,CAC7B,MAAMqT,EAAS,gBAAqBhH,GACpC,OAAOnB,EAAQ5K,MACT+S,EAAOC,WAAWV,GAAkB5S,GAAUkL,EAAQgI,cAAclT,QACpEqT,EAAOE,MAAMX,GAAkB5S,GAAUkL,EAAQgI,cAE3D,OAAOD,GAAsB,GAAI5G,EAAQnB,GA4F7C,IAAIsI,GAAiCnK,OAAO6D,OAAO,CACjDC,UAAW,KACXwF,gBApEsB,CAAChB,EAAUvI,EAAO8B,IAAY,EAAGtM,GAAAA,EAAIH,SAAAA,EAAUqO,OAAAA,MACnE,GAAIrO,EAAU,CACVyM,EAAU,CACNgI,aAAc,GACdO,iBAAiB,KACdvI,GAEP,MAAMlL,EAAUiT,GAAsB7J,EAAO0D,EAAOT,OAAQ,CACxD6G,aAAc,CACVQ,mBAAoB,UACjBxI,EAAQgI,gBAInB,GAA2B,OAAvBlT,EAAQuJ,WACR,OAAO,EAEX,IAAI,KAAE/I,EAAI,GAAED,GAA2B,iBAAboR,EACpB,CAAEnR,KAAMmR,EAAUpR,GAAIoR,GACtBA,EACFgC,GAAoB,EACpBC,GAAqB,EAmBzB,IAlByB5T,EAxBPuJ,WAAWsK,WAAW,KAyBlC7T,EACA,CAACA,IACDgK,SAAQ7I,IAEVA,EAAK2S,QACLH,IAAoBA,IACdxS,EAAK8K,QAAgC,IAAtB9K,EAAKqO,MAAMtK,QAEhC0O,IAAqBA,GACfzS,EAAK4C,WAQXvD,IAASD,GAAMqT,EAAoB,CACnC,MAAM,OAAE7T,GAAWnB,EAAGwB,IAAIO,QAAQH,GACTT,EAAOyB,cACxBzB,EAAOJ,KAAKC,KAAK0C,OACjBvC,EAAO0B,aAEXjB,GAAQ,EACRD,GAAM,GAKVoT,EACA/U,EAAG4D,WAAW4G,EAAO5I,EAAMD,GAG3B3B,EAAGuE,YAAY3C,EAAMD,EAAIP,GAGzBkL,EAAQuI,iBAjFpB,SAAiC7U,EAAImV,EAAUC,GAC3C,MAAMC,EAAOrV,EAAGsV,MAAMhP,OAAS,EAC/B,GAAI+O,EAAOF,EACP,OAEJ,MAAMtT,EAAO7B,EAAGsV,MAAMD,GACtB,KAAMxT,aAAgB,MAAeA,aAAgB,MACjD,OAEJ,MAAMI,EAAMjC,EAAGgC,QAAQuT,KAAKF,GAC5B,IAAIrQ,EAAM,EACV/C,EAAImJ,SAAQ,CAACoK,EAAOC,EAAKC,EAAUC,KACnB,IAAR3Q,IACAA,EAAM2Q,MAGd3V,EAAG8B,aAAa,UAAe9B,EAAGwB,IAAIO,QAAQiD,GAAMoQ,IAkE5CQ,CAAwB5V,EAAIA,EAAGsV,MAAMhP,OAAS,GAAI,GAG1D,OAAO,KAYX,IAAIuP,GAA8BpL,OAAO6D,OAAO,CAC9CC,UAAW,KACXrO,aANmB,IAAM,EAAGN,MAAAA,EAAOC,SAAAA,KAC1BK,EAAeN,EAAOC,KAYjC,IAAIiW,GAA6BrL,OAAO6D,OAAO,CAC7CC,UAAW,KACXnL,YANkB,IAAM,EAAGxD,MAAAA,EAAOC,SAAAA,KACzBuD,EAAcxD,EAAOC,KAQhC,SAASkW,KACL,MAA4B,oBAAdvN,WACR,MAAMC,KAAKD,UAAUE,UAgF/B,IAAIsN,GAAkCvL,OAAO6D,OAAO,CAClDC,UAAW,KACXkC,iBA5BuBvE,GAAQ,EAAGgC,OAAAA,EAAQ/N,KAAAA,EAAMH,GAAAA,EAAIH,SAAAA,MAClD,MAAMsL,EAnDV,SAA0Be,GACtB,MAAM+J,EAAQ/J,EAAKjH,MAAM,UACzB,IAIIiR,EACAC,EACAC,EACAC,EAPAC,EAASL,EAAMA,EAAM3P,OAAS,GACnB,UAAXgQ,IACAA,EAAS,KAMb,IAAK,IAAIpT,EAAI,EAAGA,EAAI+S,EAAM3P,OAAS,EAAGpD,GAAK,EAAG,CAC1C,MAAMqT,EAAMN,EAAM/S,GAClB,GAAI,kBAAkBuF,KAAK8N,GACvBF,GAAO,OAEN,GAAI,YAAY5N,KAAK8N,GACtBL,GAAM,OAEL,GAAI,sBAAsBzN,KAAK8N,GAChCJ,GAAO,OAEN,GAAI,cAAc1N,KAAK8N,GACxBH,GAAQ,MAEP,KAAI,SAAS3N,KAAK8N,GASnB,MAAM,IAAIvG,MAAM,+BAA+BuG,KAR3C9D,MAAWsD,KACXM,GAAO,EAGPF,GAAO,GAmBnB,OAZID,IACAI,EAAS,OAAOA,KAEhBH,IACAG,EAAS,QAAQA,KAEjBD,IACAC,EAAS,QAAQA,KAEjBF,IACAE,EAAS,SAASA,KAEfA,EAGME,CAAiBtK,GAAMjH,MAAM,UACpCoD,EAAM8C,EAAKkG,MAAKnH,IAAS,CAAC,MAAO,OAAQ,OAAQ,SAASwI,SAASxI,KACnEuM,EAAQ,IAAIC,cAAc,UAAW,CACvCrO,IAAa,UAARA,EACC,IACAA,EACNsO,OAAQxL,EAAKuH,SAAS,OACtBkE,QAASzL,EAAKuH,SAAS,QACvBmE,QAAS1L,EAAKuH,SAAS,QACvBoE,SAAU3L,EAAKuH,SAAS,SACxBqE,SAAS,EACTC,YAAY,IAEVC,EAAsB/I,EAAOgJ,oBAAmB,KAClD/W,EAAKgX,SAAS,iBAAiBC,GAAKA,EAAEjX,EAAMsW,QAQhD,OANAQ,MAAAA,GAA0EA,EAAoB3B,MAAMlK,SAAQvJ,IACxG,MAAMwV,EAAUxV,EAAKI,IAAIjC,EAAGgC,SACxBqV,GAAWxX,GACXG,EAAGsX,UAAUD,OAGd,KAQX,SAASE,GAAa3X,EAAOuQ,EAAYiB,EAAa,IAClD,MAAM,KAAExP,EAAI,GAAED,EAAE,MAAE5B,GAAUH,EAAME,UAC5BiB,EAAOoP,EACPL,EAAYK,EAAYvQ,EAAM6N,QAC9B,KACA+J,EAAa,GACnB5X,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,GAAIK,EAAK8K,OACL,OAEJ,MAAMoK,EAAenK,KAAKC,IAAI3L,EAAMM,GAC9BwV,EAAapK,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKJ,UAC3CqV,EAAW3Q,KAAK,CACZtE,KAAAA,EACAX,KAAM6V,EACN9V,GAAI+V,OAGZ,MAAMC,EAAiBhW,EAAKC,EACtBgW,EAAoBJ,EACrB3J,QAAO0B,IACHxO,GAGEA,EAAKmL,OAASqD,EAAUhN,KAAKxB,KAAKmL,OAExC2B,QAAO0B,GAAauB,GAAevB,EAAUhN,KAAKkF,MAAO2J,EAAY,CAAEH,QAAQ,MACpF,GAAIlR,EACA,QAAS6X,EAAkBtR,OAI/B,OAFcsR,EACTC,QAAO,CAACC,EAAKvI,IAAcuI,EAAMvI,EAAU5N,GAAK4N,EAAU3N,MAAM,IACrD+V,EAYpB,IAAII,GAAsBtN,OAAO6D,OAAO,CACtCC,UAAW,KACX3N,KAXW,CAACuP,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,OAEnC0X,GAAa3X,EADjBkQ,EAAYK,EAAYvQ,EAAM6N,QACA2D,IF1nB/C,SAAcxR,EAAOC,GACnB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAMjE,EAASF,IAAS,QAAWA,GAChE,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GEunBEW,CAAOhB,EAAOC,KAYzB,IAAImY,GAAgCvN,OAAO6D,OAAO,CAChDC,UAAW,KACXxJ,eANqB,IAAM,EAAGnF,MAAAA,EAAOC,SAAAA,KAC5BkF,EAAiBnF,EAAOC,KAanC,IAAIoY,GAA8BxN,OAAO6D,OAAO,CAC9CC,UAAW,KACX3E,aAPmBuG,GAAc,EAAGvQ,MAAAA,EAAOC,SAAAA,KAElC+J,EADMkG,EAAYK,EAAYvQ,EAAM6N,QACpC7D,CAAqBhK,EAAOC,KAYvC,IAAIqY,GAA+BzN,OAAO6D,OAAO,CAC/CC,UAAW,KACX/K,cANoB,IAAM,EAAG5D,MAAAA,EAAOC,SAAAA,KAC3B2D,EAAgB5D,EAAOC,KAQlC,SAASsY,GAAwBjM,EAAMuB,GACnC,OAAIA,EAAOG,MAAM1B,GACN,OAEPuB,EAAOmD,MAAM1E,GACN,OAEJ,KAQX,SAASkM,GAAYC,EAAKC,GACtB,MAAM7M,EAA+B,iBAAhB6M,EACf,CAACA,GACDA,EACN,OAAO7N,OACFU,KAAKkN,GACLR,QAAO,CAACU,EAAQC,KACZ/M,EAAMiH,SAAS8F,KAChBD,EAAOC,GAAQH,EAAIG,IAEhBD,IACR,IAqCP,IAAIE,GAAiChO,OAAO6D,OAAO,CACjDC,UAAW,KACXmK,gBApCsB,CAACvI,EAAYiB,IAAe,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC9D,IAAI2H,EAAW,KACXmR,EAAW,KACf,MAAMC,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,QAAKmL,IAGc,SAAfA,IACApR,EAAWsI,EAAYK,EAAYvQ,EAAM6N,SAE1B,SAAfmL,IACAD,EAAWhI,GAAYR,EAAYvQ,EAAM6N,SAEzC5N,GACAG,EAAGF,UAAUqO,OAAO/C,SAAQ3K,IACxBb,EAAM4B,IAAImG,aAAalH,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,KAAK,CAACK,EAAML,KACtDsF,GAAYA,IAAajF,EAAKxB,MAC9Bf,EAAG0F,cAAcxD,OAAK4J,EAAWsM,GAAY7V,EAAKkF,MAAO2J,IAEzDuH,GAAYpW,EAAKqO,MAAMtK,QACvB/D,EAAKqO,MAAMxF,SAAQqG,IACXkH,IAAalH,EAAK1Q,MAClBf,EAAG6Y,QAAQ3W,EAAKA,EAAMK,EAAKJ,SAAUwW,EAASpS,OAAO6R,GAAY3G,EAAKhK,MAAO2J,eAO9F,MAeX,IAAI0H,GAAgCrO,OAAO6D,OAAO,CAChDC,UAAW,KACXtO,eATqB,IAAM,EAAGD,GAAAA,EAAIH,SAAAA,MAC5BA,GACAG,EAAGC,kBAEA,KAeX,IAAI8Y,GAA2BtO,OAAO6D,OAAO,CAC3CC,UAAW,KACXyK,UATgB,IAAM,EAAGhZ,GAAAA,EAAI8H,SAAAA,KACpBA,EAASmR,iBAAiB,CAC7BrX,KAAM,EACND,GAAI3B,EAAGwB,IAAIJ,QAAQC,SAa3B,IAAI6X,GAAoCzO,OAAO6D,OAAO,CACpDC,UAAW,KACXzL,mBANyB,IAAM,EAAGlD,MAAAA,EAAOC,SAAAA,KAChCiD,EAAqBlD,EAAOC,KAYvC,IAAIsZ,GAAmC1O,OAAO6D,OAAO,CACnDC,UAAW,KACXhL,kBANwB,IAAM,EAAG3D,MAAAA,EAAOC,SAAAA,KAC/B0D,EAAoB3D,EAAOC,KAYtC,IAAIuZ,GAAkC3O,OAAO6D,OAAO,CAClDC,UAAW,KACX8K,iBANuB,IAAM,EAAGzZ,MAAAA,EAAOC,SAAAA,KFjoBzC,SAA0BD,EAAOC,GAC/B,IAGIqC,EAHAa,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZhD,EAAKoB,EAAIpB,GAET2X,EAAO3U,EAAM4U,YAAY5X,GAC7B,OAAY,GAAR2X,IACJpX,EAAMyC,EAAM9D,OAAOyY,GACfzZ,GAAYA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKU,MACxE,GEynBEmX,CAAmBzZ,EAAOC,KAarC,IAAI2Z,GAAoC/O,OAAO6D,OAAO,CACpDC,UAAW,KACXjH,mBANyB,IAAM,EAAG1H,MAAAA,EAAOC,SAAAA,KAChCyH,EAAqB1H,EAAOC,KAavC,IAAI4Z,GAAsChP,OAAO6D,OAAO,CACtDC,UAAW,KACXlH,qBAN2B,IAAM,EAAGzH,MAAAA,EAAOC,SAAAA,KAClCwH,EAAuBzH,EAAOC,KAQzC,SAAS6Z,GAAetY,EAASqM,EAAQ6G,EAAe,IACpD,OAAOD,GAAsBjT,EAASqM,EAAQ,CAAE/L,OAAO,EAAO4S,aAAAA,IAelE,IAAIqF,GAA4BlP,OAAO6D,OAAO,CAC5CC,UAAW,KACXW,WAdiB,CAAC9N,EAAS6N,GAAa,EAAOqF,EAAe,KAAO,EAAGtU,GAAAA,EAAIkO,OAAAA,EAAQrO,SAAAA,MAClF,MAAM,IAAE2B,GAAQxB,EACV4S,EAAW8G,GAAetY,EAAS8M,EAAOT,OAAQ6G,GAClDxU,EAAY,YAAqB0B,EAAK,EAAGA,EAAIJ,QAAQC,MAM3D,OALIxB,GACAG,EAAG8B,aAAahC,GACX8Z,qBAAqBhH,GAAU,GAC/BiH,QAAQ,iBAAkB5K,IAE5B,KAQX,SAAS6K,GAAkBla,EAAOuQ,GAC9B,MAAMpP,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,KAAE7L,EAAI,GAAED,EAAE,MAAE5B,GAAUH,EAAME,UAC5B8Q,EAAQ,GACV7Q,GACIH,EAAM8T,aACN9C,EAAM/J,QAAQjH,EAAM8T,aAExB9C,EAAM/J,QAAQjH,EAAME,UAAUkD,MAAM4N,UAGpChR,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAIY,IAC7BqO,EAAM/J,QAAQtE,EAAKqO,UAG3B,MAAMa,EAAOb,EAAMS,MAAK0I,GAAYA,EAAShZ,KAAKmL,OAASnL,EAAKmL,OAChE,OAAKuF,EAGE,IAAKA,EAAKhK,OAFN,GAgDf,IAAIuS,GAAyBvP,OAAO6D,OAAO,CACzCC,UAAW,KACX0L,QA7Cc,CAAC9J,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC3D,MAAM,UAAEC,GAAcE,GAChB,MAAED,EAAK,OAAEoO,GAAWrO,EACpBiB,EAAO4P,GAAYR,EAAYvQ,EAAM6N,QAC3C,GAAI5N,EACA,GAAIE,EAAO,CACP,MAAMma,EAAgBJ,GAAkBla,EAAOmB,GAC/Cf,EAAGma,cAAcpZ,EAAKwF,OAAO,IACtB2T,KACA9I,UAIPjD,EAAO/C,SAAQ3K,IACX,MAAMmB,EAAOnB,EAAMkE,MAAMzC,IACnBP,EAAKlB,EAAMmE,IAAI1C,IACrBtC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,MAAMkY,EAAc9M,KAAKC,IAAIrL,EAAKN,GAC5ByY,EAAY/M,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAC5BY,EAAKqO,MAAMS,MAAKI,GAAQA,EAAK1Q,OAASA,IAKtDwB,EAAKqO,MAAMxF,SAAQqG,IACX1Q,IAAS0Q,EAAK1Q,MACdf,EAAG6Y,QAAQuB,EAAaC,EAAWtZ,EAAKwF,OAAO,IACxCkL,EAAKhK,SACL2J,QAMfpR,EAAG6Y,QAAQuB,EAAaC,EAAWtZ,EAAKwF,OAAO6K,UAMnE,OAAO,KAaX,IAAIkJ,GAAyB7P,OAAO6D,OAAO,CACzCC,UAAW,KACXsL,QAPc,CAACxR,EAAKmC,IAAU,EAAGxK,GAAAA,MAC/BA,EAAG6Z,QAAQxR,EAAKmC,IACT,KA8BX,IAAI+P,GAAyB9P,OAAO6D,OAAO,CACzCC,UAAW,KACXiM,QAxBc,CAACrK,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,EAAU4a,MAAAA,MACjE,MAAM1Z,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAE3C,OAAK1M,EAAK6B,YAIH6X,IAEF9K,SAAQ,EAAG7H,SAAAA,OACQP,EAAaxG,EAAMqQ,EAAnB7J,CAA+B3H,IAI5CkI,EAASsH,eAEfO,SAAQ,EAAG/P,MAAO8a,KACZnT,EAAaxG,EAAMqQ,EAAnB7J,CAA+BmT,EAAc7a,KAEnD8a,OAfDvO,QAAQC,KAAK,yEACN,MAkCf,IAAIuO,GAAkCnQ,OAAO6D,OAAO,CAClDC,UAAW,KACXsM,iBAduB9H,GAAY,EAAG/S,GAAAA,EAAIH,SAAAA,MACxC,GAAIA,EAAU,CACV,MAAM,IAAE2B,GAAQxB,EACVkT,EAAS,aAAkB1R,GAAKI,KAChCuR,EAAS,WAAgB3R,GAAKG,GAC9BmZ,EAAcjI,GAAOE,EAAUG,EAAQC,GACvCrT,EAAY,YAAqB0B,EAAKsZ,GAC5C9a,EAAG8B,aAAahC,GAEpB,OAAO,KAwBX,IAAIib,GAAkCtQ,OAAO6D,OAAO,CAClDC,UAAW,KACX0K,iBAlBuBlG,GAAY,EAAG/S,GAAAA,EAAIH,SAAAA,MACxC,GAAIA,EAAU,CACV,MAAM,IAAE2B,GAAQxB,GACV,KAAE4B,EAAI,GAAED,GAA2B,iBAAboR,EACtB,CAAEnR,KAAMmR,EAAUpR,GAAIoR,GACtBA,EACAG,EAAS,aAAsB1R,GAAKI,KACpCuR,EAAS,WAAoB3R,GAAKG,GAClCqZ,EAAenI,GAAOjR,EAAMsR,EAAQC,GACpC8H,EAAcpI,GAAOlR,EAAIuR,EAAQC,GACjCrT,EAAY,YAAqB0B,EAAKwZ,EAAcC,GAC1Djb,EAAG8B,aAAahC,GAEpB,OAAO,KAaX,IAAIob,GAA8BzQ,OAAO6D,OAAO,CAC9CC,UAAW,KACX4M,aAPmBhL,GAAc,EAAGvQ,MAAAA,EAAOC,SAAAA,MACzC,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAC3C,OD19BkB5D,EC09BI9I,EDz9BjB,SAASnB,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAK,SAAUrC,GAAQ,OAAOA,EAAKM,YAAcN,EAAKG,WAAW3B,MAAQ8I,KACtG,IAAKpJ,EAAS,OAAO,EACrB,IAAIuI,EAAavI,EAAMuI,WACvB,GAAkB,GAAdA,EAAmB,OAAO,EAC9B,IAAI7H,EAASV,EAAMU,OAAQL,EAAaK,EAAOuI,MAAMV,EAAa,GAClE,GAAIlI,EAAWC,MAAQ8I,EAAY,OAAO,EAE1C,GAAIhK,EAAU,CACZ,IAAIub,EAAeta,EAAW6B,WAAa7B,EAAW6B,UAAU5B,MAAQI,EAAOJ,KAC3Esa,EAAQ,UAAcD,EAAevR,EAAStD,SAAW,MACzD7E,EAAQ,IAAI,KAAM,UAAcmI,EAAStD,OAAO,KAAM,UAAcpF,EAAOJ,KAAKwF,OAAO,KAAM8U,MAC3ED,EAAe,EAAI,EAAG,GACxCva,EAASJ,EAAM2G,MAAO3F,EAAQhB,EAAMuE,IACxCnF,EAASD,EAAMI,GAAG6B,KAAK,IAAI,KAAkBhB,GAAUua,EAAe,EAAI,GAAI3Z,EACjCZ,EAAQY,EAAOC,EAAO,GAAG,IAC5DzB,kBAEZ,OAAO,ICo8BqBL,EAAOC,GD19BvC,IAAsBgK,KCk+BtB,SAASyR,GAAsBC,EAAqBC,EAAUpK,GAC1D,OAAO3G,OAAOiD,YAAYjD,OACrBkD,QAAQyD,GACRvD,QAAO,EAAE3B,MACV,MAAMuP,EAAqBF,EAAoBlK,MAAKnH,GACzCA,EAAKnJ,OAASya,GAAYtR,EAAKgC,OAASA,IAEnD,QAAKuP,GAGEA,EAAmBC,UAAUC,gBAa5C,SAASC,GAAYhc,EAAOic,GACxB,MAAMjL,EAAQhR,EAAM8T,aACZ9T,EAAME,UAAU8E,IAAItE,cAAgBV,EAAME,UAAU6E,MAAMiM,QAClE,GAAIA,EAAO,CACP,MAAMkL,EAAgBlL,EAAM/C,QAAO4D,GAAQoK,MAAAA,OAAyD,EAASA,EAAgBnJ,SAASjB,EAAK1Q,KAAKmL,QAChJtM,EAAMI,GAAG4b,YAAYE,IAsE7B,IAAIC,GAA4BtR,OAAO6D,OAAO,CAC5CC,UAAW,KACXrJ,WArEiB,EAAG8W,UAAAA,GAAY,GAAS,KAAO,EAAGhc,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAUqO,OAAAA,MACtE,MAAM,UAAEpO,EAAS,IAAE0B,GAAQxB,GACrB,MAAE2E,EAAK,IAAEC,GAAQ9E,EAEjBmc,EAAgBX,GADMpN,EAAOgO,iBAAiB9K,WACazM,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OACtG,GAAI3H,aAAqB,MAAiBA,EAAUyC,KAAK4C,QACrD,SAAKR,EAAMrE,gBAAiB,QAASkB,EAAKmD,EAAMzC,QAG5CrC,IACImc,GACAJ,GAAYhc,EAAOsO,EAAOgO,iBAAiBL,iBAE/C7b,EAAGiF,MAAMN,EAAMzC,KAAKjC,mBAEjB,GAEX,IAAK0E,EAAMxD,OAAOgE,QACd,OAAO,EAEX,GAAItF,EAAU,CACV,MAAMuF,EAAQR,EAAItE,eAAiBsE,EAAIzD,OAAOC,QAAQC,KAClDvB,aAAqB,MACrBE,EAAGL,kBAEP,MAAM0F,EAAwB,IAAhBV,EAAMtC,WACdyJ,EA3Cd,SAA0BhI,GACtB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,GAAK,EAAG,CACzC,MAAM,KAAEnC,GAAS+C,EAAME,KAAKd,GAC5B,GAAInC,EAAK6B,cAAgB7B,EAAKkD,mBAC1B,OAAOlD,EAGf,OAAO,KAqCGob,CAAiBxX,EAAMpC,MAAM,GAAG8B,eAAeM,EAAMP,YAAY,KACvE,IAAIkB,EAAQF,GAASC,EACf,CAAC,CACKtE,KAAMsE,EACNoC,MAAOwU,SAEbnQ,EACFvG,GAAM,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GAYzD,GAXKA,GACGC,KACD,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGmD,EAAQ,CAAC,CAAEtE,KAAMsE,SAAWyG,KAC9EvG,GAAM,EACND,EAAQD,EACF,CAAC,CACKtE,KAAMsE,EACNoC,MAAOwU,SAEbnQ,GAENvG,IACAvF,EAAGiF,MAAMjF,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GACnCD,IACID,IACAT,EAAMrE,cACPqE,EAAMxD,OAAOJ,OAASsE,GAAO,CAChC,MAAMG,EAAQxF,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAC7B4E,EAASzF,EAAGwB,IAAIO,QAAQyD,GAC1Bb,EAAMpC,MAAM,GAAG+B,eAAemB,EAAOtC,QAASsC,EAAOtC,QAAU,EAAGkC,IAClErF,EAAG0F,cAAc1F,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAWwE,GAIzD2W,GACAJ,GAAYhc,EAAOsO,EAAOgO,iBAAiBL,iBAE/C7b,EAAGC,iBAEP,OAAO,KA2FX,IAAImc,GAA+B3R,OAAO6D,OAAO,CAC/CC,UAAW,KACX8N,cArFoBlM,GAAc,EAAGnQ,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAUqO,OAAAA,MACxD,IAAIf,EACJ,MAAMpM,EAAO+O,EAAYK,EAAYvQ,EAAM6N,SACrC,MAAE9I,EAAK,IAAEC,GAAQhF,EAAME,UAGvByC,EAAO3C,EAAME,UAAUyC,KAC7B,GAAKA,GAAQA,EAAK4C,SAAYR,EAAMtC,MAAQ,IAAMsC,EAAMhB,WAAWiB,GAC/D,OAAO,EAEX,MAAM0X,EAAc3X,EAAMpC,MAAM,GAChC,GAAI+Z,EAAYvb,OAASA,EACrB,OAAO,EAEX,MAAMwa,EAAsBrN,EAAOgO,iBAAiB9K,WACpD,GAAkC,IAA9BzM,EAAMxD,OAAOC,QAAQC,MAAcsD,EAAMpC,MAAM,GAAGM,aAAe8B,EAAMP,YAAY,GAAI,CAIvF,GAAoB,IAAhBO,EAAMtC,OACHsC,EAAMpC,MAAM,GAAGxB,OAASA,GACxB4D,EAAMxB,OAAO,KAAOwB,EAAMpC,MAAM,GAAGM,WAAa,EACnD,OAAO,EAEX,GAAIhD,EAAU,CACV,IAAIwG,EAAO,WAEX,MAAMkW,EAAc5X,EAAMxB,OAAO,GAC3B,EACAwB,EAAMxB,OAAO,GACT,EACA,EAGV,IAAK,IAAIqZ,EAAI7X,EAAMtC,MAAQka,EAAaC,GAAK7X,EAAMtC,MAAQ,EAAGma,GAAK,EAC/DnW,EAAO,UAAc1B,EAAMpC,KAAKia,GAAGhW,KAAKH,IAG5C,MAAMoW,EAAa9X,EAAMP,YAAY,GAAKO,EAAMpC,MAAM,GAAGM,WACnD,EACA8B,EAAMP,YAAY,GAAKO,EAAMpC,MAAM,GAAGM,WAClC,EACA,EAEJ6Z,EAAwBpB,GAAsBC,EAAqB5W,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OACxGkV,GAAqD,QAAxCxP,EAAKpM,EAAK6b,aAAanN,mBAAgC,IAAPtC,OAAgB,EAASA,EAAG3I,cAAckY,UAA2B5Q,EACxIzF,EAAOA,EAAKgE,OAAO,UAActJ,EAAKyD,cAAc,KAAMmY,SAAa7Q,IACvE,MAAM1E,EAAQzC,EAAM9D,OAAO8D,EAAMtC,OAASka,EAAc,IACxDvc,EAAG6c,QAAQzV,EAAOzC,EAAMlD,OAAOgb,GAAa,IAAI,KAAMpW,EAAM,EAAIkW,EAAa,IAC7E,IAAI7X,GAAO,EACX1E,EAAGwB,IAAImG,aAAaP,EAAOpH,EAAGwB,IAAIJ,QAAQC,MAAM,CAACyb,EAAG5a,KAChD,GAAIwC,GAAO,EACP,OAAO,EAEPoY,EAAEla,aAAkC,IAAnBka,EAAE1b,QAAQC,OAC3BqD,EAAMxC,EAAM,MAGhBwC,GAAO,GACP1E,EAAG8B,aAAa,UAAmB9B,EAAGwB,IAAIO,QAAQ2C,KAEtD1E,EAAGC,iBAEP,OAAO,EAEX,MAAM0c,EAAW/X,EAAI1C,MAAQyC,EAAMK,MAC7BsX,EAAYjY,eAAe,GAAGoL,YAC9B,KACAsN,EAAoBzB,GAAsBC,EAAqBe,EAAYvb,KAAKmL,KAAMoQ,EAAY7U,OAClGiV,EAAwBpB,GAAsBC,EAAqB5W,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OAC9GzH,EAAGsC,OAAOqC,EAAMzC,IAAK0C,EAAI1C,KACzB,MAAMoD,EAAQqX,EACR,CAAC,CAAE5b,KAAAA,EAAM0G,MAAOsV,GAAqB,CAAEhc,KAAM4b,EAAUlV,MAAOiV,IAC9D,CAAC,CAAE3b,KAAAA,EAAM0G,MAAOsV,IACtB,SAAK,QAAS/c,EAAGwB,IAAKmD,EAAMzC,IAAK,KAG7BrC,GACAG,EAAGiF,MAAMN,EAAMzC,IAAK,EAAGoD,GAAOrF,kBAE3B,MAQX,SAAS+c,GAA2B/Z,EAAMga,GACtC,IAAK,IAAI/Z,EAAID,EAAKZ,MAAOa,EAAI,EAAGA,GAAK,EAAG,CACpC,MAAMX,EAAOU,EAAKV,KAAKW,GACvB,GAAI+Z,EAAU1a,GACV,MAAO,CACHL,IAAKgB,EAAI,EAAID,EAAKpC,OAAOqC,GAAK,EAC9BkE,MAAOnE,EAAKmE,MAAMlE,GAClBb,MAAOa,EACPX,KAAAA,IAMhB,SAAS2a,GAAeD,GACpB,OAAQnd,GAAckd,GAA2Bld,EAAU6E,MAAOsY,GAGtE,SAASE,GAAgBC,GAIrB,MAAO,CACHC,eAJmBD,EAAWvP,QAAOjC,GAAgC,cAAnBA,EAAU7K,OAK5Duc,eAJmBF,EAAWvP,QAAOjC,GAAgC,SAAnBA,EAAU7K,OAK5Dwc,eAJmBH,EAAWvP,QAAOjC,GAAgC,SAAnBA,EAAU7K,QAQpE,SAASyc,GAAOtR,EAAMkR,GAClB,MAAM,eAAEE,GAAmBH,GAAgBC,GACrCxR,EAAY0R,EAAejM,MAAKnH,GAAQA,EAAKgC,OAASA,IAC5D,IAAKN,EACD,OAAO,EAEX,MAKM6R,EAAQlS,EAAaI,EAAkBC,EAAW,QALxC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,WAGvB,MAAqB,iBAAViR,GAGJA,EAAMxY,MAAM,KAAKyN,SAAS,QAGrC,MAAMgL,GAAoB,CAAC1d,EAAI6I,KAC3B,MAAMmB,EAAOkT,IAAe3a,GAAQA,EAAKxB,OAAS8H,GAArCqU,CAA+Cld,EAAGF,WAC/D,IAAKkK,EACD,OAAO,EAEX,MAAMnJ,EAASb,EAAGwB,IAAIO,QAAQuL,KAAKC,IAAI,EAAGvD,EAAK9H,IAAM,IAAIrB,OAAOmJ,EAAK3H,OACrE,QAAeyJ,IAAXjL,EACA,OAAO,EAEX,MAAMC,EAAad,EAAGwB,IAAImc,OAAO9c,GAGjC,OAFyBmJ,EAAKzH,KAAKxB,QAAUD,MAAAA,OAA+C,EAASA,EAAWC,SACzG,QAAQf,EAAGwB,IAAKwI,EAAK9H,OAI5BlC,EAAG+F,KAAKiE,EAAK9H,MACN,IAEL0b,GAAmB,CAAC5d,EAAI6I,KAC1B,MAAMmB,EAAOkT,IAAe3a,GAAQA,EAAKxB,OAAS8H,GAArCqU,CAA+Cld,EAAGF,WAC/D,IAAKkK,EACD,OAAO,EAEX,MAAMvI,EAAQzB,EAAGwB,IAAIO,QAAQiI,EAAK5C,OAAO3F,MAAMuI,EAAK3H,OACpD,QAAcyJ,IAAVrK,EACA,OAAO,EAEX,MAAM6B,EAAYtD,EAAGwB,IAAImc,OAAOlc,GAGhC,OAFwBuI,EAAKzH,KAAKxB,QAAUuC,MAAAA,OAA6C,EAASA,EAAUvC,SACrG,QAAQf,EAAGwB,IAAKC,KAIvBzB,EAAG+F,KAAKtE,IACD,IA+CX,IAAIoc,GAA4BpT,OAAO6D,OAAO,CAC5CC,UAAW,KACXuP,WA/CiB,CAACC,EAAgBC,IAAmB,EAAG9P,OAAAA,EAAQlO,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAU4a,MAAAA,EAAO3S,SAAAA,EAAUvC,IAAAA,MACpG,MAAM,WAAE6X,GAAelP,EAAOgO,iBACxBrT,EAAWiH,EAAYiO,EAAgBne,EAAM6N,QAC7C5D,EAAWiG,EAAYkO,EAAgBpe,EAAM6N,SAC7C,UAAE3N,GAAcF,GAChB,MAAE+E,EAAK,IAAEC,GAAQ9E,EACjBW,EAAQkE,EAAMjE,WAAWkE,GAC/B,IAAKnE,EACD,OAAO,EAEX,MAAMwd,EAAaf,IAAe3a,GAAQib,GAAOjb,EAAKxB,KAAKmL,KAAMkR,IAA9CF,CAA2Dpd,GAC9E,GAAIW,EAAM4B,OAAS,GAAK4b,GAAcxd,EAAM4B,MAAQ4b,EAAW5b,OAAS,EAAG,CAEvE,GAAI4b,EAAW1b,KAAKxB,OAAS8H,EACzB,OAAOf,EAAS8B,aAAaC,GAGjC,GAAI2T,GAAOS,EAAW1b,KAAKxB,KAAKmL,KAAMkR,IAC/BvU,EAASqV,aAAaD,EAAW1b,KAAKnB,UACtCvB,EACH,OAAO4a,IACF9K,SAAQ,KACT3P,EAAG0F,cAAcuY,EAAW/b,IAAK2G,IAC1B,KAEN8G,SAAQ,IAAM+N,GAAkB1d,EAAI6I,KACpC8G,SAAQ,IAAMiO,GAAiB5d,EAAI6I,KACnC8R,MAGb,OAAOF,IAEF9K,SAAQ,MACapK,IAAMqD,WAAWC,IAIhCf,EAASsH,eAEfxG,WAAWC,GACX8G,SAAQ,IAAM+N,GAAkB1d,EAAI6I,KACpC8G,SAAQ,IAAMiO,GAAiB5d,EAAI6I,KACnC8R,SAQT,SAASwD,GAAave,EAAOuQ,EAAYiB,EAAa,IAClD,MAAM,MAAErR,EAAK,OAAEoO,GAAWvO,EAAME,UAC1BiB,EAAOoP,EACPQ,GAAYR,EAAYvQ,EAAM6N,QAC9B,KACN,GAAI1N,EACA,SAAUH,EAAM8T,aAAe9T,EAAME,UAAU6E,MAAMiM,SAChD/C,QAAO4D,IACH1Q,GAGEA,EAAKmL,OAASuF,EAAK1Q,KAAKmL,OAE9BmF,MAAKI,GAAQX,GAAeW,EAAKhK,MAAO2J,EAAY,CAAEH,QAAQ,MAEvE,IAAI0G,EAAiB,EACrB,MAAMyG,EAAa,GAmBnB,GAlBAjQ,EAAO/C,SAAQ,EAAGzG,MAAAA,EAAOC,IAAAA,MACrB,MAAMhD,EAAO+C,EAAMzC,IACbP,EAAKiD,EAAI1C,IACftC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,IAAKK,EAAK8K,SAAW9K,EAAKqO,MAAMtK,OAC5B,OAEJ,MAAMmR,EAAenK,KAAKC,IAAI3L,EAAMM,GAC9BwV,EAAapK,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKJ,UAE3CwV,GADcD,EAAaD,EAE3B2G,EAAWvX,QAAQtE,EAAKqO,MAAM3O,KAAIwP,IAAQ,CACtCA,KAAAA,EACA7P,KAAM6V,EACN9V,GAAI+V,aAIO,IAAnBC,EACA,OAAO,EAGX,MAAM0G,EAAeD,EAChBvQ,QAAOyQ,IACHvd,GAGEA,EAAKmL,OAASoS,EAAU7M,KAAK1Q,KAAKmL,OAExC2B,QAAOyQ,GAAaxN,GAAewN,EAAU7M,KAAKhK,MAAO2J,EAAY,CAAEH,QAAQ,MAC/E4G,QAAO,CAACC,EAAKwG,IAAcxG,EAAMwG,EAAU3c,GAAK2c,EAAU1c,MAAM,GAG/D2c,EAAgBH,EACjBvQ,QAAOyQ,IACHvd,GAGEud,EAAU7M,KAAK1Q,OAASA,GACxBud,EAAU7M,KAAK1Q,KAAKyd,SAASzd,KAEnC8W,QAAO,CAACC,EAAKwG,IAAcxG,EAAMwG,EAAU3c,GAAK2c,EAAU1c,MAAM,GAMrE,OAHcyc,EAAe,EACvBA,EAAeE,EACfF,IACU1G,EAapB,IAAI8G,GAA4BhU,OAAO6D,OAAO,CAC5CC,UAAW,KACXmQ,WAZiB,CAACvO,EAAYiB,EAAa,GAAI9E,EAAU,KAAO,EAAG1M,MAAAA,EAAOkI,SAAAA,MACxE,MAAM,qBAAE6W,GAAuB,GAAUrS,EACnCvL,EAAO4P,GAAYR,EAAYvQ,EAAM6N,QAE3C,OADiB0Q,GAAave,EAAOmB,EAAMqQ,GAEhCtJ,EAAS8W,UAAU7d,EAAM,CAAE4d,qBAAAA,IAE/B7W,EAASmS,QAAQlZ,EAAMqQ,MAkBlC,IAAIyN,GAA4BpU,OAAO6D,OAAO,CAC5CC,UAAW,KACXuQ,WAZiB,CAAC3O,EAAY4O,EAAkB3N,EAAa,KAAO,EAAGxR,MAAAA,EAAOkI,SAAAA,MAC5E,MAAM/G,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QACrCuR,EAAalP,EAAYiP,EAAkBnf,EAAM6N,QAEvD,OADiB8J,GAAa3X,EAAOmB,EAAMqQ,GAEhCtJ,EAAS0S,QAAQwE,GAErBlX,EAAS0S,QAAQzZ,EAAMqQ,MAiBlC,IAAI6N,GAA4BxU,OAAO6D,OAAO,CAC5CC,UAAW,KACX2Q,WAXiB,CAAC/O,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOkI,SAAAA,MAC1D,MAAM/G,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAE3C,OADiB8J,GAAa3X,EAAOmB,EAAMqQ,GAEhCtJ,EAASlH,KAAKG,GAElB+G,EAASqX,OAAOpe,EAAMqQ,MAoCjC,IAAIgO,GAA+B3U,OAAO6D,OAAO,CAC/CC,UAAW,KACX8Q,cA9BoB,IAAM,EAAGzf,MAAAA,EAAOC,SAAAA,MAClC,MAAMyf,EAAU1f,EAAM0f,QACtB,IAAK,IAAIpc,EAAI,EAAGA,EAAIoc,EAAQhZ,OAAQpD,GAAK,EAAG,CACxC,MAAMqc,EAASD,EAAQpc,GACvB,IAAIsc,EAGJ,GAAID,EAAOve,KAAKye,eAAiBD,EAAWD,EAAOG,SAAS9f,IAAS,CACjE,GAAIC,EAAU,CACV,MAAMG,EAAKJ,EAAMI,GACX2f,EAASH,EAASI,UACxB,IAAK,IAAIC,EAAIF,EAAOrK,MAAMhP,OAAS,EAAGuZ,GAAK,EAAGA,GAAK,EAC/C7f,EAAG6B,KAAK8d,EAAOrK,MAAMuK,GAAGC,OAAOH,EAAOI,KAAKF,KAE/C,GAAIL,EAASvS,KAAM,CACf,MAAM2D,EAAQ5Q,EAAGwB,IAAIO,QAAQyd,EAAS5d,MAAMgP,QAC5C5Q,EAAGuE,YAAYib,EAAS5d,KAAM4d,EAAS7d,GAAI/B,EAAM6N,OAAOR,KAAKuS,EAASvS,KAAM2D,SAG5E5Q,EAAGsC,OAAOkd,EAAS5d,KAAM4d,EAAS7d,IAG1C,OAAO,GAGf,OAAO,KAsBX,IAAIqe,GAA+BvV,OAAO6D,OAAO,CAC/CC,UAAW,KACX0R,cAhBoB,IAAM,EAAGjgB,GAAAA,EAAIH,SAAAA,MAC/B,MAAM,UAAEC,GAAcE,GAChB,MAAED,EAAK,OAAEoO,GAAWrO,EAC1B,OAAIC,GAGAF,GACAsO,EAAO/C,SAAQ3K,IACXT,EAAGkgB,WAAWzf,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,SAJtC,KA2Cf,IAAIie,GAA2B1V,OAAO6D,OAAO,CAC3CC,UAAW,KACXqQ,UA9BgB,CAACzO,EAAY7D,EAAU,KAAO,EAAGtM,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC1D,IAAIsN,EACJ,MAAM,qBAAEwR,GAAuB,GAAUrS,GACnC,UAAExM,GAAcE,EAChBe,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,MAAE9I,EAAK,MAAE5E,EAAK,OAAEoO,GAAWrO,EACjC,IAAKD,EACD,OAAO,EAEX,GAAIE,GAAS4e,EAAsB,CAC/B,IAAI,KAAE/c,EAAI,GAAED,GAAO7B,EACnB,MAAM2H,EAAkE,QAAzD0F,EAAKxI,EAAMiM,QAAQS,MAAKI,GAAQA,EAAK1Q,OAASA,WAA0B,IAAPoM,OAAgB,EAASA,EAAG1F,MACtGhH,EAAQ8Q,GAAa5M,EAAO5D,EAAM0G,GACpChH,IACAmB,EAAOnB,EAAMmB,KACbD,EAAKlB,EAAMkB,IAEf3B,EAAGkgB,WAAWte,EAAMD,EAAIZ,QAGxBoN,EAAO/C,SAAQ3K,IACXT,EAAGkgB,WAAWzf,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,IAAKnB,MAItD,OADAf,EAAGogB,iBAAiBrf,IACb,KAoDX,IAAIsf,GAAkC5V,OAAO6D,OAAO,CAClDC,UAAW,KACX+R,iBA9CuB,CAACnQ,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MACpE,IAAI2H,EAAW,KACXmR,EAAW,KACf,MAAMC,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,QAAKmL,IAGc,SAAfA,IACApR,EAAWsI,EAAYK,EAAYvQ,EAAM6N,SAE1B,SAAfmL,IACAD,EAAWhI,GAAYR,EAAYvQ,EAAM6N,SAEzC5N,GACAG,EAAGF,UAAUqO,OAAO/C,SAAQ3K,IACxB,MAAMmB,EAAOnB,EAAMkE,MAAMzC,IACnBP,EAAKlB,EAAMmE,IAAI1C,IACrBtC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KAChCsF,GAAYA,IAAajF,EAAKxB,MAC9Bf,EAAG0F,cAAcxD,OAAK4J,EAAW,IAC1BvJ,EAAKkF,SACL2J,IAGPuH,GAAYpW,EAAKqO,MAAMtK,QACvB/D,EAAKqO,MAAMxF,SAAQqG,IACf,GAAIkH,IAAalH,EAAK1Q,KAAM,CACxB,MAAMqZ,EAAc9M,KAAKC,IAAIrL,EAAKN,GAC5ByY,EAAY/M,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAChD3B,EAAG6Y,QAAQuB,EAAaC,EAAW1B,EAASpS,OAAO,IAC5CkL,EAAKhK,SACL2J,gBAQxB,MAaX,IAAImP,GAAwB9V,OAAO6D,OAAO,CACxCC,UAAW,KACX4Q,OAPa,CAAChP,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,MACtD,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAC3C,OFlxCYjG,EEkxCIzG,EFlxCM0G,EEkxCA2J,EFjxCjB,SAASxR,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAM4b,EAAW/f,IAAS,QAAaA,EAAO+G,EAAUC,GACrF,QAAK+Y,IACD3gB,GAAYA,EAASD,EAAMI,GAAGqG,KAAK5F,EAAO+f,GAAUvgB,mBACjD,KE0wC2BL,EAAOC,GFlxC7C,IAAgB2H,EAAUC,KE+xC1B,IAAIgZ,GAA4BhW,OAAO6D,OAAO,CAC5CC,UAAW,KACX3F,WAPiB,CAACuH,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,KAEnD+I,EADMkH,EAAYK,EAAYvQ,EAAM6N,QACjB2D,EAAnBxI,CAA+BhJ,EAAOC,KAQjD,MAAM6gB,GAAW1U,EAAUzF,OAAO,CAC9B2F,KAAM,WACNyU,YAAW,KACA,IACAtS,KACAU,KACAI,KACAO,KACAG,KACAI,KACAG,KACAE,KACAC,KACAG,MACAoB,MACAG,MACAmB,MACAQ,MACAC,MACAe,MACAiB,MACAC,MACAE,MACA+B,MACAC,MACAC,MACAC,MACAO,MACAK,MACAC,MACAG,MACAC,MACAC,MACAI,MACAC,MACAE,MACAK,MACAM,MACAC,MACAK,MACAG,MACAG,MACAa,MACAK,MACAyB,MACAY,MACAI,MACAI,MACAG,MACAY,MACAG,MACAE,MACAE,MACAE,OAKTG,GAAW5U,EAAUzF,OAAO,CAC9B2F,KAAM,WACN8B,wBACI,MAAO,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,YACnBoD,MAAO,CACHoV,SAAU,IAAM5U,KAAKiC,OAAO5B,QAAQuU,gBAOlDC,GAAc9U,EAAUzF,OAAO,CACjC2F,KAAM,cACN8B,wBACI,MAAM,OAAEE,GAAWjC,KACnB,MAAO,CACH,IAAI,KAAO,CACP5D,IAAK,IAAI,KAAU,eACnBoD,MAAO,CACHsV,gBAAiB,CACb1N,MAAO,CAAClT,EAAMsW,KACVvI,EAAO8S,WAAY,EACnB,MAAMC,EAAc/S,EAAOtO,MAAMI,GAC5B6Z,QAAQ,QAAS,CAAEpD,MAAAA,IACnBoD,QAAQ,gBAAgB,GAE7B,OADA1Z,EAAKN,SAASohB,IACP,GAEXzS,KAAM,CAACrO,EAAMsW,KACTvI,EAAO8S,WAAY,EACnB,MAAMC,EAAc/S,EAAOtO,MAAMI,GAC5B6Z,QAAQ,OAAQ,CAAEpD,MAAAA,IAClBoD,QAAQ,gBAAgB,GAE7B,OADA1Z,EAAKN,SAASohB,IACP,WASnC,SAASC,GAAqBnV,GAC1B,MAAM,MAAEnM,EAAK,YAAEqhB,GAAgBlV,EAC/B,IAAI,UAAEjM,GAAcmhB,GAChB,IAAEzf,GAAQyf,GACV,YAAEvN,GAAgBuN,EACtB,MAAO,IACArhB,EACH6N,OAAQ7N,EAAM6N,OACd6R,QAAS1f,EAAM0f,QACf6B,MAAOvhB,EAAMuhB,MAAMzV,KAAK9L,GACxBwhB,iBAAkBxhB,EAAMwhB,iBAAiB1V,KAAK9L,GAC9CyhB,YAAazhB,EAAMyhB,YAAY3V,KAAK9L,GACpC0hB,OAAQ1hB,EAAM0hB,OAAO5V,KAAK9L,GACtB8T,kBACA,OAAOA,GAEP5T,gBACA,OAAOA,GAEP0B,UACA,OAAOA,GAEPxB,SAIA,OAHAF,EAAYmhB,EAAYnhB,UACxB0B,EAAMyf,EAAYzf,IAClBkS,EAAcuN,EAAYvN,YACnBuN,IAKnB,MAAMM,GACFzW,YAAYW,GACRQ,KAAKiC,OAASzC,EAAMyC,OACpBjC,KAAKuV,YAAcvV,KAAKiC,OAAOgO,iBAAiBpU,SAChDmE,KAAKwV,YAAchW,EAAM7L,MAEzB8hB,qBACA,QAASzV,KAAKwV,YAEd7hB,YACA,OAAOqM,KAAKwV,aAAexV,KAAKiC,OAAOtO,MAEvCkI,eACA,MAAM,YAAE0Z,EAAW,OAAEtT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,GACX,GAAElO,GAAOJ,EACT6L,EAAQQ,KAAK0V,WAAW3hB,GAC9B,OAAOyK,OAAOiD,YAAYjD,OACrBkD,QAAQ6T,GACRvf,KAAI,EAAEiK,EAAMyD,KAQN,CAACzD,EAPO,IAAI0V,KACf,MAAMC,EAAWlS,KAAWiS,EAAXjS,CAAiBlE,GAIlC,OAHKzL,EAAG8hB,QAAQ,oBAAuB7V,KAAKyV,gBACxCvhB,EAAKN,SAASG,GAEX6hB,OAKfpH,YACA,MAAO,IAAMxO,KAAK8V,cAElBxc,UACA,MAAO,IAAM0G,KAAK+V,YAEtBD,YAAYE,EAASC,GAAiB,GAClC,MAAM,YAAEV,EAAW,OAAEtT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,EACXiU,EAAY,GACZC,IAAwBH,EACxBjiB,EAAKiiB,GAAWriB,EAAMI,GAUtBya,EAAQ,IACPhQ,OAAOiD,YAAYjD,OAAOkD,QAAQ6T,GAAavf,KAAI,EAAEiK,EAAMyD,KAOnD,CAACzD,EANe,IAAI0V,KACvB,MAAMnW,EAAQQ,KAAK0V,WAAW3hB,EAAIkiB,GAC5BL,EAAWlS,KAAWiS,EAAXjS,CAAiBlE,GAElC,OADA0W,EAAUtb,KAAKgb,GACRpH,OAIfE,IAnBQ,KACHyH,IACEF,GACCliB,EAAG8hB,QAAQ,oBACX7V,KAAKyV,gBACTvhB,EAAKN,SAASG,GAEXmiB,EAAUjR,OAAM2Q,IAAyB,IAAbA,MAcvC,OAAOpH,EAEXuH,UAAUC,GACN,MAAM,YAAET,EAAW,MAAE5hB,GAAUqM,KACzBpM,OAAWiM,EACX9L,EAAKiiB,GAAWriB,EAAMI,GACtByL,EAAQQ,KAAK0V,WAAW3hB,EAAIH,GAC5BwiB,EAAoB5X,OAAOiD,YAAYjD,OACxCkD,QAAQ6T,GACRvf,KAAI,EAAEiK,EAAMyD,KACN,CAACzD,EAAM,IAAI0V,IAASjS,KAAWiS,EAAXjS,CAAiB,IAAKlE,EAAO5L,SAAAA,QAE5D,MAAO,IACAwiB,EACH5H,MAAO,IAAMxO,KAAK8V,YAAY/hB,EAAIH,IAG1C8hB,WAAW3hB,EAAIkiB,GAAiB,GAC5B,MAAM,YAAEV,EAAW,OAAEtT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,EACbtO,EAAM8T,aACN1T,EAAG2T,eAAe/T,EAAM8T,aAE5B,MAAMjI,EAAQ,CACVzL,GAAAA,EACAkO,OAAAA,EACA/N,KAAAA,EACAP,MAAOshB,GAAqB,CACxBthB,MAAAA,EACAqhB,YAAajhB,IAEjBH,SAAUqiB,EACJ,YACApW,EACN2O,MAAO,IAAMxO,KAAK8V,YAAY/hB,GAC9BuF,IAAK,IAAM0G,KAAK+V,UAAUhiB,GACtB8H,eACA,OAAO2C,OAAOiD,YAAYjD,OACrBkD,QAAQ6T,GACRvf,KAAI,EAAEiK,EAAMyD,KACN,CAACzD,EAAM,IAAI0V,IAASjS,KAAWiS,EAAXjS,CAAiBlE,SAIxD,OAAOA,GAIf,MAAM6W,GAAStW,EAAUzF,OAAO,CAC5B2F,KAAM,SACNqW,uBACI,MAAMC,EAAkB,IAAMvW,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACvE,IAAMA,EAASuX,gBAEf,IAAMvX,EAAS6H,SAAQ,EAAG3P,GAAAA,MACtB,MAAM,UAAEF,EAAS,IAAE0B,GAAQxB,GACrB,MAAED,EAAK,QAAE0D,GAAY3D,GACrB,IAAEoC,EAAG,OAAEf,GAAWsC,EAClBgf,EAAY,aAAkBjhB,GAAKI,OAASM,EAClD,UAAKnC,GACG0iB,GACAthB,EAAOJ,KAAK6B,cACbzB,EAAOuhB,YAAYpc,SAGnBwB,EAASsH,gBAEpB,IAAMtH,EAASnI,kBACf,IAAMmI,EAAS5H,eACf,IAAM4H,EAAShF,wBAEb6f,EAAe,IAAM1W,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACpE,IAAMA,EAASnI,kBACf,IAAMmI,EAAS1E,cACf,IAAM0E,EAASvE,uBAQbqf,EAAa,CACfC,MAPgB,IAAM5W,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACnE,IAAMA,EAAStE,gBACf,IAAMsE,EAASrD,sBACf,IAAMqD,EAAS/C,iBACf,IAAM+C,EAAS5C,gBAIf,YAAa,IAAM+G,KAAKiC,OAAOpG,SAAS5D,WACxC4e,UAAWN,EACX,gBAAiBA,EACjB,kBAAmBA,EACnBO,OAAQJ,EACR,aAAcA,EACd,QAAS,IAAM1W,KAAKiC,OAAOpG,SAASkR,aAElCgK,EAAW,IACVJ,EACHta,KAAM,IAAM2D,KAAKiC,OAAOpG,SAAST,uBACjCkB,IAAK,IAAM0D,KAAKiC,OAAOpG,SAASR,sBAE9B2b,EAAY,IACXL,EACH,SAAUJ,EACV,gBAAiBA,EACjB,SAAUG,EACV,qBAAsBA,EACtB,aAAcA,EACd,QAASA,EACT,SAAU,IAAM1W,KAAKiC,OAAOpG,SAAST,uBACrC,SAAU,IAAM4E,KAAKiC,OAAOpG,SAASR,sBAEzC,OAAImL,MAAWsD,KACJkN,EAEJD,GAEXhV,wBACI,MAAO,CAMH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,iBACnB6a,kBAAmB,CAACC,EAAcC,EAAUC,KAGxC,KAFmBF,EAAaG,MAAKrC,GAAeA,EAAYsC,eACxDH,EAAS5hB,IAAIiS,GAAG4P,EAAS7hB,MAE7B,OAEJ,MAAM,MAAEzB,EAAK,KAAE6B,EAAI,GAAED,GAAOyhB,EAAStjB,UAC/B0jB,EAAU,aAAkBJ,EAAS5hB,KAAKI,KAC1C6hB,EAAS,WAAgBL,EAAS5hB,KAAKG,GACvC+hB,EAAiB9hB,IAAS4hB,GAAW7hB,IAAO8hB,EAC5CE,EAAsF,IAA5EN,EAAS7hB,IAAIoiB,YAAY,EAAGP,EAAS7hB,IAAIJ,QAAQC,KAAM,IAAK,KAAKiF,OACjF,GAAIvG,IAAU2jB,IAAmBC,EAC7B,OAEJ,MAAM3jB,EAAKqjB,EAASrjB,GACdJ,EAAQshB,GAAqB,CAC/BthB,MAAOyjB,EACPpC,YAAajhB,KAEX,SAAE8H,GAAa,IAAIyZ,GAAe,CACpCrT,OAAQjC,KAAKiC,OACbtO,MAAAA,IAGJ,OADAkI,EAASsH,aACJpP,EAAGsV,MAAMhP,OAGPtG,OAHP,SAUd6jB,GAAW7X,EAAUzF,OAAO,CAC9B2F,KAAM,WACN8B,wBACI,MAAO,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,YACnBoD,MAAO,CACH2F,WAAY,KACR,GAAInF,KAAKiC,OAAO4V,WACZ,MAAO,CACHC,SAAU,aAU1C,IAAI3G,GAA0B3S,OAAO6D,OAAO,CAC1CC,UAAW,KACXR,wBAAyBA,EACzB2S,SAAUA,GACVE,SAAUA,GACVE,YAAaA,GACbwB,OAAQA,GACRuB,SAAUA,KAGZ,SAASG,GAAkBpkB,EAAOuQ,GAC9B,MAAMpP,EAAO+O,EAAYK,EAAYvQ,EAAM6N,SACrC,KAAE7L,EAAI,GAAED,GAAO/B,EAAME,UACrB8N,EAAQ,GACdhO,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAIY,IAC7BqL,EAAM/G,KAAKtE,MAEf,MAAMA,EAAOqL,EACRqW,UACA5S,MAAK6S,GAAYA,EAASnjB,KAAKmL,OAASnL,EAAKmL,OAClD,OAAK3J,EAGE,IAAKA,EAAKkF,OAFN,GAKf,SAAS0c,GAAcvkB,EAAOuQ,GAC1B,MAAMyI,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,MAAmB,SAAfmL,EACOoL,GAAkBpkB,EAAOuQ,GAEjB,SAAfyI,EACOkB,GAAkBla,EAAOuQ,GAE7B,GAGX,SAASiU,GAASxkB,EAAOsM,EAAMkF,EAAa,IACxC,IAAKlF,EACD,OAAOqL,GAAa3X,EAAO,KAAMwR,IAAe+M,GAAave,EAAO,KAAMwR,GAE9E,MAAMwH,EAAaT,GAAwBjM,EAAMtM,EAAM6N,QACvD,MAAmB,SAAfmL,EACOrB,GAAa3X,EAAOsM,EAAMkF,GAElB,SAAfwH,GACOuF,GAAave,EAAOsM,EAAMkF,GAKzC,SAASiT,GAAoBC,EAAU7W,GACnC,MAAM8W,EAAmB,gBACT9W,GACX+W,kBAAkBF,GAEjBG,EADoB7R,SAAS8R,eAAeC,qBACdC,cAAc,OAElD,OADAH,EAAUI,YAAYN,GACfE,EAAUK,UAGrB,SAASC,GAAQxiB,EAAM+J,GAKnB,OAAOO,EAAetK,EAJR,CACVX,KAAM,EACND,GAAIY,EAAKnB,QAAQC,MAEciL,GAGvC,SAAS0Y,GAAYziB,GACjB,IAAI4K,EACJ,MAAM8X,EAAsD,QAApC9X,EAAK5K,EAAKxB,KAAKyD,uBAAoC,IAAP2I,OAAgB,EAASA,EAAGmU,SAC1FlgB,EAAUmB,EAAK+e,SACrB,OAAO4D,KAAKC,UAAUF,KAAoBC,KAAKC,UAAU/jB,GAe7D,MAAMgkB,GACFta,YAAYiB,GACRE,KAAKoF,KAAOtF,EAAOsF,KACnBpF,KAAKoZ,QAAUtZ,EAAOsZ,SAwB9B,SAASC,GAAMvZ,GACX,IAAIoB,EACJ,MAAM,OAAEe,EAAM,KAAEtM,EAAI,GAAED,EAAE,KAAEsL,EAAI,MAAEsY,EAAK,OAAEhG,GAAYxT,GAC7C,KAAE5L,GAAS+N,EACjB,GAAI/N,EAAKqlB,UACL,OAAO,EAEX,MAAM7gB,EAAQxE,EAAKP,MAAM4B,IAAIO,QAAQH,GACrC,GAEA+C,EAAMxD,OAAOJ,KAAKC,KAAK0C,OAEoC,QAAhDyJ,EAAMxI,EAAM7D,YAAc6D,EAAMrB,iBAA+B,IAAP6J,OAAgB,EAASA,EAAGyD,MAAMS,MAAKI,GAAQA,EAAK1Q,KAAKC,KAAK0C,QAC7H,OAAO,EAEX,IAAI+hB,GAAU,EACd,MACMC,EAAa/gB,EAAMxD,OAAOyiB,YAAYtW,KAAKC,IAAI,EAAG5I,EAAMrE,aAD7C,KACuEqE,EAAMrE,kBAAcwL,EAAW,KAAOmB,EA6C9H,OA5CAsY,EAAMna,SAAQua,IACV,GAAIF,EACA,OAEJ,MAAM3hB,EA3CkB,EAACmJ,EAAMoE,KACnC,GAAIR,GAASQ,GACT,OAAOA,EAAKuU,KAAK3Y,GAErB,MAAM4Y,EAAiBxU,EAAKpE,GAC5B,IAAK4Y,EACD,OAAO,KAEX,MAAMvP,EAAS,GAWf,OAVAA,EAAOzP,KAAKgf,EAAe5Y,MAC3BqJ,EAAOnT,MAAQ0iB,EAAe1iB,MAC9BmT,EAAOwP,MAAQ7Y,EACfqJ,EAAOyP,KAAOF,EAAeE,KACzBF,EAAethB,cACVshB,EAAe5Y,KAAKyF,SAASmT,EAAethB,cAC7C6H,QAAQC,KAAK,sFAEjBiK,EAAOzP,KAAKgf,EAAethB,cAExB+R,GAwBW0P,CAAwBN,EAAYC,EAAKtU,MACvD,IAAKvN,EACD,OAEJ,MAAM9D,EAAKG,EAAKP,MAAMI,GAChBJ,EAAQshB,GAAqB,CAC/BthB,MAAOO,EAAKP,MACZqhB,YAAajhB,IAEXS,EAAQ,CACVmB,KAAMA,GAAQkC,EAAM,GAAGwC,OAAS2G,EAAK3G,QACrC3E,GAAAA,IAEE,SAAEmG,EAAQ,MAAE2S,EAAK,IAAElV,GAAQ,IAAIgc,GAAe,CAChDrT,OAAAA,EACAtO,MAAAA,IAWY,OATA+lB,EAAKN,QAAQ,CACzBzlB,MAAAA,EACAa,MAAAA,EACAqD,MAAAA,EACAgE,SAAAA,EACA2S,MAAAA,EACAlV,IAAAA,KAGqBvF,EAAGsV,MAAMhP,SAKlCtG,EAAG6Z,QAAQ0F,EAAQ,CACfK,UAAW5f,EACX4B,KAAAA,EACAD,GAAAA,EACAsL,KAAAA,IAEJ9M,EAAKN,SAASG,GACdylB,GAAU,MAEPA,EAOX,SAASQ,GAAiBxa,GACtB,MAAM,OAAEyC,EAAM,MAAEqX,GAAU9Z,EACpB8T,EAAS,IAAI,KAAO,CACtB3f,MAAO,CACHsmB,KAAI,IACO,KAEX/E,MAAMnhB,EAAImmB,GACN,MAAMC,EAASpmB,EAAG8hB,QAAQ7V,MAC1B,OAAIma,IAGGpmB,EAAGqmB,cAAgBrmB,EAAGujB,WACvB,KACA4C,KAGd1a,MAAO,CACH6a,gBAAe,CAACnmB,EAAMyB,EAAMD,EAAIsL,IACrBqY,GAAM,CACTpX,OAAAA,EACAtM,KAAAA,EACAD,GAAAA,EACAsL,KAAAA,EACAsY,MAAAA,EACAhG,OAAAA,IAGRwB,gBAAiB,CACbwF,eAAgBpmB,IACZqmB,YAAW,KACP,MAAM,QAAEpmB,GAAYD,EAAKP,MAAME,UAC3BM,GACAklB,GAAM,CACFpX,OAAAA,EACAtM,KAAMxB,EAAQ8B,IACdP,GAAIvB,EAAQ8B,IACZ+K,KAAM,GACNsY,MAAAA,EACAhG,OAAAA,QAIL,IAKfkH,cAActmB,EAAMsW,GAChB,GAAkB,UAAdA,EAAMpO,IACN,OAAO,EAEX,MAAM,QAAEjI,GAAYD,EAAKP,MAAME,UAC/B,QAAIM,GACOklB,GAAM,CACTpX,OAAAA,EACAtM,KAAMxB,EAAQ8B,IACdP,GAAIvB,EAAQ8B,IACZ+K,KAAM,KACNsY,MAAAA,EACAhG,OAAAA,MAOhBE,cAAc,IAElB,OAAOF,EAOX,MAAMmH,GACF5b,YAAYiB,GACRE,KAAKoF,KAAOtF,EAAOsF,KACnBpF,KAAKoZ,QAAUtZ,EAAOsZ,SA0B9B,SAAS1K,GAAI5O,GACT,MAAM,OAAEmC,EAAM,MAAEtO,EAAK,KAAEgC,EAAI,GAAED,EAAE,KAAEgkB,GAAU5Z,GACrC,SAAEjE,EAAQ,MAAE2S,EAAK,IAAElV,GAAQ,IAAIgc,GAAe,CAChDrT,OAAAA,EACAtO,MAAAA,IAEE+mB,EAAW,GACjB/mB,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,IAAKK,EAAKK,aAAeL,EAAKxB,KAAKC,KAAK0C,KACpC,OAEJ,MAAMsX,EAAe1N,KAAKC,IAAI3L,EAAMM,GAC9B0kB,EAAatZ,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKnB,QAAQC,MAnC3B,EAAC4L,EAAMoE,KACnC,GAAIR,GAASQ,GACT,MAAO,IAAIpE,EAAK4Z,SAASxV,IAE7B,MAAMyV,EAAUzV,EAAKpE,GACrB,OAAK6Z,EAGEA,EAAQ7kB,KAAI8kB,IACf,MAAMzQ,EAAS,GAWf,OAVAA,EAAOzP,KAAKkgB,EAAe9Z,MAC3BqJ,EAAOnT,MAAQ4jB,EAAe5jB,MAC9BmT,EAAOwP,MAAQ7Y,EACfqJ,EAAOyP,KAAOgB,EAAehB,KACzBgB,EAAexiB,cACVwiB,EAAe9Z,KAAKyF,SAASqU,EAAexiB,cAC7C6H,QAAQC,KAAK,sFAEjBiK,EAAOzP,KAAKkgB,EAAexiB,cAExB+R,KAdA,IA+BS0Q,CADIzkB,EAAKqhB,YAAY5I,EAAe9Y,EAAK0kB,EAAa1kB,OAAK4J,EAAW,KACjC6Z,EAAKtU,MAClDjG,SAAQtH,IACZ,QAAoBgI,IAAhBhI,EAAMX,MACN,OAEJ,MAAMiE,EAAQ4T,EAAelX,EAAMX,MAAQ,EACrC6B,EAAMoC,EAAQtD,EAAM,GAAGwC,OACvB7F,EAAQ,CACVmB,KAAMhC,EAAMI,GAAGgC,QAAQC,IAAImF,GAC3BzF,GAAI/B,EAAMI,GAAGgC,QAAQC,IAAI+C,IAEvBqgB,EAAUM,EAAKN,QAAQ,CACzBzlB,MAAAA,EACAa,MAAAA,EACAqD,MAAAA,EACAgE,SAAAA,EACA2S,MAAAA,EACAlV,IAAAA,IAEJohB,EAAS9f,KAAKwe,SAItB,OADgBsB,EAASzV,OAAMmU,GAAuB,OAAZA,IAQ9C,SAAS4B,GAAiBxb,GACtB,MAAM,OAAEyC,EAAM,MAAEqX,GAAU9Z,EAC1B,IAAIyb,EAAoB,KACpBC,GAA0B,EAC1BC,GAA2B,EAmE/B,OAlEgB7B,EAAMtjB,KAAI0jB,GACf,IAAI,KAAO,CAEdxlB,KAAKA,GACD,MAAMknB,EAAmB5Q,IACrB,IAAItJ,EACJ+Z,GAAuD,QAAjC/Z,EAAKhN,EAAKwO,IAAI2Y,qBAAkC,IAAPna,OAAgB,EAASA,EAAGoa,SAAS9Q,EAAM9V,SACpGR,EAAKwO,IAAI2Y,cACT,MAGV,OADA1Y,OAAO4Y,iBAAiB,YAAaH,GAC9B,CACHI,UACI7Y,OAAO8Y,oBAAoB,YAAaL,MAIpD5b,MAAO,CACHsV,gBAAiB,CACb4G,KAAMxnB,IACFinB,EAA2BF,IAAsB/mB,EAAKwO,IAAI2Y,eACnD,GAEXM,MAAO,CAACznB,EAAMsW,KACV,IAAItJ,EACJ,MAAM0a,EAAsC,QAA9B1a,EAAKsJ,EAAMqR,qBAAkC,IAAP3a,OAAgB,EAASA,EAAG4a,QAAQ,aAExF,OADAZ,KAA6BU,MAAAA,OAAmC,EAASA,EAAKnV,SAAS,mBAChF,KAInBwQ,kBAAmB,CAACC,EAAcC,EAAUxjB,KACxC,MAAMqhB,EAAckC,EAAa,GAC3B6E,EAA6C,UAAnC/G,EAAYa,QAAQ,aAA2BqF,EACzDc,EAA4C,SAAnChH,EAAYa,QAAQ,aAA0BsF,EAC7D,IAAKY,IAAYC,EACb,OAGJ,MAAMrmB,EAAOwhB,EAAS5hB,IAAIJ,QAAQ8mB,cAActoB,EAAM4B,IAAIJ,SACpDO,EAAKyhB,EAAS5hB,IAAIJ,QAAQ+mB,YAAYvoB,EAAM4B,IAAIJ,SACtD,GA1HY,iBA0HEQ,IAAUD,GAAMC,IAASD,EAAGymB,EACtC,OAIJ,MAAMpoB,EAAKJ,EAAMI,GACXqoB,EAAiBnH,GAAqB,CACxCthB,MAAAA,EACAqhB,YAAajhB,IAUjB,OARgB2a,GAAI,CAChBzM,OAAAA,EACAtO,MAAOyoB,EACPzmB,KAAM0L,KAAKC,IAAI3L,EAAO,EAAG,GACzBD,GAAIA,EAAGymB,EACPzC,KAAAA,KAGa3lB,EAAGsV,MAAMhP,OAGnBtG,OAHP,OAchB,SAASsoB,GAA4BlL,GACjC,MAAM7B,EAAsB,IACtB,eAAE+B,EAAc,eAAEC,GAAmBJ,GAAgBC,GACrDmL,EAAwB,IAAIjL,KAAmBC,GAC/CiL,EAAmB,CACrBC,QAAS,KACTC,UAAU,EACVC,WAAY,KACZC,UAAW,KACXjN,aAAa,GAwDjB,OAtDAyB,EAAWhS,SAAQQ,IACf,MAKMid,EAAsBld,EAAkBC,EAAW,sBALzC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,UAGvB,IAAKqc,EACD,OAGqBA,IACRzd,SAAQ0d,IACrBA,EAAgBxjB,MAAM8F,SAAQrK,IAC1B0J,OACKkD,QAAQmb,EAAgB1X,YACxBhG,SAAQ,EAAEc,EAAMwP,MACjBH,EAAoB1U,KAAK,CACrB9F,KAAAA,EACAmL,KAAAA,EACAwP,UAAW,IACJ8M,KACA9M,iBAO3B6M,EAAsBnd,SAAQQ,IAC1B,MAAMJ,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SAEjBuc,EAAgBpd,EAAkBC,EAAW,gBAAiBJ,GACpE,IAAKud,EACD,OAGJ,MAAM3X,EAAa2X,IACnBte,OACKkD,QAAQyD,GACRhG,SAAQ,EAAEc,EAAMwP,MACjBH,EAAoB1U,KAAK,CACrB9F,KAAM6K,EAAUM,KAChBA,KAAAA,EACAwP,UAAW,IACJ8M,KACA9M,WAKZH,EAGX,SAASyN,MAAmBC,GACxB,OAAOA,EACFpb,QAAO3D,KAAUA,IACjB2N,QAAO,CAAC3F,EAAOhI,KAChB,MAAMgf,EAAmB,IAAKhX,GAiB9B,OAhBAzH,OAAOkD,QAAQzD,GAAMkB,SAAQ,EAAE/C,EAAKmC,MACjB0e,EAAiB7gB,GAM5B6gB,EAAiB7gB,GADT,UAARA,EACwB,CAAC6gB,EAAiB7gB,GAAMmC,GAAOzE,KAAK,KAE/C,UAARsC,EACmB,CAAC6gB,EAAiB7gB,GAAMmC,GAAOzE,KAAK,MAGpCyE,EAVxB0e,EAAiB7gB,GAAOmC,KAazB0e,IACR,IAGP,SAASC,GAAsBC,EAAY7N,GACvC,OAAOA,EACF1N,QAAO3D,GAAQA,EAAKwR,UAAUgN,WAC9BzmB,KAAIiI,GACAA,EAAKwR,UAAUiN,WAKbze,EAAKwR,UAAUiN,WAAWS,EAAW3hB,QAAU,GAJ3C,CACH,CAACyC,EAAKgC,MAAOkd,EAAW3hB,MAAMyC,EAAKgC,SAK1C2L,QAAO,CAACzG,EAAYsK,IAAcsN,GAAgB5X,EAAYsK,IAAY,IA6BnF,SAAS2N,GAAqCC,EAAW/N,GACrD,OAAI+N,EAAUC,MACHD,EAEJ,IACAA,EACHE,SAAUjnB,IACN,MAAM2X,EAAgBoP,EAAUE,SAC1BF,EAAUE,SAASjnB,GACnB+mB,EAAU7hB,MAChB,IAAsB,IAAlByS,EACA,OAAO,EAEX,MAAM+B,EAAgBV,EAAoB1D,QAAO,CAAC3F,EAAOhI,KACrD,MAAMM,EAAQN,EAAKwR,UAAUkN,UACvB1e,EAAKwR,UAAUkN,UAAUrmB,GArC/C,SAAoBiI,GAChB,MAAqB,iBAAVA,EACAA,EAEPA,EAAM1G,MAAM,wBACL2lB,OAAOjf,GAEJ,SAAVA,GAGU,UAAVA,GAGGA,EAyBWkf,CAAWnnB,EAAKonB,aAAazf,EAAKgC,OACxC,OAAI1B,MAAAA,EACO0H,EAEJ,IACAA,EACH,CAAChI,EAAKgC,MAAO1B,KAElB,IACH,MAAO,IAAK0P,KAAkB+B,KAK1C,SAAS2N,GAAkB7D,GACvB,OAAOtb,OAAOiD,YAAYjD,OAAOkD,QAAQoY,GAAMlY,QAAO,EAAExF,EAAKmC,MAC7C,UAARnC,IA1DZ,SAAuBmC,EAAQ,IAC3B,OAAqC,IAA9BC,OAAOU,KAAKX,GAAOlE,QAAgBkE,EAAMM,cAAgBL,OAyDrCof,CAAcrf,KAG9BA,MAAAA,KAGf,SAASsf,GAA8B1M,GACnC,IAAIjQ,EACJ,MAAM4c,EAAgBzB,GAA4BlL,IAC5C,eAAEE,EAAc,eAAEC,GAAmBJ,GAAgBC,GACrD4M,EAA+F,QAApF7c,EAAKmQ,EAAejM,MAAKzF,GAAaD,EAAkBC,EAAW,oBAAgC,IAAPuB,OAAgB,EAASA,EAAGjB,KACnI0B,EAAQnD,OAAOiD,YAAY4P,EAAerb,KAAI2J,IAChD,MAAM2P,EAAsBwO,EAAclc,QAAO6N,GAAaA,EAAU3a,OAAS6K,EAAUM,OACrFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SASjBiB,EAASmc,GAAkB,IAPTxM,EAAWvF,QAAO,CAACoS,EAAQxgB,KAC/C,MAAMygB,EAAmBve,EAAkBlC,EAAG,mBAAoB+B,GAClE,MAAO,IACAye,KACCC,EAAmBA,EAAiBte,GAAa,MAE1D,IAGCxK,QAASmK,EAAaI,EAAkBC,EAAW,UAAWJ,IAC9DoF,MAAOrF,EAAaI,EAAkBC,EAAW,QAASJ,IAC1DiS,MAAOlS,EAAaI,EAAkBC,EAAW,QAASJ,IAC1D2e,OAAQ5e,EAAaI,EAAkBC,EAAW,SAAUJ,IAC5D4e,KAAM7e,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD6e,WAAY9e,EAAaI,EAAkBC,EAAW,aAAcJ,IACpE8e,UAAW/e,EAAaI,EAAkBC,EAAW,YAAaJ,IAClE9H,KAAM6H,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD+e,SAAUhf,EAAaI,EAAkBC,EAAW,WAAYJ,IAChEvK,UAAWsK,EAAaI,EAAkBC,EAAW,YAAaJ,IAClE/D,MAAOgD,OAAOiD,YAAY6N,EAAoBtZ,KAAIwZ,IAC9C,IAAItO,EACJ,MAAO,CAACsO,EAAmBvP,KAAM,CAAEuc,QAAyH,QAA/Gtb,EAAKsO,MAAAA,OAA+D,EAASA,EAAmBC,iBAA8B,IAAPvO,OAAgB,EAASA,EAAGsb,gBAGlMG,EAAYrd,EAAaI,EAAkBC,EAAW,YAAaJ,IACrEod,IACAnb,EAAO+c,SAAW5B,EACb3mB,KAAIqnB,GAAaD,GAAqCC,EAAW/N,MAE1E,MAAMoN,EAAahd,EAAkBC,EAAW,aAAcJ,GAC1Dmd,IACAlb,EAAOgd,MAAQloB,GAAQomB,EAAW,CAC9BpmB,KAAAA,EACAmoB,eAAgBvB,GAAsB5mB,EAAMgZ,MAGpD,MAAMoP,EAAahf,EAAkBC,EAAW,aAAcJ,GAI9D,OAHImf,IACAld,EAAOK,OAAS6c,GAEb,CAAC/e,EAAUM,KAAMuB,OAEtBmD,EAAQnG,OAAOiD,YAAY6P,EAAetb,KAAI2J,IAChD,MAAM2P,EAAsBwO,EAAclc,QAAO6N,GAAaA,EAAU3a,OAAS6K,EAAUM,OACrFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SASjBiB,EAASmc,GAAkB,IAPTxM,EAAWvF,QAAO,CAACoS,EAAQxgB,KAC/C,MAAMmhB,EAAmBjf,EAAkBlC,EAAG,mBAAoB+B,GAClE,MAAO,IACAye,KACCW,EAAmBA,EAAiBhf,GAAa,MAE1D,IAGCif,UAAWtf,EAAaI,EAAkBC,EAAW,YAAaJ,IAClEgT,SAAUjT,EAAaI,EAAkBC,EAAW,WAAYJ,IAChEiS,MAAOlS,EAAaI,EAAkBC,EAAW,QAASJ,IAC1Dsf,SAAUvf,EAAaI,EAAkBC,EAAW,WAAYJ,IAChE9H,KAAM6H,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD/D,MAAOgD,OAAOiD,YAAY6N,EAAoBtZ,KAAIwZ,IAC9C,IAAItO,EACJ,MAAO,CAACsO,EAAmBvP,KAAM,CAAEuc,QAAyH,QAA/Gtb,EAAKsO,MAAAA,OAA+D,EAASA,EAAmBC,iBAA8B,IAAPvO,OAAgB,EAASA,EAAGsb,gBAGlMG,EAAYrd,EAAaI,EAAkBC,EAAW,YAAaJ,IACrEod,IACAnb,EAAO+c,SAAW5B,EACb3mB,KAAIqnB,GAAaD,GAAqCC,EAAW/N,MAE1E,MAAMoN,EAAahd,EAAkBC,EAAW,aAAcJ,GAO9D,OANImd,IACAlb,EAAOgd,MAAQhZ,GAAQkX,EAAW,CAC9BlX,KAAAA,EACAiZ,eAAgBvB,GAAsB1X,EAAM8J,MAG7C,CAAC3P,EAAUM,KAAMuB,OAE5B,OAAO,IAAI,KAAO,CACduc,QAAAA,EACApc,MAAAA,EACAgD,MAAAA,IAIR,SAASma,GAAoB7e,EAAMuB,GAC/B,OAAOA,EAAOG,MAAM1B,IAASuB,EAAOmD,MAAM1E,IAAS,KAGvD,SAAS8e,GAAwBpf,EAAWqf,GACxC,OAAI7Y,MAAMC,QAAQ4Y,GACPA,EAAQ3H,MAAK4H,IACyB,iBAArBA,EACdA,EACAA,EAAiBhf,QACPN,EAAUM,OAG3B+e,EAQX,MAAME,GACFrgB,YAAYsS,EAAYlP,GACpBjC,KAAK4P,gBAAkB,GACvB5P,KAAKiC,OAASA,EACdjC,KAAKmR,WAAa+N,GAAiBppB,QAAQqb,GAC3CnR,KAAKwB,OAASqc,GAA8B7d,KAAKmR,YACjDnR,KAAKmR,WAAWhS,SAAQQ,IACpB,IAAIuB,EAEJlB,KAAKiC,OAAOkd,iBAAiBxf,EAAUM,MAAQN,EAAUY,QACzD,MAAMhB,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAQjC,KAAKiC,OACbnN,KAAMgqB,GAAoBnf,EAAUM,KAAMD,KAAKwB,SAEnD,GAAuB,SAAnB7B,EAAU7K,KAAiB,EACuE,QAA7EoM,EAAK5B,EAAaI,EAAkBC,EAAW,cAAeJ,WAA8B,IAAP2B,GAAgBA,IAEtHlB,KAAK4P,gBAAgBhV,KAAK+E,EAAUM,MAG5C,MAAMmf,EAAiB1f,EAAkBC,EAAW,iBAAkBJ,GAClE6f,GACApf,KAAKiC,OAAOod,GAAG,eAAgBD,GAEnC,MAAME,EAAW5f,EAAkBC,EAAW,WAAYJ,GACtD+f,GACAtf,KAAKiC,OAAOod,GAAG,SAAUC,GAE7B,MAAMC,EAAW7f,EAAkBC,EAAW,WAAYJ,GACtDggB,GACAvf,KAAKiC,OAAOod,GAAG,SAAUE,GAE7B,MAAMC,EAAoB9f,EAAkBC,EAAW,oBAAqBJ,GACxEigB,GACAxf,KAAKiC,OAAOod,GAAG,kBAAmBG,GAEtC,MAAMC,EAAgB/f,EAAkBC,EAAW,gBAAiBJ,GAChEkgB,GACAzf,KAAKiC,OAAOod,GAAG,cAAeI,GAElC,MAAMC,EAAUhgB,EAAkBC,EAAW,UAAWJ,GACpDmgB,GACA1f,KAAKiC,OAAOod,GAAG,QAASK,GAE5B,MAAMC,EAASjgB,EAAkBC,EAAW,SAAUJ,GAClDogB,GACA3f,KAAKiC,OAAOod,GAAG,OAAQM,GAE3B,MAAMC,EAAYlgB,EAAkBC,EAAW,YAAaJ,GACxDqgB,GACA5f,KAAKiC,OAAOod,GAAG,UAAWO,MAItCpf,eAAe2Q,GACX,MAAM0O,EAAqBX,GAAiBY,KAAKZ,GAAiBa,QAAQ5O,IACpE6O,EAhEd,SAAwB/Z,GACpB,MAAMga,EAAWha,EAAMrE,QAAO,CAACse,EAAIhpB,IAAU+O,EAAMka,QAAQD,KAAQhpB,IACnE,MAAO,IAAI,IAAIkpB,IAAIH,IA8DSI,CAAeR,EAAmB7pB,KAAI2J,GAAaA,EAAUM,QAIrF,OAHI+f,EAAgB3lB,QAChB8F,QAAQC,KAAK,oDAAoD4f,EAAgBhqB,KAAIiI,GAAQ,IAAIA,OAASnE,KAAK,oCAE5G+lB,EAEXrf,eAAe2Q,GACX,OAAOA,EACFnb,KAAI2J,IACL,MAKM2gB,EAAgB5gB,EAAkBC,EAAW,gBALnC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,UAGvB,OAAI+f,EACO,CACH3gB,KACGK,KAAK+f,QAAQO,MAGjB3gB,KAGN4gB,KAAK,IAEd/f,YAAY2Q,GAER,OAAOA,EAAW2O,MAAK,CAACU,EAAGrE,KACvB,MAAMsE,EAAY/gB,EAAkB8gB,EAAG,aAFnB,IAGdE,EAAYhhB,EAAkByc,EAAG,aAHnB,IAIpB,OAAIsE,EAAYC,GACJ,EAERD,EAAYC,EACL,EAEJ,KAGX7kB,eACA,OAAOmE,KAAKmR,WAAWvF,QAAO,CAAC/P,EAAU8D,KACrC,MAOM+U,EAAchV,EAAkBC,EAAW,cAPjC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAQjC,KAAKiC,OACbnN,KAAMgqB,GAAoBnf,EAAUM,KAAMD,KAAKwB,UAGnD,OAAKkT,EAGE,IACA7Y,KACA6Y,KAJI7Y,IAMZ,IAEHwX,cACA,MAAM,OAAEpR,GAAWjC,KAMbmR,EAAa+N,GAAiBY,KAAK,IAAI9f,KAAKmR,YAAY6G,WACxD2I,EAAa,GACbC,EAAa,GACbC,EAAa1P,EACdnb,KAAI2J,IACL,MAAMJ,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAAA,EACAnN,KAAMgqB,GAAoBnf,EAAUM,KAAMD,KAAKwB,SAE7C6R,EAAU,GACViD,EAAuB5W,EAAkBC,EAAW,uBAAwBJ,GAClF,GAAI+W,EAAsB,CACtB,MAAMwK,EAAWtiB,OAAOiD,YAAYjD,OAC/BkD,QAAQ4U,KACRtgB,KAAI,EAAE+qB,EAAUC,KACV,CAACD,EAAU,IAAMC,EAAO,CAAE/e,OAAAA,QAE/Bgf,GAAe,OAAOH,GAC5BzN,EAAQzY,KAAKqmB,GAEjB,MAAMC,EAAgBxhB,EAAkBC,EAAW,gBAAiBJ,GAChEwf,GAAwBpf,EAAWsC,EAAO5B,QAAQ8gB,mBAAqBD,GACvEP,EAAW/lB,QAAQsmB,KAEvB,MAAME,EAAgB1hB,EAAkBC,EAAW,gBAAiBJ,GAChEwf,GAAwBpf,EAAWsC,EAAO5B,QAAQghB,mBAAqBD,GACvER,EAAWhmB,QAAQwmB,KAEvB,MAAMrf,EAAwBrC,EAAkBC,EAAW,wBAAyBJ,GACpF,GAAIwC,EAAuB,CACvB,MAAMuf,EAAqBvf,IAC3BsR,EAAQzY,QAAQ0mB,GAEpB,OAAOjO,KAENkN,OACL,MAAO,CACHvG,GAAiB,CACb/X,OAAAA,EACAqX,MAAOqH,OAER3F,GAAiB,CAChB/Y,OAAAA,EACAqX,MAAOsH,OAERC,GAGP1b,iBACA,OAAOkX,GAA4Brc,KAAKmR,YAExCoQ,gBACA,MAAM,OAAEtf,GAAWjC,MACb,eAAEqR,GAAmBH,GAAgBlR,KAAKmR,YAChD,OAAO3S,OAAOiD,YAAY4P,EACrBzP,QAAOjC,KAAeD,EAAkBC,EAAW,iBACnD3J,KAAI2J,IACL,MAAM2P,EAAsBtP,KAAKmF,WAAWvD,QAAO6N,GAAaA,EAAU3a,OAAS6K,EAAUM,OACvFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAAA,EACAnN,KAAM+O,EAAYlE,EAAUM,KAAMD,KAAKwB,SAErCggB,EAAc9hB,EAAkBC,EAAW,cAAeJ,GAChE,IAAKiiB,EACD,MAAO,GAaX,MAAO,CAAC7hB,EAAUM,KAXD,CAAC3J,EAAMpC,EAAMutB,EAAQC,KAClC,MAAMjD,EAAiBvB,GAAsB5mB,EAAMgZ,GACnD,OAAOkS,GAAAA,CAAc,CACjBvf,OAAAA,EACA3L,KAAAA,EACAmrB,OAAAA,EACAC,YAAAA,EACAjD,eAAAA,EACA9e,UAAAA,WAuHpB,MAAMgiB,WA/GN,MACI9iB,cACImB,KAAKkW,UAAY,GAErBmJ,GAAG7U,EAAO7G,GAKN,OAJK3D,KAAKkW,UAAU1L,KAChBxK,KAAKkW,UAAU1L,GAAS,IAE5BxK,KAAKkW,UAAU1L,GAAO5P,KAAK+I,GACpB3D,KAEX4hB,KAAKpX,KAAUmL,GACX,MAAMO,EAAYlW,KAAKkW,UAAU1L,GAIjC,OAHI0L,GACAA,EAAU/W,SAAQyW,GAAYA,EAASV,MAAMlV,KAAM2V,KAEhD3V,KAEX6hB,IAAIrX,EAAO7G,GACP,MAAMuS,EAAYlW,KAAKkW,UAAU1L,GASjC,OARI0L,IACIvS,EACA3D,KAAKkW,UAAU1L,GAAS0L,EAAUtU,QAAOgU,GAAYA,IAAajS,WAG3D3D,KAAKkW,UAAU1L,IAGvBxK,KAEX8hB,qBACI9hB,KAAKkW,UAAY,KAiFrBrX,YAAYwB,EAAU,IAClB0hB,QACA/hB,KAAK+U,WAAY,EACjB/U,KAAKmf,iBAAmB,GACxBnf,KAAKK,QAAU,CACX2hB,QAASrb,SAASgS,cAAc,OAChCxjB,QAAS,GACT8sB,WAAW,EACX9Q,WAAY,GACZ+Q,WAAW,EACXtN,UAAU,EACVuN,YAAa,GACb9Z,aAAc,GACd8Y,kBAAkB,EAClBE,kBAAkB,EAClBe,sBAAsB,EACtBhD,eAAgB,IAAM,KACtBE,SAAU,IAAM,KAChBC,SAAU,IAAM,KAChBC,kBAAmB,IAAM,KACzBC,cAAe,IAAM,KACrBC,QAAS,IAAM,KACfC,OAAQ,IAAM,KACdC,UAAW,IAAM,MAErB5f,KAAKqiB,wBAAyB,EAC9BriB,KAAKgL,oBAAsB,KAC3BhL,KAAKsiB,WAAWjiB,GAChBL,KAAKuiB,yBACLviB,KAAKwiB,uBACLxiB,KAAKyiB,eACLziB,KAAKqf,GAAG,eAAgBrf,KAAKK,QAAQ+e,gBACrCpf,KAAK4hB,KAAK,eAAgB,CAAE3f,OAAQjC,OACpCA,KAAK0iB,aACL1iB,KAAKiiB,YACLjiB,KAAKqf,GAAG,SAAUrf,KAAKK,QAAQif,UAC/Btf,KAAKqf,GAAG,SAAUrf,KAAKK,QAAQkf,UAC/Bvf,KAAKqf,GAAG,kBAAmBrf,KAAKK,QAAQmf,mBACxCxf,KAAKqf,GAAG,cAAerf,KAAKK,QAAQof,eACpCzf,KAAKqf,GAAG,QAASrf,KAAKK,QAAQqf,SAC9B1f,KAAKqf,GAAG,OAAQrf,KAAKK,QAAQsf,QAC7B3f,KAAKqf,GAAG,UAAWrf,KAAKK,QAAQuf,WAChCjd,OAAO4X,YAAW,KACVva,KAAKyC,cAGTzC,KAAKnE,SAASuL,MAAMpH,KAAKK,QAAQ6hB,WACjCliB,KAAK4hB,KAAK,SAAU,CAAE3f,OAAQjC,UAC/B,GAKHO,cACA,OAAOP,KAAKmf,iBAKZtjB,eACA,OAAOmE,KAAK2iB,eAAe9mB,SAK/B2S,QACI,OAAOxO,KAAK2iB,eAAenU,QAK/BlV,MACI,OAAO0G,KAAK2iB,eAAerpB,MAK/B2oB,YACQjiB,KAAKK,QAAQ4hB,WAAatb,WAC1B3G,KAAK4iB,IAxgCjB,SAAwBtF,GACpB,MAAMuF,EAAiBlc,SAASmc,cAAc,4BAC9C,GAAuB,OAAnBD,EACA,OAAOA,EAEX,MAAME,EAAYpc,SAASgS,cAAc,SAIzC,OAHAoK,EAAUC,aAAa,oBAAqB,IAC5CD,EAAUlK,UAAYyE,EACtB3W,SAASsc,qBAAqB,QAAQ,GAAGrK,YAAYmK,GAC9CA,EA+/BYG,CA5JT,08CAoKVZ,WAAWjiB,EAAU,IACjBL,KAAKK,QAAU,IACRL,KAAKK,WACLA,GAEFL,KAAK9L,MAAS8L,KAAKrM,QAASqM,KAAKyC,cAGlCzC,KAAKK,QAAQ8hB,aACbniB,KAAK9L,KAAKivB,SAASnjB,KAAKK,QAAQ8hB,aAEpCniB,KAAK9L,KAAKkvB,YAAYpjB,KAAKrM,QAK/B0vB,YAAYzO,GACR5U,KAAKsiB,WAAW,CAAE1N,SAAAA,IAKlBiD,iBAIA,OAAO7X,KAAKK,QAAQuU,UACb5U,KAAK9L,MACL8L,KAAK9L,KAAK0gB,SAKjBjhB,YACA,OAAOqM,KAAK9L,KAAKP,MAQrB2vB,eAAehQ,EAAQiQ,GACnB,MAAMlQ,EAAUhU,EAAWkkB,GACrBA,EAAcjQ,EAAQtT,KAAKrM,MAAM0f,SACjC,IAAIrT,KAAKrM,MAAM0f,QAASC,GACxB3f,EAAQqM,KAAKrM,MAAMyhB,YAAY,CAAE/B,QAAAA,IACvCrT,KAAK9L,KAAKkvB,YAAYzvB,GAO1B6vB,iBAAiBC,GACb,GAAIzjB,KAAKyC,YACL,OAEJ,MAAMxC,EAAkC,iBAApBwjB,EACd,GAAGA,KAEHA,EAAgBrnB,IAChBzI,EAAQqM,KAAKrM,MAAMyhB,YAAY,CAEjC/B,QAASrT,KAAKrM,MAAM0f,QAAQzR,QAAO0R,IAAWA,EAAOlX,IAAI4M,WAAW/I,OAExED,KAAK9L,KAAKkvB,YAAYzvB,GAK1B4uB,yBACI,MAGMmB,EAAgB,IAHC1jB,KAAKK,QAAQ+hB,qBAC9B5jB,OAAOmlB,OAAOxS,IACd,MACuCnR,KAAKK,QAAQ8Q,YAAYvP,QAAOjC,GAClE,CAAC,YAAa,OAAQ,QAAQ8G,SAAS9G,MAAAA,OAA6C,EAASA,EAAU7K,QAElHkL,KAAKiQ,iBAAmB,IAAIiP,GAAiBwE,EAAe1jB,MAKhEwiB,uBACIxiB,KAAK2iB,eAAiB,IAAIrN,GAAe,CACrCrT,OAAQjC,OAMhByiB,eACIziB,KAAKwB,OAASxB,KAAKiQ,iBAAiBzO,OAKxCkhB,aACI,MAAMntB,EAAMkY,GAAezN,KAAKK,QAAQlL,QAAS6K,KAAKwB,OAAQxB,KAAKK,QAAQgI,cACrExU,EAAYgT,GAAqBtR,EAAKyK,KAAKK,QAAQ6hB,WACzDliB,KAAK9L,KAAO,IAAI,KAAW8L,KAAKK,QAAQ2hB,QAAS,IAC1ChiB,KAAKK,QAAQ8hB,YAChByB,oBAAqB5jB,KAAK4jB,oBAAoBnkB,KAAKO,MACnDrM,MAAO,YAAmB,CACtB4B,IAAAA,EACA1B,UAAAA,MAKR,MAAMujB,EAAWpX,KAAKrM,MAAMyhB,YAAY,CACpC/B,QAASrT,KAAKiQ,iBAAiBoD,UAEnCrT,KAAK9L,KAAKkvB,YAAYhM,GACtBpX,KAAK6jB,kBAGO7jB,KAAK9L,KAAKwO,IAClBT,OAASjC,KAKjB6jB,kBACI7jB,KAAK9L,KAAKivB,SAAS,CACf5B,UAAWvhB,KAAKiQ,iBAAiBsR,YAGzCtW,mBAAmBtH,GACf3D,KAAKqiB,wBAAyB,EAC9B1e,IACA3D,KAAKqiB,wBAAyB,EAC9B,MAAMtuB,EAAKiM,KAAKgL,oBAEhB,OADAhL,KAAKgL,oBAAsB,KACpBjX,EAOX6vB,oBAAoB5O,GAChB,GAAIhV,KAAKqiB,uBACL,OAAKriB,KAAKgL,yBAIVgK,EAAY3L,MAAMlK,SAAQvJ,IAAU,IAAIsL,EAAI,OAA2C,QAAnCA,EAAKlB,KAAKgL,2BAAwC,IAAP9J,OAAgB,EAASA,EAAGtL,KAAKA,WAH5HoK,KAAKgL,oBAAsBgK,GAMnC,MAAMrhB,EAAQqM,KAAKrM,MAAMuhB,MAAMF,GACzB8O,GAAuB9jB,KAAKrM,MAAME,UAAU2T,GAAG7T,EAAME,WAC3DmM,KAAK9L,KAAKkvB,YAAYzvB,GACtBqM,KAAK4hB,KAAK,cAAe,CACrB3f,OAAQjC,KACRgV,YAAAA,IAEA8O,GACA9jB,KAAK4hB,KAAK,kBAAmB,CACzB3f,OAAQjC,KACRgV,YAAAA,IAGR,MAAM5N,EAAQ4N,EAAYa,QAAQ,SAC5BtT,EAAOyS,EAAYa,QAAQ,QAC7BzO,GACApH,KAAK4hB,KAAK,QAAS,CACf3f,OAAQjC,KACRwK,MAAOpD,EAAMoD,MACbwK,YAAAA,IAGJzS,GACAvC,KAAK4hB,KAAK,OAAQ,CACd3f,OAAQjC,KACRwK,MAAOjI,EAAKiI,MACZwK,YAAAA,IAGHA,EAAYsC,aAActC,EAAYa,QAAQ,kBAGnD7V,KAAK4hB,KAAK,SAAU,CAChB3f,OAAQjC,KACRgV,YAAAA,IAMRkD,cAAcpU,GACV,OAAOoU,GAAclY,KAAKrM,MAAOmQ,GAErCqU,SAAS4L,EAAkBC,GACvB,MAAM/jB,EAAmC,iBAArB8jB,EACdA,EACA,KACA5e,EAAyC,iBAArB4e,EACpBC,EACAD,EACN,OAAO5L,GAASnY,KAAKrM,MAAOsM,EAAMkF,GAKtC8e,UACI,OAAOjkB,KAAKrM,MAAM4B,IAAI8f,SAK1B6O,UACI,OAAO9L,GAAoBpY,KAAKrM,MAAM4B,IAAIJ,QAAS6K,KAAKwB,QAK5DsX,QAAQzY,GACJ,MAAM,eAAES,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GACtE,OAAOyY,GAAQ9Y,KAAKrM,MAAM4B,IAAK,CAC3BuL,eAAAA,EACAC,gBAAiB,IACVA,KACAQ,EAA4BvB,KAAKwB,WAO5CkW,cACA,OAAOqB,GAAY/Y,KAAKrM,MAAM4B,KAOlC4uB,oBAEI,OADAhkB,QAAQC,KAAK,+HACNJ,KAAKrM,MAAM4B,IAAIJ,QAAQC,KAAO,EAKzComB,UACIxb,KAAK4hB,KAAK,WACN5hB,KAAK9L,MACL8L,KAAK9L,KAAKsnB,UAEdxb,KAAK8hB,qBAKLrf,kBACA,IAAIvB,EAEJ,QAA8B,QAApBA,EAAKlB,KAAK9L,YAAyB,IAAPgN,OAAgB,EAASA,EAAGkjB,UAI1E,MAAMC,GACFxlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,OACZkL,KAAKC,KAAO,OACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIukB,GAAKvkB,GAEpBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAI0kB,GAAK1jB,GAgB3B,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,MAAM2kB,GACFzlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,OACZkL,KAAKC,KAAO,OACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIwkB,GAAKxkB,GAEpBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAI2kB,GAAK3jB,GAgB3B,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,MAAM4kB,GACF1lB,YAAY2lB,EAAWhlB,EAAOa,GAC1BL,KAAKykB,YAAa,EAClBzkB,KAAKwkB,UAAYA,EACjBxkB,KAAKiC,OAASzC,EAAMyC,OACpBjC,KAAKK,QAAU,CACXqkB,UAAW,KACXC,eAAgB,QACbtkB,GAEPL,KAAKL,UAAYH,EAAMG,UACvBK,KAAK1J,KAAOkJ,EAAMlJ,KAClB0J,KAAK0hB,YAAcliB,EAAMkiB,YACzB1hB,KAAKyhB,OAASjiB,EAAMiiB,OACpBzhB,KAAK4kB,QAETA,SAIIliB,UACA,OAAO,KAEPmiB,iBACA,OAAO,KAEXC,YAAYta,GACR,IAAItJ,EAAI6jB,EAAIC,EACZ,MAAM,KAAE9wB,GAAS8L,KAAKiC,OAChBvN,EAAS8V,EAAM9V,OAGfuwB,EAAiC,IAApBvwB,EAAO6G,SACY,QAA/B2F,EAAKxM,EAAO2mB,qBAAkC,IAAPna,OAAgB,EAASA,EAAGgkB,QAAQ,sBAC5ExwB,EAAOwwB,QAAQ,sBACrB,IAAKllB,KAAK0C,MACyB,QAA1BqiB,EAAK/kB,KAAK6kB,kBAA+B,IAAPE,OAAgB,EAASA,EAAGzJ,SAAS5mB,MACxEuwB,EACJ,OAEJ,IAAIE,EAAI,EACJC,EAAI,EAER,GAAIplB,KAAK0C,MAAQuiB,EAAY,CACzB,MAAMI,EAASrlB,KAAK0C,IAAI4iB,wBAClBC,EAAYN,EAAWK,wBAC7BH,EAAII,EAAUJ,EAAIE,EAAOF,EAAI3a,EAAMgb,QACnCJ,EAAIG,EAAUH,EAAIC,EAAOD,EAAI5a,EAAMib,QAET,QAA7BT,EAAKxa,EAAMkb,oBAAiC,IAAPV,GAAyBA,EAAGW,aAAa3lB,KAAK0C,IAAKyiB,EAAGC,GAG5F,MAAMvxB,EAAY,YAAqBK,EAAKP,MAAM4B,IAAKyK,KAAKyhB,UACtDzM,EAAc9gB,EAAKP,MAAMI,GAAG8B,aAAahC,GAC/CK,EAAKN,SAASohB,GAElB0P,UAAUla,GACN,IAAItJ,EACJ,IAAKlB,KAAK0C,IACN,OAAO,EAEX,GAAsC,mBAA3B1C,KAAKK,QAAQqkB,UACpB,OAAO1kB,KAAKK,QAAQqkB,UAAU,CAAEla,MAAAA,IAEpC,MAAM9V,EAAS8V,EAAM9V,OAGrB,KAFoBsL,KAAK0C,IAAI4Y,SAAS5mB,MAAwC,QAA1BwM,EAAKlB,KAAK6kB,kBAA+B,IAAP3jB,OAAgB,EAASA,EAAGoa,SAAS5mB,KAGvH,OAAO,EAEX,MAAMkxB,EAA6B,SAAfpb,EAAM1V,KAI1B,IAHgB,CAAC,QAAS,SAAU,SAAU,YAAY2R,SAAS/R,EAAOmxB,UACnEnxB,EAAOoxB,qBAEEF,EACZ,OAAO,EAEX,MAAM,WAAE/N,GAAe7X,KAAKiC,QACtB,WAAEwiB,GAAezkB,KACjB+lB,IAAgB/lB,KAAK1J,KAAKxB,KAAKC,KAAKspB,UACpC2H,EAAe,kBAA2BhmB,KAAK1J,MAC/C2vB,EAA6B,SAAfzb,EAAM1V,KACpBoxB,EAA8B,UAAf1b,EAAM1V,KACrBqxB,EAA4B,QAAf3b,EAAM1V,KACnBsxB,EAA8B,cAAf5b,EAAM1V,KACrBuxB,EAAc7b,EAAM1V,KAAKkU,WAAW,QAO1C,IAHK+c,GAAeC,GAAgBK,GAChC7b,EAAM8b,iBAENP,GAAeM,IAAgB5B,EAE/B,OADAja,EAAM8b,kBACC,EAGX,GAAIP,GAAelO,IAAe4M,GAAc2B,EAAc,CAC1D,MAAMnB,EAAavwB,EAAOwwB,QAAQ,sBACRD,IAClBjlB,KAAK0C,MAAQuiB,GAAejlB,KAAK0C,IAAI4Y,SAAS2J,MAElDjlB,KAAKykB,YAAa,EAClB9d,SAAS4U,iBAAiB,WAAW,KACjCvb,KAAKykB,YAAa,IACnB,CAAE8B,MAAM,IACX5f,SAAS4U,iBAAiB,WAAW,KACjCvb,KAAKykB,YAAa,IACnB,CAAE8B,MAAM,KAInB,QAAI9B,GACGmB,GACAK,GACAC,GACAC,GACCC,GAAgBJ,GAK5BrB,eAAe6B,GACX,IAAKxmB,KAAK0C,MAAQ1C,KAAK6kB,WACnB,OAAO,EAEX,GAA2C,mBAAhC7kB,KAAKK,QAAQskB,eACpB,OAAO3kB,KAAKK,QAAQskB,eAAe,CAAE6B,SAAAA,IAIzC,GAAIxmB,KAAK1J,KAAKmwB,QAAUzmB,KAAK1J,KAAKH,OAC9B,OAAO,EAGX,GAAsB,cAAlBqwB,EAAS1xB,KACT,OAAO,EAMX,GAAIkL,KAAK0C,IAAI4Y,SAASkL,EAAS9xB,SACN,cAAlB8xB,EAAS1xB,MACT0R,MACAxG,KAAKiC,OAAO8S,UAAW,CAO1B,GANqB,IACd5O,MAAMxQ,KAAK6wB,EAASE,eACpBvgB,MAAMxQ,KAAK6wB,EAASG,eAIV1hB,OAAM3O,GAAQA,EAAKwvB,oBAChC,OAAO,EAKf,OAAI9lB,KAAK6kB,aAAe2B,EAAS9xB,QAA4B,eAAlB8xB,EAAS1xB,OAIhDkL,KAAK6kB,WAAWvJ,SAASkL,EAAS9xB,QAK1C2f,iBAAiBlP,GACbnF,KAAKiC,OAAOpG,SAAS6H,SAAQ,EAAG3P,GAAAA,MAC5B,MAAMkC,EAAM+J,KAAKyhB,SAKjB,OAJA1tB,EAAG0F,cAAcxD,OAAK4J,EAAW,IAC1BG,KAAK1J,KAAKkF,SACV2J,KAEA,KAGflB,aACI,MAAMtO,EAAOqK,KAAKyhB,SACZ/rB,EAAKC,EAAOqK,KAAK1J,KAAKJ,SAC5B8J,KAAKiC,OAAOpG,SAASuI,YAAY,CAAEzO,KAAAA,EAAMD,GAAAA,KAIjD,MAAMkxB,GACF/nB,YAAYmW,GACRhV,KAAKgV,YAAcA,EACnBhV,KAAK6mB,YAAc7mB,KAAKgV,YAAY3L,MAAMhP,OAE9CrE,IAAI8Q,GACA,IAAIggB,GAAU,EAYd,MAAO,CACHhgB,SAZmB9G,KAAKgV,YAAY3L,MACnC5T,MAAMuK,KAAK6mB,aACXjb,QAAO,CAACmb,EAAanxB,KACtB,MAAMoxB,EAAYpxB,EACbqxB,SACAD,UAAUD,GAIf,OAHIC,EAAUF,UACVA,GAAU,GAEPE,EAAU/wB,MAClB6Q,GAGCggB,QAAAA,IASZ,SAASI,GAAcpnB,GACnB,OAAO,IAAIqZ,GAAU,CACjB/T,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOoY,mBAAerY,EAAWhI,IAAU,IACrE,GAAE9D,GAAOJ,EACTwH,EAAQ3G,EAAMmB,KACpB,IAAIoD,EAAMvE,EAAMkB,GAChB,GAAImC,EAAM,GAAI,CAEV,IAAIsvB,EAAahsB,EADFtD,EAAM,GAAGuvB,YAAYvvB,EAAM,IAEtCsvB,EAAapuB,EACbouB,EAAapuB,EAGbA,EAAMouB,EAAatvB,EAAM,GAAGwC,OAGhC,MAAMgtB,EAAWxvB,EAAM,GAAGA,EAAM,GAAGwC,OAAS,GAC5CtG,EAAG4D,WAAW0vB,EAAUlsB,EAAQtD,EAAM,GAAGwC,OAAS,GAElDtG,EAAGuE,YAAY6uB,EAAYpuB,EAAK+G,EAAOhL,KAAKwF,OAAO6K,SAE9CtN,EAAM,IACX9D,EAAGuE,YAAY6C,EAAOpC,EAAK+G,EAAOhL,KAAKwF,OAAO6K,OAM9D,SAASmiB,GAAgB3xB,EAAMD,EAAIH,GAC/B,MAAMoP,EAAQ,GA2Bd,OAzBIhP,IAASD,EACTH,EACKO,QAAQH,GACRgP,QACAxF,SAAQqG,IACT,MACMhR,EAAQ8Q,GADD/P,EAAIO,QAAQH,EAAO,GACC6P,EAAK1Q,MACjCN,GAGLmQ,EAAM/J,KAAK,CACP4K,KAAAA,KACGhR,OAKXe,EAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KAC9B0O,EAAM/J,QAAQtE,EAAKqO,MAAM3O,KAAIwP,IAAQ,CACjC7P,KAAMM,EACNP,GAAIO,EAAMK,EAAKJ,SACfsP,KAAAA,UAILb,EAOX,SAAS4iB,GAAcznB,GACnB,OAAO,IAAIqZ,GAAU,CACjB/T,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOoY,mBAAerY,EAAWhI,GACjE,IAAmB,IAAfsN,GAAuC,OAAfA,EACxB,OAAO,KAEX,MAAM,GAAEpR,GAAOJ,EACT6zB,EAAe3vB,EAAMA,EAAMwC,OAAS,GACpCotB,EAAY5vB,EAAM,GACxB,IAAI6vB,EAAUlzB,EAAMkB,GACpB,GAAI8xB,EAAc,CACd,MAAMG,EAAcF,EAAUG,OAAO,MAC/BC,EAAYrzB,EAAMmB,KAAO8xB,EAAUtH,QAAQqH,GAC3CM,EAAUD,EAAYL,EAAantB,OAQzC,GAPsBitB,GAAgB9yB,EAAMmB,KAAMnB,EAAMkB,GAAI/B,EAAM4B,KAC7DqM,QAAO3D,GAESA,EAAKuH,KAAK1Q,KAAKizB,SAChB3iB,MAAKtQ,GAAQA,IAASgL,EAAOhL,MAAQA,IAASmJ,EAAKuH,KAAK1Q,SAEvE8M,QAAO3D,GAAQA,EAAKvI,GAAKmyB,IACZxtB,OACd,OAAO,KAEPytB,EAAUtzB,EAAMkB,IAChB3B,EAAGsC,OAAOyxB,EAAStzB,EAAMkB,IAEzBmyB,EAAYrzB,EAAMmB,MAClB5B,EAAGsC,OAAO7B,EAAMmB,KAAOgyB,EAAaE,GAExCH,EAAUlzB,EAAMmB,KAAOgyB,EAAcH,EAAantB,OAClDtG,EAAG6Y,QAAQpY,EAAMmB,KAAOgyB,EAAaD,EAAS5nB,EAAOhL,KAAKwF,OAAO6K,GAAc,KAC/EpR,EAAGogB,iBAAiBrU,EAAOhL,UAY3C,SAASkzB,GAAuBloB,GAC5B,OAAO,IAAIqZ,GAAU,CACjB/T,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMmG,EAASrK,EAAM4B,IAAIO,QAAQtB,EAAMmB,MACjCwP,EAAa7F,EAAaQ,EAAOoY,mBAAerY,EAAWhI,IAAU,GAC3E,IAAKmG,EAAO1H,MAAM,GAAG+B,eAAe2F,EAAO9G,OAAO,GAAI8G,EAAO7F,YAAY,GAAI2H,EAAOhL,MAChF,OAAO,KAEXnB,EAAMI,GACDsC,OAAO7B,EAAMmB,KAAMnB,EAAMkB,IACzB4F,aAAa9G,EAAMmB,KAAMnB,EAAMmB,KAAMmK,EAAOhL,KAAMqQ,MASnE,SAAS8iB,GAAcnoB,GACnB,OAAO,IAAIqZ,GAAU,CACjB/T,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,IAAIgB,EAASiH,EAAO8Q,QAChBzV,EAAQ3G,EAAMmB,KAClB,MAAMoD,EAAMvE,EAAMkB,GAClB,GAAImC,EAAM,GAAI,CACV,MAAM6N,EAAS7N,EAAM,GAAGuvB,YAAYvvB,EAAM,IAC1CgB,GAAUhB,EAAM,GAAGpC,MAAMiQ,EAAS7N,EAAM,GAAGwC,QAC3Cc,GAASuK,EACT,MAAMwiB,EAAS/sB,EAAQpC,EACnBmvB,EAAS,IACTrvB,EAAShB,EAAM,GAAGpC,MAAMiQ,EAASwiB,EAAQxiB,GAAU7M,EACnDsC,EAAQpC,GAGhBpF,EAAMI,GAAG4D,WAAWkB,EAAQsC,EAAOpC,MAmB/C,SAASovB,GAAkBroB,GACvB,OAAO,IAAIqZ,GAAU,CACjB/T,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOoY,mBAAerY,EAAWhI,IAAU,GACrE9D,EAAKJ,EAAMI,GAAGsC,OAAO7B,EAAMmB,KAAMnB,EAAMkB,IAEvCjB,EADSV,EAAGwB,IAAIO,QAAQtB,EAAMmB,MACVlB,aACpB8f,EAAW9f,IAAc,QAAaA,EAAYqL,EAAOhL,KAAMqQ,GACrE,IAAKoP,EACD,OAAO,KAEXxgB,EAAGqG,KAAK3F,EAAY8f,GACpB,MAAM3f,EAASb,EAAGwB,IAAIO,QAAQtB,EAAMmB,KAAO,GAAGd,WAC1CD,GACGA,EAAOE,OAASgL,EAAOhL,OACvB,QAAQf,EAAGwB,IAAKf,EAAMmB,KAAO,MAC3BmK,EAAOsoB,eAAiBtoB,EAAOsoB,cAAcvwB,EAAOjD,KACzDb,EAAG+F,KAAKtF,EAAMmB,KAAO,MAUrC,SAAS0yB,GAAcvoB,GACnB,OAAO,IAAI2a,GAAU,CACjBrV,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOoY,mBAAerY,EAAWhI,GACjE,IAAmB,IAAfsN,GAAuC,OAAfA,EACxB,OAAO,KAEX,MAAM,GAAEpR,GAAOJ,EACT6zB,EAAe3vB,EAAMA,EAAMwC,OAAS,GACpCotB,EAAY5vB,EAAM,GACxB,IAAI6vB,EAAUlzB,EAAMkB,GACpB,GAAI8xB,EAAc,CACd,MAAMG,EAAcF,EAAUG,OAAO,MAC/BC,EAAYrzB,EAAMmB,KAAO8xB,EAAUtH,QAAQqH,GAC3CM,EAAUD,EAAYL,EAAantB,OAQzC,GAPsBitB,GAAgB9yB,EAAMmB,KAAMnB,EAAMkB,GAAI/B,EAAM4B,KAC7DqM,QAAO3D,GAESA,EAAKuH,KAAK1Q,KAAKizB,SAChB3iB,MAAKtQ,GAAQA,IAASgL,EAAOhL,MAAQA,IAASmJ,EAAKuH,KAAK1Q,SAEvE8M,QAAO3D,GAAQA,EAAKvI,GAAKmyB,IACZxtB,OACd,OAAO,KAEPytB,EAAUtzB,EAAMkB,IAChB3B,EAAGsC,OAAOyxB,EAAStzB,EAAMkB,IAEzBmyB,EAAYrzB,EAAMmB,MAClB5B,EAAGsC,OAAO7B,EAAMmB,KAAOgyB,EAAaE,GAExCH,EAAUlzB,EAAMmB,KAAOgyB,EAAcH,EAAantB,OAClDtG,EAAG6Y,QAAQpY,EAAMmB,KAAOgyB,EAAaD,EAAS5nB,EAAOhL,KAAKwF,OAAO6K,GAAc,KAC/EpR,EAAGogB,iBAAiBrU,EAAOhL,UAU3C,SAASwzB,GAAcxoB,GACnB,OAAO,IAAI2a,GAAU,CACjBrV,KAAMtF,EAAOsF,KACbgU,QAAS,EAAGzlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,IAAIgB,EAASiH,EAAO8Q,QAChBzV,EAAQ3G,EAAMmB,KAClB,MAAMoD,EAAMvE,EAAMkB,GAClB,GAAImC,EAAM,GAAI,CACV,MAAM6N,EAAS7N,EAAM,GAAGuvB,YAAYvvB,EAAM,IAC1CgB,GAAUhB,EAAM,GAAGpC,MAAMiQ,EAAS7N,EAAM,GAAGwC,QAC3Cc,GAASuK,EACT,MAAMwiB,EAAS/sB,EAAQpC,EACnBmvB,EAAS,IACTrvB,EAAShB,EAAM,GAAGpC,MAAMiQ,EAASwiB,EAAQxiB,GAAU7M,EACnDsC,EAAQpC,GAGhBpF,EAAMI,GAAG4D,WAAWkB,EAAQsC,EAAOpC,MAM/C,SAASwvB,GAAeC,GACpB,OAAOA,EAAO5X,QAAQ,wBAAyB,QAMnD,SAAS6X,GAAwBC,EAAQxR,GACrC,MAAMvD,EAAY,IAAI,KAAU+U,GAMhC,OALAxR,EAAa/X,SAAQ6V,IACjBA,EAAY3L,MAAMlK,SAAQvJ,IACtB+d,EAAU/d,KAAKA,SAGhB+d,EAGX,SAAS,GAAe9b,GACpB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,GAAK,EAAG,CACzC,MAAM,KAAEnC,GAAS+C,EAAME,KAAKd,GAC5B,GAAInC,EAAK6B,cAAgB7B,EAAKkD,mBAC1B,OAAOlD,EAGf,OAAO,KAGX,SAAS6zB,GAAaryB,EAAM0a,GACxB,MAAM4X,EAAe,GASrB,OARAtyB,EAAKuyB,aAAY,CAACprB,EAAOxH,KACjB+a,EAAUvT,IACVmrB,EAAahuB,KAAK,CACdtE,KAAMmH,EACNxH,IAAAA,OAIL2yB,EAMX,SAASE,GAAoBxyB,EAAM9B,EAAOwc,GACtC,MAAM4X,EAAe,GAkBrB,OARAtyB,EAAKoF,aAAalH,EAAMmB,KAAMnB,EAAMkB,IAAI,CAAC+H,EAAOxH,KACxC+a,EAAUvT,IACVmrB,EAAahuB,KAAK,CACdtE,KAAMmH,EACNxH,IAAAA,OAIL2yB,EAGX,SAASG,GAAU5X,GAEf,OAAO0M,GADoBqB,GAAiBppB,QAAQqb,IAIxD,SAAS6X,GAAazzB,EAAK4b,GACvB,MAAM3P,EAASunB,GAAU5X,GAEzB,OAAOiH,GADa,cAAgB5W,EAAQjM,GACLJ,QAASqM,GAGpD,SAASynB,GAAarN,EAAMzK,GACxB,MAAM3P,EAASunB,GAAU5X,GACnBzO,EAAMqF,GAAkB6T,GAC9B,OAAO,gBAAqBpa,GACvBkH,MAAMhG,GACN2S,SAGT,SAAS6T,GAAa3zB,EAAK4b,EAAY9Q,GACnC,MAAM,eAAES,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GAChEmB,EAASunB,GAAU5X,GAEzB,OAAO2H,GADa,cAAgBtX,EAAQjM,GAChB,CACxBuL,eAAAA,EACAC,gBAAiB,IACVA,KACAQ,EAA4BC,MAuB3C,SAAS2nB,GAAsBC,GAC3B,MAAMC,EAfV,SAA0BC,EAAOC,EAAKtQ,KAAKC,WACvC,MAAMsQ,EAAO,GACb,OAAOF,EAAM1nB,QAAO3D,IAChB,MAAM7B,EAAMmtB,EAAGtrB,GACf,OAAOO,OAAOC,UAAUgrB,eAAe9qB,KAAK6qB,EAAMptB,KAE3CotB,EAAKptB,IAAO,MASDstB,CAAiBN,GACvC,OAAgC,IAAzBC,EAAchvB,OACfgvB,EACAA,EAAcznB,QAAO,CAAC+nB,EAAQzyB,KACfmyB,EAAcznB,QAAO,CAACgoB,EAAG3yB,IAAMA,IAAMC,IACrCmgB,MAAKwS,GACPF,EAAOG,SAASn0B,MAAQk0B,EAAYC,SAASn0B,MAC7Cg0B,EAAOG,SAASp0B,IAAMm0B,EAAYC,SAASp0B,IAC3Ci0B,EAAOI,SAASp0B,MAAQk0B,EAAYE,SAASp0B,MAC7Cg0B,EAAOI,SAASr0B,IAAMm0B,EAAYE,SAASr0B,OAQlE,SAASs0B,GAAiBrW,GACtB,MAAM,QAAE5d,EAAO,MAAEsT,GAAUsK,EACrByV,EAAU,GAmChB,OAlCArzB,EAAQuT,KAAKnK,SAAQ,CAAC8qB,EAAS/yB,KAC3B,MAAMgL,EAAS,GAIf,GAAK+nB,EAAQ/nB,OAAO7H,OAQhB4vB,EAAQ9qB,SAAQ,CAACxJ,EAAMD,KACnBwM,EAAOtH,KAAK,CAAEjF,KAAAA,EAAMD,GAAAA,WATA,CACxB,MAAM,KAAEC,EAAI,GAAED,GAAO2T,EAAMnS,GAC3B,QAAa2I,IAATlK,QAA6BkK,IAAPnK,EACtB,OAEJwM,EAAOtH,KAAK,CAAEjF,KAAAA,EAAMD,GAAAA,IAOxBwM,EAAO/C,SAAQ,EAAGxJ,KAAAA,EAAMD,GAAAA,MACpB,MAAMw0B,EAAWn0B,EAAQN,MAAMyB,GAAOlB,IAAIL,GAAO,GAC3Cw0B,EAASp0B,EAAQN,MAAMyB,GAAOlB,IAAIN,GAClC00B,EAAWr0B,EAAQ8d,SAAS7d,IAAIk0B,GAAW,GAC3CG,EAASt0B,EAAQ8d,SAAS7d,IAAIm0B,GACpCf,EAAQxuB,KAAK,CACTkvB,SAAU,CACNn0B,KAAMy0B,EACN10B,GAAI20B,GAERN,SAAU,CACNp0B,KAAMu0B,EACNx0B,GAAIy0B,WAKbhB,GAAsBC,GAGjC,SAASkB,GAAah0B,EAAMi0B,EAAc,GACtC,MACMC,EADYl0B,EAAKxB,OAASwB,EAAKxB,KAAK0M,OAAOipB,YACnB,EAAI,EAC5B90B,EAAO40B,EACP70B,EAAKC,EAAOW,EAAKJ,SACjByO,EAAQrO,EAAKqO,MAAM3O,KAAIwP,IACzB,MAAMvG,EAAS,CACXnK,KAAM0Q,EAAK1Q,KAAKmL,MAKpB,OAHIzB,OAAOU,KAAKsG,EAAKhK,OAAOnB,SACxB4E,EAAOzD,MAAQ,IAAKgK,EAAKhK,QAEtByD,KAELzD,EAAQ,IAAKlF,EAAKkF,OAClByD,EAAS,CACXnK,KAAMwB,EAAKxB,KAAKmL,KAChBtK,KAAAA,EACAD,GAAAA,GAkBJ,OAhBI8I,OAAOU,KAAK1D,GAAOnB,SACnB4E,EAAOzD,MAAQA,GAEfmJ,EAAMtK,SACN4E,EAAO0F,MAAQA,GAEfrO,EAAKnB,QAAQyB,aACbqI,EAAO9J,QAAU,GACjBmB,EAAK6I,SAAQ,CAAC1B,EAAOiI,KACjB,IAAIxE,EACsB,QAAzBA,EAAKjC,EAAO9J,eAA4B,IAAP+L,GAAyBA,EAAGtG,KAAK0vB,GAAa7sB,EAAO8sB,EAAc7kB,EAAS8kB,QAGlHl0B,EAAK0K,OACL/B,EAAO+B,KAAO1K,EAAK0K,MAEhB/B,EAGX,SAASyrB,GAAgBnsB,GACrB,OAAO2H,GAAS3H,IAAUA,aAAiB,KAG/C,SAASosB,GAAaz2B,EAAMyB,EAAMD,GAC9B,MACMwR,EAAShT,EAAKP,MAAM4B,IAAIJ,QAAQC,KAChC2Z,EAAenI,GAAOjR,EAFb,EAE2BuR,GACpC8H,EAAcpI,GAAOlR,EAHZ,EAGwBwR,GACjC/L,EAAQjH,EAAK02B,YAAY7b,GACzBhW,EAAM7E,EAAK02B,YAAY5b,GAAc,GACrC6b,EAAMxpB,KAAKc,IAAIhH,EAAM0vB,IAAK9xB,EAAI8xB,KAC9BC,EAASzpB,KAAKC,IAAInG,EAAM2vB,OAAQ/xB,EAAI+xB,QACpCC,EAAO1pB,KAAKc,IAAIhH,EAAM4vB,KAAMhyB,EAAIgyB,MAChCC,EAAQ3pB,KAAKC,IAAInG,EAAM6vB,MAAOjyB,EAAIiyB,OAKlClR,EAAO,CACT+Q,IAAAA,EACAC,OAAAA,EACAC,KAAAA,EACAC,MAAAA,EACAC,MATUD,EAAQD,EAUlBG,OATWJ,EAASD,EAUpB1F,EATM4F,EAUN3F,EATMyF,GAWV,MAAO,IACA/Q,EACHzE,OAAQ,IAAMyE,K,6EC9tItB,IA5FO,IAAIqR,EAAO,CAChB,EAAG,YACH,EAAG,MACH,GAAI,QACJ,GAAI,UACJ,GAAI,QACJ,GAAI,QACJ,GAAI,UACJ,GAAI,MACJ,GAAI,WACJ,GAAI,SACJ,GAAI,IACJ,GAAI,SACJ,GAAI,WACJ,GAAI,MACJ,GAAI,OACJ,GAAI,YACJ,GAAI,UACJ,GAAI,aACJ,GAAI,YACJ,GAAI,cACJ,GAAI,SACJ,GAAI,SACJ,GAAI,IACJ,GAAI,IACJ,GAAI,OACJ,GAAI,OACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,UACL,IAAK,aACL,IAAK,QACL,IAAK,QACL,IAAK,UACL,IAAK,UACL,IAAK,MACL,IAAK,MACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,IACL,IAAK,IACL,IAAK,KAGIhhB,EAAQ,CACjB,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KAGHihB,EAA6B,oBAAb7uB,WAA4B,gBAAgBod,KAAKpd,UAAUmK,WAC3E2kB,EAA6B,oBAAb9uB,WAA4B,iBAAiBC,KAAKD,UAAU+uB,QAC5EC,EAA4B,oBAAbhvB,WAA4B,aAAaC,KAAKD,UAAUmK,WACvE8kB,EAA0B,oBAAbjvB,WAA4B,MAAMC,KAAKD,UAAUE,UAC9DgvB,EAAyB,oBAAblvB,WAA4B,gDAAgDod,KAAKpd,UAAUmK,WACvGglB,EAAsBN,IAAWI,IAAQJ,EAAO,GAAK,KAAOG,GAASC,EAGhEv0B,EAAI,EAAGA,EAAI,GAAIA,IAAKk0B,EAAK,GAAKl0B,GAAKk0B,EAAK,GAAKl0B,GAAK00B,OAAO10B,GAGlE,IAASA,EAAI,EAAGA,GAAK,GAAIA,IAAKk0B,EAAKl0B,EAAI,KAAO,IAAMA,EAGpD,IAASA,EAAI,GAAIA,GAAK,GAAIA,IACxBk0B,EAAKl0B,GAAK00B,OAAOC,aAAa30B,EAAI,IAClCkT,EAAMlT,GAAK00B,OAAOC,aAAa30B,GAIjC,IAAK,IAAIQ,KAAQ0zB,EAAWhhB,EAAMsf,eAAehyB,KAAO0S,EAAM1S,GAAQ0zB,EAAK1zB,I,eCnGvE,EAA0B,oBAAb8E,WAA2B,qBAAqBC,KAAKD,UAAUE,UAEhF,SAAS8N,EAAiBtK,GACxB,IAEIgK,EAAKC,EAAMC,EAAOC,EAFlBJ,EAAQ/J,EAAKjH,MAAM,UAAWqR,EAASL,EAAMA,EAAM3P,OAAS,GAClD,SAAVgQ,IAAqBA,EAAS,KAElC,IAAK,IAAIpT,EAAI,EAAGA,EAAI+S,EAAM3P,OAAS,EAAGpD,IAAK,CACzC,IAAIqT,EAAMN,EAAM/S,GAChB,GAAI,kBAAkBuF,KAAK8N,GAAQF,GAAO,OACrC,GAAI,YAAY5N,KAAK8N,GAAQL,GAAM,OACnC,GAAI,sBAAsBzN,KAAK8N,GAAQJ,GAAO,OAC9C,GAAI,cAAc1N,KAAK8N,GAAQH,GAAQ,MACvC,KAAI,SAAS3N,KAAK8N,GAChB,MAAM,IAAIvG,MAAM,+BAAiCuG,GADrB,EAAOF,GAAO,EAAeF,GAAO,GAOzE,OAJID,IAAOI,EAAS,OAASA,GACzBH,IAAQG,EAAS,QAAUA,GAC3BD,IAAQC,EAAS,QAAUA,GAC3BF,IAASE,EAAS,SAAWA,GAC1BA,EAST,SAASwhB,EAAU5rB,EAAMuK,EAAOL,GAK9B,OAJIK,EAAME,SAAUzK,EAAO,OAASA,GAChCuK,EAAMG,UAAW1K,EAAO,QAAUA,GAClCuK,EAAMI,UAAW3K,EAAO,QAAUA,IACxB,IAAVkK,GAAmBK,EAAMK,WAAY5K,EAAO,SAAWA,GACpDA,EAiCT,SAAS6rB,EAAOhL,GACd,OAAO,IAAI,KAAO,CAACthB,MAAO,CAACgb,cAAeuR,EAAejL,MAO3D,SAASiL,EAAejL,GACtB,IAAI9qB,EArDN,SAAmBA,GACjB,IAAIuE,EAAOiE,OAAOlE,OAAO,MACzB,IAAK,IAAIiS,KAAQvW,EAAOuE,EAAKgQ,EAAiBgC,IAASvW,EAAIuW,GAC3D,OAAOhS,EAkDGyxB,CAAUlL,GACpB,OAAO,SAAS5sB,EAAMsW,GACpB,IAAqEyhB,EAAjEhsB,EDwBD,SAAiBuK,GAGtB,IAEIvK,IAFYyrB,IAAwBlhB,EAAMG,SAAWH,EAAME,QAAUF,EAAMI,WAC5EygB,GAAUI,IAAOjhB,EAAMK,UAAYL,EAAMpO,KAA2B,GAApBoO,EAAMpO,IAAI/B,SACnCmQ,EAAMpO,MAC7BoO,EAAMK,SAAWV,EAAQghB,GAAM3gB,EAAM0hB,UACtC1hB,EAAMpO,KAAO,eASf,MAPY,OAAR6D,IAAeA,EAAO,UACd,OAARA,IAAeA,EAAO,UAEd,QAARA,IAAgBA,EAAO,aACf,MAARA,IAAcA,EAAO,WACb,SAARA,IAAiBA,EAAO,cAChB,QAARA,IAAgBA,EAAO,aACpBA,ECxCMksB,CAAQ3hB,GAAQ4hB,EAAwB,GAAfnsB,EAAK5F,QAAuB,KAAR4F,EACpDosB,EAASr2B,EAAI61B,EAAU5rB,EAAMuK,GAAQ4hB,IACzC,GAAIC,GAAUA,EAAOn4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,EAChE,GAAIk4B,IAAW5hB,EAAMK,UAAYL,EAAME,QAAUF,EAAMI,SAAW3K,EAAKqsB,WAAW,GAAK,OAClFL,EAAWd,EAAK3gB,EAAM0hB,WAAaD,GAAYhsB,EAAM,CAKxD,IAAIssB,EAAWv2B,EAAI61B,EAAUI,EAAUzhB,GAAO,IAC9C,GAAI+hB,GAAYA,EAASr4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,OAC/D,GAAIk4B,GAAU5hB,EAAMK,SAAU,CAGnC,IAAI2hB,EAAYx2B,EAAI61B,EAAU5rB,EAAMuK,GAAO,IAC3C,GAAIgiB,GAAaA,EAAUt4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,EAExE,OAAO,K,sBCjGX,SAASu4B,EAAWt3B,GAClB6K,KAAK7K,QAAUA,E,6PAGjBs3B,EAAWhuB,UAAY,CACrBI,YAAa4tB,EAEbrnB,KAAM,SAAShJ,GACb,IAAK,IAAInF,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,GAAK,EAC5C,GAAI+I,KAAK7K,QAAQ8B,KAAOmF,EAAK,OAAOnF,EACtC,OAAQ,GAMVy1B,IAAK,SAAStwB,GACZ,IAAIgB,EAAQ4C,KAAKoF,KAAKhJ,GACtB,OAAiB,GAAVgB,OAAcyC,EAAYG,KAAK7K,QAAQiI,EAAQ,IAOxDuvB,OAAQ,SAASvwB,EAAKmC,EAAOquB,GAC3B,IAAIC,EAAOD,GAAUA,GAAUxwB,EAAM4D,KAAK8sB,OAAOF,GAAU5sB,KACvD5C,EAAQyvB,EAAKznB,KAAKhJ,GAAMjH,EAAU03B,EAAK13B,QAAQM,QAOnD,OANc,GAAV2H,EACFjI,EAAQyF,KAAKgyB,GAAUxwB,EAAKmC,IAE5BpJ,EAAQiI,EAAQ,GAAKmB,EACjBquB,IAAQz3B,EAAQiI,GAASwvB,IAExB,IAAIH,EAAWt3B,IAKxB23B,OAAQ,SAAS1wB,GACf,IAAIgB,EAAQ4C,KAAKoF,KAAKhJ,GACtB,IAAc,GAAVgB,EAAa,OAAO4C,KACxB,IAAI7K,EAAU6K,KAAK7K,QAAQM,QAE3B,OADAN,EAAQ43B,OAAO3vB,EAAO,GACf,IAAIqvB,EAAWt3B,IAKxB63B,WAAY,SAAS5wB,EAAKmC,GACxB,OAAO,IAAIkuB,EAAW,CAACrwB,EAAKmC,GAAO0uB,OAAOjtB,KAAK8sB,OAAO1wB,GAAKjH,WAK7D+3B,SAAU,SAAS9wB,EAAKmC,GACtB,IAAIpJ,EAAU6K,KAAK8sB,OAAO1wB,GAAKjH,QAAQM,QAEvC,OADAN,EAAQyF,KAAKwB,EAAKmC,GACX,IAAIkuB,EAAWt3B,IAMxBg4B,UAAW,SAASC,EAAOhxB,EAAKmC,GAC9B,IAAI8uB,EAAUrtB,KAAK8sB,OAAO1wB,GAAMjH,EAAUk4B,EAAQl4B,QAAQM,QACtD2H,EAAQiwB,EAAQjoB,KAAKgoB,GAEzB,OADAj4B,EAAQ43B,QAAiB,GAAV3vB,EAAcjI,EAAQkF,OAAS+C,EAAO,EAAGhB,EAAKmC,GACtD,IAAIkuB,EAAWt3B,IAMxBgK,QAAS,SAASgM,GAChB,IAAK,IAAIlU,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,GAAK,EAC5CkU,EAAEnL,KAAK7K,QAAQ8B,GAAI+I,KAAK7K,QAAQ8B,EAAI,KAMxCq2B,QAAS,SAASt3B,GAEhB,OADAA,EAAMy2B,EAAW92B,KAAKK,IACbZ,KACF,IAAIq3B,EAAWz2B,EAAIb,QAAQ83B,OAAOjtB,KAAKutB,SAASv3B,GAAKb,UADtC6K,MAOxB5B,OAAQ,SAASpI,GAEf,OADAA,EAAMy2B,EAAW92B,KAAKK,IACbZ,KACF,IAAIq3B,EAAWzsB,KAAKutB,SAASv3B,GAAKb,QAAQ83B,OAAOj3B,EAAIb,UADtC6K,MAOxButB,SAAU,SAASv3B,GACjB,IAAIqU,EAASrK,KACbhK,EAAMy2B,EAAW92B,KAAKK,GACtB,IAAK,IAAIiB,EAAI,EAAGA,EAAIjB,EAAIb,QAAQkF,OAAQpD,GAAK,EAC3CoT,EAASA,EAAOyiB,OAAO92B,EAAIb,QAAQ8B,IACrC,OAAOoT,GAKLjV,WACF,OAAO4K,KAAK7K,QAAQkF,QAAU,IAQlCoyB,EAAW92B,KAAO,SAAS4I,GACzB,GAAIA,aAAiBkuB,EAAY,OAAOluB,EACxC,IAAIpJ,EAAU,GACd,GAAIoJ,EAAO,IAAK,IAAIgO,KAAQhO,EAAOpJ,EAAQyF,KAAK2R,EAAMhO,EAAMgO,IAC5D,OAAO,IAAIkgB,EAAWt3B,IAGxB,IAEA,EAFiBs3B,EC9HjB,SAASxQ,EAAcuE,EAAGrE,EAAGlmB,GAC3B,IAAK,IAAIgB,EAAI,GAAIA,IAAK,CACpB,GAAIA,GAAKupB,EAAE5pB,YAAcK,GAAKklB,EAAEvlB,WAC5B,OAAO4pB,EAAE5pB,YAAculB,EAAEvlB,WAAa,KAAOX,EAEjD,IAAIu3B,EAAShN,EAAE/iB,MAAMxG,GAAIw2B,EAAStR,EAAE1e,MAAMxG,GAC1C,GAAIu2B,GAAUC,EAAd,CAEA,IAAKD,EAAOE,WAAWD,GAAW,OAAOx3B,EAEzC,GAAIu3B,EAAOpsB,QAAUosB,EAAOxsB,MAAQysB,EAAOzsB,KAAM,CAC/C,IAAK,IAAI4S,EAAI,EAAG4Z,EAAOxsB,KAAK4S,IAAM6Z,EAAOzsB,KAAK4S,GAAIA,IAC9C3d,IACJ,OAAOA,EAET,GAAIu3B,EAAOr4B,QAAQC,MAAQq4B,EAAOt4B,QAAQC,KAAM,CAC9C,IAAIga,EAAQ6M,EAAcuR,EAAOr4B,QAASs4B,EAAOt4B,QAASc,EAAM,GAChE,GAAa,MAATmZ,EAAiB,OAAOA,EAE9BnZ,GAAOu3B,EAAOt3B,cAbUD,GAAOu3B,EAAOt3B,UAiB1C,SAASgmB,EAAYsE,EAAGrE,EAAGwR,EAAMC,GAC/B,IAAK,IAAIC,EAAKrN,EAAE5pB,WAAYk3B,EAAK3R,EAAEvlB,aAAc,CAC/C,GAAU,GAANi3B,GAAiB,GAANC,EACX,OAAOD,GAAMC,EAAK,KAAO,CAACtN,EAAGmN,EAAMxR,EAAGyR,GAE1C,IAAIJ,EAAShN,EAAE/iB,QAAQowB,GAAKJ,EAAStR,EAAE1e,QAAQqwB,GAAK14B,EAAOo4B,EAAOt3B,SAClE,GAAIs3B,GAAUC,EAAd,CAKA,IAAKD,EAAOE,WAAWD,GAAW,MAAO,CAACjN,EAAGmN,EAAMxR,EAAGyR,GAEtD,GAAIJ,EAAOpsB,QAAUosB,EAAOxsB,MAAQysB,EAAOzsB,KAAM,CAE/C,IADA,IAAIqM,EAAO,EAAG0gB,EAAU1sB,KAAKc,IAAIqrB,EAAOxsB,KAAK3G,OAAQozB,EAAOzsB,KAAK3G,QAC1DgT,EAAO0gB,GAAWP,EAAOxsB,KAAKwsB,EAAOxsB,KAAK3G,OAASgT,EAAO,IAAMogB,EAAOzsB,KAAKysB,EAAOzsB,KAAK3G,OAASgT,EAAO,IAC7GA,IAAQsgB,IAAQC,IAElB,MAAO,CAACpN,EAAGmN,EAAMxR,EAAGyR,GAEtB,GAAIJ,EAAOr4B,QAAQC,MAAQq4B,EAAOt4B,QAAQC,KAAM,CAC9C,IAAIga,EAAQ8M,EAAYsR,EAAOr4B,QAASs4B,EAAOt4B,QAASw4B,EAAO,EAAGC,EAAO,GACzE,GAAIxe,EAAS,OAAOA,EAEtBue,GAAQv4B,EAAMw4B,GAAQx4B,OAjBpBu4B,GAAQv4B,EAAMw4B,GAAQx4B,GA0B5B,IAAI44B,EAAW,SAAkB74B,EAASC,GAMxC,GALA4K,KAAK7K,QAAUA,EAIf6K,KAAK5K,KAAOA,GAAQ,EACR,MAARA,EAAgB,IAAK,IAAI6B,EAAI,EAAGA,EAAI9B,EAAQkF,OAAQpD,IACpD+I,KAAK5K,MAAQD,EAAQ8B,GAAGf,UAG1B+3B,EAAqB,CAAEx3B,WAAY,CAAEy3B,cAAc,GAAOx3B,UAAW,CAAEw3B,cAAc,GAAOt3B,WAAY,CAAEs3B,cAAc,IAM5HF,EAASvvB,UAAU/C,aAAe,SAAuB/F,EAAMD,EAAIyV,EAAGgjB,EAAWj5B,QAC1D,IAAdi5B,IAAuBA,EAAY,GAE1C,IAAK,IAAIl3B,EAAI,EAAGhB,EAAM,EAAGA,EAAMP,EAAIuB,IAAK,CACtC,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GAAI8B,EAAM9C,EAAMwH,EAAMvH,SAC/C,GAAI6C,EAAMpD,IAAiD,IAAzCwV,EAAE1N,EAAO0wB,EAAYl4B,EAAKf,EAAQ+B,IAAgBwG,EAAMtI,QAAQC,KAAM,CACtF,IAAI+F,EAAQlF,EAAM,EAClBwH,EAAM/B,aAAa2F,KAAKC,IAAI,EAAG3L,EAAOwF,GACnBkG,KAAKc,IAAI1E,EAAMtI,QAAQC,KAAMM,EAAKyF,GAClCgQ,EAAGgjB,EAAYhzB,GAEpClF,EAAM8C,IAOVi1B,EAASvvB,UAAUoqB,YAAc,SAAsB1d,GACrDnL,KAAKtE,aAAa,EAAGsE,KAAK5K,KAAM+V,IAMlC6iB,EAASvvB,UAAUkZ,YAAc,SAAsBhiB,EAAMD,EAAIoL,EAAgBstB,GAC/E,IAAIptB,EAAO,GAAIC,GAAY,EAa3B,OAZAjB,KAAKtE,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GACtCK,EAAK8K,QACPJ,GAAQ1K,EAAK0K,KAAKvL,MAAM4L,KAAKC,IAAI3L,EAAMM,GAAOA,EAAKP,EAAKO,GACxDgL,GAAaH,GACJxK,EAAKmwB,QAAU2H,GACxBptB,GAA4B,mBAAbotB,EAA0BA,EAAS93B,GAAO83B,EACzDntB,GAAaH,IACHG,GAAa3K,EAAK4C,UAC5B8H,GAAQF,EACRG,GAAY,KAEb,GACID,GAMTgtB,EAASvvB,UAAUL,OAAS,SAAiBiwB,GAC3C,IAAKA,EAAMj5B,KAAQ,OAAO4K,KAC1B,IAAKA,KAAK5K,KAAQ,OAAOi5B,EACzB,IAAIjlB,EAAOpJ,KAAKtJ,UAAW6C,EAAQ80B,EAAM53B,WAAYtB,EAAU6K,KAAK7K,QAAQM,QAASwB,EAAI,EAKzF,IAJImS,EAAKhI,QAAUgI,EAAKskB,WAAWn0B,KACjCpE,EAAQA,EAAQkF,OAAS,GAAK+O,EAAKklB,SAASllB,EAAKpI,KAAOzH,EAAMyH,MAC9D/J,EAAI,GAECA,EAAIo3B,EAAMl5B,QAAQkF,OAAQpD,IAAO9B,EAAQyF,KAAKyzB,EAAMl5B,QAAQ8B,IACnE,OAAO,IAAI+2B,EAAS74B,EAAS6K,KAAK5K,KAAOi5B,EAAMj5B,OAKjD44B,EAASvvB,UAAU8vB,IAAM,SAAc54B,EAAMD,GAE3C,GADU,MAANA,IAAcA,EAAKsK,KAAK5K,MAChB,GAARO,GAAaD,GAAMsK,KAAK5K,KAAQ,OAAO4K,KAC3C,IAAIqK,EAAS,GAAIjV,EAAO,EACxB,GAAIM,EAAKC,EAAQ,IAAK,IAAIsB,EAAI,EAAGhB,EAAM,EAAGA,EAAMP,EAAIuB,IAAK,CACvD,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GAAI8B,EAAM9C,EAAMwH,EAAMvH,SAC3C6C,EAAMpD,KACJM,EAAMN,GAAQoD,EAAMrD,KAElB+H,EADAA,EAAM2D,OACE3D,EAAM8wB,IAAIltB,KAAKC,IAAI,EAAG3L,EAAOM,GAAMoL,KAAKc,IAAI1E,EAAMuD,KAAK3G,OAAQ3E,EAAKO,IAEpEwH,EAAM8wB,IAAIltB,KAAKC,IAAI,EAAG3L,EAAOM,EAAM,GAAIoL,KAAKc,IAAI1E,EAAMtI,QAAQC,KAAMM,EAAKO,EAAM,KAE7FoU,EAAOzP,KAAK6C,GACZrI,GAAQqI,EAAMvH,UAEhBD,EAAM8C,EAER,OAAO,IAAIi1B,EAAS3jB,EAAQjV,IAG9B44B,EAASvvB,UAAU+vB,WAAa,SAAqB74B,EAAMD,GACzD,OAAIC,GAAQD,EAAas4B,EAASl6B,MACtB,GAAR6B,GAAaD,GAAMsK,KAAK7K,QAAQkF,OAAiB2F,KAC9C,IAAIguB,EAAShuB,KAAK7K,QAAQM,MAAME,EAAMD,KAM/Cs4B,EAASvvB,UAAUgwB,aAAe,SAAuBv3B,EAAOZ,GAC9D,IAAIo4B,EAAU1uB,KAAK7K,QAAQ+B,GAC3B,GAAIw3B,GAAWp4B,EAAQ,OAAO0J,KAC9B,IAAIzF,EAAOyF,KAAK7K,QAAQM,QACpBL,EAAO4K,KAAK5K,KAAOkB,EAAKJ,SAAWw4B,EAAQx4B,SAE/C,OADAqE,EAAKrD,GAASZ,EACP,IAAI03B,EAASzzB,EAAMnF,IAM5B44B,EAASvvB,UAAUuuB,WAAa,SAAqB12B,GACnD,OAAO,IAAI03B,EAAS,CAAC13B,GAAM22B,OAAOjtB,KAAK7K,SAAU6K,KAAK5K,KAAOkB,EAAKJ,WAMpE83B,EAASvvB,UAAUyuB,SAAW,SAAmB52B,GAC/C,OAAO,IAAI03B,EAAShuB,KAAK7K,QAAQ83B,OAAO32B,GAAO0J,KAAK5K,KAAOkB,EAAKJ,WAKlE83B,EAASvvB,UAAU+I,GAAK,SAAa6mB,GACnC,GAAIruB,KAAK7K,QAAQkF,QAAUg0B,EAAMl5B,QAAQkF,OAAU,OAAO,EAC1D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,IACrC,IAAK+I,KAAK7K,QAAQ8B,GAAGuQ,GAAG6mB,EAAMl5B,QAAQ8B,IAAO,OAAO,EACxD,OAAO,GAKTg3B,EAAmBx3B,WAAWi2B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQ,GAAK,MAIjG84B,EAAmBv3B,UAAUg2B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAAK,MAItH4zB,EAAmBr3B,WAAW81B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQkF,QAKtE2zB,EAASvvB,UAAUhB,MAAQ,SAAgBvG,GACzC,IAAIkG,EAAQ4C,KAAK7K,QAAQ+B,GACzB,IAAKkG,EAAS,MAAM,IAAIuxB,WAAW,SAAWz3B,EAAQ,qBAAuB8I,MAC7E,OAAO5C,GAKT4wB,EAASvvB,UAAUmwB,WAAa,SAAqB13B,GACnD,OAAO8I,KAAK7K,QAAQ+B,IAMtB82B,EAASvvB,UAAUU,QAAU,SAAkBgM,GAC7C,IAAK,IAAIlU,EAAI,EAAG43B,EAAI,EAAG53B,EAAI+I,KAAK7K,QAAQkF,OAAQpD,IAAK,CACnD,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GACzBkU,EAAE1N,EAAOoxB,EAAG53B,GACZ43B,GAAKpxB,EAAMvH,WAOf83B,EAASvvB,UAAUwd,cAAgB,SAA0BoS,EAAOp4B,GAGlE,YAFe,IAARA,IAAiBA,EAAM,GAEvBgmB,EAAcjc,KAAMquB,EAAOp4B,IAQpC+3B,EAASvvB,UAAUyd,YAAc,SAAwBmS,EAAOp4B,EAAK64B,GAInE,YAHe,IAAR74B,IAAiBA,EAAM+J,KAAK5K,WACf,IAAb05B,IAAsBA,EAAWT,EAAMj5B,MAEvC8mB,EAAYlc,KAAMquB,EAAOp4B,EAAK64B,IAOvCd,EAASvvB,UAAUswB,UAAY,SAAoB94B,EAAK+4B,GAGtD,QAFiB,IAAVA,IAAmBA,GAAS,GAExB,GAAP/4B,EAAY,OAAOg5B,EAAS,EAAGh5B,GACnC,GAAIA,GAAO+J,KAAK5K,KAAQ,OAAO65B,EAASjvB,KAAK7K,QAAQkF,OAAQpE,GAC7D,GAAIA,EAAM+J,KAAK5K,MAAQa,EAAM,EAAK,MAAM,IAAI04B,WAAY,YAAc14B,EAAM,yBAA2B,KAAS,KAChH,IAAK,IAAIgB,EAAI,EAAGi4B,EAAS,GAAIj4B,IAAK,CAChC,IAAyB8B,EAAMm2B,EAArBlvB,KAAKvC,MAAMxG,GAAuBf,SAC5C,GAAI6C,GAAO9C,EACT,OAAI8C,GAAO9C,GAAO+4B,EAAQ,EAAYC,EAASh4B,EAAI,EAAG8B,GAC/Ck2B,EAASh4B,EAAGi4B,GAErBA,EAASn2B,IAMbi1B,EAASvvB,UAAUC,SAAW,WAAuB,MAAO,IAAMsB,KAAKmvB,gBAAkB,KAEzFnB,EAASvvB,UAAU0wB,cAAgB,WAA4B,OAAOnvB,KAAK7K,QAAQ2E,KAAK,OAIxFk0B,EAASvvB,UAAU4W,OAAS,WAC1B,OAAOrV,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQa,KAAI,SAAU6a,GAAK,OAAOA,EAAEwE,YAAe,MAKvF2Y,EAASoB,SAAW,SAAmB5tB,EAAQjD,GAC7C,IAAKA,EAAS,OAAOyvB,EAASl6B,MAC9B,IAAKqS,MAAMC,QAAQ7H,GAAU,MAAM,IAAIowB,WAAW,uCAClD,OAAO,IAAIX,EAASzvB,EAAMvI,IAAIwL,EAAO8G,gBAMvC0lB,EAASqB,UAAY,SAAoB/F,GACvC,IAAKA,EAAMjvB,OAAU,OAAO2zB,EAASl6B,MAErC,IADA,IAAIw7B,EAAQl6B,EAAO,EACV6B,EAAI,EAAGA,EAAIqyB,EAAMjvB,OAAQpD,IAAK,CACrC,IAAIX,EAAOgzB,EAAMryB,GACjB7B,GAAQkB,EAAKJ,SACTe,GAAKX,EAAK8K,QAAUkoB,EAAMryB,EAAI,GAAGy2B,WAAWp3B,IACzCg5B,IAAUA,EAAShG,EAAM7zB,MAAM,EAAGwB,IACvCq4B,EAAOA,EAAOj1B,OAAS,GAAK/D,EAAKg4B,SAASgB,EAAOA,EAAOj1B,OAAS,GAAG2G,KAAO1K,EAAK0K,OACvEsuB,GACTA,EAAO10B,KAAKtE,GAGhB,OAAO,IAAI03B,EAASsB,GAAUhG,EAAOl0B,IAQvC44B,EAASr4B,KAAO,SAAegM,GAC7B,IAAKA,EAAS,OAAOqsB,EAASl6B,MAC9B,GAAI6N,aAAiBqsB,EAAY,OAAOrsB,EACxC,GAAIwE,MAAMC,QAAQzE,GAAU,OAAO3B,KAAKqvB,UAAU1tB,GAClD,GAAIA,EAAMnG,MAAS,OAAO,IAAIwyB,EAAS,CAACrsB,GAAQA,EAAMzL,UACtD,MAAM,IAAIy4B,WAAW,mBAAqBhtB,EAAQ,kBAC5BA,EAAMjG,aAAe,mEAAqE,MAGlH8C,OAAO+wB,iBAAkBvB,EAASvvB,UAAWwvB,GAE7C,IAAI7wB,EAAQ,CAAClG,MAAO,EAAGwO,OAAQ,GAC/B,SAASupB,EAAS/3B,EAAOwO,GAGvB,OAFAtI,EAAMlG,MAAQA,EACdkG,EAAMsI,OAASA,EACRtI,EAST,SAASoyB,EAAYhP,EAAGrE,GACtB,GAAIqE,IAAMrE,EAAK,OAAO,EACtB,IAAMqE,GAAiB,iBAALA,IACZrE,GAAiB,iBAALA,EAAkB,OAAO,EAC3C,IAAImN,EAAQnjB,MAAMC,QAAQoa,GAC1B,GAAIra,MAAMC,QAAQ+V,IAAMmN,EAAS,OAAO,EACxC,GAAIA,EAAO,CACT,GAAI9I,EAAEnmB,QAAU8hB,EAAE9hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIupB,EAAEnmB,OAAQpD,IAAO,IAAKu4B,EAAYhP,EAAEvpB,GAAIklB,EAAEllB,IAAO,OAAO,MACvE,CACL,IAAK,IAAI43B,KAAKrO,EAAK,KAAMqO,KAAK1S,KAAOqT,EAAYhP,EAAEqO,GAAI1S,EAAE0S,IAAO,OAAO,EACvE,IAAK,IAAIY,KAAOtT,EAAK,KAAMsT,KAAOjP,GAAM,OAAO,EAEjD,OAAO,EAfTwN,EAASl6B,MAAQ,IAAIk6B,EAAS,GAAI,GAwBlC,IAAI1J,EAAO,SAAcxvB,EAAM0G,GAG7BwE,KAAKlL,KAAOA,EAGZkL,KAAKxE,MAAQA,GAyGf,SAASk0B,EAAaC,GACpB,IAAIC,EAAM7rB,MAAMpF,KAAKqB,KAAM2vB,GAE3B,OADAC,EAAIttB,UAAYotB,EAAajxB,UACtBmxB,EAnGTtL,EAAK7lB,UAAUoxB,SAAW,SAAmBC,GAE3C,IADA,IAAIv1B,EAAMw1B,GAAS,EACV94B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAAK,CACnC,IAAIo3B,EAAQyB,EAAI74B,GAChB,GAAI+I,KAAKwH,GAAG6mB,GAAU,OAAOyB,EAC7B,GAAI9vB,KAAKlL,KAAKyd,SAAS8b,EAAMv5B,MACtByF,IAAQA,EAAOu1B,EAAIr6B,MAAM,EAAGwB,QAC5B,IAAIo3B,EAAMv5B,KAAKyd,SAASvS,KAAKlL,MAClC,OAAOg7B,GAEFC,GAAU1B,EAAMv5B,KAAKk7B,KAAOhwB,KAAKlL,KAAKk7B,OACpCz1B,IAAQA,EAAOu1B,EAAIr6B,MAAM,EAAGwB,IACjCsD,EAAKK,KAAKoF,MACV+vB,GAAS,GAEPx1B,GAAQA,EAAKK,KAAKyzB,IAK1B,OAFK9zB,IAAQA,EAAOu1B,EAAIr6B,SACnBs6B,GAAUx1B,EAAKK,KAAKoF,MAClBzF,GAMT+pB,EAAK7lB,UAAUwxB,cAAgB,SAAwBH,GACrD,IAAK,IAAI74B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAC5B,GAAI+I,KAAKwH,GAAGsoB,EAAI74B,IACd,OAAO64B,EAAIr6B,MAAM,EAAGwB,GAAGg2B,OAAO6C,EAAIr6B,MAAMwB,EAAI,IAClD,OAAO64B,GAKTxL,EAAK7lB,UAAUmH,QAAU,SAAkBkqB,GACzC,IAAK,IAAI74B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAC5B,GAAI+I,KAAKwH,GAAGsoB,EAAI74B,IAAO,OAAO,EAClC,OAAO,GAMTqtB,EAAK7lB,UAAU+I,GAAK,SAAa6mB,GAC/B,OAAOruB,MAAQquB,GACZruB,KAAKlL,MAAQu5B,EAAMv5B,MAAQ06B,EAAYxvB,KAAKxE,MAAO6yB,EAAM7yB,QAK9D8oB,EAAK7lB,UAAU4W,OAAS,WACtB,IAAIjJ,EAAM,CAACtX,KAAMkL,KAAKlL,KAAKmL,MAC3B,IAAK,IAAI2pB,KAAK5pB,KAAKxE,MAAO,CACxB4Q,EAAI5Q,MAAQwE,KAAKxE,MACjB,MAEF,OAAO4Q,GAITkY,EAAK8K,SAAW,SAAmB5tB,EAAQ0uB,GACzC,IAAKA,EAAQ,MAAM,IAAIvB,WAAW,mCAClC,IAAI75B,EAAO0M,EAAOmD,MAAMurB,EAAKp7B,MAC7B,IAAKA,EAAQ,MAAM,IAAI65B,WAAY,yBAA4BuB,EAAS,KAAI,mBAC5E,OAAOp7B,EAAKwF,OAAO41B,EAAK10B,QAK1B8oB,EAAK6L,QAAU,SAAkB3P,EAAGrE,GAClC,GAAIqE,GAAKrE,EAAK,OAAO,EACrB,GAAIqE,EAAEnmB,QAAU8hB,EAAE9hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIupB,EAAEnmB,OAAQpD,IAC1B,IAAKupB,EAAEvpB,GAAGuQ,GAAG2U,EAAEllB,IAAO,OAAO,EACjC,OAAO,GAMTqtB,EAAK8L,QAAU,SAAkBzrB,GAC/B,IAAKA,GAAyB,GAAhBA,EAAMtK,OAAe,OAAOiqB,EAAK+L,KAC/C,GAAI1rB,aAAiB2f,EAAQ,MAAO,CAAC3f,GACrC,IAAIpK,EAAOoK,EAAMlP,QAEjB,OADA8E,EAAKulB,MAAK,SAAUU,EAAGrE,GAAK,OAAOqE,EAAE1rB,KAAKk7B,KAAO7T,EAAErnB,KAAKk7B,QACjDz1B,GAIT+pB,EAAK+L,KAAO,GAYZX,EAAajxB,UAAYD,OAAOlE,OAAOyJ,MAAMtF,WAC7CixB,EAAajxB,UAAUI,YAAc6wB,EACrCA,EAAajxB,UAAUwB,KAAO,eAK9B,IAAIqwB,EAAQ,SAAen7B,EAASo7B,EAAWC,GAE7CxwB,KAAK7K,QAAUA,EAEf6K,KAAKuwB,UAAYA,EAEjBvwB,KAAKwwB,QAAUA,GAGbC,EAAuB,CAAEr7B,KAAM,CAAE84B,cAAc,IA6DnD,SAASwC,EAAYv7B,EAASQ,EAAMD,GAClC,IAAIoB,EAAM3B,EAAQ45B,UAAUp5B,GACxBuB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACbjI,EAAQtI,EAAQy5B,WAAW13B,GAC3By5B,EAAQx7B,EAAQ45B,UAAUr5B,GAC1Bk7B,EAAUD,EAAMz5B,MAChB25B,EAAWF,EAAMjrB,OACrB,GAAIA,GAAU/P,GAAQ8H,EAAM2D,OAAQ,CAClC,GAAIyvB,GAAYn7B,IAAOP,EAAQsI,MAAMmzB,GAASxvB,OAAU,MAAM,IAAIutB,WAAW,2BAC7E,OAAOx5B,EAAQo5B,IAAI,EAAG54B,GAAMyI,OAAOjJ,EAAQo5B,IAAI74B,IAEjD,GAAIwB,GAAS05B,EAAW,MAAM,IAAIjC,WAAW,2BAC7C,OAAOx5B,EAAQs5B,aAAav3B,EAAOuG,EAAMlD,KAAKm2B,EAAYjzB,EAAMtI,QAASQ,EAAO+P,EAAS,EAAGhQ,EAAKgQ,EAAS,KAG5G,SAASorB,EAAW37B,EAAS47B,EAAMl4B,EAAQ3D,GACzC,IAAI4B,EAAM3B,EAAQ45B,UAAUgC,GACxB75B,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACbjI,EAAQtI,EAAQy5B,WAAW13B,GAC/B,GAAIwO,GAAUqrB,GAAQtzB,EAAM2D,OAC1B,OAAIlM,IAAWA,EAAO0E,WAAW1C,EAAOA,EAAO2B,GAAkB,KAC1D1D,EAAQo5B,IAAI,EAAGwC,GAAM3yB,OAAOvF,GAAQuF,OAAOjJ,EAAQo5B,IAAIwC,IAEhE,IAAI3hB,EAAQ0hB,EAAWrzB,EAAMtI,QAAS47B,EAAOrrB,EAAS,EAAG7M,GACzD,OAAOuW,GAASja,EAAQs5B,aAAav3B,EAAOuG,EAAMlD,KAAK6U,IAOzD,SAASwB,EAAQlY,EAAOC,EAAKlD,GAC3B,GAAIA,EAAM86B,UAAY73B,EAAMtC,MACxB,MAAM,IAAIs5B,EAAa,mDAC3B,GAAIh3B,EAAMtC,MAAQX,EAAM86B,WAAa53B,EAAIvC,MAAQX,EAAM+6B,QACnD,MAAM,IAAId,EAAa,4BAC3B,OAAOsB,EAAat4B,EAAOC,EAAKlD,EAAO,GAGzC,SAASu7B,EAAat4B,EAAOC,EAAKlD,EAAOW,GACvC,IAAIc,EAAQwB,EAAMxB,MAAMd,GAAQE,EAAOoC,EAAMpC,KAAKF,GAClD,GAAIc,GAASyB,EAAIzB,MAAMd,IAAUA,EAAQsC,EAAMtC,MAAQX,EAAM86B,UAAW,CACtE,IAAInhB,EAAQ4hB,EAAat4B,EAAOC,EAAKlD,EAAOW,EAAQ,GACpD,OAAOE,EAAKiE,KAAKjE,EAAKnB,QAAQs5B,aAAav3B,EAAOkY,IAC7C,GAAK3Z,EAAMN,QAAQC,KAEnB,IAAKK,EAAM86B,WAAc96B,EAAM+6B,SAAW93B,EAAMtC,OAASA,GAASuC,EAAIvC,OAASA,EAG/E,CACL,IAAIU,EAgFR,SAAgCrB,EAAOw7B,GAGrC,IAFA,IAAIC,EAAQD,EAAO76B,MAAQX,EAAM86B,UAC7Bj6B,EADiD26B,EAAO36B,KAAK46B,GAC/C32B,KAAK9E,EAAMN,SACpB8B,EAAIi6B,EAAQ,EAAGj6B,GAAK,EAAGA,IAC5BX,EAAO26B,EAAO36B,KAAKW,GAAGsD,KAAKyzB,EAASr4B,KAAKW,IAC7C,MAAO,CAAC6E,MAAO7E,EAAK66B,eAAe17B,EAAM86B,UAAYW,GAC7Cn4B,IAAKzC,EAAK66B,eAAe76B,EAAKnB,QAAQC,KAAOK,EAAM+6B,QAAUU,IAtFzDE,CAAuB37B,EAAOiD,GAGxC,OAAO,EAAMpC,EAAM+6B,EAAgB34B,EAFvB5B,EAAIqE,MACNrE,EAAIiC,IACwCJ,EAAKvC,IAN3D,IAAIlB,EAASwD,EAAMxD,OAAQC,EAAUD,EAAOC,QAC5C,OAAO,EAAMD,EAAQC,EAAQo5B,IAAI,EAAG71B,EAAMrE,cAAc+J,OAAO3I,EAAMN,SAASiJ,OAAOjJ,EAAQo5B,IAAI51B,EAAItE,gBAHrG,OAAO,EAAMiC,EAAMg7B,EAAc54B,EAAOC,EAAKvC,IAYjD,SAASm7B,EAAUC,EAAMC,GACvB,IAAKA,EAAI38B,KAAK6E,kBAAkB63B,EAAK18B,MACjC,MAAM,IAAI46B,EAAa,eAAiB+B,EAAI38B,KAAKmL,KAAO,SAAWuxB,EAAK18B,KAAKmL,MAGnF,SAASyxB,EAASC,EAASC,EAAQx7B,GACjC,IAAIE,EAAOq7B,EAAQr7B,KAAKF,GAExB,OADAm7B,EAAUj7B,EAAMs7B,EAAOt7B,KAAKF,IACrBE,EAGT,SAASu7B,EAAQp0B,EAAO/I,GACtB,IAAI0U,EAAO1U,EAAO2F,OAAS,EACvB+O,GAAQ,GAAK3L,EAAM2D,QAAU3D,EAAMiwB,WAAWh5B,EAAO0U,IACrD1U,EAAO0U,GAAQ3L,EAAM6wB,SAAS55B,EAAO0U,GAAMpI,KAAOvD,EAAMuD,MAExDtM,EAAOkG,KAAK6C,GAGlB,SAASq0B,EAAS9zB,EAAQ+zB,EAAM37B,EAAO1B,GACrC,IAAI4B,GAAQy7B,GAAQ/zB,GAAQ1H,KAAKF,GAC7B2G,EAAa,EAAGE,EAAW80B,EAAOA,EAAK76B,MAAMd,GAASE,EAAKM,WAC3DoH,IACFjB,EAAaiB,EAAO9G,MAAMd,GACtB4H,EAAO5H,MAAQA,EACjB2G,IACSiB,EAAOg0B,aAChBH,EAAQ7zB,EAAO3G,UAAW3C,GAC1BqI,MAGJ,IAAK,IAAI9F,EAAI8F,EAAY9F,EAAIgG,EAAUhG,IAAO46B,EAAQv7B,EAAKmH,MAAMxG,GAAIvC,GACjEq9B,GAAQA,EAAK37B,OAASA,GAAS27B,EAAKC,YACpCH,EAAQE,EAAKl9B,WAAYH,GAG/B,SAAS,EAAM4B,EAAMnB,GACnB,IAAKmB,EAAKxB,KAAKmd,aAAa9c,GACxB,MAAM,IAAIu6B,EAAa,4BAA8Bp5B,EAAKxB,KAAKmL,MACnE,OAAO3J,EAAKiE,KAAKpF,GAGnB,SAASk8B,EAAgB34B,EAAOsF,EAAQ+zB,EAAMp5B,EAAKvC,GACjD,IAAIm6B,EAAY73B,EAAMtC,MAAQA,GAASs7B,EAASh5B,EAAOsF,EAAQ5H,EAAQ,GACnEo6B,EAAU73B,EAAIvC,MAAQA,GAASs7B,EAASK,EAAMp5B,EAAKvC,EAAQ,GAE3DjB,EAAU,GAad,OAZA28B,EAAS,KAAMp5B,EAAOtC,EAAOjB,GACzBo7B,GAAaC,GAAWxyB,EAAO9G,MAAMd,IAAU27B,EAAK76B,MAAMd,IAC5Dm7B,EAAUhB,EAAWC,GACrBqB,EAAQ,EAAMtB,EAAWc,EAAgB34B,EAAOsF,EAAQ+zB,EAAMp5B,EAAKvC,EAAQ,IAAKjB,KAE5Eo7B,GACAsB,EAAQ,EAAMtB,EAAWe,EAAc54B,EAAOsF,EAAQ5H,EAAQ,IAAKjB,GACvE28B,EAAS9zB,EAAQ+zB,EAAM37B,EAAOjB,GAC1Bq7B,GACAqB,EAAQ,EAAMrB,EAASc,EAAcS,EAAMp5B,EAAKvC,EAAQ,IAAKjB,IAEnE28B,EAASn5B,EAAK,KAAMvC,EAAOjB,GACpB,IAAI64B,EAAS74B,GAGtB,SAASm8B,EAAc54B,EAAOC,EAAKvC,GACjC,IAAIjB,EAAU,IACd28B,EAAS,KAAMp5B,EAAOtC,EAAOjB,GACzBuD,EAAMtC,MAAQA,IAEhBy7B,EAAQ,EADGH,EAASh5B,EAAOC,EAAKvC,EAAQ,GACpBk7B,EAAc54B,EAAOC,EAAKvC,EAAQ,IAAKjB,GAG7D,OADA28B,EAASn5B,EAAK,KAAMvC,EAAOjB,GACpB,IAAI64B,EAAS74B,GA1LtBs7B,EAAqBr7B,KAAKs3B,IAAM,WAC9B,OAAO1sB,KAAK7K,QAAQC,KAAO4K,KAAKuwB,UAAYvwB,KAAKwwB,SAGnDF,EAAM7xB,UAAUwzB,SAAW,SAAmBh8B,EAAKoiB,GACjD,IAAIljB,EAAU27B,EAAW9wB,KAAK7K,QAASc,EAAM+J,KAAKuwB,UAAWlY,EAAU,MACvE,OAAOljB,GAAW,IAAIm7B,EAAMn7B,EAAS6K,KAAKuwB,UAAWvwB,KAAKwwB,UAG5DF,EAAM7xB,UAAUyzB,cAAgB,SAAwBv8B,EAAMD,GAC5D,OAAO,IAAI46B,EAAMI,EAAY1wB,KAAK7K,QAASQ,EAAOqK,KAAKuwB,UAAW76B,EAAKsK,KAAKuwB,WAAYvwB,KAAKuwB,UAAWvwB,KAAKwwB,UAK/GF,EAAM7xB,UAAU+I,GAAK,SAAa6mB,GAChC,OAAOruB,KAAK7K,QAAQqS,GAAG6mB,EAAMl5B,UAAY6K,KAAKuwB,WAAalC,EAAMkC,WAAavwB,KAAKwwB,SAAWnC,EAAMmC,SAGtGF,EAAM7xB,UAAUC,SAAW,WACzB,OAAOsB,KAAK7K,QAAU,IAAM6K,KAAKuwB,UAAY,IAAMvwB,KAAKwwB,QAAU,KAKpEF,EAAM7xB,UAAU4W,OAAS,WACvB,IAAKrV,KAAK7K,QAAQC,KAAQ,OAAO,KACjC,IAAI86B,EAAO,CAAC/6B,QAAS6K,KAAK7K,QAAQkgB,UAGlC,OAFIrV,KAAKuwB,UAAY,IAAKL,EAAKK,UAAYvwB,KAAKuwB,WAC5CvwB,KAAKwwB,QAAU,IAAKN,EAAKM,QAAUxwB,KAAKwwB,SACrCN,GAKTI,EAAMlB,SAAW,SAAmB5tB,EAAQ0uB,GAC1C,IAAKA,EAAQ,OAAOI,EAAMx8B,MAC1B,IAAIy8B,EAAYL,EAAKK,WAAa,EAAGC,EAAUN,EAAKM,SAAW,EAC/D,GAAwB,iBAAbD,GAA2C,iBAAXC,EACvC,MAAM,IAAI7B,WAAW,oCACzB,OAAO,IAAI2B,EAAMtC,EAASoB,SAAS5tB,EAAQ0uB,EAAK/6B,SAAUo7B,EAAWC,IAMvEF,EAAM6B,QAAU,SAAkB9Z,EAAU+Z,QACjB,IAAlBA,IAA2BA,GAAc,GAGhD,IADA,IAAI7B,EAAY,EAAGC,EAAU,EACpB3f,EAAIwH,EAAS5hB,WAAYoa,IAAMA,EAAE4V,SAAW2L,IAAkBvhB,EAAE/b,KAAKC,KAAKC,WAAY6b,EAAIA,EAAEpa,WAAc85B,IACnH,IAAK,IAAI8B,EAAMha,EAAS3hB,UAAW27B,IAAQA,EAAI5L,SAAW2L,IAAkBC,EAAIv9B,KAAKC,KAAKC,WAAYq9B,EAAMA,EAAI37B,UAAa85B,IAC7H,OAAO,IAAIF,EAAMjY,EAAUkY,EAAWC,IAGxChyB,OAAO+wB,iBAAkBe,EAAM7xB,UAAWgyB,GAiC1CH,EAAMx8B,MAAQ,IAAIw8B,EAAMtC,EAASl6B,MAAO,EAAG,GAsH3C,IAAIw+B,EAAc,SAAqBr8B,EAAKs8B,EAAMl+B,GAEhD2L,KAAK/J,IAAMA,EACX+J,KAAKuyB,KAAOA,EAKZvyB,KAAK5J,MAAQm8B,EAAKl4B,OAAS,EAAI,EAE/B2F,KAAK3L,aAAeA,GAGlBm+B,EAAuB,CAAEt9B,OAAQ,CAAEg5B,cAAc,GAAO34B,IAAK,CAAE24B,cAAc,GAAO8D,WAAY,CAAE9D,cAAc,GAAO72B,UAAW,CAAE62B,cAAc,GAAOr5B,WAAY,CAAEq5B,cAAc,IAEzLoE,EAAY7zB,UAAUg0B,aAAe,SAAuBC,GAC1D,OAAW,MAAPA,EAAsB1yB,KAAK5J,MAC3Bs8B,EAAM,EAAY1yB,KAAK5J,MAAQs8B,EAC5BA,GAOTF,EAAqBt9B,OAAOw3B,IAAM,WAAc,OAAO1sB,KAAK1J,KAAK0J,KAAK5J,QAItEo8B,EAAqBj9B,IAAIm3B,IAAM,WAAc,OAAO1sB,KAAK1J,KAAK,IAK9Dg8B,EAAY7zB,UAAUnI,KAAO,SAAeF,GAAS,OAAO4J,KAAKuyB,KAAgC,EAA3BvyB,KAAKyyB,aAAar8B,KAMxFk8B,EAAY7zB,UAAUvH,MAAQ,SAAgBd,GAAS,OAAO4J,KAAKuyB,KAAgC,EAA3BvyB,KAAKyyB,aAAar8B,GAAa,IAKvGk8B,EAAY7zB,UAAUtG,WAAa,SAAqB/B,GAEtD,OADAA,EAAQ4J,KAAKyyB,aAAar8B,GACnB4J,KAAK9I,MAAMd,IAAUA,GAAS4J,KAAK5J,OAAU4J,KAAKgyB,WAAiB,EAAJ,IAMxEM,EAAY7zB,UAAUtD,MAAQ,SAAgB/E,GAE5C,OAAgB,IADhBA,EAAQ4J,KAAKyyB,aAAar8B,IACN,EAAI4J,KAAKuyB,KAAa,EAARn8B,EAAY,GAAK,GAMrDk8B,EAAY7zB,UAAU1F,IAAM,SAAc3C,GAExC,OADAA,EAAQ4J,KAAKyyB,aAAar8B,GACnB4J,KAAK7E,MAAM/E,GAAS4J,KAAK1J,KAAKF,GAAOjB,QAAQC,MAOtDk9B,EAAY7zB,UAAU7J,OAAS,SAAiBwB,GAE9C,KADAA,EAAQ4J,KAAKyyB,aAAar8B,IACZ,MAAM,IAAIu4B,WAAW,kDACnC,OAAOv4B,GAAS4J,KAAK5J,MAAQ,EAAI4J,KAAK/J,IAAM+J,KAAKuyB,KAAa,EAARn8B,EAAY,IAMpEk8B,EAAY7zB,UAAUjJ,MAAQ,SAAgBY,GAE5C,KADAA,EAAQ4J,KAAKyyB,aAAar8B,IACZ,MAAM,IAAIu4B,WAAW,iDACnC,OAAOv4B,GAAS4J,KAAK5J,MAAQ,EAAI4J,KAAK/J,IAAM+J,KAAKuyB,KAAa,EAARn8B,EAAY,GAAK4J,KAAKuyB,KAAa,EAARn8B,GAAWF,UAO9Fs8B,EAAqBR,WAAWtF,IAAM,WAAc,OAAO1sB,KAAK/J,IAAM+J,KAAKuyB,KAAKvyB,KAAKuyB,KAAKl4B,OAAS,IAMnGm4B,EAAqBn7B,UAAUq1B,IAAM,WACnC,IAAIx3B,EAAS8K,KAAK9K,OAAQgC,EAAQ8I,KAAK9I,MAAM8I,KAAK5J,OAClD,GAAIc,GAAShC,EAAO0B,WAAc,OAAO,KACzC,IAAI+7B,EAAO3yB,KAAK/J,IAAM+J,KAAKuyB,KAAKvyB,KAAKuyB,KAAKl4B,OAAS,GAAIoD,EAAQvI,EAAOuI,MAAMvG,GAC5E,OAAOy7B,EAAOz9B,EAAOuI,MAAMvG,GAAOq3B,IAAIoE,GAAQl1B,GAOhD+0B,EAAqB39B,WAAW63B,IAAM,WACpC,IAAIx1B,EAAQ8I,KAAK9I,MAAM8I,KAAK5J,OACxBu8B,EAAO3yB,KAAK/J,IAAM+J,KAAKuyB,KAAKvyB,KAAKuyB,KAAKl4B,OAAS,GACnD,OAAIs4B,EAAe3yB,KAAK9K,OAAOuI,MAAMvG,GAAOq3B,IAAI,EAAGoE,GACnC,GAATz7B,EAAa,KAAO8I,KAAK9K,OAAOuI,MAAMvG,EAAQ,IAMvDo7B,EAAY7zB,UAAUm0B,WAAa,SAAqB17B,EAAOd,GAC7DA,EAAQ4J,KAAKyyB,aAAar8B,GAE1B,IADA,IAAIE,EAAO0J,KAAKuyB,KAAa,EAARn8B,GAAYH,EAAe,GAATG,EAAa,EAAI4J,KAAKuyB,KAAa,EAARn8B,EAAY,GAAK,EAC1Ea,EAAI,EAAGA,EAAIC,EAAOD,IAAOhB,GAAOK,EAAKmH,MAAMxG,GAAGf,SACvD,OAAOD,GAQTq8B,EAAY7zB,UAAUkG,MAAQ,WAC5B,IAAIzP,EAAS8K,KAAK9K,OAAQgC,EAAQ8I,KAAK9I,QAGvC,GAA2B,GAAvBhC,EAAOC,QAAQC,KAAa,OAAOkvB,EAAK+L,KAG5C,GAAIrwB,KAAKgyB,WAAc,OAAO98B,EAAOuI,MAAMvG,GAAOyN,MAElD,IAAI6sB,EAAOt8B,EAAO05B,WAAW13B,EAAQ,GAAIm3B,EAAQn5B,EAAO05B,WAAW13B,GAGnE,IAAKs6B,EAAM,CAAE,IAAIqB,EAAMrB,EAAMA,EAAOnD,EAAOA,EAAQwE,EAKnD,IADA,IAAIluB,EAAQ6sB,EAAK7sB,MACR1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,KACO,IAAjC0N,EAAM1N,GAAGnC,KAAKC,KAAK6pB,WAAyByP,GAAU1pB,EAAM1N,GAAG2O,QAAQyoB,EAAM1pB,SAC/EA,EAAQA,EAAM1N,KAAKg5B,cAActrB,IAEvC,OAAOA,GAUT2tB,EAAY7zB,UAAUq0B,YAAc,SAAsBf,GACxD,IAAIv8B,EAAQwK,KAAK9K,OAAO05B,WAAW5uB,KAAK9I,SACxC,IAAK1B,IAAUA,EAAM0F,SAAY,OAAO,KAGxC,IADA,IAAIyJ,EAAQnP,EAAMmP,MAAOouB,EAAOhB,EAAK78B,OAAO05B,WAAWmD,EAAK76B,SACnDD,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,KACO,IAAjC0N,EAAM1N,GAAGnC,KAAKC,KAAK6pB,WAAyBmU,GAASpuB,EAAM1N,GAAG2O,QAAQmtB,EAAKpuB,SAC7EA,EAAQA,EAAM1N,KAAKg5B,cAActrB,IACvC,OAAOA,GAMT2tB,EAAY7zB,UAAU6O,YAAc,SAAsBrX,GACxD,IAAK,IAAIG,EAAQ4J,KAAK5J,MAAOA,EAAQ,EAAGA,IACpC,GAAI4J,KAAK7E,MAAM/E,IAAUH,GAAO+J,KAAKjH,IAAI3C,IAAUH,EAAO,OAAOG,EACrE,OAAO,GAWTk8B,EAAY7zB,UAAUhK,WAAa,SAAqB45B,EAAO2E,GAG7D,QAFiB,IAAV3E,IAAmBA,EAAQruB,MAE9BquB,EAAMp4B,IAAM+J,KAAK/J,IAAO,OAAOo4B,EAAM55B,WAAWuL,MACpD,IAAK,IAAIuQ,EAAIvQ,KAAK5J,OAAS4J,KAAK9K,OAAO0D,eAAiBoH,KAAK/J,KAAOo4B,EAAMp4B,IAAM,EAAI,GAAIsa,GAAK,EAAGA,IAC5F,GAAI8d,EAAMp4B,KAAO+J,KAAKjH,IAAIwX,MAAQyiB,GAAQA,EAAKhzB,KAAK1J,KAAKia,KACvD,OAAO,IAAI0iB,EAAUjzB,KAAMquB,EAAO9d,IAK1C+hB,EAAY7zB,UAAU/G,WAAa,SAAqB22B,GACtD,OAAOruB,KAAK/J,IAAM+J,KAAK3L,cAAgBg6B,EAAMp4B,IAAMo4B,EAAMh6B,cAK3Di+B,EAAY7zB,UAAU6C,IAAM,SAAc+sB,GACxC,OAAOA,EAAMp4B,IAAM+J,KAAK/J,IAAMo4B,EAAQruB,MAKxCsyB,EAAY7zB,UAAU0D,IAAM,SAAcksB,GACxC,OAAOA,EAAMp4B,IAAM+J,KAAK/J,IAAMo4B,EAAQruB,MAGxCsyB,EAAY7zB,UAAUC,SAAW,WAE/B,IADA,IAAIw0B,EAAM,GACDj8B,EAAI,EAAGA,GAAK+I,KAAK5J,MAAOa,IAC7Bi8B,IAAQA,EAAM,IAAM,IAAMlzB,KAAK1J,KAAKW,GAAGnC,KAAKmL,KAAO,IAAMD,KAAK9I,MAAMD,EAAI,GAC5E,OAAOi8B,EAAM,IAAMlzB,KAAK3L,cAG1Bi+B,EAAYx8B,QAAU,SAAkBP,EAAKU,GAC3C,KAAMA,GAAO,GAAKA,GAAOV,EAAIJ,QAAQC,MAAS,MAAM,IAAIu5B,WAAW,YAAc14B,EAAM,iBAGvF,IAFA,IAAIs8B,EAAO,GACPp3B,EAAQ,EAAG9G,EAAe4B,EACrBK,EAAOf,IAAO,CACrB,IAAIuB,EAAMR,EAAKnB,QAAQ45B,UAAU16B,GAC3B6C,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACfytB,EAAM9+B,EAAeqR,EAEzB,GADA6sB,EAAK33B,KAAKtE,EAAMY,EAAOiE,EAAQuK,IAC1BytB,EAAO,MAEZ,IADA78B,EAAOA,EAAKmH,MAAMvG,IACTkK,OAAU,MACnB/M,EAAe8+B,EAAM,EACrBh4B,GAASuK,EAAS,EAEpB,OAAO,IAAI4sB,EAAYr8B,EAAKs8B,EAAMl+B,IAGpCi+B,EAAYc,cAAgB,SAAwB79B,EAAKU,GACvD,IAAK,IAAIgB,EAAI,EAAGA,EAAIo8B,EAAah5B,OAAQpD,IAAK,CAC5C,IAAIq8B,EAASD,EAAap8B,GAC1B,GAAIq8B,EAAOr9B,KAAOA,GAAOq9B,EAAO/9B,KAAOA,EAAO,OAAO+9B,EAEvD,IAAIjpB,EAASgpB,EAAaE,GAAmBjB,EAAYx8B,QAAQP,EAAKU,GAEtE,OADAs9B,GAAmBA,EAAkB,GAAKC,EACnCnpB,GAGT7L,OAAO+wB,iBAAkB+C,EAAY7zB,UAAW+zB,GAEhD,IAAIa,EAAe,GAAIE,EAAkB,EAAGC,EAAmB,GAI3DP,EAAY,SAAmBv6B,EAAOC,EAAKvC,GAM7C4J,KAAKtH,MAAQA,EAGbsH,KAAKrH,IAAMA,EAEXqH,KAAK5J,MAAQA,GAGXq9B,EAAyB,CAAEt4B,MAAO,CAAE+yB,cAAc,GAAOn1B,IAAK,CAAEm1B,cAAc,GAAOh5B,OAAQ,CAAEg5B,cAAc,GAAOnxB,WAAY,CAAEmxB,cAAc,GAAOjxB,SAAU,CAAEixB,cAAc,IAGrLuF,EAAuBt4B,MAAMuxB,IAAM,WAAc,OAAO1sB,KAAKtH,MAAM9D,OAAOoL,KAAK5J,MAAQ,IAEvFq9B,EAAuB16B,IAAI2zB,IAAM,WAAc,OAAO1sB,KAAKrH,IAAInD,MAAMwK,KAAK5J,MAAQ,IAGlFq9B,EAAuBv+B,OAAOw3B,IAAM,WAAc,OAAO1sB,KAAKtH,MAAMpC,KAAK0J,KAAK5J,QAE9Eq9B,EAAuB12B,WAAW2vB,IAAM,WAAc,OAAO1sB,KAAKtH,MAAMxB,MAAM8I,KAAK5J,QAEnFq9B,EAAuBx2B,SAASyvB,IAAM,WAAc,OAAO1sB,KAAKrH,IAAIR,WAAW6H,KAAK5J,QAEpFoI,OAAO+wB,iBAAkB0D,EAAUx0B,UAAWg1B,GAE9C,IAAIC,EAAal1B,OAAOlE,OAAO,MAc3B+pB,EAAO,SAAcvvB,EAAM0G,EAAOrG,EAASwP,GAG7C3E,KAAKlL,KAAOA,EAMZkL,KAAKxE,MAAQA,EAIbwE,KAAK7K,QAAUA,GAAW64B,EAASl6B,MAKnCkM,KAAK2E,MAAQA,GAAS2f,EAAK+L,MAGzBsD,EAAuB,CAAEz9B,SAAU,CAAEg4B,cAAc,GAAOt3B,WAAY,CAAEs3B,cAAc,GAAOzX,YAAa,CAAEyX,cAAc,GAAOz3B,WAAY,CAAEy3B,cAAc,GAAOx3B,UAAW,CAAEw3B,cAAc,GAAOh1B,QAAS,CAAEg1B,cAAc,GAAOv3B,YAAa,CAAEu3B,cAAc,GAAOt1B,cAAe,CAAEs1B,cAAc,GAAOhzB,SAAU,CAAEgzB,cAAc,GAAO9sB,OAAQ,CAAE8sB,cAAc,GAAOzH,OAAQ,CAAEyH,cAAc,GAAO/3B,OAAQ,CAAE+3B,cAAc,IAW3ayF,EAAqBz9B,SAASw2B,IAAM,WAAc,OAAO1sB,KAAKymB,OAAS,EAAI,EAAIzmB,KAAK7K,QAAQC,MAI5Fu+B,EAAqB/8B,WAAW81B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQyB,YAKxEytB,EAAK5lB,UAAUhB,MAAQ,SAAgBvG,GAAS,OAAO8I,KAAK7K,QAAQsI,MAAMvG,IAI1EmtB,EAAK5lB,UAAUmwB,WAAa,SAAqB13B,GAAS,OAAO8I,KAAK7K,QAAQy5B,WAAW13B,IAKzFmtB,EAAK5lB,UAAUU,QAAU,SAAkBgM,GAAKnL,KAAK7K,QAAQgK,QAAQgM,IAUrEkZ,EAAK5lB,UAAU/C,aAAe,SAAuB/F,EAAMD,EAAIyV,EAAG1F,QAC5C,IAAbA,IAAsBA,EAAW,GAExCzF,KAAK7K,QAAQuG,aAAa/F,EAAMD,EAAIyV,EAAG1F,EAAUzF,OAMnDqkB,EAAK5lB,UAAUoqB,YAAc,SAAsB1d,GACjDnL,KAAKtE,aAAa,EAAGsE,KAAK7K,QAAQC,KAAM+V,IAM1CwoB,EAAqBld,YAAYiW,IAAM,WAAc,OAAO1sB,KAAK2X,YAAY,EAAG3X,KAAK7K,QAAQC,KAAM,KAOnGivB,EAAK5lB,UAAUkZ,YAAc,SAAsBhiB,EAAMD,EAAIoL,EAAgBstB,GAC3E,OAAOpuB,KAAK7K,QAAQwiB,YAAYhiB,EAAMD,EAAIoL,EAAgBstB,IAM5DuF,EAAqBl9B,WAAWi2B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQsB,YAKxEk9B,EAAqBj9B,UAAUg2B,IAAM,WAAc,OAAO1sB,KAAK7K,QAAQuB,WAIvE2tB,EAAK5lB,UAAU+I,GAAK,SAAa6mB,GAC/B,OAAOruB,MAAQquB,GAAUruB,KAAK0tB,WAAWW,IAAUruB,KAAK7K,QAAQqS,GAAG6mB,EAAMl5B,UAM3EkvB,EAAK5lB,UAAUivB,WAAa,SAAqBW,GAC/C,OAAOruB,KAAKrE,UAAU0yB,EAAMv5B,KAAMu5B,EAAM7yB,MAAO6yB,EAAM1pB,QAMvD0f,EAAK5lB,UAAU9C,UAAY,SAAoB7G,EAAM0G,EAAOmJ,GAC1D,OAAO3E,KAAKlL,MAAQA,GAClB06B,EAAYxvB,KAAKxE,MAAOA,GAAS1G,EAAK8+B,cAAgBF,IACtDpP,EAAK6L,QAAQnwB,KAAK2E,MAAOA,GAAS2f,EAAK+L,OAM3ChM,EAAK5lB,UAAUlE,KAAO,SAAepF,GAGnC,YAFmB,IAAZA,IAAqBA,EAAU,MAElCA,GAAW6K,KAAK7K,QAAkB6K,KAC/B,IAAIA,KAAKnB,YAAYmB,KAAKlL,KAAMkL,KAAKxE,MAAOrG,EAAS6K,KAAK2E,QAMnE0f,EAAK5lB,UAAU+G,KAAO,SAAeb,GACnC,OAAOA,GAAS3E,KAAK2E,MAAQ3E,KAAO,IAAIA,KAAKnB,YAAYmB,KAAKlL,KAAMkL,KAAKxE,MAAOwE,KAAK7K,QAASwP,IAOhG0f,EAAK5lB,UAAU8vB,IAAM,SAAc54B,EAAMD,GACvC,OAAY,GAARC,GAAaD,GAAMsK,KAAK7K,QAAQC,KAAe4K,KAC5CA,KAAKzF,KAAKyF,KAAK7K,QAAQo5B,IAAI54B,EAAMD,KAM1C2uB,EAAK5lB,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIm+B,GAI/C,QAHc,IAAPn+B,IAAgBA,EAAKsK,KAAK7K,QAAQC,WACf,IAAnBy+B,IAA4BA,GAAiB,GAEhDl+B,GAAQD,EAAM,OAAO46B,EAAMx8B,MAE/B,IAAI4E,EAAQsH,KAAKlK,QAAQH,GAAOgD,EAAMqH,KAAKlK,QAAQJ,GAC/CU,EAAQy9B,EAAiB,EAAIn7B,EAAM4U,YAAY5X,GAC/CyF,EAAQzC,EAAMyC,MAAM/E,GACpBjB,EADmCuD,EAAMpC,KAAKF,GAC/BjB,QAAQo5B,IAAI71B,EAAMzC,IAAMkF,EAAOxC,EAAI1C,IAAMkF,GAC5D,OAAO,IAAIm1B,EAAMn7B,EAASuD,EAAMtC,MAAQA,EAAOuC,EAAIvC,MAAQA,IAU7DiuB,EAAK5lB,UAAUmS,QAAU,SAAoBjb,EAAMD,EAAID,GACrD,OAAOmb,EAAQ5Q,KAAKlK,QAAQH,GAAOqK,KAAKlK,QAAQJ,GAAKD,IAKvD4uB,EAAK5lB,UAAUiT,OAAS,SAAiBzb,GACvC,IAAK,IAAIK,EAAO0J,OAAQ,CACtB,IAAIlJ,EAAMR,EAAKnB,QAAQ45B,UAAU94B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OAEnB,KADApP,EAAOA,EAAKs4B,WAAW13B,IACV,OAAO,KACpB,GAAIwO,GAAUzP,GAAOK,EAAK8K,OAAU,OAAO9K,EAC3CL,GAAOyP,EAAS,IAQpB2e,EAAK5lB,UAAU8G,WAAa,SAAqBtP,GAC/C,IAAIa,EAAMkJ,KAAK7K,QAAQ45B,UAAU94B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACnB,MAAO,CAACpP,KAAM0J,KAAK7K,QAAQy5B,WAAW13B,GAAQA,MAAOA,EAAOwO,OAAQA,IAOtE2e,EAAK5lB,UAAUq1B,YAAc,SAAsB79B,GACjD,GAAW,GAAPA,EAAY,MAAO,CAACK,KAAM,KAAMY,MAAO,EAAGwO,OAAQ,GACtD,IAAI5O,EAAMkJ,KAAK7K,QAAQ45B,UAAU94B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACnB,GAAIA,EAASzP,EAAO,MAAO,CAACK,KAAM0J,KAAK7K,QAAQsI,MAAMvG,GAAQA,MAAOA,EAAOwO,OAAQA,GACnF,IAAIpP,EAAO0J,KAAK7K,QAAQsI,MAAMvG,EAAQ,GACtC,MAAO,CAACZ,KAAMA,EAAMY,MAAOA,EAAQ,EAAGwO,OAAQA,EAASpP,EAAKJ,WAM9DmuB,EAAK5lB,UAAU3I,QAAU,SAAkBG,GAAO,OAAOq8B,EAAYc,cAAcpzB,KAAM/J,IAEzFouB,EAAK5lB,UAAU0yB,eAAiB,SAAyBl7B,GAAO,OAAOq8B,EAAYx8B,QAAQkK,KAAM/J,IAKjGouB,EAAK5lB,UAAUs1B,aAAe,SAAuBp+B,EAAMD,EAAIZ,GAC7D,IAAIsI,GAAQ,EAKZ,OAJI1H,EAAKC,GAAQqK,KAAKtE,aAAa/F,EAAMD,GAAI,SAAUY,GAErD,OADIxB,EAAK8Q,QAAQtP,EAAKqO,SAAUvH,GAAQ,IAChCA,KAEHA,GAKTu2B,EAAqBz6B,QAAQwzB,IAAM,WAAc,OAAO1sB,KAAKlL,KAAKoE,SAKlEy6B,EAAqBh9B,YAAY+1B,IAAM,WAAc,OAAO1sB,KAAKlL,KAAK6B,aAItEg9B,EAAqB/6B,cAAc8zB,IAAM,WAAc,OAAO1sB,KAAKlL,KAAK8D,eAKxE+6B,EAAqBz4B,SAASwxB,IAAM,WAAc,OAAO1sB,KAAKlL,KAAKoG,UAInEy4B,EAAqBvyB,OAAOsrB,IAAM,WAAc,OAAO1sB,KAAKlL,KAAKsM,QAIjEuyB,EAAqBlN,OAAOiG,IAAM,WAAc,OAAO1sB,KAAKlL,KAAK2xB,QAQjEkN,EAAqBx9B,OAAOu2B,IAAM,WAAc,OAAO1sB,KAAKlL,KAAKqB,QAKjEkuB,EAAK5lB,UAAUC,SAAW,WACxB,GAAIsB,KAAKlL,KAAKC,KAAKi/B,cAAiB,OAAOh0B,KAAKlL,KAAKC,KAAKi/B,cAAch0B,MACxE,IAAIC,EAAOD,KAAKlL,KAAKmL,KAGrB,OAFID,KAAK7K,QAAQC,OACb6K,GAAQ,IAAMD,KAAK7K,QAAQg6B,gBAAkB,KAC1C8E,EAAUj0B,KAAK2E,MAAO1E,IAK/BokB,EAAK5lB,UAAUrG,eAAiB,SAAyBlB,GACvD,IAAIW,EAAQmI,KAAKlL,KAAK6b,aAAaujB,cAAcl0B,KAAK7K,QAAS,EAAG+B,GAClE,IAAKW,EAAS,MAAM,IAAIkM,MAAM,wDAC9B,OAAOlM,GASTwsB,EAAK5lB,UAAU7E,WAAa,SAAqBjE,EAAMD,EAAIy+B,EAAah5B,EAAOpC,QACtD,IAAhBo7B,IAAyBA,EAAcnG,EAASl6B,YACtC,IAAVqH,IAAmBA,EAAQ,QACnB,IAARpC,IAAiBA,EAAMo7B,EAAYv9B,YAE1C,IAAIw9B,EAAMp0B,KAAK5H,eAAezC,GAAMu+B,cAAcC,EAAah5B,EAAOpC,GAClEs7B,EAAMD,GAAOA,EAAIF,cAAcl0B,KAAK7K,QAASO,GACjD,IAAK2+B,IAAQA,EAAIl6B,SAAY,OAAO,EACpC,IAAK,IAAIlD,EAAIkE,EAAOlE,EAAI8B,EAAK9B,IAAO,IAAK+I,KAAKlL,KAAKw/B,YAAYH,EAAY12B,MAAMxG,GAAG0N,OAAU,OAAO,EACrG,OAAO,GAMT0f,EAAK5lB,UAAUpG,eAAiB,SAAyB1C,EAAMD,EAAIZ,EAAM6P,GACvE,GAAIA,IAAU3E,KAAKlL,KAAKw/B,YAAY3vB,GAAU,OAAO,EACrD,IAAIxJ,EAAQ6E,KAAK5H,eAAezC,GAAMuE,UAAUpF,GAC5CiE,EAAMoC,GAASA,EAAM+4B,cAAcl0B,KAAK7K,QAASO,GACrD,QAAOqD,GAAMA,EAAIoB,UAQnBkqB,EAAK5lB,UAAU81B,UAAY,SAAoBlG,GAC7C,OAAIA,EAAMl5B,QAAQC,KAAe4K,KAAKpG,WAAWoG,KAAKpJ,WAAYoJ,KAAKpJ,WAAYy3B,EAAMl5B,SAC3E6K,KAAKlL,KAAK6E,kBAAkB00B,EAAMv5B,OAMlDuvB,EAAK5lB,UAAUwK,MAAQ,WACrB,IAAKjJ,KAAKlL,KAAKmd,aAAajS,KAAK7K,SAC7B,MAAM,IAAIw5B,WAAY,4BAA+B3uB,KAAKlL,KAAS,KAAI,KAAQkL,KAAK7K,QAAQuJ,WAAWjJ,MAAM,EAAG,KAEpH,IADA,IAAI8E,EAAO+pB,EAAK+L,KACPp5B,EAAI,EAAGA,EAAI+I,KAAK2E,MAAMtK,OAAQpD,IAAOsD,EAAOyF,KAAK2E,MAAM1N,GAAG44B,SAASt1B,GAC5E,IAAK+pB,EAAK6L,QAAQ51B,EAAMyF,KAAK2E,OACzB,MAAM,IAAIgqB,WAAY,wCAA2C3uB,KAAKlL,KAAS,KAAI,KAAQkL,KAAK2E,MAAM3O,KAAI,SAAUw+B,GAAK,OAAOA,EAAE1/B,KAAKmL,SAC3ID,KAAK7K,QAAQgK,SAAQ,SAAU7I,GAAQ,OAAOA,EAAK2S,YAKrDob,EAAK5lB,UAAU4W,OAAS,WACtB,IAAIjJ,EAAM,CAACtX,KAAMkL,KAAKlL,KAAKmL,MAC3B,IAAK,IAAI2pB,KAAK5pB,KAAKxE,MAAO,CACxB4Q,EAAI5Q,MAAQwE,KAAKxE,MACjB,MAMF,OAJIwE,KAAK7K,QAAQC,OACbgX,EAAIjX,QAAU6K,KAAK7K,QAAQkgB,UAC3BrV,KAAK2E,MAAMtK,SACX+R,EAAIzH,MAAQ3E,KAAK2E,MAAM3O,KAAI,SAAU6a,GAAK,OAAOA,EAAEwE,aAChDjJ,GAKTiY,EAAK+K,SAAW,SAAmB5tB,EAAQ0uB,GACzC,IAAKA,EAAQ,MAAM,IAAIvB,WAAW,mCAClC,IAAIhqB,EAAQ,KACZ,GAAIurB,EAAKvrB,MAAO,CACd,IAAKwB,MAAMC,QAAQ8pB,EAAKvrB,OAAU,MAAM,IAAIgqB,WAAW,uCACvDhqB,EAAQurB,EAAKvrB,MAAM3O,IAAIwL,EAAOizB,cAEhC,GAAiB,QAAbvE,EAAKp7B,KAAgB,CACvB,GAAwB,iBAAbo7B,EAAKlvB,KAAoB,MAAM,IAAI2tB,WAAW,6BACzD,OAAOntB,EAAOR,KAAKkvB,EAAKlvB,KAAM2D,GAEhC,IAAIxP,EAAU64B,EAASoB,SAAS5tB,EAAQ0uB,EAAK/6B,SAC7C,OAAOqM,EAAOjG,SAAS20B,EAAKp7B,MAAMwF,OAAO41B,EAAK10B,MAAOrG,EAASwP,IAGhEnG,OAAO+wB,iBAAkBlL,EAAK5lB,UAAWk1B,GAEzC,IAAIe,EAAyB,SAAUrQ,GACrC,SAASqQ,EAAS5/B,EAAM0G,EAAOrG,EAASwP,GAGtC,GAFA0f,EAAK1lB,KAAKqB,KAAMlL,EAAM0G,EAAO,KAAMmJ,IAE9BxP,EAAW,MAAM,IAAIw5B,WAAW,oCAErC3uB,KAAKgB,KAAO7L,EAGTkvB,IAAOqQ,EAASpyB,UAAY+hB,GACjCqQ,EAASj2B,UAAYD,OAAOlE,OAAQ+pB,GAAQA,EAAK5lB,WACjDi2B,EAASj2B,UAAUI,YAAc61B,EAEjC,IAAIjE,EAAuB,CAAEha,YAAa,CAAEyX,cAAc,GAAOh4B,SAAU,CAAEg4B,cAAc,IA0C3F,OAxCAwG,EAASj2B,UAAUC,SAAW,WAC5B,OAAIsB,KAAKlL,KAAKC,KAAKi/B,cAAwBh0B,KAAKlL,KAAKC,KAAKi/B,cAAch0B,MACjEi0B,EAAUj0B,KAAK2E,MAAOsU,KAAKC,UAAUlZ,KAAKgB,QAGnDyvB,EAAqBha,YAAYiW,IAAM,WAAc,OAAO1sB,KAAKgB,MAEjE0zB,EAASj2B,UAAUkZ,YAAc,SAAsBhiB,EAAMD,GAAM,OAAOsK,KAAKgB,KAAKvL,MAAME,EAAMD,IAEhG+6B,EAAqBv6B,SAASw2B,IAAM,WAAc,OAAO1sB,KAAKgB,KAAK3G,QAEnEq6B,EAASj2B,UAAU+G,KAAO,SAAeb,GACvC,OAAOA,GAAS3E,KAAK2E,MAAQ3E,KAAO,IAAI00B,EAAS10B,KAAKlL,KAAMkL,KAAKxE,MAAOwE,KAAKgB,KAAM2D,IAGrF+vB,EAASj2B,UAAU6vB,SAAW,SAAmBttB,GAC/C,OAAIA,GAAQhB,KAAKgB,KAAehB,KACzB,IAAI00B,EAAS10B,KAAKlL,KAAMkL,KAAKxE,MAAOwF,EAAMhB,KAAK2E,QAGxD+vB,EAASj2B,UAAU8vB,IAAM,SAAc54B,EAAMD,GAI3C,YAHc,IAATC,IAAkBA,EAAO,QAClB,IAAPD,IAAgBA,EAAKsK,KAAKgB,KAAK3G,QAExB,GAAR1E,GAAaD,GAAMsK,KAAKgB,KAAK3G,OAAiB2F,KAC3CA,KAAKsuB,SAAStuB,KAAKgB,KAAKvL,MAAME,EAAMD,KAG7Cg/B,EAASj2B,UAAU+I,GAAK,SAAa6mB,GACnC,OAAOruB,KAAK0tB,WAAWW,IAAUruB,KAAKgB,MAAQqtB,EAAMrtB,MAGtD0zB,EAASj2B,UAAU4W,OAAS,WAC1B,IAAI8V,EAAO9G,EAAK5lB,UAAU4W,OAAO1W,KAAKqB,MAEtC,OADAmrB,EAAKnqB,KAAOhB,KAAKgB,KACVmqB,GAGT3sB,OAAO+wB,iBAAkBmF,EAASj2B,UAAWgyB,GAEtCiE,EAvDmB,CAwD1BrQ,GAEF,SAAS4P,EAAUtvB,EAAOuuB,GACxB,IAAK,IAAIj8B,EAAI0N,EAAMtK,OAAS,EAAGpD,GAAK,EAAGA,IACnCi8B,EAAMvuB,EAAM1N,GAAGnC,KAAKmL,KAAO,IAAMizB,EAAM,IAC3C,OAAOA,EAOT,IAAIyB,EAAe,SAAsBx6B,GAGvC6F,KAAK7F,SAAWA,EAChB6F,KAAK+yB,KAAO,GACZ/yB,KAAK40B,UAAY,IAGfC,EAAuB,CAAEj8B,cAAe,CAAEs1B,cAAc,GAAO1qB,YAAa,CAAE0qB,cAAc,GAAOp2B,UAAW,CAAEo2B,cAAc,IAElIyG,EAAajsB,MAAQ,SAAgB8f,EAAQsM,GAC3C,IAAIC,EAAS,IAAIC,EAAYxM,EAAQsM,GACrC,GAAmB,MAAfC,EAAOhC,KAAgB,OAAO4B,EAAa7gC,MAC/C,IAAImhC,EAAOC,EAAUH,GACjBA,EAAOhC,MAAQgC,EAAOnF,IAAI,4BAC9B,IAAI/3B,EAuVN,SAAas9B,GACX,IAAIC,EAAU52B,OAAOlE,OAAO,MAC5B,OAAO+6B,EAAQC,EAASH,EAAK,IAE7B,SAASE,EAAQE,GACf,IAAIC,EAAM,GACVD,EAAOp2B,SAAQ,SAAU7I,GACvB6+B,EAAI7+B,GAAM6I,SAAQ,SAAUrI,GAC1B,IAAI2+B,EAAO3+B,EAAI2+B,KACX//B,EAAKoB,EAAIpB,GAEb,GAAK+/B,EAAL,CACA,IAAIC,EAAQF,EAAIrV,QAAQsV,GAAO3F,EAAM4F,GAAS,GAAKF,EAAIE,EAAQ,GAC/DJ,EAASH,EAAKz/B,GAAIyJ,SAAQ,SAAU7I,GAC7Bw5B,GAAO0F,EAAI56B,KAAK66B,EAAM3F,EAAM,KACP,GAAtBA,EAAI3P,QAAQ7pB,IAAew5B,EAAIl1B,KAAKtE,aAK9C,IADA,IAAI3C,EAAQyhC,EAAQG,EAAOz7B,KAAK,MAAQ,IAAI66B,EAAaY,EAAOpV,QAAQgV,EAAI96B,OAAS,IAAM,GAClFpD,EAAI,EAAGA,EAAIu+B,EAAIn7B,OAAQpD,GAAK,EAAG,CACtC,IAAI0+B,EAAWH,EAAIv+B,EAAI,GAAG6oB,KAAK8V,GAC/BjiC,EAAMo/B,KAAKn4B,KAAK46B,EAAIv+B,GAAIm+B,EAAQO,EAAS77B,KAAK,OAASu7B,EAAQM,IAEjE,OAAOhiC,GA/WGkiC,CAkQd,SAAaZ,GACX,IAAIE,EAAM,CAAC,IAEX,OADAW,EAAQC,EAAQd,EAAM,GAAI3+B,KACnB6+B,EAEP,SAAS7+B,IAAS,OAAO6+B,EAAIv6B,KAAK,IAAM,EACxC,SAAS7C,EAAKpC,EAAMD,EAAI+/B,GACtB,IAAI19B,EAAO,CAAC09B,KAAMA,EAAM//B,GAAIA,GAE5B,OADAy/B,EAAIx/B,GAAMiF,KAAK7C,GACRA,EAET,SAAS+9B,EAAQE,EAAOtgC,GAAMsgC,EAAM72B,SAAQ,SAAUpH,GAAQ,OAAOA,EAAKrC,GAAKA,KAE/E,SAASqgC,EAAQd,EAAMt/B,GACrB,GAAiB,UAAbs/B,EAAKngC,KACP,OAAOmgC,EAAKgB,MAAMrqB,QAAO,SAAU4pB,EAAKP,GAAQ,OAAOO,EAAIvI,OAAO8I,EAAQd,EAAMt/B,MAAW,IACtF,GAAiB,OAAbs/B,EAAKngC,KACd,IAAK,IAAImC,EAAI,GAAIA,IAAK,CACpB,IAAI87B,EAAOgD,EAAQd,EAAKgB,MAAMh/B,GAAItB,GAClC,GAAIsB,GAAKg+B,EAAKgB,MAAM57B,OAAS,EAAK,OAAO04B,EACzC+C,EAAQ/C,EAAMp9B,EAAOW,SAElB,IAAiB,QAAb2+B,EAAKngC,KAAgB,CAC9B,IAAIohC,EAAO5/B,IAGX,OAFAyB,EAAKpC,EAAMugC,GACXJ,EAAQC,EAAQd,EAAKA,KAAMiB,GAAOA,GAC3B,CAACn+B,EAAKm+B,IACR,GAAiB,QAAbjB,EAAKngC,KAAgB,CAC9B,IAAIqhC,EAAS7/B,IAGb,OAFAw/B,EAAQC,EAAQd,EAAKA,KAAMt/B,GAAOwgC,GAClCL,EAAQC,EAAQd,EAAKA,KAAMkB,GAASA,GAC7B,CAACp+B,EAAKo+B,IACR,GAAiB,OAAblB,EAAKngC,KACd,MAAO,CAACiD,EAAKpC,IAAOs3B,OAAO8I,EAAQd,EAAKA,KAAMt/B,IACzC,GAAiB,SAAbs/B,EAAKngC,KAAiB,CAE/B,IADA,IAAIshC,EAAMzgC,EACDqF,EAAM,EAAGA,EAAMi6B,EAAK9yB,IAAKnH,IAAO,CACvC,IAAIq7B,EAAS//B,IACbw/B,EAAQC,EAAQd,EAAKA,KAAMmB,GAAMC,GACjCD,EAAMC,EAER,IAAiB,GAAbpB,EAAK3zB,IACPw0B,EAAQC,EAAQd,EAAKA,KAAMmB,GAAMA,QAEjC,IAAK,IAAI74B,EAAM03B,EAAK9yB,IAAK5E,EAAM03B,EAAK3zB,IAAK/D,IAAO,CAC9C,IAAI+4B,EAAShgC,IACbyB,EAAKq+B,EAAKE,GACVR,EAAQC,EAAQd,EAAKA,KAAMmB,GAAME,GACjCF,EAAME,EAGV,MAAO,CAACv+B,EAAKq+B,IACR,GAAiB,QAAbnB,EAAKngC,KACd,MAAO,CAACiD,EAAKpC,EAAM,KAAMs/B,EAAK12B,UAvTlB42B,CAAIF,IAEpB,OAiXF,SAA0Bp9B,EAAOk9B,GAC/B,IAAK,IAAI99B,EAAI,EAAGs/B,EAAO,CAAC1+B,GAAQZ,EAAIs/B,EAAKl8B,OAAQpD,IAAK,CAEpD,IADA,IAAItD,EAAQ4iC,EAAKt/B,GAAIu/B,GAAQ7iC,EAAMwG,SAAUwH,EAAQ,GAC5CiS,EAAI,EAAGA,EAAIjgB,EAAMo/B,KAAK14B,OAAQuZ,GAAK,EAAG,CAC7C,IAAItd,EAAO3C,EAAMo/B,KAAKnf,GAAImf,EAAOp/B,EAAMo/B,KAAKnf,EAAI,GAChDjS,EAAM/G,KAAKtE,EAAK2J,OACZu2B,GAAUlgC,EAAK8K,QAAU9K,EAAK0B,qBAAuBw+B,GAAO,IACrC,GAAvBD,EAAKpW,QAAQ4S,IAAewD,EAAK37B,KAAKm4B,GAExCyD,GAAQzB,EAAOnF,IAAI,+BAAiCjuB,EAAM7H,KAAK,MAAQ,mFA3X7E28B,CAAiB5+B,EAAOk9B,GACjBl9B,GAMT88B,EAAal2B,UAAUvE,UAAY,SAAoBpF,GACrD,IAAK,IAAImC,EAAI,EAAGA,EAAI+I,KAAK+yB,KAAK14B,OAAQpD,GAAK,EACvC,GAAI+I,KAAK+yB,KAAK97B,IAAMnC,EAAQ,OAAOkL,KAAK+yB,KAAK97B,EAAI,GACrD,OAAO,MAMT09B,EAAal2B,UAAUy1B,cAAgB,SAAwBwC,EAAMv7B,EAAOpC,QACzD,IAAVoC,IAAmBA,EAAQ,QACnB,IAARpC,IAAiBA,EAAM29B,EAAK9/B,YAGnC,IADA,IAAIw/B,EAAMp2B,KACD/I,EAAIkE,EAAOi7B,GAAOn/B,EAAI8B,EAAK9B,IAChCm/B,EAAMA,EAAIl8B,UAAUw8B,EAAKj5B,MAAMxG,GAAGnC,MACtC,OAAOshC,GAGTvB,EAAqBj8B,cAAc8zB,IAAM,WACvC,IAAInzB,EAAQyG,KAAK+yB,KAAK,GACtB,QAAOx5B,GAAQA,EAAM2B,UAMvB25B,EAAqBrxB,YAAYkpB,IAAM,WACrC,IAAK,IAAIz1B,EAAI,EAAGA,EAAI+I,KAAK+yB,KAAK14B,OAAQpD,GAAK,EAAG,CAC5C,IAAInC,EAAOkL,KAAK+yB,KAAK97B,GACrB,IAAMnC,EAAKsM,SAAUtM,EAAKkD,mBAAuB,OAAOlD,IAI5D6/B,EAAal2B,UAAUk4B,WAAa,SAAqBtI,GACvD,IAAK,IAAIp3B,EAAI,EAAGA,EAAI+I,KAAK+yB,KAAK14B,OAAQpD,GAAK,EACvC,IAAK,IAAI2c,EAAI,EAAGA,EAAIya,EAAM0E,KAAK14B,OAAQuZ,GAAK,EAC1C,GAAI5T,KAAK+yB,KAAK97B,IAAMo3B,EAAM0E,KAAKnf,GAAM,OAAO,EAClD,OAAO,GAUT+gB,EAAal2B,UAAUm4B,WAAa,SAAqBphC,EAAOqhC,EAAO95B,QACpD,IAAV85B,IAAmBA,GAAQ,QACZ,IAAf95B,IAAwBA,EAAa,GAE5C,IAAIysB,EAAO,CAACxpB,MAgBZ,OAfA,SAAS4nB,EAAO/vB,EAAOwB,GACrB,IAAIy9B,EAAWj/B,EAAMq8B,cAAc1+B,EAAOuH,GAC1C,GAAI+5B,KAAcD,GAASC,EAAS38B,UAChC,OAAO6zB,EAASr4B,KAAK0D,EAAMrD,KAAI,SAAU+gC,GAAM,OAAOA,EAAGx+B,oBAE7D,IAAK,IAAItB,EAAI,EAAGA,EAAIY,EAAMk7B,KAAK14B,OAAQpD,GAAK,EAAG,CAC7C,IAAInC,EAAO+C,EAAMk7B,KAAK97B,GAAI87B,EAAOl7B,EAAMk7B,KAAK97B,EAAI,GAChD,IAAMnC,EAAKsM,SAAUtM,EAAKkD,qBAA8C,GAAvBwxB,EAAKrJ,QAAQ4S,GAAa,CACzEvJ,EAAK5uB,KAAKm4B,GACV,IAAI31B,EAAQwqB,EAAOmL,EAAM15B,EAAM4zB,OAAOn4B,IACtC,GAAIsI,EAAS,OAAOA,IAKnBwqB,CAAO5nB,KAAM,KAQtB20B,EAAal2B,UAAUxE,aAAe,SAAuBvF,GAC3D,IAAK,IAAIuC,EAAI,EAAGA,EAAI+I,KAAK40B,UAAUv6B,OAAQpD,GAAK,EAC5C,GAAI+I,KAAK40B,UAAU39B,IAAMvC,EAAU,OAAOsL,KAAK40B,UAAU39B,EAAI,GACjE,IAAI+/B,EAAWh3B,KAAKi3B,gBAAgBviC,GAEpC,OADAsL,KAAK40B,UAAUh6B,KAAKlG,EAAQsiC,GACrBA,GAGTrC,EAAal2B,UAAUw4B,gBAAkB,SAA0BviC,GAEjE,IADA,IAAI80B,EAAOhrB,OAAOlE,OAAO,MAAO48B,EAAS,CAAC,CAACr/B,MAAOmI,KAAMlL,KAAM,KAAMqiC,IAAK,OAClED,EAAO78B,QAAQ,CACpB,IAAIq0B,EAAUwI,EAAO/sB,QAAStS,EAAQ62B,EAAQ72B,MAC9C,GAAIA,EAAMqC,UAAUxF,GAAS,CAE3B,IADA,IAAI2V,EAAS,GACJ+B,EAAMsiB,EAAStiB,EAAItX,KAAMsX,EAAMA,EAAI+qB,IACxC9sB,EAAOzP,KAAKwR,EAAItX,MACpB,OAAOuV,EAAO2N,UAEhB,IAAK,IAAI/gB,EAAI,EAAGA,EAAIY,EAAMk7B,KAAK14B,OAAQpD,GAAK,EAAG,CAC7C,IAAInC,EAAO+C,EAAMk7B,KAAK97B,GACjBnC,EAAK2xB,QAAW3xB,EAAKkD,oBAAwBlD,EAAKmL,QAAQupB,GAAWkF,EAAQ55B,OAAQ+C,EAAMk7B,KAAK97B,EAAI,GAAGkD,WAC1G+8B,EAAOt8B,KAAK,CAAC/C,MAAO/C,EAAK6b,aAAc7b,KAAMA,EAAMqiC,IAAKzI,IACxDlF,EAAK10B,EAAKmL,OAAQ,MAS1B40B,EAAqB/8B,UAAU40B,IAAM,WACnC,OAAO1sB,KAAK+yB,KAAK14B,QAAU,GAM7Bs6B,EAAal2B,UAAU1G,KAAO,SAAe8Y,GAC3C,IAAI5Z,EAAI4Z,GAAK,EACb,GAAI5Z,GAAK+I,KAAK+yB,KAAK14B,OAAU,MAAM,IAAIs0B,WAAY,cAAgB9d,EAAI,iCACvE,MAAO,CAAC/b,KAAMkL,KAAK+yB,KAAK97B,GAAI87B,KAAM/yB,KAAK+yB,KAAK97B,EAAI,KAGlD09B,EAAal2B,UAAUC,SAAW,WAChC,IAAI8qB,EAAO,GAOX,OANA,SAAS4N,EAAK5C,GACZhL,EAAK5uB,KAAK45B,GACV,IAAK,IAAIv9B,EAAI,EAAGA,EAAIu9B,EAAEzB,KAAK14B,OAAQpD,GAAK,GACJ,GAA5BuyB,EAAKrJ,QAAQqU,EAAEzB,KAAK97B,KAAamgC,EAAK5C,EAAEzB,KAAK97B,IAEvDmgC,CAAKp3B,MACEwpB,EAAKxzB,KAAI,SAAUw+B,EAAGv9B,GAE3B,IADA,IAAIu+B,EAAMv+B,GAAKu9B,EAAEr6B,SAAW,IAAM,KAAO,IAChCa,EAAM,EAAGA,EAAMw5B,EAAEzB,KAAK14B,OAAQW,GAAO,EAC1Cw6B,IAAQx6B,EAAM,KAAO,IAAMw5B,EAAEzB,KAAK/3B,GAAKiF,KAAO,KAAOupB,EAAKrJ,QAAQqU,EAAEzB,KAAK/3B,EAAM,IACnF,OAAOw6B,KACN17B,KAAK,OAGV0E,OAAO+wB,iBAAkBoF,EAAal2B,UAAWo2B,GAEjDF,EAAa7gC,MAAQ,IAAI6gC,GAAa,GAEtC,IAAIK,EAAc,SAAqBxM,EAAQsM,GAC7C90B,KAAKwoB,OAASA,EACdxoB,KAAK80B,UAAYA,EACjB90B,KAAKke,OAAS,KACdle,KAAK/J,IAAM,EACX+J,KAAKq3B,OAAS7O,EAAOxvB,MAAM,kBACgB,IAAvCgH,KAAKq3B,OAAOr3B,KAAKq3B,OAAOh9B,OAAS,IAAY2F,KAAKq3B,OAAOC,MACvC,IAAlBt3B,KAAKq3B,OAAO,IAAYr3B,KAAKq3B,OAAOltB,SAGtCotB,EAAyB,CAAExE,KAAM,CAAE7E,cAAc,IAUrD,SAASgH,EAAUH,GACjB,IAAIkB,EAAQ,GACZ,GAAKA,EAAMr7B,KAAK48B,EAAazC,UACtBA,EAAO0C,IAAI,MAClB,OAAuB,GAAhBxB,EAAM57B,OAAc47B,EAAM,GAAK,CAACnhC,KAAM,SAAUmhC,MAAOA,GAGhE,SAASuB,EAAazC,GACpB,IAAIkB,EAAQ,GACZ,GAAKA,EAAMr7B,KAAK88B,EAAmB3C,UAC5BA,EAAOhC,MAAuB,KAAfgC,EAAOhC,MAA8B,KAAfgC,EAAOhC,MACnD,OAAuB,GAAhBkD,EAAM57B,OAAc47B,EAAM,GAAK,CAACnhC,KAAM,MAAOmhC,MAAOA,GAG7D,SAASyB,EAAmB3C,GAE1B,IADA,IAAIE,EA4CN,SAAuBF,GACrB,GAAIA,EAAO0C,IAAI,KAAM,CACnB,IAAIxC,EAAOC,EAAUH,GAErB,OADKA,EAAO0C,IAAI,MAAQ1C,EAAOnF,IAAI,yBAC5BqF,EACF,IAAK,KAAKz4B,KAAKu4B,EAAOhC,MAAO,CAClC,IAAIkD,EAlBR,SAAqBlB,EAAQ90B,GAC3B,IAAI5G,EAAQ07B,EAAOD,UAAWhgC,EAAOuE,EAAM4G,GAC3C,GAAInL,EAAQ,MAAO,CAACA,GACpB,IAAIuV,EAAS,GACb,IAAK,IAAIkF,KAAYlW,EAAO,CAC1B,IAAIs+B,EAASt+B,EAAMkW,GACfooB,EAAOC,OAAOzX,QAAQlgB,IAAS,GAAKoK,EAAOzP,KAAK+8B,GAEjC,GAAjBttB,EAAOhQ,QAAe06B,EAAOnF,IAAI,0BAA4B3vB,EAAO,WACxE,OAAOoK,EASOwtB,CAAY9C,EAAQA,EAAOhC,MAAM/8B,KAAI,SAAUlB,GAGzD,OAFqB,MAAjBigC,EAAO7W,OAAkB6W,EAAO7W,OAASppB,EAAKoG,SACzC65B,EAAO7W,QAAUppB,EAAKoG,UAAY65B,EAAOnF,IAAI,mCAC/C,CAAC96B,KAAM,OAAQyJ,MAAOzJ,MAG/B,OADAigC,EAAO9+B,MACgB,GAAhBggC,EAAM57B,OAAc47B,EAAM,GAAK,CAACnhC,KAAM,SAAUmhC,MAAOA,GAE9DlB,EAAOnF,IAAI,qBAAuBmF,EAAOhC,KAAO,KA1DvC+E,CAAc/C,KAEvB,GAAIA,EAAO0C,IAAI,KACXxC,EAAO,CAACngC,KAAM,OAAQmgC,KAAMA,QAC3B,GAAIF,EAAO0C,IAAI,KAChBxC,EAAO,CAACngC,KAAM,OAAQmgC,KAAMA,QAC3B,GAAIF,EAAO0C,IAAI,KAChBxC,EAAO,CAACngC,KAAM,MAAOmgC,KAAMA,OAC1B,KAAIF,EAAO0C,IAAI,KAEb,MADHxC,EAAO8C,EAAehD,EAAQE,GAGpC,OAAOA,EAGT,SAAS+C,EAASjD,GACZ,KAAKv4B,KAAKu4B,EAAOhC,OAASgC,EAAOnF,IAAI,yBAA2BmF,EAAOhC,KAAO,KAClF,IAAI1oB,EAASmT,OAAOuX,EAAOhC,MAE3B,OADAgC,EAAO9+B,MACAoU,EAGT,SAAS0tB,EAAehD,EAAQE,GAC9B,IAAI9yB,EAAM61B,EAASjD,GAASzzB,EAAMa,EAMlC,OALI4yB,EAAO0C,IAAI,OACan2B,EAAP,KAAfyzB,EAAOhC,KAAqBiF,EAASjD,IAC3B,GAEXA,EAAO0C,IAAI,MAAQ1C,EAAOnF,IAAI,yBAC5B,CAAC96B,KAAM,QAASqN,IAAKA,EAAKb,IAAKA,EAAK2zB,KAAMA,GAwGnD,SAASW,EAAIpV,EAAGrE,GAAK,OAAOA,EAAIqE,EAKhC,SAAS8U,EAASH,EAAK7+B,GACrB,IAAI+T,EAAS,GAEb,OAEA,SAAS+sB,EAAK9gC,GACZ,IAAI0/B,EAAQb,EAAI7+B,GAChB,GAAoB,GAAhB0/B,EAAM37B,SAAgB27B,EAAM,GAAGP,KAAQ,OAAO2B,EAAKpB,EAAM,GAAGtgC,IAChE2U,EAAOzP,KAAKtE,GACZ,IAAK,IAAIW,EAAI,EAAGA,EAAI++B,EAAM37B,OAAQpD,IAAK,CACrC,IAAIH,EAAMk/B,EAAM/+B,GACZw+B,EAAO3+B,EAAI2+B,KACX//B,EAAKoB,EAAIpB,GACR+/B,IAA+B,GAAvBprB,EAAO8V,QAAQzqB,IAAa0hC,EAAK1hC,IAXlD0hC,CAAK9gC,GACE+T,EAAOyV,KAAK8V,GAgErB,SAAShC,EAAap4B,GACpB,IAAIy8B,EAAWz5B,OAAOlE,OAAO,MAC7B,IAAK,IAAI49B,KAAY18B,EAAO,CAC1B,IAAI28B,EAAO38B,EAAM08B,GACjB,IAAKC,EAAKC,WAAc,OAAO,KAC/BH,EAASC,GAAYC,EAAK3b,QAE5B,OAAOyb,EAGT,SAASI,EAAa78B,EAAO+C,GAC3B,IAAI+5B,EAAQ95B,OAAOlE,OAAO,MAC1B,IAAK,IAAI2F,KAAQzE,EAAO,CACtB,IAAI+8B,EAAQh6B,GAASA,EAAM0B,GAC3B,QAAcJ,IAAV04B,EAAqB,CACvB,IAAIJ,EAAO38B,EAAMyE,GACjB,IAAIk4B,EAAKC,WACF,MAAM,IAAIzJ,WAAW,mCAAqC1uB,GAD1Cs4B,EAAQJ,EAAK3b,QAGtC8b,EAAMr4B,GAAQs4B,EAEhB,OAAOD,EAGT,SAASE,EAAUh9B,GACjB,IAAI6O,EAAS7L,OAAOlE,OAAO,MAC3B,GAAIkB,EAAS,IAAK,IAAIyE,KAAQzE,EAAS6O,EAAOpK,GAAQ,IAAIw4B,GAAUj9B,EAAMyE,IAC1E,OAAOoK,EA/PTktB,EAAuBxE,KAAKrG,IAAM,WAAc,OAAO1sB,KAAKq3B,OAAOr3B,KAAK/J,MAExE++B,EAAYv2B,UAAUg5B,IAAM,SAAciB,GAAO,OAAO14B,KAAK+yB,MAAQ2F,IAAQ14B,KAAK/J,QAAS,IAE3F++B,EAAYv2B,UAAUmxB,IAAM,SAAcsD,GAAO,MAAM,IAAIyF,YAAYzF,EAAM,4BAA8BlzB,KAAKwoB,OAAS,OAEzHhqB,OAAO+wB,iBAAkByF,EAAYv2B,UAAW84B,GAgQhD,IAAIqB,EAAW,SAAkB34B,EAAMuB,EAAQzM,GAG7CiL,KAAKC,KAAOA,EAIZD,KAAKwB,OAASA,EAIdxB,KAAKjL,KAAOA,EAEZiL,KAAK43B,OAAS7iC,EAAKyc,MAAQzc,EAAKyc,MAAMxY,MAAM,KAAO,GACnDgH,KAAKxE,MAAQg9B,EAAUzjC,EAAKyG,OAE5BwE,KAAK4zB,aAAeA,EAAa5zB,KAAKxE,OAItCwE,KAAK2Q,aAAe,KAKpB3Q,KAAK64B,QAAU,KAIf74B,KAAKpH,cAAgB,KAIrBoH,KAAK9G,UAAYnE,EAAKmpB,QAAkB,QAARje,GAIhCD,KAAKoB,OAAiB,QAARnB,GAGZ64B,GAAuB,CAAE59B,SAAU,CAAEgzB,cAAc,GAAOv3B,YAAa,CAAEu3B,cAAc,GAAOzH,OAAQ,CAAEyH,cAAc,GAAO/3B,OAAQ,CAAE+3B,cAAc,GAAO6K,WAAY,CAAE7K,cAAc,IAI5L4K,GAAqB59B,SAASwxB,IAAM,WAAc,OAAQ1sB,KAAK9G,SAK/D4/B,GAAqBniC,YAAY+1B,IAAM,WAAc,OAAO1sB,KAAK9G,SAAW8G,KAAKpH,eAIjFkgC,GAAqBrS,OAAOiG,IAAM,WAAc,OAAO1sB,KAAK2Q,cAAgBgkB,EAAa7gC,OAKzFglC,GAAqB3iC,OAAOu2B,IAAM,WAAc,OAAO1sB,KAAKymB,QAAUzmB,KAAKjL,KAAKopB,MAIhF2a,GAAqBC,WAAWrM,IAAM,WAAc,OAAO1sB,KAAKjL,KAAKgkC,aAAe/4B,KAAKjL,KAAK0C,KAAO,MAAQ,WAI7GmhC,EAASn6B,UAAUzG,iBAAmB,WACpC,IAAK,IAAI6Y,KAAK7Q,KAAKxE,MAAS,GAAIwE,KAAKxE,MAAMqV,GAAGmoB,WAAc,OAAO,EACnE,OAAO,GAGTJ,EAASn6B,UAAU9E,kBAAoB,SAA4B00B,GACjE,OAAOruB,MAAQquB,GAASruB,KAAK2Q,aAAagmB,WAAWtI,EAAM1d,eAG7DioB,EAASn6B,UAAU45B,aAAe,SAAyB78B,GACzD,OAAKA,GAASwE,KAAK4zB,aAAuB5zB,KAAK4zB,aACjCyE,EAAar4B,KAAKxE,MAAOA,IAUzCo9B,EAASn6B,UAAUnE,OAAS,SAAiBkB,EAAOrG,EAASwP,GAC3D,GAAI3E,KAAKoB,OAAU,MAAM,IAAI2C,MAAM,8CACnC,OAAO,IAAIsgB,EAAKrkB,KAAMA,KAAKq4B,aAAa78B,GAAQwyB,EAASr4B,KAAKR,GAAUmvB,EAAK8L,QAAQzrB,KAOvFi0B,EAASn6B,UAAUw6B,cAAgB,SAAwBz9B,EAAOrG,EAASwP,GAEzE,GADAxP,EAAU64B,EAASr4B,KAAKR,IACnB6K,KAAKiS,aAAa9c,GACnB,MAAM,IAAIw5B,WAAW,4BAA8B3uB,KAAKC,MAC5D,OAAO,IAAIokB,EAAKrkB,KAAMA,KAAKq4B,aAAa78B,GAAQrG,EAASmvB,EAAK8L,QAAQzrB,KAUxEi0B,EAASn6B,UAAUlG,cAAgB,SAAwBiD,EAAOrG,EAASwP,GAGzE,GAFAnJ,EAAQwE,KAAKq4B,aAAa78B,IAC1BrG,EAAU64B,EAASr4B,KAAKR,IACZC,KAAM,CAChB,IAAIR,EAASoL,KAAK2Q,aAAaimB,WAAWzhC,GAC1C,IAAKP,EAAU,OAAO,KACtBO,EAAUP,EAAOwJ,OAAOjJ,GAE1B,IAAIK,EAAQwK,KAAK2Q,aAAaujB,cAAc/+B,GAASyhC,WAAW5I,EAASl6B,OAAO,GAChF,OAAK0B,EACE,IAAI6uB,EAAKrkB,KAAMxE,EAAOrG,EAAQiJ,OAAO5I,GAAQ8uB,EAAK8L,QAAQzrB,IAD5C,MAOvBi0B,EAASn6B,UAAUwT,aAAe,SAAuB9c,GACvD,IAAIkV,EAASrK,KAAK2Q,aAAaujB,cAAc/+B,GAC7C,IAAKkV,IAAWA,EAAOlQ,SAAY,OAAO,EAC1C,IAAK,IAAIlD,EAAI,EAAGA,EAAI9B,EAAQyB,WAAYK,IACpC,IAAK+I,KAAKs0B,YAAYn/B,EAAQsI,MAAMxG,GAAG0N,OAAU,OAAO,EAC5D,OAAO,GAKTi0B,EAASn6B,UAAUy6B,eAAiB,SAAyBxsB,GAC3D,OAAuB,MAAhB1M,KAAK64B,SAAmB74B,KAAK64B,QAAQ1Y,QAAQzT,IAAa,GAKnEksB,EAASn6B,UAAU61B,YAAc,SAAsB3vB,GACrD,GAAoB,MAAhB3E,KAAK64B,QAAmB,OAAO,EACnC,IAAK,IAAI5hC,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAO,IAAK+I,KAAKk5B,eAAev0B,EAAM1N,GAAGnC,MAAS,OAAO,EAC3F,OAAO,GAKT8jC,EAASn6B,UAAU06B,aAAe,SAAuBx0B,GACvD,GAAoB,MAAhB3E,KAAK64B,QAAmB,OAAOl0B,EAEnC,IADA,IAAIpK,EACKtD,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAC3B+I,KAAKk5B,eAAev0B,EAAM1N,GAAGnC,MAEvByF,GACTA,EAAKK,KAAK+J,EAAM1N,IAFXsD,IAAQA,EAAOoK,EAAMlP,MAAM,EAAGwB,IAKvC,OAAQsD,EAAeA,EAAKF,OAASE,EAAO+pB,EAAKxwB,MAAlC6Q,GAGjBi0B,EAAS7C,QAAU,SAAkBp0B,EAAOH,GAC1C,IAAI6I,EAAS7L,OAAOlE,OAAO,MAC3BqH,EAAMxC,SAAQ,SAAUc,EAAMlL,GAAQ,OAAOsV,EAAOpK,GAAQ,IAAI24B,EAAS34B,EAAMuB,EAAQzM,MAEvF,IAAIqkC,EAAU53B,EAAOzM,KAAKgpB,SAAW,MACrC,IAAK1T,EAAO+uB,GAAY,MAAM,IAAIzK,WAAW,yCAA2CyK,EAAU,MAClG,IAAK/uB,EAAOrJ,KAAQ,MAAM,IAAI2tB,WAAW,oCACzC,IAAK,IAAI/E,KAAKvf,EAAOrJ,KAAKxF,MAAS,MAAM,IAAImzB,WAAW,iDAExD,OAAOtkB,GAGT7L,OAAO+wB,iBAAkBqJ,EAASn6B,UAAWq6B,IAI7C,IAAIL,GAAY,SAAmBp4B,GACjCL,KAAKo4B,WAAa55B,OAAOC,UAAUgrB,eAAe9qB,KAAK0B,EAAS,WAChEL,KAAKwc,QAAUnc,EAAQmc,SAGrB6c,GAAyB,CAAEL,WAAY,CAAE9K,cAAc,IAE3DmL,GAAuBL,WAAWtM,IAAM,WACtC,OAAQ1sB,KAAKo4B,YAGf55B,OAAO+wB,iBAAkBkJ,GAAUh6B,UAAW46B,IAQ9C,IAAIC,GAAW,SAAkBr5B,EAAM+vB,EAAMxuB,EAAQzM,GAGnDiL,KAAKC,KAAOA,EAIZD,KAAKwB,OAASA,EAIdxB,KAAKjL,KAAOA,EAEZiL,KAAKxE,MAAQg9B,EAAUzjC,EAAKyG,OAE5BwE,KAAKgwB,KAAOA,EACZhwB,KAAK+nB,SAAW,KAChB,IAAIkQ,EAAWrE,EAAa5zB,KAAKxE,OACjCwE,KAAKu5B,SAAWtB,GAAY,IAAI3T,EAAKtkB,KAAMi4B,IAO7CqB,GAAS76B,UAAUnE,OAAS,SAAiBkB,GAC3C,OAAKA,GAASwE,KAAKu5B,SAAmBv5B,KAAKu5B,SACpC,IAAIjV,EAAKtkB,KAAMq4B,EAAar4B,KAAKxE,MAAOA,KAGjD89B,GAASvD,QAAU,SAAkBpxB,EAAOnD,GAC1C,IAAI6I,EAAS7L,OAAOlE,OAAO,MAAO01B,EAAO,EAEzC,OADArrB,EAAMxF,SAAQ,SAAUc,EAAMlL,GAAQ,OAAOsV,EAAOpK,GAAQ,IAAIq5B,GAASr5B,EAAM+vB,IAAQxuB,EAAQzM,MACxFsV,GAMTivB,GAAS76B,UAAUwxB,cAAgB,SAAwBH,GACzD,IAAK,IAAI74B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAAW64B,EAAI74B,GAAGnC,MAAQkL,OACxD8vB,EAAMA,EAAIr6B,MAAM,EAAGwB,GAAGg2B,OAAO6C,EAAIr6B,MAAMwB,EAAI,IAC3CA,KAEF,OAAO64B,GAKTwJ,GAAS76B,UAAUmH,QAAU,SAAkBkqB,GAC7C,IAAK,IAAI74B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAC5B,GAAI64B,EAAI74B,GAAGnC,MAAQkL,KAAQ,OAAO8vB,EAAI74B,IAM5CqiC,GAAS76B,UAAU8T,SAAW,SAAmB8b,GAC/C,OAAOruB,KAAK+nB,SAAS5H,QAAQkO,IAAU,GAmLzC,IAAImL,GAAS,SAAgBzkC,GAQ3B,IAAK,IAAIwX,KADTvM,KAAKjL,KAAO,GACKA,EAAQiL,KAAKjL,KAAKwX,GAAQxX,EAAKwX,GAChDvM,KAAKjL,KAAK4M,MAAQ,OAAgB5M,EAAK4M,OACvC3B,KAAKjL,KAAK4P,MAAQ,OAAgB5P,EAAK4P,OAIvC3E,KAAK2B,MAAQi3B,EAAS7C,QAAQ/1B,KAAKjL,KAAK4M,MAAO3B,MAI/CA,KAAK2E,MAAQ20B,GAASvD,QAAQ/1B,KAAKjL,KAAK4P,MAAO3E,MAE/C,IAAIy5B,EAAmBj7B,OAAOlE,OAAO,MACrC,IAAK,IAAIo/B,KAAU15B,KAAK2B,MAAO,CAC7B,GAAI+3B,KAAU15B,KAAK2E,MACf,MAAM,IAAIgqB,WAAW+K,EAAS,sCAClC,IAAI5kC,EAAOkL,KAAK2B,MAAM+3B,GAASC,EAAc7kC,EAAKC,KAAKI,SAAW,GAAIykC,EAAW9kC,EAAKC,KAAK4P,MAC3F7P,EAAK6b,aAAe8oB,EAAiBE,KAClCF,EAAiBE,GAAehF,EAAajsB,MAAMixB,EAAa35B,KAAK2B,QACxE7M,EAAK8D,cAAgB9D,EAAK6b,aAAa/X,cACvC9D,EAAK+jC,QAAsB,KAAZe,EAAkB,KAC/BA,EAAWC,GAAY75B,KAAM45B,EAAS5gC,MAAM,MAChC,IAAZ4gC,GAAmB9kC,EAAK8D,cAAqB,KAAL,GAE5C,IAAK,IAAIkhC,KAAU95B,KAAK2E,MAAO,CAC7B,IAAIgzB,EAAS33B,KAAK2E,MAAMm1B,GAASC,EAAOpC,EAAO5iC,KAAKwd,SACpDolB,EAAO5P,SAAmB,MAARgS,EAAe,CAACpC,GAAkB,IAARoC,EAAa,GAAKF,GAAY75B,KAAM+5B,EAAK/gC,MAAM,MAG7FgH,KAAKsI,aAAetI,KAAKsI,aAAa7I,KAAKO,MAC3CA,KAAKy0B,aAAez0B,KAAKy0B,aAAah1B,KAAKO,MAK3CA,KAAKyqB,YAAczqB,KAAK2B,MAAM3B,KAAKjL,KAAKgpB,SAAW,OAMnD/d,KAAKszB,OAAS90B,OAAOlE,OAAO,MAC5B0F,KAAKszB,OAAO0G,UAAYx7B,OAAOlE,OAAO,OAsDxC,SAASu/B,GAAYr4B,EAAQmD,GAE3B,IADA,IAAIvH,EAAQ,GACHnG,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAK,CACrC,IAAIgJ,EAAO0E,EAAM1N,GAAIuO,EAAOhE,EAAOmD,MAAM1E,GAAOg6B,EAAKz0B,EACrD,GAAIA,EACFpI,EAAMxC,KAAK4K,QAEX,IAAK,IAAI+G,KAAQ/K,EAAOmD,MAAO,CAC7B,IAAIu1B,EAAS14B,EAAOmD,MAAM4H,IACd,KAARtM,GAAgBi6B,EAAOnlC,KAAKyc,OAAS0oB,EAAOnlC,KAAKyc,MAAMxY,MAAM,KAAKmnB,QAAQlgB,IAAS,IACnF7C,EAAMxC,KAAKq/B,EAAKC,GAGxB,IAAKD,EAAM,MAAM,IAAItB,YAAY,uBAAyBh0B,EAAM1N,GAAK,KAEvE,OAAOmG,EA7DTo8B,GAAO/6B,UAAUnI,KAAO,SAAexB,EAAM0G,EAAOrG,EAASwP,GAC3D,GAAmB,iBAAR7P,EACPA,EAAOkL,KAAKzE,SAASzG,OACpB,MAAMA,aAAgB8jC,GACvB,MAAM,IAAIjK,WAAW,sBAAwB75B,GAC5C,GAAIA,EAAK0M,QAAUxB,KACpB,MAAM,IAAI2uB,WAAW,yCAA2C75B,EAAKmL,KAAO,KAEhF,OAAOnL,EAAKmkC,cAAcz9B,EAAOrG,EAASwP,IAM5C60B,GAAO/6B,UAAUuC,KAAO,SAAem5B,EAAQx1B,GAC7C,IAAI7P,EAAOkL,KAAK2B,MAAMX,KACtB,OAAO,IAAI0zB,EAAS5/B,EAAMA,EAAK8+B,aAAcuG,EAAQ7V,EAAK8L,QAAQzrB,KAKpE60B,GAAO/6B,UAAU+G,KAAO,SAAe1Q,EAAM0G,GAE3C,MADmB,iBAAR1G,IAAoBA,EAAOkL,KAAK2E,MAAM7P,IAC1CA,EAAKwF,OAAOkB,IAMrBg+B,GAAO/6B,UAAU6J,aAAe,SAAuB4nB,GACrD,OAAO7L,EAAK+K,SAASpvB,KAAMkwB,IAM7BsJ,GAAO/6B,UAAUg2B,aAAe,SAAuBvE,GACrD,OAAO5L,EAAK8K,SAASpvB,KAAMkwB,IAG7BsJ,GAAO/6B,UAAUlD,SAAW,SAAmB0E,GAC7C,IAAI7C,EAAQ4C,KAAK2B,MAAM1B,GACvB,IAAK7C,EAAS,MAAM,IAAIuxB,WAAW,sBAAwB1uB,GAC3D,OAAO7C,GAuKT,IAAI6K,GAAY,SAAmBzG,EAAQ8X,GACzC,IAAI8gB,EAASp6B,KAIbA,KAAKwB,OAASA,EAIdxB,KAAKsZ,MAAQA,EACbtZ,KAAKq6B,KAAO,GACZr6B,KAAKs6B,OAAS,GAEdhhB,EAAMna,SAAQ,SAAUua,GAClBA,EAAK6gB,IAAOH,EAAOC,KAAKz/B,KAAK8e,GACxBA,EAAK4D,OAAS8c,EAAOE,OAAO1/B,KAAK8e,MAI5C1Z,KAAKw6B,gBAAkBx6B,KAAKq6B,KAAKhjB,MAAK,SAAUojB,GAC9C,IAAK,aAAaj+B,KAAKi+B,EAAEF,OAASE,EAAEnkC,KAAQ,OAAO,EACnD,IAAIA,EAAOkL,EAAOG,MAAM84B,EAAEnkC,MAC1B,OAAOA,EAAKqa,aAAazW,UAAU5D,OAMvC2R,GAAUxJ,UAAUiK,MAAQ,SAAgBhG,EAAKrC,QAC5B,IAAZA,IAAqBA,EAAU,IAEtC,IAAId,EAAU,IAAIm7B,GAAa16B,KAAMK,GAAS,GAE9C,OADAd,EAAQo7B,OAAOj4B,EAAK,KAAMrC,EAAQ1K,KAAM0K,EAAQ3K,IACzC6J,EAAQq7B,UAUjB3yB,GAAUxJ,UAAUgK,WAAa,SAAqB/F,EAAKrC,QACtC,IAAZA,IAAqBA,EAAU,IAEtC,IAAId,EAAU,IAAIm7B,GAAa16B,KAAMK,GAAS,GAE9C,OADAd,EAAQo7B,OAAOj4B,EAAK,KAAMrC,EAAQ1K,KAAM0K,EAAQ3K,IACzC46B,EAAM6B,QAAQ5yB,EAAQq7B,WAG/B3yB,GAAUxJ,UAAUo8B,SAAW,SAAmBn4B,EAAKnD,EAAS/J,GAC9D,IAAK,IAAIyB,EAAIzB,EAAQwK,KAAKq6B,KAAKla,QAAQ3qB,GAAS,EAAI,EAAGyB,EAAI+I,KAAKq6B,KAAKhgC,OAAQpD,IAAK,CAChF,IAAIyiB,EAAO1Z,KAAKq6B,KAAKpjC,GACrB,GAAI4jB,GAAQnY,EAAKgX,EAAK6gB,YACE16B,IAAnB6Z,EAAKohB,WAA2Bp4B,EAAIq4B,cAAgBrhB,EAAKohB,cACxDphB,EAAKna,SAAWA,EAAQy7B,eAAethB,EAAKna,UAAW,CAC3D,GAAIma,EAAK6D,SAAU,CACjB,IAAIlT,EAASqP,EAAK6D,SAAS7a,GAC3B,IAAe,IAAX2H,EAAoB,SACxBqP,EAAKle,MAAQ6O,EAEf,OAAOqP,KAKbzR,GAAUxJ,UAAUw8B,WAAa,SAAqB1uB,EAAMhO,EAAOgB,EAAS/J,GAC1E,IAAK,IAAIyB,EAAIzB,EAAQwK,KAAKs6B,OAAOna,QAAQ3qB,GAAS,EAAI,EAAGyB,EAAI+I,KAAKs6B,OAAOjgC,OAAQpD,IAAK,CACpF,IAAIyiB,EAAO1Z,KAAKs6B,OAAOrjC,GACvB,KAAgC,GAA5ByiB,EAAK4D,MAAM6C,QAAQ5T,IACnBmN,EAAKna,UAAYA,EAAQy7B,eAAethB,EAAKna,UAI7Cma,EAAK4D,MAAMjjB,OAASkS,EAAKlS,SACc,IAAtCqf,EAAK4D,MAAMgP,WAAW/f,EAAKlS,SAAiBqf,EAAK4D,MAAM7nB,MAAM8W,EAAKlS,OAAS,IAAMkE,IANtF,CAQA,GAAImb,EAAK6D,SAAU,CACjB,IAAIlT,EAASqP,EAAK6D,SAAShf,GAC3B,IAAe,IAAX8L,EAAoB,SACxBqP,EAAKle,MAAQ6O,EAEf,OAAOqP,KAKXzR,GAAUizB,YAAc,SAAsB15B,GAC5C,IAAI6I,EAAS,GACb,SAASxR,EAAO6gB,GAEd,IADA,IAAIyhB,EAA4B,MAAjBzhB,EAAKyhB,SAAmB,GAAKzhB,EAAKyhB,SAAUlkC,EAAI,EACxDA,EAAIoT,EAAOhQ,OAAQpD,IAAK,CAC7B,IAAI87B,EAAO1oB,EAAOpT,GAClB,IADsD,MAAjB87B,EAAKoI,SAAmB,GAAKpI,EAAKoI,UACpDA,EAAY,MAEjC9wB,EAAO0iB,OAAO91B,EAAG,EAAGyiB,GAGtB,IAAIwc,EAAO,SAAWj2B,GACpB,IAAIqZ,EAAQ9X,EAAOmD,MAAM1E,GAAMlL,KAAKwpB,SAChCjF,GAASA,EAAMna,SAAQ,SAAUua,GACnC7gB,EAAO6gB,EAAOnf,GAAKmf,IACnBA,EAAKlU,KAAOvF,MAId,IAAK,IAAIA,KAAQuB,EAAOmD,MAAOuxB,EAAMj2B,GACvC,IACMm7B,EAOJ,IAAK,IAAIC,KAAU75B,EAAOG,MAPtBy5B,OAAAA,GAAAA,EAAU55B,EAAOG,MAAM05B,GAAQtmC,KAAKwpB,WACzB6c,EAAQj8B,SAAQ,SAAUua,GACvC7gB,EAAO6gB,EAAOnf,GAAKmf,IACnBA,EAAKpjB,KAAO+kC,KAKhB,OAAOhxB,GAOTpC,GAAUqzB,WAAa,SAAqB95B,GAC1C,OAAOA,EAAO8xB,OAAOiI,YAClB/5B,EAAO8xB,OAAOiI,UAAY,IAAItzB,GAAUzG,EAAQyG,GAAUizB,YAAY15B,MAI3E,IAAIg6B,GAAY,CACdC,SAAS,EAAMC,SAAS,EAAMC,OAAO,EAAMC,YAAY,EAAMC,QAAQ,EACrEC,IAAI,EAAMC,KAAK,EAAMC,IAAI,EAAMC,UAAU,EAAMC,YAAY,EAAMC,QAAQ,EACzEC,QAAQ,EAAMC,MAAM,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EACtEC,IAAI,EAAMC,QAAQ,EAAMC,QAAQ,EAAMC,IAAI,EAAMC,IAAI,EAAMC,UAAU,EAAMC,IAAI,EAC9Eh+B,QAAQ,EAAM4vB,GAAG,EAAMqO,KAAK,EAAMC,SAAS,EAAMC,OAAO,EAAMC,OAAO,EAAMC,IAAI,GAI7EC,GAAa,CACfC,MAAM,EAAMR,UAAU,EAAMS,QAAQ,EAAMC,QAAQ,EAAMpgB,OAAO,EAAMqgB,OAAO,GAI1EC,GAAW,CAACX,IAAI,EAAMK,IAAI,GAK9B,SAASO,GAAa/oC,EAAM+T,EAAoBsiB,GAC9C,OAA0B,MAAtBtiB,GAAsCA,EAHtB,EAG6D,IACvD,SAAvBA,EAJ2C,EAIY,GACnD/T,GAA2B,OAAnBA,EAAKikC,WAAsB+E,GAAgD,EAAP3S,EAGrF,IAAI4S,GAAc,SAAqBjpC,EAAM0G,EAAOmJ,EAAOq5B,EAAcC,EAAOpmC,EAAOwI,GACrFL,KAAKlL,KAAOA,EACZkL,KAAKxE,MAAQA,EACbwE,KAAKi+B,MAAQA,EACbj+B,KAAKnI,MAAQA,IAZoD,EAY1CwI,EAA0B,KAAOvL,EAAK6b,cAC7D3Q,KAAKK,QAAUA,EACfL,KAAK7K,QAAU,GAEf6K,KAAK2E,MAAQA,EAEb3E,KAAKk+B,YAAc5Z,EAAK+L,KAExBrwB,KAAKg+B,aAAeA,EAEpBh+B,KAAKm+B,WAAa,IAGpBJ,GAAYt/B,UAAUxE,aAAe,SAAuB3D,GAC1D,IAAK0J,KAAKnI,MAAO,CACf,IAAKmI,KAAKlL,KAAQ,MAAO,GACzB,IAAIspC,EAAOp+B,KAAKlL,KAAK6b,aAAaimB,WAAW5I,EAASr4B,KAAKW,IAC3D,IAAI8nC,EAEG,CACL,IAAoChkC,EAAhCe,EAAQ6E,KAAKlL,KAAK6b,aACtB,OAAIvW,EAAOe,EAAMlB,aAAa3D,EAAKxB,QACjCkL,KAAKnI,MAAQsD,EACNf,GAEA,KAPT4F,KAAKnI,MAAQmI,KAAKlL,KAAK6b,aAAaujB,cAAckK,GAWtD,OAAOp+B,KAAKnI,MAAMoC,aAAa3D,EAAKxB,OAGtCipC,GAAYt/B,UAAUm8B,OAAS,SAAiBpK,GAC9C,KA7CoB,EA6CdxwB,KAAKK,SAA4B,CACrC,IAAkDm0B,EAA9CprB,EAAOpJ,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAC1C+O,GAAQA,EAAKhI,SAAWozB,EAAI,oBAAoB7a,KAAKvQ,EAAKpI,SACxDoI,EAAKpI,KAAK3G,QAAUm6B,EAAE,GAAGn6B,OAAU2F,KAAK7K,QAAQmiC,MAC7Ct3B,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAAK+O,EAAKklB,SAASllB,EAAKpI,KAAKvL,MAAM,EAAG2T,EAAKpI,KAAK3G,OAASm6B,EAAE,GAAGn6B,UAG5G,IAAIlF,EAAU64B,EAASr4B,KAAKqK,KAAK7K,SAGjC,OAFKq7B,GAAWxwB,KAAKnI,QACjB1C,EAAUA,EAAQiJ,OAAO4B,KAAKnI,MAAM++B,WAAW5I,EAASl6B,OAAO,KAC5DkM,KAAKlL,KAAOkL,KAAKlL,KAAKwF,OAAO0F,KAAKxE,MAAOrG,EAAS6K,KAAK2E,OAASxP,GAGzE4oC,GAAYt/B,UAAU4/B,iBAAmB,SAA2B74B,GAClE,IAAK,IAAIvO,EAAI+I,KAAKm+B,WAAW9jC,OAAS,EAAGpD,GAAK,EAAGA,IAC7C,GAAIuO,EAAKgC,GAAGxH,KAAKm+B,WAAWlnC,IAAO,OAAO+I,KAAKm+B,WAAWpR,OAAO91B,EAAG,GAAG,IAG7E8mC,GAAYt/B,UAAU6/B,aAAe,SAAuB5tB,GAC1D,IAAK,IAAIzZ,EAAI,EAAGsnC,EAAUv+B,KAAKg+B,aAAc/mC,EAAIsnC,EAAQlkC,OAAQpD,IAAK,CACpE,IAAIuO,EAAO+4B,EAAQtnC,IACd+I,KAAKlL,KAAOkL,KAAKlL,KAAKokC,eAAe1zB,EAAK1Q,MAAQ0pC,GAAah5B,EAAK1Q,KAAM4b,MAC1ElL,EAAKI,QAAQ5F,KAAKk+B,eACrBl+B,KAAKk+B,YAAc14B,EAAKqqB,SAAS7vB,KAAKk+B,aACtCl+B,KAAKg+B,aAAex4B,EAAKyqB,cAAcjwB,KAAKg+B,iBAKlDD,GAAYt/B,UAAUggC,cAAgB,SAAwBnoC,GAC5D,OAAI0J,KAAKlL,KAAekL,KAAKlL,KAAK8D,cAC9BoH,KAAK7K,QAAQkF,OAAiB2F,KAAK7K,QAAQ,GAAG+F,SAC3C5E,EAAKooC,aAAelD,GAAU/R,eAAenzB,EAAKooC,WAAWC,SAASC,gBAG/E,IAAIlE,GAAe,SAAsBlyB,EAAQnI,EAASw+B,GAExD7+B,KAAKwI,OAASA,EAEdxI,KAAKK,QAAUA,EACfL,KAAK8+B,OAASD,EACd,IAA+BE,EAA3BhhB,EAAU1d,EAAQ0d,QAClBihB,EAAanB,GAAa,KAAMx9B,EAAQwI,mBAAoB,IAAMg2B,EAvFL,EAuF4B,GAEzFE,EADAhhB,EACa,IAAIggB,GAAYhgB,EAAQjpB,KAAMipB,EAAQviB,MAAO8oB,EAAK+L,KAAM/L,EAAK+L,MAAM,EACrDhwB,EAAQ4+B,UAAYlhB,EAAQjpB,KAAK6b,aAAcquB,GAE7D,IAAIjB,GADZc,EACwB,KAEAr2B,EAAOhH,OAAOipB,YAFR,KAAMnG,EAAK+L,KAAM/L,EAAK+L,MAAM,EAAM,KAAM2O,GAG/Eh/B,KAAK2B,MAAQ,CAACo9B,GAEd/+B,KAAK6+B,KAAO,EACZ7+B,KAAKoF,KAAO/E,EAAQ6+B,cACpBl/B,KAAKm/B,YAAa,GAGhBC,GAAuB,CAAEvU,IAAK,CAAEqD,cAAc,GAAOmR,WAAY,CAAEnR,cAAc,IAwYrF,SAASrT,GAAQnY,EAAK48B,GACpB,OAAQ58B,EAAImY,SAAWnY,EAAI68B,mBAAqB78B,EAAI88B,uBAAyB98B,EAAI+8B,oBAAoB9gC,KAAK+D,EAAK48B,GAWjH,SAAS/kC,GAAK6R,GACZ,IAAI7R,EAAO,GACX,IAAK,IAAIgS,KAAQH,EAAO7R,EAAKgS,GAAQH,EAAIG,GACzC,OAAOhS,EAMT,SAASikC,GAAa9xB,EAAUnR,GAC9B,IAAIoG,EAAQpG,EAASiG,OAAOG,MACxBu0B,EAAO,SAAWj2B,GACpB,IAAI/K,EAASyM,EAAM1B,GACnB,GAAK/K,EAAOgkC,eAAexsB,GAA3B,CACA,IAAI8c,EAAO,GAAI4N,EAAO,SAAUv/B,GAC9B2xB,EAAK5uB,KAAK/C,GACV,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,IAAK,CACxC,IAAIH,EAAMe,EAAME,KAAKd,GACjBnC,EAAOgC,EAAIhC,KACXi+B,EAAOj8B,EAAIi8B,KACf,GAAIj+B,GAAQyG,EAAY,OAAO,EAC/B,GAAIiuB,EAAKrJ,QAAQ4S,GAAQ,GAAKqE,EAAKrE,GAAS,OAAO,IAGvD,OAAIqE,EAAKliC,EAAOyb,cAAwB,CAAE+uB,GAAG,QAA7C,IAGF,IAAK,IAAIz/B,KAAQ0B,EAAO,CACtB,IAAIg+B,EAAWzJ,EAAMj2B,GAErB,GAAK0/B,EAAW,OAAOA,EAASD,GAhbpCN,GAAqBvU,IAAI6B,IAAM,WAC7B,OAAO1sB,KAAK2B,MAAM3B,KAAK6+B,OAOzBnE,GAAaj8B,UAAUmhC,OAAS,SAAiBl9B,GAC/C,GAAoB,GAAhBA,EAAInH,SACNyE,KAAK6/B,YAAYn9B,QACZ,GAAoB,GAAhBA,EAAInH,SAAe,CAC5B,IAAI+hB,EAAQ5a,EAAIgb,aAAa,SACzB/Y,EAAQ2Y,EAAQtd,KAAK8/B,WA+X7B,SAAqBxiB,GACnB,IAAuCkX,EAAnCuL,EAAK,6BAAiC11B,EAAS,GACnD,KAAOmqB,EAAIuL,EAAGpmB,KAAK2D,IAAUjT,EAAOzP,KAAK45B,EAAE,GAAIA,EAAE,GAAGwL,QACpD,OAAO31B,EAlY+B41B,CAAY3iB,IAAU,KAAMuN,EAAM7qB,KAAK6qB,IAC3E,GAAa,MAATlmB,EAAiB,IAAK,IAAI1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAO+I,KAAKkgC,eAAev7B,EAAM1N,IAExF,GADA+I,KAAKmgC,WAAWz9B,GACH,MAATiC,EAAiB,IAAK,IAAI3J,EAAM,EAAGA,EAAM2J,EAAMtK,OAAQW,IAASgF,KAAKogC,kBAAkBz7B,EAAM3J,GAAM6vB,KAI3G6P,GAAaj8B,UAAUohC,YAAc,SAAsBn9B,GACzD,IAAInE,EAAQmE,EAAI29B,UACZxV,EAAM7qB,KAAK6qB,IACf,GA/H8C,EA+H1CA,EAAIxqB,SACJwqB,EAAI4T,cAAc/7B,IAClB,mBAAmBlG,KAAK+B,GAAQ,CAClC,GAlIkB,EAkIZssB,EAAIxqB,QAgBR9B,EAlJ0C,EA+I/BssB,EAAIxqB,QAGP9B,EAAMqS,QAAQ,SAAU,MAFxBrS,EAAMqS,QAAQ,YAAa,UATnC,GAJArS,EAAQA,EAAMqS,QAAQ,oBAAqB,KAIvC,mBAAmBpU,KAAK+B,IAAUyB,KAAK6+B,MAAQ7+B,KAAK2B,MAAMtH,OAAS,EAAG,CACxE,IAAIxF,EAAag2B,EAAI11B,QAAQ01B,EAAI11B,QAAQkF,OAAS,GAC9CimC,EAAgB59B,EAAI69B,kBACnB1rC,GACAyrC,GAA2C,MAA1BA,EAAc3B,UAC/B9pC,EAAWuM,QAAU,mBAAmB5E,KAAK3H,EAAWmM,SACzDzC,EAAQA,EAAM9I,MAAM,IAOxB8I,GAASyB,KAAKwgC,WAAWxgC,KAAKwI,OAAOhH,OAAOR,KAAKzC,IACrDyB,KAAKygC,WAAW/9B,QAEhB1C,KAAK0gC,WAAWh+B,IAOpBg4B,GAAaj8B,UAAU0hC,WAAa,SAAqBz9B,EAAKi+B,GAC5D,IAAuCC,EAAnC3gC,EAAOyC,EAAIi8B,SAASC,cACpBhB,GAASnU,eAAexpB,IAASD,KAAKwI,OAAOgyB,gBA+TnD,SAAuB93B,GACrB,IAAK,IAAIjF,EAAQiF,EAAIjM,WAAYoqC,EAAW,KAAMpjC,EAAOA,EAAQA,EAAMqjC,YAAa,CAClF,IAAI7gC,EAAyB,GAAlBxC,EAAMlC,SAAgBkC,EAAMkhC,SAASC,cAAgB,KAC5D3+B,GAAQ29B,GAASnU,eAAexpB,IAAS4gC,GAC3CA,EAASjoB,YAAYnb,GACrBA,EAAQojC,GACS,MAAR5gC,EACT4gC,EAAWpjC,EACFwC,IACT4gC,EAAW,OAxUoDE,CAAcr+B,GACjF,IAAIgX,EAAQ1Z,KAAKK,QAAQ2gC,cAAgBhhC,KAAKK,QAAQ2gC,aAAat+B,KAC9Dk+B,EAAS5gC,KAAKwI,OAAOqyB,SAASn4B,EAAK1C,KAAM2gC,IAC9C,GAAIjnB,EAAOA,EAAKunB,OAAS1D,GAAW9T,eAAexpB,GACjDD,KAAK0gC,WAAWh+B,GAChB1C,KAAKkhC,eAAex+B,QACf,IAAKgX,GAAQA,EAAKynB,MAAQznB,EAAK0nB,YAAa,CAC7C1nB,GAAQA,EAAK0nB,YAAephC,KAAK6+B,KAAOx9B,KAAKC,IAAI,EAAGtB,KAAK6+B,KAAO,GAC3DnlB,GAAQA,EAAKynB,KAAK5lC,WAAYmH,EAAMgX,EAAKynB,MAClD,IAAIE,EAAMxW,EAAM7qB,KAAK6qB,IAAKyW,EAAgBthC,KAAKm/B,WAC/C,GAAI3D,GAAU/R,eAAexpB,GAC3BohC,GAAO,EACFxW,EAAI/1B,OAAQkL,KAAKm/B,YAAa,QAC9B,IAAKz8B,EAAIjM,WAEd,YADAuJ,KAAKuhC,aAAa7+B,GAGpB1C,KAAK26B,OAAOj4B,GACR2+B,GAAQrhC,KAAKqhC,KAAKxW,GACtB7qB,KAAKm/B,WAAamC,OAElBthC,KAAKwhC,iBAAiB9+B,EAAKgX,GAAyB,IAAnBA,EAAK+nB,UAAsBb,EAAS,OAKzElG,GAAaj8B,UAAU8iC,aAAe,SAAuB7+B,GACvC,MAAhBA,EAAIi8B,UAAoB3+B,KAAK6qB,IAAI/1B,MAAQkL,KAAK6qB,IAAI/1B,KAAK8D,eACvDoH,KAAK6/B,YAAYn9B,EAAIg/B,cAAcC,eAAe,QAIxDjH,GAAaj8B,UAAUyiC,eAAiB,SAAyBx+B,GAE3C,MAAhBA,EAAIi8B,UAAsB3+B,KAAK6qB,IAAI/1B,MAASkL,KAAK6qB,IAAI/1B,KAAK8D,eAC1DoH,KAAK4hC,UAAU5hC,KAAKwI,OAAOhH,OAAOR,KAAK,OAM7C05B,GAAaj8B,UAAUqhC,WAAa,SAAqBxF,GACvD,IAAI31B,EAAQ2f,EAAK+L,KACjB/S,EAAO,IAAK,IAAIrmB,EAAI,EAAGA,EAAIqjC,EAAOjgC,OAAQpD,GAAK,EAC7C,IAAK,IAAIzB,EAAQ,OAAQ,CACvB,IAAIkkB,EAAO1Z,KAAKwI,OAAOyyB,WAAWX,EAAOrjC,GAAIqjC,EAAOrjC,EAAI,GAAI+I,KAAMxK,GAClE,IAAKkkB,EAAQ,SAAS4D,EACtB,GAAI5D,EAAKunB,OAAU,OAAO,KAE1B,GADAt8B,EAAQ3E,KAAKwI,OAAOhH,OAAOmD,MAAM+U,EAAKlU,MAAMlL,OAAOof,EAAKle,OAAOq0B,SAASlrB,IACjD,IAAnB+U,EAAK+nB,UACF,MADyBjsC,EAAQkkB,EAI5C,OAAO/U,GAOT+1B,GAAaj8B,UAAU+iC,iBAAmB,SAA2B9+B,EAAKgX,EAAMmoB,GAC5E,IAEER,EAAM9lC,EAAoBiK,EAFxB40B,EAASp6B,KAGX0Z,EAAKpjB,MACPiF,EAAWyE,KAAKwI,OAAOhH,OAAOG,MAAM+X,EAAKpjB,OAC3BmwB,OAEFzmB,KAAKwgC,WAAWjlC,EAASjB,OAAOof,EAAKle,SAC/CwE,KAAKuhC,aAAa7+B,GAFlB2+B,EAAOrhC,KAAKuE,MAAMhJ,EAAUme,EAAKle,MAAOke,EAAK7Q,qBAM/CrD,EADWxF,KAAKwI,OAAOhH,OAAOmD,MAAM+U,EAAKlU,MACzBlL,OAAOof,EAAKle,OAC5BwE,KAAKkgC,eAAe16B,IAEtB,IAAIs8B,EAAU9hC,KAAK6qB,IAEnB,GAAItvB,GAAYA,EAASkrB,OACvBzmB,KAAK0gC,WAAWh+B,QACX,GAAIm/B,EACT7hC,KAAKmgC,WAAWz9B,EAAKm/B,QAChB,GAAInoB,EAAKqoB,WACd/hC,KAAK0gC,WAAWh+B,GAChBgX,EAAKqoB,WAAWr/B,EAAK1C,KAAKwI,OAAOhH,QAAQrC,SAAQ,SAAU7I,GAAQ,OAAO8jC,EAAOoG,WAAWlqC,UACvF,CACL,IAAIuuB,EAAanL,EAAKsoB,eACG,iBAAdnd,EAA0BA,EAAaniB,EAAIogB,cAAc+B,GACtC,mBAAdA,IAA4BA,EAAaA,EAAWniB,IAC/DmiB,IAAcA,EAAaniB,GAChC1C,KAAKiiC,WAAWv/B,EAAKmiB,GAAY,GACjC7kB,KAAK26B,OAAO9V,EAAYwc,GAEtBA,IAAQrhC,KAAKqhC,KAAKS,GAAU9hC,KAAK6+B,QACjCr5B,GAAQxF,KAAKogC,kBAAkB56B,EAAMs8B,IAO3CpH,GAAaj8B,UAAUk8B,OAAS,SAAiBzlC,EAAQmsC,EAAMtkC,EAAYE,GAEzE,IADA,IAAI/F,EAAQ6F,GAAc,EACjB2F,EAAM3F,EAAa7H,EAAOgtC,WAAWnlC,GAAc7H,EAAOuB,WAC1DsC,EAAkB,MAAZkE,EAAmB,KAAO/H,EAAOgtC,WAAWjlC,GACtDyF,GAAO3J,EAAK2J,EAAMA,EAAIo+B,cAAe5pC,EACxC8I,KAAKmiC,YAAYjtC,EAAQgC,GACzB8I,KAAK4/B,OAAOl9B,GACR2+B,GAAQ7F,GAAU/R,eAAe/mB,EAAIi8B,SAASC,gBAC9C5+B,KAAKqhC,KAAKA,GAEhBrhC,KAAKmiC,YAAYjtC,EAAQgC,IAM3BwjC,GAAaj8B,UAAUmjC,UAAY,SAAoBtrC,GAErD,IADA,IAAI8rC,EAAOf,EACFjrC,EAAQ4J,KAAK6+B,KAAMzoC,GAAS,EAAGA,IAAS,CAC/C,IAAIisC,EAAKriC,KAAK2B,MAAMvL,GAChBgH,EAAQilC,EAAGpoC,aAAa3D,GAC5B,GAAI8G,KAAWglC,GAASA,EAAM/nC,OAAS+C,EAAM/C,UAC3C+nC,EAAQhlC,EACRikC,EAAOgB,GACFjlC,EAAM/C,QAAU,MAEvB,GAAIgoC,EAAGpE,MAAS,MAElB,IAAKmE,EAAS,OAAO,EACrBpiC,KAAKqhC,KAAKA,GACV,IAAK,IAAIpqC,EAAI,EAAGA,EAAImrC,EAAM/nC,OAAQpD,IAC9B+I,KAAKsiC,WAAWF,EAAMnrC,GAAI,MAAM,GACpC,OAAO,GAKTyjC,GAAaj8B,UAAU+hC,WAAa,SAAqBlqC,GACvD,GAAIA,EAAK4E,UAAY8E,KAAKm/B,aAAen/B,KAAK6qB,IAAI/1B,KAAM,CACtD,IAAIytC,EAAQviC,KAAKwiC,uBACbD,GAASviC,KAAKsiC,WAAWC,GAE/B,GAAIviC,KAAK4hC,UAAUtrC,GAAO,CACxB0J,KAAKyiC,aACL,IAAI5X,EAAM7qB,KAAK6qB,IACfA,EAAIyT,aAAahoC,EAAKxB,MAClB+1B,EAAIhzB,QAASgzB,EAAIhzB,MAAQgzB,EAAIhzB,MAAMqC,UAAU5D,EAAKxB,OAEtD,IADA,IAAI6P,EAAQkmB,EAAIqT,YACPjnC,EAAI,EAAGA,EAAIX,EAAKqO,MAAMtK,OAAQpD,IAC9B4zB,EAAI/1B,OAAQ+1B,EAAI/1B,KAAKokC,eAAe5iC,EAAKqO,MAAM1N,GAAGnC,QACrD6P,EAAQrO,EAAKqO,MAAM1N,GAAG44B,SAASlrB,IAErC,OADAkmB,EAAI11B,QAAQyF,KAAKtE,EAAKkP,KAAKb,KACpB,EAET,OAAO,GAMT+1B,GAAaj8B,UAAU8F,MAAQ,SAAgBzP,EAAM0G,EAAOknC,GAC1D,IAAIzI,EAAKj6B,KAAK4hC,UAAU9sC,EAAKwF,OAAOkB,IAEpC,OADIy+B,GAAMj6B,KAAKsiC,WAAWxtC,EAAM0G,GAAO,EAAMknC,GACtCzI,GAITS,GAAaj8B,UAAU6jC,WAAa,SAAqBxtC,EAAM0G,EAAOyiC,EAAOyE,GAC3E1iC,KAAKyiC,aACL,IAAI5X,EAAM7qB,KAAK6qB,IACfA,EAAIyT,aAAaxpC,GACjB+1B,EAAIhzB,MAAQgzB,EAAIhzB,OAASgzB,EAAIhzB,MAAMqC,UAAUpF,EAAM0G,GACnD,IAAI6E,EAAUw9B,GAAa/oC,EAAM4tC,EAAY7X,EAAIxqB,SA7UgB,EA8U5DwqB,EAAIxqB,SAAkD,GAAtBwqB,EAAI11B,QAAQkF,SAAegG,GA9UC,GA+UjEL,KAAK2B,MAAM/G,KAAK,IAAImjC,GAAYjpC,EAAM0G,EAAOqvB,EAAIqT,YAAarT,EAAImT,aAAcC,EAAO,KAAM59B,IAC7FL,KAAK6+B,QAKPnE,GAAaj8B,UAAUgkC,WAAa,SAAqBjS,GACvD,IAAIv5B,EAAI+I,KAAK2B,MAAMtH,OAAS,EAC5B,GAAIpD,EAAI+I,KAAK6+B,KAAM,CACjB,KAAO5nC,EAAI+I,KAAK6+B,KAAM5nC,IAAO+I,KAAK2B,MAAM1K,EAAI,GAAG9B,QAAQyF,KAAKoF,KAAK2B,MAAM1K,GAAG2jC,OAAOpK,IACjFxwB,KAAK2B,MAAMtH,OAAS2F,KAAK6+B,KAAO,IAIpCnE,GAAaj8B,UAAUm8B,OAAS,WAG9B,OAFA56B,KAAK6+B,KAAO,EACZ7+B,KAAKyiC,WAAWziC,KAAK8+B,QACd9+B,KAAK2B,MAAM,GAAGi5B,OAAO56B,KAAK8+B,QAAU9+B,KAAKK,QAAQsiC,UAG1DjI,GAAaj8B,UAAU4iC,KAAO,SAAe3rC,GAC3C,IAAK,IAAIuB,EAAI+I,KAAK6+B,KAAM5nC,GAAK,EAAGA,IAAO,GAAI+I,KAAK2B,MAAM1K,IAAMvB,EAE1D,YADAsK,KAAK6+B,KAAO5nC,IAKhBmoC,GAAqBC,WAAW3S,IAAM,WACpC1sB,KAAKyiC,aAEL,IADA,IAAIxsC,EAAM,EACDgB,EAAI+I,KAAK6+B,KAAM5nC,GAAK,EAAGA,IAAK,CAEnC,IADA,IAAI9B,EAAU6K,KAAK2B,MAAM1K,GAAG9B,QACnBye,EAAIze,EAAQkF,OAAS,EAAGuZ,GAAK,EAAGA,IACrC3d,GAAOd,EAAQye,GAAG1d,SAClBe,GAAKhB,IAEX,OAAOA,GAGTykC,GAAaj8B,UAAU0jC,YAAc,SAAsBjtC,EAAQwQ,GACjE,GAAI1F,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IACjD+I,KAAKoF,KAAKnO,GAAGX,MAAQpB,GAAU8K,KAAKoF,KAAKnO,GAAGyO,QAAUA,IACtD1F,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKq/B,aAIhC3E,GAAaj8B,UAAUiiC,WAAa,SAAqBxrC,GACvD,GAAI8K,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IAC7B,MAApB+I,KAAKoF,KAAKnO,GAAGhB,KAAkC,GAAnBf,EAAOqG,UAAiBrG,EAAOomB,SAAStb,KAAKoF,KAAKnO,GAAGX,QACjF0J,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKq/B,aAIhC3E,GAAaj8B,UAAUwjC,WAAa,SAAqB/sC,EAAQC,EAASP,GACxE,GAAIM,GAAUC,GAAW6K,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IAAK,CAC/E,GAAwB,MAApB+I,KAAKoF,KAAKnO,GAAGhB,KAAkC,GAAnBf,EAAOqG,UAAiBrG,EAAOomB,SAAStb,KAAKoF,KAAKnO,GAAGX,MACzEnB,EAAQytC,wBAAwB5iC,KAAKoF,KAAKnO,GAAGX,OAC5C1B,EAAS,EAAI,KACpBoL,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKq/B,cAKlC3E,GAAaj8B,UAAUgiC,WAAa,SAAqBoC,GACvD,GAAI7iC,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IACjD+I,KAAKoF,KAAKnO,GAAGX,MAAQusC,IACrB7iC,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKq/B,YAAcwD,EAASxC,UAAUhmC,OAAS2F,KAAKoF,KAAKnO,GAAGyO,UAOvFg1B,GAAaj8B,UAAUu8B,eAAiB,SAAyBz7B,GAC7D,IAAI66B,EAASp6B,KAEf,GAAIT,EAAQ4gB,QAAQ,MAAQ,EACxB,OAAO5gB,EAAQvG,MAAM,YAAYqe,KAAKrX,KAAKg7B,eAAgBh7B,MAE/D,IAAIgK,EAAQzK,EAAQvG,MAAM,KACtB8pC,EAAS9iC,KAAKK,QAAQd,QACtBwjC,IAAW/iC,KAAK8+B,QAAYgE,GAAUA,EAAO5tC,OAAOJ,MAAQkL,KAAK2B,MAAM,GAAG7M,MAC1EkuC,IAAaF,EAASA,EAAO1sC,MAAQ,EAAI,IAAM2sC,EAAU,EAAI,GAC7DlrC,EAAQ,SAAUZ,EAAGb,GACvB,KAAOa,GAAK,EAAGA,IAAK,CAClB,IAAIgsC,EAAOj5B,EAAM/S,GACjB,GAAY,IAARgsC,EAAY,CACd,GAAIhsC,GAAK+S,EAAM3P,OAAS,GAAU,GAALpD,EAAU,SACvC,KAAOb,GAAS4sC,EAAU5sC,IACtB,GAAIyB,EAAMZ,EAAI,EAAGb,GAAU,OAAO,EACtC,OAAO,EAEP,IAAI28B,EAAO38B,EAAQ,GAAe,GAATA,GAAc2sC,EAAW3I,EAAOz4B,MAAMvL,GAAOtB,KAChEguC,GAAU1sC,GAAS4sC,EAAWF,EAAOxsC,KAAKF,EAAQ4sC,GAAUluC,KAC5D,KACN,IAAKi+B,GAASA,EAAK9yB,MAAQgjC,IAAsC,GAA9BlQ,EAAK6E,OAAOzX,QAAQ8iB,GACnD,OAAO,EACX7sC,IAGJ,OAAO,GAET,OAAOyB,EAAMmS,EAAM3P,OAAS,EAAG2F,KAAK6+B,OAGtCnE,GAAaj8B,UAAU+jC,qBAAuB,WAC5C,IAAIU,EAAWljC,KAAKK,QAAQd,QAC5B,GAAI2jC,EAAY,IAAK,IAAI3yB,EAAI2yB,EAAS9sC,MAAOma,GAAK,EAAGA,IAAK,CACxD,IAAInX,EAAQ8pC,EAAS5sC,KAAKia,GAAGnY,eAAe8qC,EAAS/qC,WAAWoY,IAAI/M,YACpE,GAAIpK,GAASA,EAAMzC,aAAeyC,EAAMw6B,aAAgB,OAAOx6B,EAEjE,IAAK,IAAI6G,KAAQD,KAAKwI,OAAOhH,OAAOG,MAAO,CACzC,IAAI7M,EAAOkL,KAAKwI,OAAOhH,OAAOG,MAAM1B,GACpC,GAAInL,EAAK6B,aAAe7B,EAAK8+B,aAAgB,OAAO9+B,IAIxD4lC,GAAaj8B,UAAUyhC,eAAiB,SAAyB16B,GAC/D,IAAIpI,EAuFN,SAA2BoI,EAAMsqB,GAC/B,IAAK,IAAI74B,EAAI,EAAGA,EAAI64B,EAAIz1B,OAAQpD,IAC9B,GAAIuO,EAAKgC,GAAGsoB,EAAI74B,IAAO,OAAO64B,EAAI74B,GAzFxBksC,CAAkB39B,EAAMxF,KAAK6qB,IAAImT,cACzC5gC,GAAS4C,KAAK6qB,IAAIsT,WAAWvjC,KAAKwC,GACtC4C,KAAK6qB,IAAImT,aAAex4B,EAAKqqB,SAAS7vB,KAAK6qB,IAAImT,eAGjDtD,GAAaj8B,UAAU2hC,kBAAoB,SAA4B56B,EAAM49B,GAC3E,IAAK,IAAIhtC,EAAQ4J,KAAK6+B,KAAMzoC,GAAS,EAAGA,IAAS,CAC/C,IAAIitC,EAAQrjC,KAAK2B,MAAMvL,GAEvB,GADYitC,EAAMrF,aAAa5W,YAAY5hB,IAC9B,EACX69B,EAAMrF,aAAex4B,EAAKyqB,cAAcoT,EAAMrF,kBACzC,CACLqF,EAAMnF,YAAc14B,EAAKyqB,cAAcoT,EAAMnF,aAC7C,IAAIoF,EAAYD,EAAMhF,iBAAiB74B,GACnC89B,GAAaD,EAAMvuC,MAAQuuC,EAAMvuC,KAAKokC,eAAeoK,EAAUxuC,QAC/DuuC,EAAMnF,YAAcoF,EAAUzT,SAASwT,EAAMnF,cAEnD,GAAImF,GAASD,EAAQ,QAIzB5kC,OAAO+wB,iBAAkBmL,GAAaj8B,UAAW2gC,IA4FjD,IAAImE,GAAgB,SAAuB5hC,EAAOgD,GAGhD3E,KAAK2B,MAAQA,GAAS,GAGtB3B,KAAK2E,MAAQA,GAAS,IAiKxB,SAAS6+B,GAAYp3B,GACnB,IAAI/B,EAAS,GACb,IAAK,IAAIpK,KAAQmM,EAAK,CACpB,IAAIoS,EAAQpS,EAAInM,GAAMlL,KAAKypB,MACvBA,IAASnU,EAAOpK,GAAQue,GAE9B,OAAOnU,EAGT,SAAS9U,GAAI8K,GAEX,OAAOA,EAAQsG,UAAYhE,OAAOgE,SApKpC48B,GAAc9kC,UAAU8Z,kBAAoB,SAA4BF,EAAUhY,EAAS3L,GACvF,IAAI0lC,EAASp6B,UACI,IAAZK,IAAqBA,EAAU,IAEjC3L,IAAUA,EAASa,GAAI8K,GAASojC,0BAErC,IAAI5Y,EAAMn2B,EAAQwiC,EAAS,KA4B3B,OA3BA7e,EAASlZ,SAAQ,SAAU7I,GACzB,GAAI4gC,GAAU5gC,EAAKqO,MAAMtK,OAAQ,CAC1B68B,IAAUA,EAAS,IAExB,IADA,IAAIwM,EAAO,EAAGjnB,EAAW,EAClBinB,EAAOxM,EAAO78B,QAAUoiB,EAAWnmB,EAAKqO,MAAMtK,QAAQ,CAC3D,IAAI04B,EAAOz8B,EAAKqO,MAAM8X,GACtB,GAAK2d,EAAOz1B,MAAMouB,EAAKj+B,KAAKmL,MAA5B,CACA,IAAK8yB,EAAKvrB,GAAG0vB,EAAOwM,MAAsC,IAA5B3Q,EAAKj+B,KAAKC,KAAK8pB,SAAsB,MACnE6kB,GAAQ,EAAGjnB,SAF0BA,IAIvC,KAAOinB,EAAOxM,EAAO78B,QACnBwwB,EAAMqM,EAAOI,MACbJ,EAAOI,MAET,KAAO7a,EAAWnmB,EAAKqO,MAAMtK,QAAQ,CACnC,IAAIspC,EAAMrtC,EAAKqO,MAAM8X,KACjBmnB,EAAUxJ,EAAOyJ,cAAcF,EAAKrtC,EAAK4E,SAAUmF,GACnDujC,IACF1M,EAAOt8B,KAAK+oC,EAAK9Y,GACjBA,EAAIjS,YAAYgrB,EAAQlhC,KACxBmoB,EAAM+Y,EAAQ/e,YAAc+e,EAAQlhC,MAI1CmoB,EAAIjS,YAAYwhB,EAAO0J,mBAAmBxtC,EAAM+J,OAG3C3L,GAGT6uC,GAAc9kC,UAAUqlC,mBAAqB,SAA6BxtC,EAAM+J,QAC3D,IAAZA,IAAqBA,EAAU,IAEtC,IAAIvJ,EACAysC,GAAcQ,WAAWxuC,GAAI8K,GAAUL,KAAK2B,MAAMrL,EAAKxB,KAAKmL,MAAM3J,IAChEoM,EAAM5L,EAAI4L,IACVmiB,EAAa/tB,EAAI+tB,WACvB,GAAIA,EAAY,CACd,GAAIvuB,EAAKmwB,OACL,MAAM,IAAIkI,WAAW,gDACrBtuB,EAAQ2jC,UACR3jC,EAAQ2jC,UAAU1tC,EAAMuuB,EAAYxkB,GAEpCL,KAAKuY,kBAAkBjiB,EAAKnB,QAASkL,EAASwkB,GAEpD,OAAOniB,GAST6gC,GAAc9kC,UAAUwlC,cAAgB,SAAwB3tC,EAAM+J,QACjD,IAAZA,IAAqBA,EAAU,IAGtC,IADA,IAAIqC,EAAM1C,KAAK8jC,mBAAmBxtC,EAAM+J,GAC/BpJ,EAAIX,EAAKqO,MAAMtK,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAC/C,IAAImD,EAAO4F,KAAK6jC,cAAcvtC,EAAKqO,MAAM1N,GAAIX,EAAK4E,SAAUmF,GACxDjG,KACPA,EAAKyqB,YAAczqB,EAAKsI,KAAKkW,YAAYlW,GACpCA,EAAMtI,EAAKsI,KAGf,OAAOA,GAGT6gC,GAAc9kC,UAAUolC,cAAgB,SAAwBr+B,EAAM0Y,EAAQ7d,QACzD,IAAZA,IAAqBA,EAAU,IAEtC,IAAIme,EAAQxe,KAAK2E,MAAMa,EAAK1Q,KAAKmL,MACjC,OAAOue,GAAS+kB,GAAcQ,WAAWxuC,GAAI8K,GAAUme,EAAMhZ,EAAM0Y,KAOrEqlB,GAAcQ,WAAa,SAAqBxuC,EAAK2uC,EAAWC,GAG9D,QAFiB,IAAVA,IAAmBA,EAAQ,MAEV,iBAAbD,EACP,MAAO,CAACxhC,IAAKnN,EAAIosC,eAAeuC,IACpC,GAA0B,MAAtBA,EAAU3oC,SACV,MAAO,CAACmH,IAAKwhC,GACjB,GAAIA,EAAUxhC,KAAiC,MAA1BwhC,EAAUxhC,IAAInH,SAC/B,OAAO2oC,EACX,IAAIre,EAAUqe,EAAU,GAAIE,EAAQve,EAAQ1F,QAAQ,KAChDikB,EAAQ,IACVD,EAAQte,EAAQpwB,MAAM,EAAG2uC,GACzBve,EAAUA,EAAQpwB,MAAM2uC,EAAQ,IAElC,IAAIvf,EAAa,KAAMniB,EAAMyhC,EAAQ5uC,EAAI8uC,gBAAgBF,EAAOte,GAAWtwB,EAAIojB,cAAckN,GACzFrqB,EAAQ0oC,EAAU,GAAI/oC,EAAQ,EAClC,GAAIK,GAAyB,iBAATA,GAAuC,MAAlBA,EAAMD,WAAqB4K,MAAMC,QAAQ5K,GAEhF,IAAK,IAAIyE,KADT9E,EAAQ,EACSK,EAAS,GAAmB,MAAfA,EAAMyE,GAAe,CACjD,IAAIqkC,EAAUrkC,EAAKkgB,QAAQ,KACvBmkB,EAAU,EAAK5hC,EAAI6hC,eAAetkC,EAAKxK,MAAM,EAAG6uC,GAAUrkC,EAAKxK,MAAM6uC,EAAU,GAAI9oC,EAAMyE,IACtFyC,EAAIsgB,aAAa/iB,EAAMzE,EAAMyE,IAGxC,IAAK,IAAIhJ,EAAIkE,EAAOlE,EAAIitC,EAAU7pC,OAAQpD,IAAK,CAC7C,IAAIwG,EAAQymC,EAAUjtC,GACtB,GAAc,IAAVwG,EAAa,CACf,GAAIxG,EAAIitC,EAAU7pC,OAAS,GAAKpD,EAAIkE,EAChC,MAAM,IAAIwzB,WAAW,0DACzB,MAAO,CAACjsB,IAAKA,EAAKmiB,WAAYniB,GAE9B,IAAI5L,EAAMysC,GAAcQ,WAAWxuC,EAAKkI,EAAO0mC,GACzC/0B,EAAQtY,EAAI4L,IACZ8hC,EAAe1tC,EAAI+tB,WAEzB,GADAniB,EAAIkW,YAAYxJ,GACZo1B,EAAc,CAChB,GAAI3f,EAAc,MAAM,IAAI8J,WAAW,0BACvC9J,EAAa2f,GAInB,MAAO,CAAC9hC,IAAKA,EAAKmiB,WAAYA,IAMhC0e,GAAcjI,WAAa,SAAqB95B,GAC9C,OAAOA,EAAO8xB,OAAOmR,gBAClBjjC,EAAO8xB,OAAOmR,cAAgB,IAAIlB,GAAcvjC,KAAK0kC,gBAAgBljC,GAASxB,KAAK2kC,gBAAgBnjC,MAMxG+hC,GAAcmB,gBAAkB,SAA0BljC,GACxD,IAAI6I,EAASm5B,GAAYhiC,EAAOG,OAEhC,OADK0I,EAAOrJ,OAAQqJ,EAAOrJ,KAAO,SAAU1K,GAAQ,OAAOA,EAAK0K,OACzDqJ,GAKTk5B,GAAcoB,gBAAkB,SAA0BnjC,GACxD,OAAOgiC,GAAYhiC,EAAOmD,S,yPCj4GxBigC,EAAcpmC,OAAOlE,OAAO,MAI5BuqC,EAAY,SAAmBrtC,EAAST,EAAOmL,GAGjDlC,KAAKkC,OAASA,GAAU,CAAC,IAAI4iC,EAAettC,EAAQ2K,IAAIpL,GAAQS,EAAQ8J,IAAIvK,KAI5EiJ,KAAKxI,QAAUA,EAIfwI,KAAKjJ,MAAQA,GAGXk3B,EAAqB,CAAE8W,OAAQ,CAAE7W,cAAc,GAAOsP,KAAM,CAAEtP,cAAc,GAAOv4B,KAAM,CAAEu4B,cAAc,GAAOx4B,GAAI,CAAEw4B,cAAc,GAAOx1B,MAAO,CAAEw1B,cAAc,GAAOv1B,IAAK,CAAEu1B,cAAc,GAAOp6B,MAAO,CAAEo6B,cAAc,IAIhOD,EAAmB8W,OAAOrY,IAAM,WAAc,OAAO1sB,KAAKxI,QAAQvB,KAIlEg4B,EAAmBuP,KAAK9Q,IAAM,WAAc,OAAO1sB,KAAKjJ,MAAMd,KAI9Dg4B,EAAmBt4B,KAAK+2B,IAAM,WAAc,OAAO1sB,KAAKtH,MAAMzC,KAI9Dg4B,EAAmBv4B,GAAGg3B,IAAM,WAAc,OAAO1sB,KAAKrH,IAAI1C,KAI1Dg4B,EAAmBv1B,MAAMg0B,IAAM,WAC7B,OAAO1sB,KAAKkC,OAAO,GAAGxJ,OAKxBu1B,EAAmBt1B,IAAI+zB,IAAM,WAC3B,OAAO1sB,KAAKkC,OAAO,GAAGvJ,KAKxBs1B,EAAmBn6B,MAAM44B,IAAM,WAE7B,IADA,IAAIxqB,EAASlC,KAAKkC,OACTjL,EAAI,EAAGA,EAAIiL,EAAO7H,OAAQpD,IAC/B,GAAIiL,EAAOjL,GAAGyB,MAAMzC,KAAOiM,EAAOjL,GAAG0B,IAAI1C,IAAO,OAAO,EAC3D,OAAO,GAYT4uC,EAAUpmC,UAAUtJ,QAAU,WAC5B,OAAO6K,KAAKtH,MAAMpC,KAAK,GAAGb,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAI,IAMtDmvC,EAAUpmC,UAAUmS,QAAU,SAAkB7c,EAAIoB,QAC/B,IAAZA,IAAqBA,EAAU,YAMtC,IADA,IAAI6vC,EAAW7vC,EAAQA,QAAQuB,UAAWuuC,EAAa,KAC9ChuC,EAAI,EAAGA,EAAI9B,EAAQq7B,QAASv5B,IACnCguC,EAAaD,EACbA,EAAWA,EAAStuC,UAItB,IADA,IAAIwuC,EAAUnxC,EAAGsV,MAAMhP,OAAQ6H,EAASlC,KAAKkC,OACpClH,EAAM,EAAGA,EAAMkH,EAAO7H,OAAQW,IAAO,CAC5C,IAAIlE,EAAMoL,EAAOlH,GACXtC,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACV5C,EAAUhC,EAAGgC,QAAQN,MAAMyvC,GACjCnxC,EAAGoxC,aAAapvC,EAAQC,IAAI0C,EAAMzC,KAAMF,EAAQC,IAAI2C,EAAI1C,KAAM+E,EAAM,WAAc7F,GACvE,GAAP6F,GACA2O,EAAwB5V,EAAImxC,GAAUF,EAAWA,EAAS9pC,SAAW+pC,GAAcA,EAAWtuC,cAAgB,EAAI,KAO1HkuC,EAAUpmC,UAAUnG,YAAc,SAAsBvE,EAAIuC,GAE1D,IADA,IAAI4uC,EAAUnxC,EAAGsV,MAAMhP,OAAQ6H,EAASlC,KAAKkC,OACpCjL,EAAI,EAAGA,EAAIiL,EAAO7H,OAAQpD,IAAK,CACtC,IAAIH,EAAMoL,EAAOjL,GACXyB,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACV5C,EAAUhC,EAAGgC,QAAQN,MAAMyvC,GAC7BvvC,EAAOI,EAAQC,IAAI0C,EAAMzC,KAAMP,EAAKK,EAAQC,IAAI2C,EAAI1C,KACpDgB,EACFlD,EAAGqQ,YAAYzO,EAAMD,IAErB3B,EAAGqxC,iBAAiBzvC,EAAMD,EAAIY,GAC9BqT,EAAwB5V,EAAImxC,EAAS5uC,EAAK4E,UAAY,EAAI,MAiBhE2pC,EAAUQ,SAAW,SAAmBruC,EAAMsuC,EAAKC,GACjD,IAAIn2B,EAAQpY,EAAK9B,OAAO0D,cAAgB,IAAI4sC,EAAcxuC,GACpDyuC,EAAgBzuC,EAAKV,KAAK,GAAIU,EAAK9B,OAAQ8B,EAAKf,IAAKe,EAAKE,QAASouC,EAAKC,GAC9E,GAAIn2B,EAAS,OAAOA,EAEpB,IAAK,IAAIhZ,EAAQY,EAAKZ,MAAQ,EAAGA,GAAS,EAAGA,IAAS,CACpD,IAAIgH,EAAQkoC,EAAM,EACZG,EAAgBzuC,EAAKV,KAAK,GAAIU,EAAKV,KAAKF,GAAQY,EAAKpC,OAAOwB,EAAQ,GAAIY,EAAKE,MAAMd,GAAQkvC,EAAKC,GAChGE,EAAgBzuC,EAAKV,KAAK,GAAIU,EAAKV,KAAKF,GAAQY,EAAKxB,MAAMY,EAAQ,GAAIY,EAAKE,MAAMd,GAAS,EAAGkvC,EAAKC,GACzG,GAAInoC,EAAS,OAAOA,IAQxBynC,EAAUa,KAAO,SAAe1uC,EAAMmS,GAGpC,YAFgB,IAATA,IAAkBA,EAAO,GAEzBnJ,KAAKqlC,SAASruC,EAAMmS,IAASnJ,KAAKqlC,SAASruC,GAAOmS,IAAS,IAAIw8B,EAAa3uC,EAAKV,KAAK,KAQ/FuuC,EAAU3mC,QAAU,SAAkB3I,GACpC,OAAOkwC,EAAgBlwC,EAAKA,EAAK,EAAG,EAAG,IAAM,IAAIowC,EAAapwC,IAMhEsvC,EAAU1rC,MAAQ,SAAgB5D,GAChC,OAAOkwC,EAAgBlwC,EAAKA,EAAKA,EAAIJ,QAAQC,KAAMG,EAAIqB,YAAa,IAAM,IAAI+uC,EAAapwC,IAM7FsvC,EAAUzV,SAAW,SAAmB75B,EAAK26B,GAC3C,IAAKA,IAASA,EAAKp7B,KAAQ,MAAM,IAAI65B,WAAW,wCAChD,IAAIiX,EAAMhB,EAAY1U,EAAKp7B,MAC3B,IAAK8wC,EAAO,MAAM,IAAIjX,WAAY,qBAAwBuB,EAAS,KAAI,YACvE,OAAO0V,EAAIxW,SAAS75B,EAAK26B,IAQ3B2U,EAAUgB,OAAS,SAAiBC,EAAIC,GACtC,GAAID,KAAMlB,EAAe,MAAM,IAAIjW,WAAW,sCAAwCmX,GAGtF,OAFAlB,EAAYkB,GAAMC,EAClBA,EAAetnC,UAAUonC,OAASC,EAC3BC,GAWTlB,EAAUpmC,UAAUunC,YAAc,WAChC,OAAOR,EAAcS,QAAQjmC,KAAKxI,QAASwI,KAAKjJ,OAAOivC,eAGzDxnC,OAAO+wB,iBAAkBsV,EAAUpmC,UAAWwvB,GAM9C4W,EAAUpmC,UAAUynC,SAAU,EAiB9B,IAAIpB,EAAiB,SAAwBpsC,EAAOC,GAGlDqH,KAAKtH,MAAQA,EAGbsH,KAAKrH,IAAMA,GAOT6sC,EAA8B,SAAUX,GAC1C,SAASW,EAAchuC,EAAST,QACf,IAAVA,IAAmBA,EAAQS,GAEhCqtC,EAAUlmC,KAAKqB,KAAMxI,EAAST,GAG3B8tC,IAAYW,EAAcljC,UAAYuiC,GAC3CW,EAAc/mC,UAAYD,OAAOlE,OAAQuqC,GAAaA,EAAUpmC,WAChE+mC,EAAc/mC,UAAUI,YAAc2mC,EAEtC,IAAI/U,EAAuB,CAAEt8B,QAAS,CAAE+5B,cAAc,IA+EtD,OA1EAuC,EAAqBt8B,QAAQu4B,IAAM,WAAc,OAAO1sB,KAAKxI,QAAQvB,KAAO+J,KAAKjJ,MAAMd,IAAM+J,KAAKjJ,MAAQ,MAE1GyuC,EAAc/mC,UAAUzI,IAAM,SAAcT,EAAKQ,GAC/C,IAAIgB,EAAQxB,EAAIO,QAAQC,EAAQC,IAAIgK,KAAKw9B,OACzC,IAAKzmC,EAAM7B,OAAO0D,cAAiB,OAAOisC,EAAUa,KAAK3uC,GACzD,IAAIS,EAAUjC,EAAIO,QAAQC,EAAQC,IAAIgK,KAAK+kC,SAC3C,OAAO,IAAIS,EAAchuC,EAAQtC,OAAO0D,cAAgBpB,EAAUT,EAAOA,IAG3EyuC,EAAc/mC,UAAUmS,QAAU,SAAkB7c,EAAIoB,GAItD,QAHiB,IAAZA,IAAqBA,EAAU,YAEpC0vC,EAAUpmC,UAAUmS,QAAQjS,KAAKqB,KAAMjM,EAAIoB,GACvCA,GAAW,WAAa,CAC1B,IAAIwP,EAAQ3E,KAAKtH,MAAMo6B,YAAY9yB,KAAKrH,KACpCgM,GAAS5Q,EAAG4b,YAAYhL,KAIhC6gC,EAAc/mC,UAAU+I,GAAK,SAAa6mB,GACxC,OAAOA,aAAiBmX,GAAiBnX,EAAM0W,QAAU/kC,KAAK+kC,QAAU1W,EAAMmP,MAAQx9B,KAAKw9B,MAG7FgI,EAAc/mC,UAAUunC,YAAc,WACpC,OAAO,IAAIG,EAAanmC,KAAK+kC,OAAQ/kC,KAAKw9B,OAG5CgI,EAAc/mC,UAAU4W,OAAS,WAC/B,MAAO,CAACvgB,KAAM,OAAQiwC,OAAQ/kC,KAAK+kC,OAAQvH,KAAMx9B,KAAKw9B,OAGxDgI,EAAcpW,SAAW,SAAmB75B,EAAK26B,GAC/C,GAA0B,iBAAfA,EAAK6U,QAA0C,iBAAb7U,EAAKsN,KAC9C,MAAM,IAAI7O,WAAW,4CACzB,OAAO,IAAI6W,EAAcjwC,EAAIO,QAAQo6B,EAAK6U,QAASxvC,EAAIO,QAAQo6B,EAAKsN,QAKtEgI,EAAclrC,OAAS,SAAiB/E,EAAKwvC,EAAQvH,QACrC,IAATA,IAAkBA,EAAOuH,GAE9B,IAAIvtC,EAAUjC,EAAIO,QAAQivC,GAC1B,OAAO,IAAI/kC,KAAKxI,EAASgmC,GAAQuH,EAASvtC,EAAUjC,EAAIO,QAAQ0nC,KAUlEgI,EAAcS,QAAU,SAAkBzuC,EAAST,EAAOoS,GACxD,IAAIi9B,EAAO5uC,EAAQvB,IAAMc,EAAMd,IAE/B,GADKkT,IAAQi9B,IAAQj9B,EAAOi9B,GAAQ,EAAI,GAAK,IACxCrvC,EAAM7B,OAAO0D,cAAe,CAC/B,IAAIwE,EAAQynC,EAAUQ,SAAStuC,EAAOoS,GAAM,IAAS07B,EAAUQ,SAAStuC,GAAQoS,GAAM,GACtF,IAAI/L,EACG,OAAOynC,EAAUa,KAAK3uC,EAAOoS,GADvBpS,EAAQqG,EAAMrG,MAW7B,OARKS,EAAQtC,OAAO0D,gBACN,GAARwtC,IAGF5uC,GAAWqtC,EAAUQ,SAAS7tC,GAAU2R,GAAM,IAAS07B,EAAUQ,SAAS7tC,EAAS2R,GAAM,IAAO3R,SACnFvB,IAAMc,EAAMd,KAASmwC,EAAO,KAHzC5uC,EAAUT,GAMP,IAAIyuC,EAAchuC,EAAST,IAGpCyH,OAAO+wB,iBAAkBiW,EAAc/mC,UAAWgyB,GAE3C+U,EA1FwB,CA2F/BX,GAEFA,EAAUgB,OAAO,OAAQL,GAEzB,IAAIW,EAAe,SAAsBpB,EAAQvH,GAC/Cx9B,KAAK+kC,OAASA,EACd/kC,KAAKw9B,KAAOA,GAEd2I,EAAa1nC,UAAUzI,IAAM,SAAcD,GACzC,OAAO,IAAIowC,EAAapwC,EAAQC,IAAIgK,KAAK+kC,QAAShvC,EAAQC,IAAIgK,KAAKw9B,QAErE2I,EAAa1nC,UAAU3I,QAAU,SAAkBP,GACjD,OAAOiwC,EAAcS,QAAQ1wC,EAAIO,QAAQkK,KAAK+kC,QAASxvC,EAAIO,QAAQkK,KAAKw9B,QAQ1E,IAAI6I,EAA8B,SAAUxB,GAC1C,SAASwB,EAAcrvC,GACrB,IAAIV,EAAOU,EAAKK,UACZ06B,EAAO/6B,EAAKV,KAAK,GAAGR,QAAQkB,EAAKf,IAAMK,EAAKJ,UAChD2uC,EAAUlmC,KAAKqB,KAAMhJ,EAAM+6B,GAE3B/xB,KAAK1J,KAAOA,EAiDd,OA9CKuuC,IAAYwB,EAAc/jC,UAAYuiC,GAC3CwB,EAAc5nC,UAAYD,OAAOlE,OAAQuqC,GAAaA,EAAUpmC,WAChE4nC,EAAc5nC,UAAUI,YAAcwnC,EAEtCA,EAAc5nC,UAAUzI,IAAM,SAAcT,EAAKQ,GAC/C,IAAIe,EAAMf,EAAQixB,UAAUhnB,KAAK+kC,QAC7Bje,EAAUhwB,EAAIgwB,QACd7wB,EAAMa,EAAIb,IACVe,EAAOzB,EAAIO,QAAQG,GACvB,OAAI6wB,EAAkB+d,EAAUa,KAAK1uC,GAC9B,IAAIqvC,EAAcrvC,IAG3BqvC,EAAc5nC,UAAUtJ,QAAU,WAChC,OAAO,IAAI,KAAM,UAAc6K,KAAK1J,MAAO,EAAG,IAGhD+vC,EAAc5nC,UAAU+I,GAAK,SAAa6mB,GACxC,OAAOA,aAAiBgY,GAAiBhY,EAAM0W,QAAU/kC,KAAK+kC,QAGhEsB,EAAc5nC,UAAU4W,OAAS,WAC/B,MAAO,CAACvgB,KAAM,OAAQiwC,OAAQ/kC,KAAK+kC,SAGrCsB,EAAc5nC,UAAUunC,YAAc,WAA0B,OAAO,IAAIM,EAAatmC,KAAK+kC,SAE7FsB,EAAcjX,SAAW,SAAmB75B,EAAK26B,GAC/C,GAA0B,iBAAfA,EAAK6U,OACZ,MAAM,IAAIpW,WAAW,4CACzB,OAAO,IAAI0X,EAAc9wC,EAAIO,QAAQo6B,EAAK6U,UAK5CsB,EAAc/rC,OAAS,SAAiB/E,EAAKI,GAC3C,OAAO,IAAIqK,KAAKzK,EAAIO,QAAQH,KAM9B0wC,EAAcrgB,aAAe,SAAuB1vB,GAClD,OAAQA,EAAK8K,SAAwC,IAA9B9K,EAAKxB,KAAKC,KAAKqpB,YAGjCioB,EAvDwB,CAwD/BxB,GAEFwB,EAAc5nC,UAAUynC,SAAU,EAElCrB,EAAUgB,OAAO,OAAQQ,GAEzB,IAAIC,EAAe,SAAsBvB,GACvC/kC,KAAK+kC,OAASA,GAEhBuB,EAAa7nC,UAAUzI,IAAM,SAAcD,GACzC,IAAIe,EAAMf,EAAQixB,UAAUhnB,KAAK+kC,QAC3Bje,EAAUhwB,EAAIgwB,QACd7wB,EAAMa,EAAIb,IAChB,OAAO6wB,EAAU,IAAIqf,EAAalwC,EAAKA,GAAO,IAAIqwC,EAAarwC,IAEjEqwC,EAAa7nC,UAAU3I,QAAU,SAAkBP,GACjD,IAAIyB,EAAOzB,EAAIO,QAAQkK,KAAK+kC,QAASzuC,EAAOU,EAAKK,UACjD,OAAIf,GAAQ+vC,EAAcrgB,aAAa1vB,GAAgB,IAAI+vC,EAAcrvC,GAClE6tC,EAAUa,KAAK1uC,IAOxB,IAAI2uC,EAA6B,SAAUd,GACzC,SAASc,EAAapwC,GACpBsvC,EAAUlmC,KAAKqB,KAAMzK,EAAIO,QAAQ,GAAIP,EAAIO,QAAQP,EAAIJ,QAAQC,OA6B/D,OA1BKyvC,IAAYc,EAAarjC,UAAYuiC,GAC1Cc,EAAalnC,UAAYD,OAAOlE,OAAQuqC,GAAaA,EAAUpmC,WAC/DknC,EAAalnC,UAAUI,YAAc8mC,EAErCA,EAAalnC,UAAUmS,QAAU,SAAkB7c,EAAIoB,GAGrD,QAFiB,IAAZA,IAAqBA,EAAU,YAEhCA,GAAW,WAAa,CAC1BpB,EAAGsC,OAAO,EAAGtC,EAAGwB,IAAIJ,QAAQC,MAC5B,IAAIqD,EAAMosC,EAAU3mC,QAAQnK,EAAGwB,KAC1BkD,EAAI+O,GAAGzT,EAAGF,YAAcE,EAAG8B,aAAa4C,QAE7CosC,EAAUpmC,UAAUmS,QAAQjS,KAAKqB,KAAMjM,EAAIoB,IAI/CwwC,EAAalnC,UAAU4W,OAAS,WAAqB,MAAO,CAACvgB,KAAM,QAEnE6wC,EAAavW,SAAW,SAAmB75B,GAAO,OAAO,IAAIowC,EAAapwC,IAE1EowC,EAAalnC,UAAUzI,IAAM,SAAcT,GAAO,OAAO,IAAIowC,EAAapwC,IAE1EowC,EAAalnC,UAAU+I,GAAK,SAAa6mB,GAAS,OAAOA,aAAiBsX,GAE1EA,EAAalnC,UAAUunC,YAAc,WAA0B,OAAOO,GAE/DZ,EA/BuB,CAgC9Bd,GAEFA,EAAUgB,OAAO,MAAOF,GAExB,IAAIY,EAAc,CAChBvwC,IAAK,WAAiB,OAAOgK,MAC7BlK,QAAS,SAAiBP,GAAO,OAAO,IAAIowC,EAAapwC,KAQ3D,SAASkwC,EAAgBlwC,EAAKe,EAAML,EAAKiB,EAAOouC,EAAKtkC,GACnD,GAAI1K,EAAKsC,cAAiB,OAAO4sC,EAAclrC,OAAO/E,EAAKU,GAC3D,IAAK,IAAIgB,EAAIC,GAASouC,EAAM,EAAI,EAAI,GAAIA,EAAM,EAAIruC,EAAIX,EAAKM,WAAaK,GAAK,EAAGA,GAAKquC,EAAK,CACxF,IAAI7nC,EAAQnH,EAAKmH,MAAMxG,GACvB,GAAKwG,EAAMtH,QAGJ,IAAK6K,GAAQqlC,EAAcrgB,aAAavoB,GAC7C,OAAO4oC,EAAc/rC,OAAO/E,EAAKU,GAAOqvC,EAAM,EAAI7nC,EAAMvH,SAAW,QAJlD,CACjB,IAAIkZ,EAAQq2B,EAAgBlwC,EAAKkI,EAAOxH,EAAMqvC,EAAKA,EAAM,EAAI7nC,EAAM7G,WAAa,EAAG0uC,EAAKtkC,GACxF,GAAIoO,EAAS,OAAOA,EAItBnZ,GAAOwH,EAAMvH,SAAWovC,GAI5B,SAAS37B,EAAwB5V,EAAImV,EAAUC,GAC7C,IAAIC,EAAOrV,EAAGsV,MAAMhP,OAAS,EAC7B,KAAI+O,EAAOF,GAAX,CACA,IAEiCnQ,EAF7BnD,EAAO7B,EAAGsV,MAAMD,GACpB,GAAMxT,aAAgB,MAAeA,aAAgB,KAC3C7B,EAAGgC,QAAQuT,KAAKF,GACtBjK,SAAQ,SAAUoK,EAAOC,EAAKC,EAAUC,GAAoB,MAAP3Q,IAAeA,EAAM2Q,MAC9E3V,EAAG8B,aAAagvC,EAAUa,KAAK3xC,EAAGwB,IAAIO,QAAQiD,GAAMoQ,KAGtD,IAmBIq9B,EAA4B,SAAUC,GACxC,SAASD,EAAY7yC,GACnB8yC,EAAU9nC,KAAKqB,KAAMrM,EAAM4B,KAI3ByK,KAAK0mC,KAAOC,KAAKC,MACjB5mC,KAAK6mC,aAAelzC,EAAME,UAE1BmM,KAAK8mC,gBAAkB,EAGvB9mC,KAAKyH,YAAc9T,EAAM8T,YAGzBzH,KAAK+mC,QAAU,EAEf/mC,KAAKoK,KAAO5L,OAAOlE,OAAO,MAGvBmsC,IAAYD,EAAYlkC,UAAYmkC,GACzCD,EAAY/nC,UAAYD,OAAOlE,OAAQmsC,GAAaA,EAAUhoC,WAC9D+nC,EAAY/nC,UAAUI,YAAc2nC,EAEpC,IAAIvY,EAAqB,CAAEp6B,UAAW,CAAEq6B,cAAc,GAAO9T,aAAc,CAAE8T,cAAc,GAAO8Y,eAAgB,CAAE9Y,cAAc,GAAO+Y,UAAW,CAAE/Y,cAAc,GAAOgZ,iBAAkB,CAAEhZ,cAAc,IAwK7M,OAjKAD,EAAmBp6B,UAAU64B,IAAM,WAKjC,OAJI1sB,KAAK8mC,gBAAkB9mC,KAAKqJ,MAAMhP,SACpC2F,KAAK6mC,aAAe7mC,KAAK6mC,aAAa7wC,IAAIgK,KAAKzK,IAAKyK,KAAKjK,QAAQN,MAAMuK,KAAK8mC,kBAC5E9mC,KAAK8mC,gBAAkB9mC,KAAKqJ,MAAMhP,QAE7B2F,KAAK6mC,cAMdL,EAAY/nC,UAAU5I,aAAe,SAAuBhC,GAC1D,GAAIA,EAAU6E,MAAMnD,KAAOyK,KAAKzK,IAC5B,MAAM,IAAIo5B,WAAW,uEAKzB,OAJA3uB,KAAK6mC,aAAehzC,EACpBmM,KAAK8mC,gBAAkB9mC,KAAKqJ,MAAMhP,OAClC2F,KAAK+mC,SAAyC,GAlEhC,EAkEE/mC,KAAK+mC,SACrB/mC,KAAKyH,YAAc,KACZzH,MAKTiuB,EAAmB7T,aAAasS,IAAM,WACpC,OA1Ec,EA0EN1sB,KAAK+mC,SAAyB,GAKxCP,EAAY/nC,UAAUiJ,eAAiB,SAAyB/C,GAG9D,OAFA3E,KAAKyH,YAAc9C,EACnB3E,KAAK+mC,SAjF4B,EAkF1B/mC,MAOTwmC,EAAY/nC,UAAUkR,YAAc,SAAsBhL,GAGxD,OAFK,aAAa3E,KAAKyH,aAAezH,KAAKnM,UAAU6E,MAAMiM,QAASA,IAChE3E,KAAK0H,eAAe/C,GACjB3E,MAKTwmC,EAAY/nC,UAAUyP,cAAgB,SAAwB1I,GAC5D,OAAOxF,KAAK2P,YAAYnK,EAAKqqB,SAAS7vB,KAAKyH,aAAezH,KAAKnM,UAAUkD,MAAM4N,WAKjF6hC,EAAY/nC,UAAU0V,iBAAmB,SAA2B3O,GAClE,OAAOxF,KAAK2P,YAAYnK,EAAKyqB,cAAcjwB,KAAKyH,aAAezH,KAAKnM,UAAUkD,MAAM4N,WAKtFspB,EAAmB+Y,eAAeta,IAAM,WACtC,OA9GiC,EA8GzB1sB,KAAK+mC,SAA2B,GAG1CP,EAAY/nC,UAAU0oC,QAAU,SAAkBvxC,EAAML,GACtDkxC,EAAUhoC,UAAU0oC,QAAQxoC,KAAKqB,KAAMpK,EAAML,GAC7CyK,KAAK+mC,SAAyB,EAAf/mC,KAAK+mC,QACpB/mC,KAAKyH,YAAc,MAKrB++B,EAAY/nC,UAAU2oC,QAAU,SAAkBV,GAEhD,OADA1mC,KAAK0mC,KAAOA,EACL1mC,MAKTwmC,EAAY/nC,UAAU4oC,iBAAmB,SAA2B5xC,GAElE,OADAuK,KAAKnM,UAAU+c,QAAQ5Q,KAAMvK,GACtBuK,MAOTwmC,EAAY/nC,UAAUkP,qBAAuB,SAA+BrX,EAAMgxC,GAChF,IAAIzzC,EAAYmM,KAAKnM,UAIrB,OAHqB,IAAjByzC,IACAhxC,EAAOA,EAAKkP,KAAKxF,KAAKyH,cAAgB5T,EAAUC,MAAQD,EAAU6E,MAAMiM,QAAW9Q,EAAU6E,MAAMo6B,YAAYj/B,EAAU8E,MAAQ,aACrI9E,EAAUyE,YAAY0H,KAAM1J,GACrB0J,MAKTwmC,EAAY/nC,UAAU/K,gBAAkB,WAEtC,OADAsM,KAAKnM,UAAU+c,QAAQ5Q,MAChBA,MAMTwmC,EAAY/nC,UAAU9G,WAAa,SAAqBqJ,EAAMrL,EAAMD,QACtD,IAAPA,IAAgBA,EAAKC,GAE1B,IAAI6L,EAASxB,KAAKzK,IAAIT,KAAK0M,OAC3B,GAAY,MAAR7L,EACF,OAAKqL,EACEhB,KAAK2N,qBAAqBnM,EAAOR,KAAKA,IAAO,GADhChB,KAAKtM,kBAGzB,IAAKsN,EAAQ,OAAOhB,KAAKoE,YAAYzO,EAAMD,GAC3C,IAAIiP,EAAQ3E,KAAKyH,YACjB,IAAK9C,EAAO,CACV,IAAIjM,EAAQsH,KAAKzK,IAAIO,QAAQH,GAC7BgP,EAAQjP,GAAMC,EAAO+C,EAAMiM,QAAUjM,EAAMo6B,YAAY9yB,KAAKzK,IAAIO,QAAQJ,IAI1E,OAFAsK,KAAKolC,iBAAiBzvC,EAAMD,EAAI8L,EAAOR,KAAKA,EAAM2D,IAC7C3E,KAAKnM,UAAUC,OAASkM,KAAKnK,aAAagvC,EAAUa,KAAK1lC,KAAKnM,UAAU8E,MACtEqH,MAOXwmC,EAAY/nC,UAAUmP,QAAU,SAAkBxR,EAAKmC,GAErD,OADAyB,KAAKoK,KAAmB,iBAAPhO,EAAkBA,EAAMA,EAAIA,KAAOmC,EAC7CyB,MAKTwmC,EAAY/nC,UAAUoX,QAAU,SAAkBzZ,GAChD,OAAO4D,KAAKoK,KAAmB,iBAAPhO,EAAkBA,EAAMA,EAAIA,MAMtD6xB,EAAmBgZ,UAAUva,IAAM,WACjC,IAAK,IAAI9C,KAAK5pB,KAAKoK,KAAQ,OAAO,EAClC,OAAO,GAMTo8B,EAAY/nC,UAAUzK,eAAiB,WAErC,OADAgM,KAAK+mC,SAzMgD,EA0M9C/mC,MAGTiuB,EAAmBiZ,iBAAiBxa,IAAM,WACxC,OA9MqD,EA8M7C1sB,KAAK+mC,SAA4B,GAG3CvoC,OAAO+wB,iBAAkBiX,EAAY/nC,UAAWwvB,GAEzCuY,EAhMsB,CAiM7B,MAEF,SAAS/mC,EAAK0L,EAAG0hB,GACf,OAAQA,GAAS1hB,EAAQA,EAAE1L,KAAKotB,GAAX1hB,EAGvB,IAAIo8B,EAAY,SAAmBtnC,EAAMunC,EAAM3a,GAC7C7sB,KAAKC,KAAOA,EACZD,KAAKia,KAAOxa,EAAK+nC,EAAKvtB,KAAM4S,GAC5B7sB,KAAKkV,MAAQzV,EAAK+nC,EAAKtyB,MAAO2X,IAG5B4a,EAAa,CACf,IAAIF,EAAU,MAAO,CACnBttB,KAAM,SAAcna,GAAU,OAAOA,EAAOvK,KAAOuK,EAAO0B,OAAOipB,YAAYlyB,iBAC7E2c,MAAO,SAAenhB,GAAM,OAAOA,EAAGwB,OAGxC,IAAIgyC,EAAU,YAAa,CACzBttB,KAAM,SAAcna,EAAQy5B,GAAY,OAAOz5B,EAAOjM,WAAagxC,EAAU3mC,QAAQq7B,EAAShkC,MAC9F2f,MAAO,SAAenhB,GAAM,OAAOA,EAAGF,aAGxC,IAAI0zC,EAAU,cAAe,CAC3BttB,KAAM,SAAcna,GAAU,OAAOA,EAAO2H,aAAe,MAC3DyN,MAAO,SAAenhB,EAAI2zC,EAAQC,EAAMh0C,GAAS,OAAOA,EAAME,UAAUM,QAAUJ,EAAG0T,YAAc,QAGrG,IAAI8/B,EAAU,oBAAqB,CACjCttB,KAAM,WAAkB,OAAO,GAC/B/E,MAAO,SAAenhB,EAAImmB,GAAQ,OAAOnmB,EAAGmzC,iBAAmBhtB,EAAO,EAAIA,MAM1E0tB,EAAgB,SAAuBpmC,EAAQ6R,GACjD,IAAI+mB,EAASp6B,KAEbA,KAAKwB,OAASA,EACdxB,KAAKge,OAASypB,EAAWxa,SACzBjtB,KAAKqT,QAAU,GACfrT,KAAK6nC,aAAerpC,OAAOlE,OAAO,MAC9B+Y,GAAWA,EAAQlU,SAAQ,SAAUmU,GACvC,GAAI8mB,EAAOyN,aAAav0B,EAAOlX,KAC3B,MAAM,IAAIuyB,WAAW,iDAAmDrb,EAAOlX,IAAM,KACzFg+B,EAAO/mB,QAAQzY,KAAK0Y,GACpB8mB,EAAOyN,aAAav0B,EAAOlX,KAAOkX,EAC9BA,EAAOve,KAAKpB,OACZymC,EAAOpc,OAAOpjB,KAAK,IAAI2sC,EAAUj0B,EAAOlX,IAAKkX,EAAOve,KAAKpB,MAAO2f,QAWpEw0B,EAAc,SAAqBhoC,GACrCE,KAAKF,OAASA,GAGZ2wB,EAAuB,CAAEjvB,OAAQ,CAAE0sB,cAAc,GAAO7a,QAAS,CAAE6a,cAAc,GAAOn6B,GAAI,CAAEm6B,cAAc,IAchHuC,EAAqBjvB,OAAOkrB,IAAM,WAChC,OAAO1sB,KAAKF,OAAO0B,QAKrBivB,EAAqBpd,QAAQqZ,IAAM,WACjC,OAAO1sB,KAAKF,OAAOuT,SAKrBy0B,EAAYrpC,UAAUyW,MAAQ,SAAgBnhB,GAC5C,OAAOiM,KAAKmV,iBAAiBphB,GAAIJ,OAInCm0C,EAAYrpC,UAAUspC,kBAAoB,SAA4Bh0C,EAAIktC,QACtD,IAAXA,IAAoBA,GAAU,GAErC,IAAK,IAAIhqC,EAAI,EAAGA,EAAI+I,KAAKF,OAAOuT,QAAQhZ,OAAQpD,IAAO,GAAIA,GAAKgqC,EAAQ,CACtE,IAAI3tB,EAAStT,KAAKF,OAAOuT,QAAQpc,GACjC,GAAIqc,EAAOve,KAAKgzC,oBAAsBz0B,EAAOve,KAAKgzC,kBAAkBppC,KAAK2U,EAAQvf,EAAIiM,MACjF,OAAO,EAEb,OAAO,GAST8nC,EAAYrpC,UAAU0W,iBAAmB,SAA2B6yB,GAClE,IAAKhoC,KAAK+nC,kBAAkBC,GAAW,MAAO,CAACr0C,MAAOqM,KAAMkX,aAAc,IAMzE,IAJD,IAAI+wB,EAAM,CAACD,GAAS5wB,EAAWpX,KAAKkoC,WAAWF,GAASxe,EAAO,OAIrD,CAER,IADA,IAAI2e,GAAU,EACLlxC,EAAI,EAAGA,EAAI+I,KAAKF,OAAOuT,QAAQhZ,OAAQpD,IAAK,CACnD,IAAIqc,EAAStT,KAAKF,OAAOuT,QAAQpc,GACjC,GAAIqc,EAAOve,KAAKkiB,kBAAmB,CACjC,IAAIpG,EAAI2Y,EAAOA,EAAKvyB,GAAG4Z,EAAI,EAAGsG,EAAWqS,EAAOA,EAAKvyB,GAAGtD,MAAQqM,KAC5DjM,EAAK8c,EAAIo3B,EAAI5tC,QACbiZ,EAAOve,KAAKkiB,kBAAkBtY,KAAK2U,EAAQzC,EAAIo3B,EAAIxyC,MAAMob,GAAKo3B,EAAK9wB,EAAUC,GACjF,GAAIrjB,GAAMqjB,EAAS2wB,kBAAkBh0C,EAAIkD,GAAI,CAE3C,GADAlD,EAAG6Z,QAAQ,sBAAuBo6B,IAC7Bxe,EAAM,CACTA,EAAO,GACP,IAAK,IAAI5V,EAAI,EAAGA,EAAI5T,KAAKF,OAAOuT,QAAQhZ,OAAQuZ,IAC5C4V,EAAK5uB,KAAKgZ,EAAI3c,EAAI,CAACtD,MAAOyjB,EAAUvG,EAAGo3B,EAAI5tC,QAAU,CAAC1G,MAAOqM,KAAM6Q,EAAG,IAE5Eo3B,EAAIrtC,KAAK7G,GACTqjB,EAAWA,EAAS8wB,WAAWn0C,GAC/Bo0C,GAAU,EAER3e,IAAQA,EAAKvyB,GAAK,CAACtD,MAAOyjB,EAAUvG,EAAGo3B,EAAI5tC,UAGnD,IAAK8tC,EAAW,MAAO,CAACx0C,MAAOyjB,EAAUF,aAAc+wB,KAK3DH,EAAYrpC,UAAUypC,WAAa,SAAqBn0C,GACtD,IAAKA,EAAGa,OAAO4S,GAAGxH,KAAKzK,KAAQ,MAAM,IAAIo5B,WAAW,qCAEpD,IADA,IAAIyZ,EAAc,IAAIN,EAAY9nC,KAAKF,QAASke,EAAShe,KAAKF,OAAOke,OAC5D/mB,EAAI,EAAGA,EAAI+mB,EAAO3jB,OAAQpD,IAAK,CACtC,IAAI2I,EAAQoe,EAAO/mB,GACnBmxC,EAAYxoC,EAAMK,MAAQL,EAAMsV,MAAMnhB,EAAIiM,KAAKJ,EAAMK,MAAOD,KAAMooC,GAEpE,IAAK,IAAIptC,EAAM,EAAGA,EAAMqtC,EAAehuC,OAAQW,IAASqtC,EAAertC,GAAKgF,KAAMjM,EAAIq0C,GACtF,OAAOA,GAKT3X,EAAqB18B,GAAG24B,IAAM,WAAc,OAAO,IAAI8Z,EAAYxmC,OAqBnE8nC,EAAYxtC,OAAS,SAAiBwF,GAGpC,IAFA,IAAIwoC,EAAU,IAAIV,EAAc9nC,EAAOvK,IAAMuK,EAAOvK,IAAIT,KAAK0M,OAAS1B,EAAO0B,OAAQ1B,EAAOuT,SACxFkmB,EAAW,IAAIuO,EAAYQ,GACtBrxC,EAAI,EAAGA,EAAIqxC,EAAQtqB,OAAO3jB,OAAQpD,IACvCsiC,EAAS+O,EAAQtqB,OAAO/mB,GAAGgJ,MAAQqoC,EAAQtqB,OAAO/mB,GAAGgjB,KAAKna,EAAQy5B,GACtE,OAAOA,GAeTuO,EAAYrpC,UAAU2W,YAAc,SAAsBtV,GAGxD,IAFA,IAAIwoC,EAAU,IAAIV,EAAc5nC,KAAKwB,OAAQ1B,EAAOuT,SAChD2K,EAASsqB,EAAQtqB,OAAQub,EAAW,IAAIuO,EAAYQ,GAC/CrxC,EAAI,EAAGA,EAAI+mB,EAAO3jB,OAAQpD,IAAK,CACtC,IAAIgJ,EAAO+d,EAAO/mB,GAAGgJ,KACrBs5B,EAASt5B,GAAQD,KAAKypB,eAAexpB,GAAQD,KAAKC,GAAQ+d,EAAO/mB,GAAGgjB,KAAKna,EAAQy5B,GAEnF,OAAOA,GASTuO,EAAYrpC,UAAU4W,OAAS,SAAiBkzB,GAC9C,IAAIl+B,EAAS,CAAC9U,IAAKyK,KAAKzK,IAAI8f,SAAUxhB,UAAWmM,KAAKnM,UAAUwhB,UAEhE,GADIrV,KAAKyH,cAAe4C,EAAO5C,YAAczH,KAAKyH,YAAYzR,KAAI,SAAUw+B,GAAK,OAAOA,EAAEnf,aACtFkzB,GAAuC,iBAAhBA,EAA4B,IAAK,IAAIh8B,KAAQg8B,EAAc,CACpF,GAAY,OAARh8B,GAAyB,aAARA,EACjB,MAAM,IAAIoiB,WAAW,sDACzB,IAAIrb,EAASi1B,EAAah8B,GAAO5Y,EAAQ2f,EAAOve,KAAKpB,MACjDA,GAASA,EAAM0hB,SAAUhL,EAAOkC,GAAQ5Y,EAAM0hB,OAAO1W,KAAK2U,EAAQtT,KAAKsT,EAAOlX,OAEpF,OAAOiO,GAiBTy9B,EAAY1Y,SAAW,SAAmBtvB,EAAQowB,EAAMqY,GACtD,IAAKrY,EAAQ,MAAM,IAAIvB,WAAW,0CAClC,IAAK7uB,EAAO0B,OAAU,MAAM,IAAImtB,WAAW,0CAC3C,IAAI2Z,EAAU,IAAIV,EAAc9nC,EAAO0B,OAAQ1B,EAAOuT,SAClDkmB,EAAW,IAAIuO,EAAYQ,GAqB/B,OApBAA,EAAQtqB,OAAO7e,SAAQ,SAAUS,GAC/B,GAAkB,OAAdA,EAAMK,KACRs5B,EAAShkC,IAAM,cAAcuK,EAAO0B,OAAQ0uB,EAAK36B,UAC5C,GAAkB,aAAdqK,EAAMK,KACfs5B,EAAS1lC,UAAYgxC,EAAUzV,SAASmK,EAAShkC,IAAK26B,EAAKr8B,gBACtD,GAAkB,eAAd+L,EAAMK,KACXiwB,EAAKzoB,cAAe8xB,EAAS9xB,YAAcyoB,EAAKzoB,YAAYzR,IAAI8J,EAAO0B,OAAOizB,mBAC7E,CACL,GAAI8T,EAAgB,IAAK,IAAIh8B,KAAQg8B,EAAc,CACjD,IAAIj1B,EAASi1B,EAAah8B,GAAO5Y,EAAQ2f,EAAOve,KAAKpB,MACrD,GAAI2f,EAAOlX,KAAOwD,EAAMK,MAAQtM,GAASA,EAAMy7B,UAC3C5wB,OAAOC,UAAUgrB,eAAe9qB,KAAKuxB,EAAM3jB,GAG7C,YADAgtB,EAAS35B,EAAMK,MAAQtM,EAAMy7B,SAASzwB,KAAK2U,EAAQxT,EAAQowB,EAAK3jB,GAAOgtB,IAI3EA,EAAS35B,EAAMK,MAAQL,EAAMqa,KAAKna,EAAQy5B,OAGvCA,GASTuO,EAAYU,iBAAmB,SAA2Br9B,GACxDk9B,EAAeztC,KAAKuQ,IAEtB28B,EAAYW,oBAAsB,SAA8Bt9B,GAC9D,IAAI/N,EAAQirC,EAAeloB,QAAQhV,GAC/B/N,GAAS,GAAKirC,EAAetb,OAAO3vB,EAAO,IAGjDoB,OAAO+wB,iBAAkBuY,EAAYrpC,UAAWgyB,GAEhD,IAAI4X,EAAiB,GAoDrB,SAASK,EAAUt8B,EAAKygB,EAAMn4B,GAC5B,IAAK,IAAI6X,KAAQH,EAAK,CACpB,IAAIsmB,EAAMtmB,EAAIG,GACVmmB,aAAeiW,SAAYjW,EAAMA,EAAIjzB,KAAKotB,GAC7B,mBAARtgB,IAA6BmmB,EAAMgW,EAAUhW,EAAK7F,EAAM,KACjEn4B,EAAO6X,GAAQmmB,EAEjB,OAAOh+B,EAMT,IAAIk0C,EAAS,SAAgB7zC,GAG3BiL,KAAKR,MAAQ,GACTzK,EAAKyK,OAASkpC,EAAU3zC,EAAKyK,MAAOQ,KAAMA,KAAKR,OAGnDQ,KAAKjL,KAAOA,EACZiL,KAAK5D,IAAMrH,EAAKqH,IAAMrH,EAAKqH,IAAIA,IAAMysC,EAAU,WAKjDD,EAAOnqC,UAAUgV,SAAW,SAAmB9f,GAAS,OAAOA,EAAMqM,KAAK5D,MA4B1E,IAAI8C,EAAOV,OAAOlE,OAAO,MAEzB,SAASuuC,EAAU5oC,GACjB,OAAIA,KAAQf,EAAee,EAAO,OAAQf,EAAKe,IAC/Cf,EAAKe,GAAQ,EACNA,EAAO,KAOhB,IAAI6oC,EAAY,SAAmB7oC,QACrB,IAATA,IAAkBA,EAAO,OAC7BD,KAAK5D,IAAMysC,EAAU5oC,IAKtB6oC,EAAUrqC,UAAUiuB,IAAM,SAAc/4B,GAAS,OAAOA,EAAMmM,OAAO+nC,aAAa7nC,KAAK5D,MAIvF0sC,EAAUrqC,UAAUgV,SAAW,SAAmB9f,GAAS,OAAOA,EAAMqM,KAAK5D,O,8RC3kCzE2sC,EAAW1nC,KAAK2nC,IAAI,EAAG,IAG3B,SAASC,EAAa1qC,GAAS,OAJjB,MAIwBA,EAKtC,IAAI2qC,EAAY,SAAmBjzC,EAAK6wB,EAASqiB,QAC9B,IAAZriB,IAAqBA,GAAU,QACnB,IAAZqiB,IAAqBA,EAAU,MAGpCnpC,KAAK/J,IAAMA,EAGX+J,KAAK8mB,QAAUA,EACf9mB,KAAKmpC,QAAUA,GAQbC,EAAU,SAASA,EAAQlnC,EAAQmnC,GAGrC,QAFkB,IAAbA,IAAsBA,GAAW,IAEjCnnC,EAAO7H,QAAU+uC,EAAQt1C,MAAS,OAAOs1C,EAAQt1C,MACtDkM,KAAKkC,OAASA,EACdlC,KAAKqpC,SAAWA,GAGlBD,EAAQ3qC,UAAU0qC,QAAU,SAAkB5qC,GAC5C,IAAI+qC,EAAO,EAAGpyC,EAAQ+xC,EAAa1qC,GACnC,IAAKyB,KAAKqpC,SAAY,IAAK,IAAIpyC,EAAI,EAAGA,EAAIC,EAAOD,IAC7CqyC,GAAQtpC,KAAKkC,OAAW,EAAJjL,EAAQ,GAAK+I,KAAKkC,OAAW,EAAJjL,EAAQ,GACzD,OAAO+I,KAAKkC,OAAe,EAARhL,GAAaoyC,EAjClC,SAAuB/qC,GAAS,OAAQA,GAL1B,MAKmCA,IAAoBwqC,EAiC5BQ,CAAchrC,IAIvD6qC,EAAQ3qC,UAAUuoB,UAAY,SAAoB/wB,EAAKuzC,GAEtD,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BxpC,KAAKypC,KAAKxzC,EAAKuzC,GAAO,IAG9BJ,EAAQ3qC,UAAUzI,IAAM,SAAcC,EAAKuzC,GAE1C,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BxpC,KAAKypC,KAAKxzC,EAAKuzC,GAAO,IAE9BJ,EAAQ3qC,UAAUgrC,KAAO,SAAexzC,EAAKuzC,EAAOE,GAElD,IADA,IAAIJ,EAAO,EAAGK,EAAW3pC,KAAKqpC,SAAW,EAAI,EAAGO,EAAW5pC,KAAKqpC,SAAW,EAAI,EACtEpyC,EAAI,EAAGA,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CAC9C,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,IAAM+I,KAAKqpC,SAAWC,EAAO,GACrD,GAAInuC,EAAQlF,EAAO,MACnB,IAAI4zC,EAAU7pC,KAAKkC,OAAOjL,EAAI0yC,GAAWG,EAAU9pC,KAAKkC,OAAOjL,EAAI2yC,GAAW7wC,EAAMoC,EAAQ0uC,EAC5F,GAAI5zC,GAAO8C,EAAK,CACd,IACIsR,EAASlP,EAAQmuC,IADTO,EAAkB5zC,GAAOkF,GAAS,EAAIlF,GAAO8C,EAAM,EAAIywC,EAA7CA,GACc,EAAI,EAAIM,GAC5C,GAAIJ,EAAU,OAAOr/B,EACrB,IAAI8+B,EAAUlzC,IAAQuzC,EAAQ,EAAIruC,EAAQpC,GAAO,KAAmB9B,EAAI,GAAGhB,EAAMkF,GA1DzB4tC,EA2DxD,OAAO,IAAIG,EAAU7+B,EAAQm/B,EAAQ,EAAIvzC,GAAOkF,EAAQlF,GAAO8C,EAAKowC,GAEtEG,GAAQQ,EAAUD,EAEpB,OAAOH,EAASzzC,EAAMqzC,EAAO,IAAIJ,EAAUjzC,EAAMqzC,IAGnDF,EAAQ3qC,UAAUsrC,QAAU,SAAkB9zC,EAAKkzC,GAGjD,IAFA,IAAIG,EAAO,EAAGpyC,EAAQ+xC,EAAaE,GAC/BQ,EAAW3pC,KAAKqpC,SAAW,EAAI,EAAGO,EAAW5pC,KAAKqpC,SAAW,EAAI,EAC5DpyC,EAAI,EAAGA,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CAC9C,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,IAAM+I,KAAKqpC,SAAWC,EAAO,GACrD,GAAInuC,EAAQlF,EAAO,MACnB,IAAI4zC,EAAU7pC,KAAKkC,OAAOjL,EAAI0yC,GAC9B,GAAI1zC,GAD2CkF,EAAQ0uC,GACrC5yC,GAAa,EAARC,EAAa,OAAO,EAC3CoyC,GAAQtpC,KAAKkC,OAAOjL,EAAI2yC,GAAYC,EAEtC,OAAO,GAMTT,EAAQ3qC,UAAUU,QAAU,SAAkBgM,GAE5C,IADA,IAAIw+B,EAAW3pC,KAAKqpC,SAAW,EAAI,EAAGO,EAAW5pC,KAAKqpC,SAAW,EAAI,EAC5DpyC,EAAI,EAAGqyC,EAAO,EAAGryC,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CACxD,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,GAAImzB,EAAWjvB,GAAS6E,KAAKqpC,SAAWC,EAAO,GAAIpf,EAAW/uB,GAAS6E,KAAKqpC,SAAW,EAAIC,GAC/GO,EAAU7pC,KAAKkC,OAAOjL,EAAI0yC,GAAWG,EAAU9pC,KAAKkC,OAAOjL,EAAI2yC,GACnEz+B,EAAEif,EAAUA,EAAWyf,EAAS3f,EAAUA,EAAW4f,GACrDR,GAAQQ,EAAUD,IAOtBT,EAAQ3qC,UAAUoV,OAAS,WACzB,OAAO,IAAIu1B,EAAQppC,KAAKkC,QAASlC,KAAKqpC,WAGxCD,EAAQ3qC,UAAUC,SAAW,WAC3B,OAAQsB,KAAKqpC,SAAW,IAAM,IAAMpwB,KAAKC,UAAUlZ,KAAKkC,SAO1DknC,EAAQ1jC,OAAS,SAAiBmL,GAChC,OAAY,GAALA,EAASu4B,EAAQt1C,MAAQ,IAAIs1C,EAAQv4B,EAAI,EAAI,CAAC,GAAIA,EAAG,GAAK,CAAC,EAAG,EAAGA,KAG1Eu4B,EAAQt1C,MAAQ,IAAIs1C,EAAQ,IAS5B,IAAIY,EAAU,SAAiB1gC,EAAM2gC,EAAQt0C,EAAMD,GAGjDsK,KAAKsJ,KAAOA,GAAQ,GAIpBtJ,KAAKrK,KAAOA,GAAQ,EAGpBqK,KAAKtK,GAAW,MAANA,EAAasK,KAAKsJ,KAAKjP,OAAS3E,EAC1CsK,KAAKiqC,OAASA,GAyGhB,SAASC,EAAeva,GACtB,IAAIC,EAAM7rB,MAAMpF,KAAKqB,KAAM2vB,GAE3B,OADAC,EAAIttB,UAAY4nC,EAAezrC,UACxBmxB,EAvGToa,EAAQvrC,UAAUhJ,MAAQ,SAAgBE,EAAMD,GAI9C,YAHgB,IAATC,IAAkBA,EAAO,QAClB,IAAPD,IAAgBA,EAAKsK,KAAKsJ,KAAKjP,QAE/B,IAAI2vC,EAAQhqC,KAAKsJ,KAAMtJ,KAAKiqC,OAAQt0C,EAAMD,IAGnDs0C,EAAQvrC,UAAUlE,KAAO,WACvB,OAAO,IAAIyvC,EAAQhqC,KAAKsJ,KAAK7T,QAASuK,KAAKiqC,QAAUjqC,KAAKiqC,OAAOx0C,QAASuK,KAAKrK,KAAMqK,KAAKtK,KAO5Fs0C,EAAQvrC,UAAU0rC,UAAY,SAAoBn0C,EAAKo0C,GACrDpqC,KAAKtK,GAAKsK,KAAKsJ,KAAK1O,KAAK5E,GACV,MAAXo0C,GAAmBpqC,KAAKqqC,UAAUrqC,KAAKsJ,KAAKjP,OAAS,EAAG+vC,IAM9DJ,EAAQvrC,UAAU6rC,cAAgB,SAAwBv0C,GACxD,IAAK,IAAIkB,EAAI,EAAGszC,EAAYvqC,KAAKsJ,KAAKjP,OAAQpD,EAAIlB,EAAQuT,KAAKjP,OAAQpD,IAAK,CAC1E,IAAIuzC,EAAOz0C,EAAQ00C,UAAUxzC,GAC7B+I,KAAKmqC,UAAUp0C,EAAQuT,KAAKrS,GAAY,MAARuzC,GAAgBA,EAAOvzC,EAAIszC,EAAYC,EAAO,QAQlFR,EAAQvrC,UAAUgsC,UAAY,SAAoB55B,GAChD,GAAI7Q,KAAKiqC,OAAU,IAAK,IAAIhzC,EAAI,EAAGA,EAAI+I,KAAKiqC,OAAO5vC,OAAQpD,IACvD,GAAI+I,KAAKiqC,OAAOhzC,IAAM4Z,EAAK,OAAO7Q,KAAKiqC,OAAOhzC,GAAKA,EAAI,GAAK,EAAI,KAGtE+yC,EAAQvrC,UAAU4rC,UAAY,SAAoBx5B,EAAG2jB,GAC9Cx0B,KAAKiqC,SAAUjqC,KAAKiqC,OAAS,IAClCjqC,KAAKiqC,OAAOrvC,KAAKiW,EAAG2jB,IAKtBwV,EAAQvrC,UAAUisC,sBAAwB,SAAgC30C,GACxE,IAAK,IAAIkB,EAAIlB,EAAQuT,KAAKjP,OAAS,EAAGswC,EAAY3qC,KAAKsJ,KAAKjP,OAAStE,EAAQuT,KAAKjP,OAAQpD,GAAK,EAAGA,IAAK,CACrG,IAAIuzC,EAAOz0C,EAAQ00C,UAAUxzC,GAC7B+I,KAAKmqC,UAAUp0C,EAAQuT,KAAKrS,GAAG4c,SAAkB,MAAR22B,GAAgBA,EAAOvzC,EAAI0zC,EAAYH,EAAO,EAAI,QAM/FR,EAAQvrC,UAAUoV,OAAS,WACzB,IAAI+2B,EAAU,IAAIZ,EAElB,OADAY,EAAQF,sBAAsB1qC,MACvB4qC,GAKTZ,EAAQvrC,UAAUzI,IAAM,SAAcC,EAAKuzC,GAGzC,QAFiB,IAAVA,IAAmBA,EAAQ,GAE9BxpC,KAAKiqC,OAAU,OAAOjqC,KAAKypC,KAAKxzC,EAAKuzC,GAAO,GAChD,IAAK,IAAIvyC,EAAI+I,KAAKrK,KAAMsB,EAAI+I,KAAKtK,GAAIuB,IACjChB,EAAM+J,KAAKsJ,KAAKrS,GAAGjB,IAAIC,EAAKuzC,GAChC,OAAOvzC,GAMT+zC,EAAQvrC,UAAUuoB,UAAY,SAAoB/wB,EAAKuzC,GAEtD,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BxpC,KAAKypC,KAAKxzC,EAAKuzC,GAAO,IAE9BQ,EAAQvrC,UAAUgrC,KAAO,SAAexzC,EAAKuzC,EAAOE,GAGlD,IAFA,IAAI5iB,GAAU,EAEL7vB,EAAI+I,KAAKrK,KAAMsB,EAAI+I,KAAKtK,GAAIuB,IAAK,CACxC,IAAwBoT,EAAdrK,KAAKsJ,KAAKrS,GAAiB+vB,UAAU/wB,EAAKuzC,GACpD,GAAsB,MAAlBn/B,EAAO8+B,QAAiB,CAC1B,IAAI0B,EAAO7qC,KAAKyqC,UAAUxzC,GAC1B,GAAY,MAAR4zC,GAAgBA,EAAO5zC,GAAK4zC,EAAO7qC,KAAKtK,GAAI,CAC9CuB,EAAI4zC,EACJ50C,EAAM+J,KAAKsJ,KAAKuhC,GAAM1B,QAAQ9+B,EAAO8+B,SACrC,UAIA9+B,EAAOyc,UAAWA,GAAU,GAChC7wB,EAAMoU,EAAOpU,IAGf,OAAOyzC,EAASzzC,EAAM,IAAIizC,EAAUjzC,EAAK6wB,IAS3CojB,EAAezrC,UAAYD,OAAOlE,OAAOyJ,MAAMtF,WAC/CyrC,EAAezrC,UAAUI,YAAcqrC,EACvCA,EAAezrC,UAAUwB,KAAO,iBAOhC,IAAIwmC,EAAY,SAAmBlxC,GAIjCyK,KAAKzK,IAAMA,EAGXyK,KAAKqJ,MAAQ,GAGbrJ,KAAK8T,KAAO,GAGZ9T,KAAKjK,QAAU,IAAIi0C,GAGjB/b,EAAqB,CAAEr5B,OAAQ,CAAEs5B,cAAc,GAAO5W,WAAY,CAAE4W,cAAc,IAuCtF,SAAS4c,IAAiB,MAAM,IAAI/mC,MAAM,eApC1CkqB,EAAmBr5B,OAAO83B,IAAM,WAAc,OAAO1sB,KAAK8T,KAAKzZ,OAAS2F,KAAK8T,KAAK,GAAK9T,KAAKzK,KAK5FkxC,EAAUhoC,UAAU7I,KAAO,SAAe6nC,GACxC,IAAIpzB,EAASrK,KAAKqL,UAAUoyB,GAC5B,GAAIpzB,EAAO0gC,OAAU,MAAM,IAAIb,EAAe7/B,EAAO0gC,QACrD,OAAO/qC,MAMTymC,EAAUhoC,UAAU4M,UAAY,SAAoBzV,GAClD,IAAIyU,EAASzU,EAAKsf,MAAMlV,KAAKzK,KAE7B,OADK8U,EAAO0gC,QAAU/qC,KAAKmnC,QAAQvxC,EAAMyU,EAAO9U,KACzC8U,GAMT4jB,EAAmB3W,WAAWoV,IAAM,WAClC,OAAO1sB,KAAKqJ,MAAMhP,OAAS,GAG7BosC,EAAUhoC,UAAU0oC,QAAU,SAAkBvxC,EAAML,GACpDyK,KAAK8T,KAAKlZ,KAAKoF,KAAKzK,KACpByK,KAAKqJ,MAAMzO,KAAKhF,GAChBoK,KAAKjK,QAAQo0C,UAAUv0C,EAAKqxB,UAC5BjnB,KAAKzK,IAAMA,GAGbiJ,OAAO+wB,iBAAkBkX,EAAUhoC,UAAWwvB,GAI9C,IAAI+c,EAAYxsC,OAAOlE,OAAO,MAW1B2wC,EAAO,aAEXA,EAAKxsC,UAAUyW,MAAQ,SAAgBg2B,GAAQ,OAAOJ,KAMtDG,EAAKxsC,UAAUwoB,OAAS,WAAqB,OAAOmiB,EAAQt1C,OAK5Dm3C,EAAKxsC,UAAUoV,OAAS,SAAiBq3B,GAAQ,OAAOJ,KAMxDG,EAAKxsC,UAAUzI,IAAM,SAAcm1C,GAAY,OAAOL,KAMtDG,EAAKxsC,UAAU2sC,MAAQ,SAAgBC,GAAU,OAAO,MAOxDJ,EAAKxsC,UAAU4W,OAAS,WAAqB,OAAOy1B,KAKpDG,EAAK7b,SAAW,SAAmB5tB,EAAQ0uB,GACzC,IAAKA,IAASA,EAAKob,SAAY,MAAM,IAAI3c,WAAW,mCACpD,IAAI75B,EAAOk2C,EAAU9a,EAAKob,UAC1B,IAAKx2C,EAAQ,MAAM,IAAI65B,WAAY,gBAAmBuB,EAAa,SAAI,YACvE,OAAOp7B,EAAKs6B,SAAS5tB,EAAQ0uB,IAQ/B+a,EAAKpF,OAAS,SAAiBC,EAAIyF,GACjC,GAAIzF,KAAMkF,EAAa,MAAM,IAAIrc,WAAW,iCAAmCmX,GAG/E,OAFAkF,EAAUlF,GAAMyF,EAChBA,EAAU9sC,UAAUonC,OAASC,EACtByF,GAKT,IAAIC,EAAa,SAAoBj2C,EAAKw1C,GAExC/qC,KAAKzK,IAAMA,EAEXyK,KAAK+qC,OAASA,GAKhBS,EAAWvR,GAAK,SAAa1kC,GAAO,OAAO,IAAIi2C,EAAWj2C,EAAK,OAI/Di2C,EAAWC,KAAO,SAAe9b,GAAW,OAAO,IAAI6b,EAAW,KAAM7b,IAMxE6b,EAAWE,YAAc,SAAsBn2C,EAAKI,EAAMD,EAAID,GAC5D,IACE,OAAO+1C,EAAWvR,GAAG1kC,EAAIqb,QAAQjb,EAAMD,EAAID,IAC3C,MAAO+H,GACP,GAAIA,aAAa,KAAgB,OAAOguC,EAAWC,KAAKjuC,EAAEmyB,SAC1D,MAAMnyB,IAKV,IAAImuC,EAA4B,SAAUV,GACxC,SAASU,EAAYh2C,EAAMD,EAAID,EAAOyuC,GACpC+G,EAAKtsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKvK,MAAQA,EACbuK,KAAKkkC,YAAcA,EAwDrB,OArDK+G,IAAOU,EAAYrpC,UAAY2oC,GACpCU,EAAYltC,UAAYD,OAAOlE,OAAQ2wC,GAAQA,EAAKxsC,WACpDktC,EAAYltC,UAAUI,YAAc8sC,EAEpCA,EAAYltC,UAAUyW,MAAQ,SAAgB3f,GAC5C,OAAIyK,KAAKkkC,WAAa0H,EAAer2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,IAC/C81C,EAAWC,KAAK,6CACpBD,EAAWE,YAAYn2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKvK,QAG9Dk2C,EAAYltC,UAAUwoB,OAAS,WAC7B,OAAO,IAAImiB,EAAQ,CAACppC,KAAKrK,KAAMqK,KAAKtK,GAAKsK,KAAKrK,KAAMqK,KAAKvK,MAAML,QAGjEu2C,EAAYltC,UAAUoV,OAAS,SAAiBte,GAC9C,OAAO,IAAIo2C,EAAY3rC,KAAKrK,KAAMqK,KAAKrK,KAAOqK,KAAKvK,MAAML,KAAMG,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,MAG3Fi2C,EAAYltC,UAAUzI,IAAM,SAAcD,GACxC,IAAIJ,EAAOI,EAAQixB,UAAUhnB,KAAKrK,KAAM,GAAID,EAAKK,EAAQixB,UAAUhnB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKmxB,SAAWpxB,EAAGoxB,QAAkB,KAClC,IAAI6kB,EAAYh2C,EAAKM,IAAKoL,KAAKC,IAAI3L,EAAKM,IAAKP,EAAGO,KAAM+J,KAAKvK,QAGpEk2C,EAAYltC,UAAU2sC,MAAQ,SAAgB/c,GAC5C,KAAMA,aAAiBsd,IAAgBtd,EAAM6V,WAAalkC,KAAKkkC,UAAa,OAAO,KAEnF,GAAIlkC,KAAKrK,KAAOqK,KAAKvK,MAAML,MAAQi5B,EAAM14B,MAASqK,KAAKvK,MAAM+6B,SAAYnC,EAAM54B,MAAM86B,UAI9E,IAAIlC,EAAM34B,IAAMsK,KAAKrK,MAASqK,KAAKvK,MAAM86B,WAAclC,EAAM54B,MAAM+6B,QAKxE,OAAO,KAJP,IAAIqb,EAAU7rC,KAAKvK,MAAML,KAAOi5B,EAAM54B,MAAML,MAAQ,EAAI,WAClD,IAAI,KAAMi5B,EAAM54B,MAAMN,QAAQiJ,OAAO4B,KAAKvK,MAAMN,SAAUk5B,EAAM54B,MAAM86B,UAAWvwB,KAAKvK,MAAM+6B,SAClG,OAAO,IAAImb,EAAYtd,EAAM14B,KAAMqK,KAAKtK,GAAIm2C,EAAS7rC,KAAKkkC,WAN1D,IAAIzuC,EAAQuK,KAAKvK,MAAML,KAAOi5B,EAAM54B,MAAML,MAAQ,EAAI,WAChD,IAAI,KAAM4K,KAAKvK,MAAMN,QAAQiJ,OAAOiwB,EAAM54B,MAAMN,SAAU6K,KAAKvK,MAAM86B,UAAWlC,EAAM54B,MAAM+6B,SAClG,OAAO,IAAImb,EAAY3rC,KAAKrK,KAAMqK,KAAKtK,IAAM24B,EAAM34B,GAAK24B,EAAM14B,MAAOF,EAAOuK,KAAKkkC,YAUrFyH,EAAYltC,UAAU4W,OAAS,WAC7B,IAAI6a,EAAO,CAACob,SAAU,UAAW31C,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,IAG3D,OAFIsK,KAAKvK,MAAML,OAAQ86B,EAAKz6B,MAAQuK,KAAKvK,MAAM4f,UAC3CrV,KAAKkkC,YAAahU,EAAKgU,WAAY,GAChChU,GAGTyb,EAAYvc,SAAW,SAAmB5tB,EAAQ0uB,GAChD,GAAwB,iBAAbA,EAAKv6B,MAAsC,iBAAXu6B,EAAKx6B,GAC5C,MAAM,IAAIi5B,WAAW,0CACzB,OAAO,IAAIgd,EAAYzb,EAAKv6B,KAAMu6B,EAAKx6B,GAAI,cAAe8L,EAAQ0uB,EAAKz6B,SAAUy6B,EAAKgU,YAGjFyH,EApEsB,CAqE7BV,GAEFA,EAAKpF,OAAO,UAAW8F,GAKvB,IAAIG,EAAkC,SAAUb,GAC9C,SAASa,EAAkBn2C,EAAMD,EAAIq2C,EAASC,EAAOv2C,EAAOoD,EAAQqrC,GAClE+G,EAAKtsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAK+rC,QAAUA,EAGf/rC,KAAKgsC,MAAQA,EAGbhsC,KAAKvK,MAAQA,EAIbuK,KAAKnH,OAASA,EACdmH,KAAKkkC,YAAcA,EAwDrB,OArDK+G,IAAOa,EAAkBxpC,UAAY2oC,GAC1Ca,EAAkBrtC,UAAYD,OAAOlE,OAAQ2wC,GAAQA,EAAKxsC,WAC1DqtC,EAAkBrtC,UAAUI,YAAcitC,EAE1CA,EAAkBrtC,UAAUyW,MAAQ,SAAgB3f,GAClD,GAAIyK,KAAKkkC,YAAc0H,EAAer2C,EAAKyK,KAAKrK,KAAMqK,KAAK+rC,UACpCH,EAAer2C,EAAKyK,KAAKgsC,MAAOhsC,KAAKtK,KACxD,OAAO81C,EAAWC,KAAK,iDAE3B,IAAIQ,EAAM12C,EAAIE,MAAMuK,KAAK+rC,QAAS/rC,KAAKgsC,OACvC,GAAIC,EAAI1b,WAAa0b,EAAIzb,QACrB,OAAOgb,EAAWC,KAAK,2BAC3B,IAAIS,EAAWlsC,KAAKvK,MAAMw8B,SAASjyB,KAAKnH,OAAQozC,EAAI92C,SACpD,OAAK+2C,EACEV,EAAWE,YAAYn2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAIw2C,GAD/BV,EAAWC,KAAK,gCAI1CK,EAAkBrtC,UAAUwoB,OAAS,WACnC,OAAO,IAAImiB,EAAQ,CAACppC,KAAKrK,KAAMqK,KAAK+rC,QAAU/rC,KAAKrK,KAAMqK,KAAKnH,OAC1CmH,KAAKgsC,MAAOhsC,KAAKtK,GAAKsK,KAAKgsC,MAAOhsC,KAAKvK,MAAML,KAAO4K,KAAKnH,UAG/EizC,EAAkBrtC,UAAUoV,OAAS,SAAiBte,GACpD,IAAI02C,EAAMjsC,KAAKgsC,MAAQhsC,KAAK+rC,QAC5B,OAAO,IAAID,EAAkB9rC,KAAKrK,KAAMqK,KAAKrK,KAAOqK,KAAKvK,MAAML,KAAO62C,EACzCjsC,KAAKrK,KAAOqK,KAAKnH,OAAQmH,KAAKrK,KAAOqK,KAAKnH,OAASozC,EACnD12C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAIw8B,cAAclyB,KAAK+rC,QAAU/rC,KAAKrK,KAAMqK,KAAKgsC,MAAQhsC,KAAKrK,MACxFqK,KAAK+rC,QAAU/rC,KAAKrK,KAAMqK,KAAKkkC,YAG9D4H,EAAkBrtC,UAAUzI,IAAM,SAAcD,GAC9C,IAAIJ,EAAOI,EAAQixB,UAAUhnB,KAAKrK,KAAM,GAAID,EAAKK,EAAQixB,UAAUhnB,KAAKtK,IAAK,GACzEq2C,EAAUh2C,EAAQC,IAAIgK,KAAK+rC,SAAU,GAAIC,EAAQj2C,EAAQC,IAAIgK,KAAKgsC,MAAO,GAC7E,OAAKr2C,EAAKmxB,SAAWpxB,EAAGoxB,SAAYilB,EAAUp2C,EAAKM,KAAO+1C,EAAQt2C,EAAGO,IAAc,KAC5E,IAAI61C,EAAkBn2C,EAAKM,IAAKP,EAAGO,IAAK81C,EAASC,EAAOhsC,KAAKvK,MAAOuK,KAAKnH,OAAQmH,KAAKkkC,YAG/F4H,EAAkBrtC,UAAU4W,OAAS,WACnC,IAAI6a,EAAO,CAACob,SAAU,gBAAiB31C,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,GACrDq2C,QAAS/rC,KAAK+rC,QAASC,MAAOhsC,KAAKgsC,MAAOnzC,OAAQmH,KAAKnH,QAGnE,OAFImH,KAAKvK,MAAML,OAAQ86B,EAAKz6B,MAAQuK,KAAKvK,MAAM4f,UAC3CrV,KAAKkkC,YAAahU,EAAKgU,WAAY,GAChChU,GAGT4b,EAAkB1c,SAAW,SAAmB5tB,EAAQ0uB,GACtD,GAAwB,iBAAbA,EAAKv6B,MAAsC,iBAAXu6B,EAAKx6B,IACrB,iBAAhBw6B,EAAK6b,SAA4C,iBAAd7b,EAAK8b,OAA2C,iBAAf9b,EAAKr3B,OAChF,MAAM,IAAI81B,WAAW,gDACzB,OAAO,IAAImd,EAAkB5b,EAAKv6B,KAAMu6B,EAAKx6B,GAAIw6B,EAAK6b,QAAS7b,EAAK8b,MACvC,cAAexqC,EAAQ0uB,EAAKz6B,OAAQy6B,EAAKr3B,SAAUq3B,EAAKgU,YAGhF4H,EA9E4B,CA+EnCb,GAIF,SAASW,EAAer2C,EAAKI,EAAMD,GAEjC,IADA,IAAIgD,EAAQnD,EAAIO,QAAQH,GAAOo7B,EAAOr7B,EAAKC,EAAMS,EAAQsC,EAAMtC,MACxD26B,EAAO,GAAK36B,EAAQ,GAAKsC,EAAMP,WAAW/B,IAAUsC,EAAMpC,KAAKF,GAAOQ,YAC3ER,IACA26B,IAEF,GAAIA,EAAO,EAET,IADA,IAAIgC,EAAOr6B,EAAMpC,KAAKF,GAAOw4B,WAAWl2B,EAAMP,WAAW/B,IAClD26B,EAAO,GAAG,CACf,IAAKgC,GAAQA,EAAKtM,OAAU,OAAO,EACnCsM,EAAOA,EAAKt8B,WACZs6B,IAGJ,OAAO,EAGT,SAASob,EAAO71C,EAAM6E,EAAOpC,GAC3B,OAAiB,GAAToC,GAAc7E,EAAKsD,WAAWuB,EAAO7E,EAAKM,eAC/CmC,GAAOzC,EAAKM,YAAcN,EAAKsD,WAAW,EAAGb,IAOlD,SAASqzC,EAAW53C,GAGlB,IAFA,IACIW,EADSX,EAAMU,OACEC,QAAQq5B,WAAWh6B,EAAMuI,WAAYvI,EAAMyI,UACvD7G,EAAQ5B,EAAM4B,SAAUA,EAAO,CACtC,IAAIE,EAAO9B,EAAMkE,MAAMpC,KAAKF,GACxBc,EAAQ1C,EAAMkE,MAAMxB,MAAMd,GAAQ6G,EAAWzI,EAAMmE,IAAIR,WAAW/B,GACtE,GAAIA,EAAQ5B,EAAM4B,OAASE,EAAKsD,WAAW1C,EAAO+F,EAAU9H,GACxD,OAAOiB,EACX,GAAa,GAATA,GAAcE,EAAKxB,KAAKC,KAAKC,YAAcm3C,EAAO71C,EAAMY,EAAO+F,GAAa,OAiDpF,SAAShD,EAAazF,EAAO+G,EAAUC,EAAO6wC,QACxB,IAAfA,IAAwBA,EAAa73C,GAE1C,IAAI83C,EAQN,SAA6B93C,EAAOM,GAClC,IAAII,EAASV,EAAMU,OACf6H,EAAavI,EAAMuI,WACnBE,EAAWzI,EAAMyI,SACjBqvC,EAASp3C,EAAOkD,eAAe2E,GAAY9C,aAAanF,GAC5D,IAAKw3C,EAAU,OAAO,KACtB,IAAIC,EAAQD,EAAOjyC,OAASiyC,EAAO,GAAKx3C,EACxC,OAAOI,EAAOmD,eAAe0E,EAAYE,EAAUsvC,GAASD,EAAS,KAfxDE,CAAoBh4C,EAAO+G,GACpC6T,EAAQk9B,GAiBd,SAA4B93C,EAAOM,GACjC,IAAII,EAASV,EAAMU,OACf6H,EAAavI,EAAMuI,WACnBE,EAAWzI,EAAMyI,SACjBmS,EAAQla,EAAOuI,MAAMV,GACrB0vC,EAAS33C,EAAK6b,aAAa1W,aAAamV,EAAMta,MAClD,IAAK23C,EAAU,OAAO,KAGtB,IAFA,IACIC,GADWD,EAAOpyC,OAASoyC,EAAOA,EAAOpyC,OAAS,GAAKvF,GACjC6b,aACjB1Z,EAAI8F,EAAY2vC,GAAcz1C,EAAIgG,EAAUhG,IACjDy1C,EAAaA,EAAWxyC,UAAUhF,EAAOuI,MAAMxG,GAAGnC,MACtD,IAAK43C,IAAeA,EAAWvyC,SAAY,OAAO,KAClD,OAAOsyC,EA7BeE,CAAmBN,EAAY9wC,GACrD,OAAK6T,EACEk9B,EAAOt2C,IAAI42C,GAAW3f,OAAO,CAACn4B,KAAMyG,EAAUC,MAAOA,IAAQyxB,OAAO7d,EAAMpZ,IAAI42C,IADhE,KAIvB,SAASA,EAAU93C,GAAQ,MAAO,CAACA,KAAMA,EAAM0G,MAAO,MA8FtD,SAASqxC,EAASt3C,EAAKU,EAAKG,EAAO02C,QAClB,IAAV12C,IAAmBA,EAAQ,GAEhC,IAAIY,EAAOzB,EAAIO,QAAQG,GAAMk1B,EAAOn0B,EAAKZ,MAAQA,EAC7C22C,EAAaD,GAAcA,EAAWA,EAAWzyC,OAAS,IAAOrD,EAAK9B,OAC1E,GAAIi2B,EAAO,GAAKn0B,EAAK9B,OAAOJ,KAAKC,KAAKC,YACjCgC,EAAK9B,OAAO0E,WAAW5C,EAAKE,QAASF,EAAK9B,OAAO0B,cACjDm2C,EAAUj4C,KAAKmd,aAAajb,EAAK9B,OAAOC,QAAQq5B,WAAWx3B,EAAKE,QAASF,EAAK9B,OAAO0B,aACtF,OAAO,EACX,IAAK,IAAI2Z,EAAIvZ,EAAKZ,MAAQ,EAAGa,EAAIb,EAAQ,EAAGma,EAAI4a,EAAM5a,IAAKtZ,IAAK,CAC9D,IAAIX,EAAOU,EAAKV,KAAKia,GAAIy8B,EAAUh2C,EAAKE,MAAMqZ,GAC9C,GAAIja,EAAKxB,KAAKC,KAAKC,UAAa,OAAO,EACvC,IAAIi4C,EAAO32C,EAAKnB,QAAQq5B,WAAWwe,EAAS12C,EAAKM,YAC7CpB,EAASs3C,GAAcA,EAAW71C,IAAOX,EAE7C,GADId,GAASc,IAAQ22C,EAAOA,EAAKxe,aAAa,EAAGj5B,EAAMV,KAAKwF,OAAO9E,EAAMgG,UACpElF,EAAKsD,WAAWozC,EAAU,EAAG12C,EAAKM,cAAgBpB,EAAMV,KAAKmd,aAAag7B,GAC3E,OAAO,EAEb,IAAI/1C,EAAQF,EAAKmB,WAAWgzB,GACxB+hB,EAAWJ,GAAcA,EAAW,GACxC,OAAO91C,EAAKV,KAAK60B,GAAM9yB,eAAenB,EAAOA,EAAOg2C,EAAWA,EAASp4C,KAAOkC,EAAKV,KAAK60B,EAAO,GAAGr2B,MAwBrG,SAASq4C,EAAQ53C,EAAKU,GACpB,IAAIe,EAAOzB,EAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAC1C,OAAOw6B,EAAS16B,EAAKnC,WAAYmC,EAAKK,YACpCL,EAAK9B,OAAO0E,WAAW1C,EAAOA,EAAQ,GAG1C,SAASw6B,EAASlR,EAAGrE,GACnB,OAAOqE,GAAKrE,IAAMqE,EAAEiG,QAAUjG,EAAE+T,UAAUpY,GAqE5C,SAASixB,EAAU73C,EAAKU,EAAKR,GAC3B,IAAIuB,EAAOzB,EAAIO,QAAQG,GACvB,IAAKR,EAAMN,QAAQC,KAAQ,OAAOa,EAElC,IADA,IAAId,EAAUM,EAAMN,QACX8B,EAAI,EAAGA,EAAIxB,EAAM86B,UAAWt5B,IAAO9B,EAAUA,EAAQsB,WAAWtB,QACzE,IAAK,IAAIk4C,EAAO,EAAGA,IAA4B,GAAnB53C,EAAM86B,WAAkB96B,EAAML,KAAO,EAAI,GAAIi4C,IACvE,IAAK,IAAI98B,EAAIvZ,EAAKZ,MAAOma,GAAK,EAAGA,IAAK,CACpC,IAAIpH,EAAOoH,GAAKvZ,EAAKZ,MAAQ,EAAIY,EAAKf,MAAQe,EAAKmE,MAAMoV,EAAI,GAAKvZ,EAAK+B,IAAIwX,EAAI,IAAM,GAAK,EAAI,EAC1F+8B,EAAYt2C,EAAKE,MAAMqZ,IAAMpH,EAAO,EAAI,EAAI,GAC5CjU,EAAS8B,EAAKV,KAAKia,GAAIg9B,GAAO,EAClC,GAAY,GAARF,EACFE,EAAOr4C,EAAO0E,WAAW0zC,EAAWA,EAAWn4C,OAC1C,CACL,IAAIof,EAAWrf,EAAOkD,eAAek1C,GAAWrzC,aAAa9E,EAAQsB,WAAW3B,MAChFy4C,EAAOh5B,GAAYrf,EAAOmD,eAAei1C,EAAWA,EAAW/4B,EAAS,IAE1E,GAAIg5B,EACA,OAAe,GAARpkC,EAAYnS,EAAKf,IAAMkT,EAAO,EAAInS,EAAKpC,OAAO2b,EAAI,GAAKvZ,EAAKxB,MAAM+a,EAAI,GAGrF,OAAO,KAGT,SAASi9B,EAAYn1B,EAAUlN,EAAGjW,GAEhC,IADA,IAAIu4C,EAAS,GACJx2C,EAAI,EAAGA,EAAIohB,EAASzhB,WAAYK,IAAK,CAC5C,IAAIwG,EAAQ4a,EAAS5a,MAAMxG,GACvBwG,EAAMtI,QAAQC,OAAQqI,EAAQA,EAAMlD,KAAKizC,EAAY/vC,EAAMtI,QAASgW,EAAG1N,KACvEA,EAAMvC,WAAYuC,EAAQ0N,EAAE1N,EAAOvI,EAAQ+B,IAC/Cw2C,EAAO7yC,KAAK6C,GAEd,OAAO,eAAmBgwC,GAnV5BxC,EAAKpF,OAAO,gBAAiBiG,GA8C7BrF,EAAUhoC,UAAU9J,KAAO,SAASH,EAAOE,GASzC,IARA,IAAIgE,EAAQlE,EAAMkE,MACdC,EAAMnE,EAAMmE,IACZvC,EAAQ5B,EAAM4B,MAEds3C,EAAWh1C,EAAM9D,OAAOwB,EAAQ,GAAIu3C,EAASh1C,EAAInD,MAAMY,EAAQ,GAC/D+E,EAAQuyC,EAAU30C,EAAM40C,EAExB/4C,EAAS,WAAgB27B,EAAY,EAChChgB,EAAIna,EAAOw3C,GAAY,EAAOr9B,EAAI7b,EAAQ6b,IAC3Cq9B,GAAal1C,EAAMxB,MAAMqZ,GAAK,GAClCq9B,GAAY,EACZh5C,EAAS,UAAc8D,EAAMpC,KAAKia,GAAGhW,KAAK3F,IAC1C27B,KAEAp1B,IAGJ,IADA,IAAI3F,EAAQ,WAAgBg7B,EAAU,EAC7Bqd,EAAMz3C,EAAO03C,GAAc,EAAOD,EAAMn5C,EAAQm5C,IACjDC,GAAen1C,EAAInD,MAAMq4C,EAAM,GAAKl1C,EAAII,IAAI80C,IAChDC,GAAc,EACdt4C,EAAQ,UAAcmD,EAAIrC,KAAKu3C,GAAKtzC,KAAK/E,IACzCg7B,KAEAz3B,IAGJ,OAAOiH,KAAKpK,KAAK,IAAIk2C,EAAkB3wC,EAAOpC,EAAK20C,EAAUC,EACtB,IAAI,KAAM/4C,EAAOwJ,OAAO5I,GAAQ+6B,EAAWC,GAC3C57B,EAAOQ,KAAOm7B,GAAW,KAkDlEkW,EAAUhoC,UAAUrE,KAAO,SAAS5F,EAAO0I,GAEzC,IADA,IAAI/H,EAAU,WACL8B,EAAIiG,EAAS7C,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAC7C,GAAI9B,EAAQC,KAAM,CAChB,IAAIyC,EAAQqF,EAASjG,GAAGnC,KAAK6b,aAAaujB,cAAc/+B,GACxD,IAAK0C,IAAUA,EAAMsC,SACjB,MAAM,IAAIw0B,WAAW,0FAE3Bx5B,EAAU,UAAc+H,EAASjG,GAAGnC,KAAKwF,OAAO4C,EAASjG,GAAGuE,MAAOrG,IAGrE,IAAIgG,EAAQ3G,EAAM2G,MAAOpC,EAAMvE,EAAMuE,IACrC,OAAOiH,KAAKpK,KAAK,IAAIk2C,EAAkB3wC,EAAOpC,EAAKoC,EAAOpC,EAAK,IAAI,KAAM5D,EAAS,EAAG,GAAI+H,EAAS7C,QAAQ,KAM5GosC,EAAUhoC,UAAUnD,aAAe,SAAS3F,EAAMD,EAAIZ,EAAM0G,GAC1D,IAAI4+B,EAASp6B,KAGb,QAFY,IAAPtK,IAAgBA,EAAKC,IAErBb,EAAK6B,YAAe,MAAM,IAAIg4B,WAAW,oDAC9C,IAAIuW,EAAUllC,KAAKqJ,MAAMhP,OAYzB,OAXA2F,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC9C,GAAIK,EAAKK,cAAgBL,EAAKqF,UAAU7G,EAAM0G,IAalD,SAAuBjG,EAAKU,EAAKnB,GAC/B,IAAIkC,EAAOzB,EAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAC1C,OAAOF,EAAK9B,OAAOmD,eAAenB,EAAOA,EAAQ,EAAGpC,GAfMi5C,CAAc3T,EAAO7kC,IAAK6kC,EAAOrkC,QAAQN,MAAMyvC,GAASlvC,IAAIC,GAAMnB,GAAO,CAE/HslC,EAAOvgC,kBAAkBugC,EAAOrkC,QAAQN,MAAMyvC,GAASlvC,IAAIC,EAAK,GAAInB,GACpE,IAAIiB,EAAUqkC,EAAOrkC,QAAQN,MAAMyvC,GAC/B8I,EAASj4C,EAAQC,IAAIC,EAAK,GAAIg4C,EAAOl4C,EAAQC,IAAIC,EAAMK,EAAKJ,SAAU,GAG1E,OAFAkkC,EAAOxkC,KAAK,IAAIk2C,EAAkBkC,EAAQC,EAAMD,EAAS,EAAGC,EAAO,EACnC,IAAI,KAAM,UAAcn5C,EAAKwF,OAAOkB,EAAO,KAAMlF,EAAKqO,QAAS,EAAG,GAAI,GAAG,KAClG,MAGJ3E,MAWTymC,EAAUhoC,UAAUhF,cAAgB,SAASxD,EAAKnB,EAAM0G,EAAOmJ,GAC7D,IAAIrO,EAAO0J,KAAKzK,IAAImc,OAAOzb,GAC3B,IAAKK,EAAQ,MAAM,IAAIq4B,WAAW,6BAC7B75B,IAAQA,EAAOwB,EAAKxB,MACzB,IAAIo5C,EAAUp5C,EAAKwF,OAAOkB,EAAO,KAAMmJ,GAASrO,EAAKqO,OACrD,GAAIrO,EAAKmwB,OACL,OAAOzmB,KAAK1H,YAAYrC,EAAKA,EAAMK,EAAKJ,SAAUg4C,GAEtD,IAAKp5C,EAAKmd,aAAa3b,EAAKnB,SACxB,MAAM,IAAIw5B,WAAW,iCAAmC75B,EAAKmL,MAEjE,OAAOD,KAAKpK,KAAK,IAAIk2C,EAAkB71C,EAAKA,EAAMK,EAAKJ,SAAUD,EAAM,EAAGA,EAAMK,EAAKJ,SAAW,EACzD,IAAI,KAAM,UAAcg4C,GAAU,EAAG,GAAI,GAAG,KAkCrFzH,EAAUhoC,UAAUzF,MAAQ,SAAS/C,EAAKG,EAAO02C,QAChC,IAAV12C,IAAmBA,EAAQ,GAGhC,IADA,IAAIY,EAAOgJ,KAAKzK,IAAIO,QAAQG,GAAMrB,EAAS,WAAgBY,EAAQ,WAC1D+a,EAAIvZ,EAAKZ,MAAOoH,EAAIxG,EAAKZ,MAAQA,EAAOa,EAAIb,EAAQ,EAAGma,EAAI/S,EAAG+S,IAAKtZ,IAAK,CAC/ErC,EAAS,UAAcoC,EAAKV,KAAKia,GAAGhW,KAAK3F,IACzC,IAAIu5C,EAAYrB,GAAcA,EAAW71C,GACzCzB,EAAQ,UAAc24C,EAAYA,EAAUr5C,KAAKwF,OAAO6zC,EAAU3yC,MAAOhG,GAASwB,EAAKV,KAAKia,GAAGhW,KAAK/E,IAEtG,OAAOwK,KAAKpK,KAAK,IAAI+1C,EAAY11C,EAAKA,EAAK,IAAI,KAAMrB,EAAOwJ,OAAO5I,GAAQY,EAAOA,IAAQ,KA+C5FqwC,EAAUhoC,UAAU3E,KAAO,SAAS7D,EAAKG,QACxB,IAAVA,IAAmBA,EAAQ,GAEhC,IAAIR,EAAO,IAAI+1C,EAAY11C,EAAMG,EAAOH,EAAMG,EAAO,YAAa,GAClE,OAAO4J,KAAKpK,KAAKA,IAkEnB,IAAIw4C,EAA4B,SAAUnD,GACxC,SAASmD,EAAYz4C,EAAMD,EAAI8P,GAC7BylC,EAAKtsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKwF,KAAOA,EAgDd,OA7CKylC,IAAOmD,EAAY9rC,UAAY2oC,GACpCmD,EAAY3vC,UAAYD,OAAOlE,OAAQ2wC,GAAQA,EAAKxsC,WACpD2vC,EAAY3vC,UAAUI,YAAcuvC,EAEpCA,EAAY3vC,UAAUyW,MAAQ,SAAgB3f,GAC5C,IAAI6kC,EAASp6B,KAETquC,EAAW94C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAKgD,EAAQnD,EAAIO,QAAQkK,KAAKrK,MACnET,EAASwD,EAAMpC,KAAKoC,EAAM4U,YAAYtN,KAAKtK,KAC3CD,EAAQ,IAAI,KAAM+3C,EAAYa,EAASl5C,SAAS,SAAUmB,EAAMpB,GAClE,OAAKoB,EAAKH,QAAWjB,EAAOJ,KAAKokC,eAAekB,EAAO50B,KAAK1Q,MACrDwB,EAAKkP,KAAK40B,EAAO50B,KAAKqqB,SAASv5B,EAAKqO,QADiCrO,IAE3EpB,GAASm5C,EAAS9d,UAAW8d,EAAS7d,SACzC,OAAOgb,EAAWE,YAAYn2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAID,IAGzD24C,EAAY3vC,UAAUoV,OAAS,WAC7B,OAAO,IAAIy6B,EAAetuC,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKwF,OAGrD4oC,EAAY3vC,UAAUzI,IAAM,SAAcD,GACxC,IAAIJ,EAAOI,EAAQixB,UAAUhnB,KAAKrK,KAAM,GAAID,EAAKK,EAAQixB,UAAUhnB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKmxB,SAAWpxB,EAAGoxB,SAAWnxB,EAAKM,KAAOP,EAAGO,IAAc,KACxD,IAAIm4C,EAAYz4C,EAAKM,IAAKP,EAAGO,IAAK+J,KAAKwF,OAGhD4oC,EAAY3vC,UAAU2sC,MAAQ,SAAgB/c,GAC5C,GAAIA,aAAiB+f,GACjB/f,EAAM7oB,KAAKgC,GAAGxH,KAAKwF,OACnBxF,KAAKrK,MAAQ04B,EAAM34B,IAAMsK,KAAKtK,IAAM24B,EAAM14B,KAC1C,OAAO,IAAIy4C,EAAY/sC,KAAKc,IAAInC,KAAKrK,KAAM04B,EAAM14B,MAC5B0L,KAAKC,IAAItB,KAAKtK,GAAI24B,EAAM34B,IAAKsK,KAAKwF,OAG7D4oC,EAAY3vC,UAAU4W,OAAS,WAC7B,MAAO,CAACi2B,SAAU,UAAW9lC,KAAMxF,KAAKwF,KAAK6P,SACrC1f,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,KAGpC04C,EAAYhf,SAAW,SAAmB5tB,EAAQ0uB,GAChD,GAAwB,iBAAbA,EAAKv6B,MAAsC,iBAAXu6B,EAAKx6B,GAC5C,MAAM,IAAIi5B,WAAW,0CACzB,OAAO,IAAIyf,EAAYle,EAAKv6B,KAAMu6B,EAAKx6B,GAAI8L,EAAOizB,aAAavE,EAAK1qB,QAG/D4oC,EA3DsB,CA4D7BnD,GAEFA,EAAKpF,OAAO,UAAWuI,GAGvB,IAAIE,EAA+B,SAAUrD,GAC3C,SAASqD,EAAe34C,EAAMD,EAAI8P,GAChCylC,EAAKtsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKwF,KAAOA,EA8Cd,OA3CKylC,IAAOqD,EAAehsC,UAAY2oC,GACvCqD,EAAe7vC,UAAYD,OAAOlE,OAAQ2wC,GAAQA,EAAKxsC,WACvD6vC,EAAe7vC,UAAUI,YAAcyvC,EAEvCA,EAAe7vC,UAAUyW,MAAQ,SAAgB3f,GAC/C,IAAI6kC,EAASp6B,KAETquC,EAAW94C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IACrCD,EAAQ,IAAI,KAAM+3C,EAAYa,EAASl5C,SAAS,SAAUmB,GAC5D,OAAOA,EAAKkP,KAAK40B,EAAO50B,KAAKyqB,cAAc35B,EAAKqO,WAC9C0pC,EAAS9d,UAAW8d,EAAS7d,SACjC,OAAOgb,EAAWE,YAAYn2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAID,IAGzD64C,EAAe7vC,UAAUoV,OAAS,WAChC,OAAO,IAAIu6B,EAAYpuC,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKwF,OAGlD8oC,EAAe7vC,UAAUzI,IAAM,SAAcD,GAC3C,IAAIJ,EAAOI,EAAQixB,UAAUhnB,KAAKrK,KAAM,GAAID,EAAKK,EAAQixB,UAAUhnB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKmxB,SAAWpxB,EAAGoxB,SAAWnxB,EAAKM,KAAOP,EAAGO,IAAc,KACxD,IAAIq4C,EAAe34C,EAAKM,IAAKP,EAAGO,IAAK+J,KAAKwF,OAGnD8oC,EAAe7vC,UAAU2sC,MAAQ,SAAgB/c,GAC/C,GAAIA,aAAiBigB,GACjBjgB,EAAM7oB,KAAKgC,GAAGxH,KAAKwF,OACnBxF,KAAKrK,MAAQ04B,EAAM34B,IAAMsK,KAAKtK,IAAM24B,EAAM14B,KAC1C,OAAO,IAAI24C,EAAejtC,KAAKc,IAAInC,KAAKrK,KAAM04B,EAAM14B,MAC5B0L,KAAKC,IAAItB,KAAKtK,GAAI24B,EAAM34B,IAAKsK,KAAKwF,OAGhE8oC,EAAe7vC,UAAU4W,OAAS,WAChC,MAAO,CAACi2B,SAAU,aAAc9lC,KAAMxF,KAAKwF,KAAK6P,SACxC1f,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,KAGpC44C,EAAelf,SAAW,SAAmB5tB,EAAQ0uB,GACnD,GAAwB,iBAAbA,EAAKv6B,MAAsC,iBAAXu6B,EAAKx6B,GAC5C,MAAM,IAAIi5B,WAAW,6CACzB,OAAO,IAAI2f,EAAepe,EAAKv6B,KAAMu6B,EAAKx6B,GAAI8L,EAAOizB,aAAavE,EAAK1qB,QAGlE8oC,EAzDyB,CA0DhCrD,GAuHF,SAASsD,EAAYh5C,EAAKI,EAAMD,EAAID,GAIlC,QAHY,IAAPC,IAAgBA,EAAKC,QACX,IAAVF,IAAmBA,EAAQ,YAE5BE,GAAQD,IAAOD,EAAML,KAAQ,OAAO,KAExC,IAAIsD,EAAQnD,EAAIO,QAAQH,GAAOgD,EAAMpD,EAAIO,QAAQJ,GAEjD,OAAI84C,EAAc91C,EAAOC,EAAKlD,GAAiB,IAAIk2C,EAAYh2C,EAAMD,EAAID,GAClE,IAAIg5C,EAAO/1C,EAAOC,EAAKlD,GAAOi5C,MAkCvC,SAASF,EAAc91C,EAAOC,EAAKlD,GACjC,OAAQA,EAAM86B,YAAc96B,EAAM+6B,SAAW93B,EAAMyC,SAAWxC,EAAIwC,SAChEzC,EAAMxD,OAAO0E,WAAWlB,EAAMxB,QAASyB,EAAIzB,QAASzB,EAAMN,SAlK9D81C,EAAKpF,OAAO,aAAcyI,GAI1B7H,EAAUhoC,UAAUmO,QAAU,SAASjX,EAAMD,EAAI8P,GAC/C,IAAI40B,EAASp6B,KAET2uC,EAAU,GAAIC,EAAQ,GAAIC,EAAW,KAAMC,EAAS,KA0BxD,OAzBA9uC,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,EAAKf,GACnD,GAAKoB,EAAK4E,SAAV,CACA,IAAIyJ,EAAQrO,EAAKqO,MACjB,IAAKa,EAAKI,QAAQjB,IAAUzP,EAAOJ,KAAKokC,eAAe1zB,EAAK1Q,MAAO,CAIjE,IAHA,IAAIqG,EAAQkG,KAAKC,IAAIrL,EAAKN,GAAOoD,EAAMsI,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GACjEq5C,EAASvpC,EAAKqqB,SAASlrB,GAElB1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAC3B0N,EAAM1N,GAAG2O,QAAQmpC,KAChBF,GAAYA,EAASn5C,IAAMyF,GAAS0zC,EAASrpC,KAAKgC,GAAG7C,EAAM1N,IAC3D43C,EAASn5C,GAAKqD,EAEd41C,EAAQ/zC,KAAKi0C,EAAW,IAAIP,EAAenzC,EAAOpC,EAAK4L,EAAM1N,MAIjE63C,GAAUA,EAAOp5C,IAAMyF,EACvB2zC,EAAOp5C,GAAKqD,EAEZ61C,EAAMh0C,KAAKk0C,EAAS,IAAIV,EAAYjzC,EAAOpC,EAAKyM,SAIxDmpC,EAAQxvC,SAAQ,SAAU6vC,GAAK,OAAO5U,EAAOxkC,KAAKo5C,MAClDJ,EAAMzvC,SAAQ,SAAU6vC,GAAK,OAAO5U,EAAOxkC,KAAKo5C,MACzChvC,MAQTymC,EAAUhoC,UAAUwV,WAAa,SAASte,EAAMD,EAAI8P,GAClD,IAAI40B,EAASp6B,UACC,IAATwF,IAAkBA,EAAO,MAE9B,IAAIgU,EAAU,GAAI5jB,EAAO,EAkCzB,OAjCAoK,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC9C,GAAKK,EAAK4E,SAAV,CACAtF,IACA,IAAIq5C,EAAW,KACf,GAAIzpC,aAAgB,KAElB,IADA,IAAsBpI,EAAlB0yB,EAAMx5B,EAAKqO,MACRvH,EAAQoI,EAAKI,QAAQkqB,KACjCmf,IAAaA,EAAW,KAAKr0C,KAAKwC,GAC3B0yB,EAAM1yB,EAAM6yB,cAAcH,QAEnBtqB,EACLA,EAAKI,QAAQtP,EAAKqO,SAAUsqC,EAAW,CAACzpC,IAE5CypC,EAAW34C,EAAKqO,MAElB,GAAIsqC,GAAYA,EAAS50C,OAEvB,IADA,IAAItB,EAAMsI,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAC/BuB,EAAI,EAAGA,EAAIg4C,EAAS50C,OAAQpD,IAAK,CAExC,IADA,IAAIqmB,EAAQ2xB,EAASh4C,GAAIi4C,OAAU,EAC1Bt7B,EAAI,EAAGA,EAAI4F,EAAQnf,OAAQuZ,IAAK,CACvC,IAAI4gB,EAAIhb,EAAQ5F,GACZ4gB,EAAE5+B,MAAQA,EAAO,GAAK0nB,EAAM9V,GAAGgS,EAAQ5F,GAAG0J,SAAU4xB,EAAU1a,GAEhE0a,GACFA,EAAQx5C,GAAKqD,EACbm2C,EAAQt5C,KAAOA,GAEf4jB,EAAQ5e,KAAK,CAAC0iB,MAAOA,EAAO3nB,KAAM0L,KAAKC,IAAIrL,EAAKN,GAAOD,GAAIqD,EAAKnD,KAAMA,SAK9E4jB,EAAQra,SAAQ,SAAUq1B,GAAK,OAAO4F,EAAOxkC,KAAK,IAAI04C,EAAe9Z,EAAE7+B,KAAM6+B,EAAE9+B,GAAI8+B,EAAElX,WAC9Etd,MAQTymC,EAAUhoC,UAAU5E,kBAAoB,SAAS5D,EAAKk5C,EAAYt3C,QACjD,IAAVA,IAAmBA,EAAQs3C,EAAWx+B,cAI3C,IAFA,IAAIra,EAAO0J,KAAKzK,IAAImc,OAAOzb,GACvBm5C,EAAW,GAAIhZ,EAAMngC,EAAM,EACtBgB,EAAI,EAAGA,EAAIX,EAAKM,WAAYK,IAAK,CACxC,IAAIwG,EAAQnH,EAAKmH,MAAMxG,GAAI8B,EAAMq9B,EAAM34B,EAAMvH,SACzCm5C,EAAUx3C,EAAMqC,UAAUuD,EAAM3I,KAAM2I,EAAMjC,OAChD,GAAK6zC,EAEE,CACLx3C,EAAQw3C,EACR,IAAK,IAAIz7B,EAAI,EAAGA,EAAInW,EAAMkH,MAAMtK,OAAQuZ,IAAYu7B,EAAWjW,eAAez7B,EAAMkH,MAAMiP,GAAG9e,OACzFkL,KAAKpK,KAAK,IAAI04C,EAAelY,EAAKr9B,EAAK0E,EAAMkH,MAAMiP,UAJvDw7B,EAASx0C,KAAK,IAAI+wC,EAAYvV,EAAKr9B,EAAK,aAM1Cq9B,EAAMr9B,EAER,IAAKlB,EAAMsC,SAAU,CACnB,IAAIikC,EAAOvmC,EAAM++B,WAAW,YAAgB,GAC5C52B,KAAK4Q,QAAQwlB,EAAKA,EAAK,IAAI,KAAMgI,EAAM,EAAG,IAE5C,IAAK,IAAIpjC,EAAMo0C,EAAS/0C,OAAS,EAAGW,GAAO,EAAGA,IAASgF,KAAKpK,KAAKw5C,EAASp0C,IAC1E,OAAOgF,MAuBTymC,EAAUhoC,UAAUmS,QAAU,SAASjb,EAAMD,EAAID,QACnC,IAAPC,IAAgBA,EAAKC,QACX,IAAVF,IAAmBA,EAAQ,YAEhC,IAAIG,EAAO24C,EAAYvuC,KAAKzK,IAAKI,EAAMD,EAAID,GAE3C,OADIG,GAAQoK,KAAKpK,KAAKA,GACfoK,MAMTymC,EAAUhoC,UAAUnG,YAAc,SAAS3C,EAAMD,EAAIP,GACnD,OAAO6K,KAAK4Q,QAAQjb,EAAMD,EAAI,IAAI,KAAM,UAAcP,GAAU,EAAG,KAKrEsxC,EAAUhoC,UAAUpI,OAAS,SAASV,EAAMD,GAC1C,OAAOsK,KAAK4Q,QAAQjb,EAAMD,EAAI,aAKhC+wC,EAAUhoC,UAAU5F,OAAS,SAAS5C,EAAKd,GACzC,OAAO6K,KAAK1H,YAAYrC,EAAKA,EAAKd,IA4BpC,IAAIs5C,EAAS,SAAgB/1C,EAAOC,EAAKlD,GACvCuK,KAAKrH,IAAMA,EACXqH,KAAKtH,MAAQA,EACbsH,KAAKsvC,SAAW75C,EAEhBuK,KAAKuvC,SAAW,GAChB,IAAK,IAAIt4C,EAAI,EAAGA,GAAKyB,EAAMtC,MAAOa,IAAK,CACrC,IAAIX,EAAOoC,EAAMpC,KAAKW,GACtB+I,KAAKuvC,SAAS30C,KAAK,CACjB9F,KAAMwB,EAAKxB,KACX+C,MAAOvB,EAAK8B,eAAeM,EAAMP,WAAWlB,MAIhD+I,KAAK+vB,OAAS,WACd,IAAK,IAAI/0B,EAAMtC,EAAMtC,MAAO4E,EAAM,EAAGA,IACjCgF,KAAK+vB,OAAS,UAAcr3B,EAAMpC,KAAK0E,GAAKT,KAAKyF,KAAK+vB,UAGxDU,EAAuB,CAAEr6B,MAAO,CAAE83B,cAAc,IAqOpD,SAASshB,EAAiBn3B,EAAUjiB,EAAOq5C,GACzC,OAAa,GAATr5C,EAAqBiiB,EAASmW,WAAWihB,GACtCp3B,EAASoW,aAAa,EAAGpW,EAAS5hB,WAAW8D,KAAKi1C,EAAiBn3B,EAAS5hB,WAAWtB,QAASiB,EAAQ,EAAGq5C,KAGpH,SAASC,EAAcr3B,EAAUjiB,EAAOjB,GACtC,OAAa,GAATiB,EAAqBiiB,EAASja,OAAOjJ,GAClCkjB,EAASoW,aAAapW,EAASzhB,WAAa,EACtByhB,EAAS3hB,UAAU6D,KAAKm1C,EAAcr3B,EAAS3hB,UAAUvB,QAASiB,EAAQ,EAAGjB,KAG5G,SAASw6C,EAAUt3B,EAAUjiB,GAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAIb,EAAOa,IAAOohB,EAAWA,EAAS5hB,WAAWtB,QACjE,OAAOkjB,EAGT,SAASu3B,EAAet5C,EAAMi6B,EAAWC,GACvC,GAAID,GAAa,EAAK,OAAOj6B,EAC7B,IAAIogC,EAAOpgC,EAAKnB,QAOhB,OANIo7B,EAAY,IACZmG,EAAOA,EAAKjI,aAAa,EAAGmhB,EAAelZ,EAAKjgC,WAAY85B,EAAY,EAAsB,GAAnBmG,EAAK9/B,WAAkB45B,EAAU,EAAI,KAChHD,EAAY,IACdmG,EAAOpgC,EAAKxB,KAAK6b,aAAaimB,WAAWF,GAAMt4B,OAAOs4B,GAClDlG,GAAW,IAAKkG,EAAOA,EAAKt4B,OAAO9H,EAAKxB,KAAK6b,aAAaujB,cAAcwC,GAAME,WAAW,YAAgB,MAExGtgC,EAAKiE,KAAKm8B,GAGnB,SAASmZ,EAAiBl3C,EAAKvC,EAAOtB,EAAM+C,EAAOgnC,GACjD,IAAIvoC,EAAOqC,EAAIrC,KAAKF,GAAQc,EAAQ2nC,EAAOlmC,EAAIR,WAAW/B,GAASuC,EAAIzB,MAAMd,GAC7E,GAAIc,GAASZ,EAAKM,aAAe9B,EAAK6E,kBAAkBrD,EAAKxB,MAAS,OAAO,KAC7E,IAAI45C,EAAM72C,EAAM++B,WAAWtgC,EAAKnB,SAAS,EAAM+B,GAC/C,OAAOw3C,IAGT,SAAsB55C,EAAMujB,EAAUld,GACpC,IAAK,IAAIlE,EAAIkE,EAAOlE,EAAIohB,EAASzhB,WAAYK,IACzC,IAAKnC,EAAKw/B,YAAYjc,EAAS5a,MAAMxG,GAAG0N,OAAU,OAAO,EAC7D,OAAO,EANQmrC,CAAah7C,EAAMwB,EAAKnB,QAAS+B,GAASw3C,EAAM,KAiGjE,SAASqB,EAAc13B,EAAUjiB,EAAO45C,EAASC,EAAS/6C,GACxD,GAAIkB,EAAQ45C,EAAS,CACnB,IAAIz2C,EAAQ8e,EAAS5hB,WACrB4hB,EAAWA,EAASoW,aAAa,EAAGl1B,EAAMgB,KAAKw1C,EAAcx2C,EAAMpE,QAASiB,EAAQ,EAAG45C,EAASC,EAAS12C,KAE3G,GAAInD,EAAQ65C,EAAS,CACnB,IAAIp4C,EAAQ3C,EAAOkD,eAAe,GAC9B+C,EAAQtD,EAAM++B,WAAWve,GAAUja,OAAOia,GAC9CA,EAAWld,EAAMiD,OAAOvG,EAAMq8B,cAAc/4B,GAAOy7B,WAAW,YAAgB,IAEhF,OAAOve,EA0CT,SAAS63B,EAAcx3C,EAAOC,GAE5B,IADA,IAAI0R,EAAS,GACJkG,EADmBlP,KAAKc,IAAIzJ,EAAMtC,MAAOuC,EAAIvC,OAC/Bma,GAAK,EAAGA,IAAK,CAClC,IAAIpV,EAAQzC,EAAMyC,MAAMoV,GACxB,GAAIpV,EAAQzC,EAAMzC,KAAOyC,EAAMtC,MAAQma,IACnC5X,EAAII,IAAIwX,GAAK5X,EAAI1C,KAAO0C,EAAIvC,MAAQma,IACpC7X,EAAMpC,KAAKia,GAAGzb,KAAKC,KAAKC,WACxB2D,EAAIrC,KAAKia,GAAGzb,KAAKC,KAAKC,UAAa,OACnCmG,GAASxC,EAAIwC,MAAMoV,IAClBA,GAAK7X,EAAMtC,OAASma,GAAK5X,EAAIvC,OAASsC,EAAMxD,OAAO0D,eAAiBD,EAAIzD,OAAO0D,eAC/E2X,GAAK5X,EAAIwC,MAAMoV,EAAI,IAAMpV,EAAQ,IAClCkP,EAAOzP,KAAK2V,GAElB,OAAOlG,EAraTomB,EAAqBr6B,MAAMs2B,IAAM,WAAc,OAAO1sB,KAAKuvC,SAASl1C,OAAS,GAE7Eo0C,EAAOhwC,UAAUiwC,IAAM,WAIrB,KAAO1uC,KAAKsvC,SAASl6C,MAAM,CACzB,IAAIs5C,EAAM1uC,KAAKmwC,eACXzB,EAAO1uC,KAAKowC,WAAW1B,GACpB1uC,KAAKqwC,YAAcrwC,KAAKswC,WAOjC,IAAIC,EAAavwC,KAAKwwC,iBAAkBC,EAAazwC,KAAK+vB,OAAO36B,KAAO4K,KAAK5J,MAAQ4J,KAAKtH,MAAMtC,MAC5FsC,EAAQsH,KAAKtH,MAAOC,EAAMqH,KAAK0wC,MAAMH,EAAa,EAAIvwC,KAAKrH,IAAMD,EAAMnD,IAAIO,QAAQy6C,IACvF,IAAK53C,EAAO,OAAO,KAInB,IADA,IAAIxD,EAAU6K,KAAK+vB,OAAQQ,EAAY73B,EAAMtC,MAAOo6B,EAAU73B,EAAIvC,MAC3Dm6B,GAAaC,GAAiC,GAAtBr7B,EAAQyB,YACrCzB,EAAUA,EAAQsB,WAAWtB,QAC7Bo7B,IAAaC,IAEf,IAAI/6B,EAAQ,IAAI,KAAMN,EAASo7B,EAAWC,GAC1C,OAAI+f,GAAc,EACP,IAAIzE,EAAkBpzC,EAAMzC,IAAKs6C,EAAYvwC,KAAKrH,IAAI1C,IAAK+J,KAAKrH,IAAII,MAAOtD,EAAOg7C,GACzFh7C,EAAML,MAAQsD,EAAMzC,KAAO+J,KAAKrH,IAAI1C,IAC7B,IAAI01C,EAAYjzC,EAAMzC,IAAK0C,EAAI1C,IAAKR,QAD/C,GAOFg5C,EAAOhwC,UAAU0xC,aAAe,WAG9B,IAAK,IAAI9C,EAAO,EAAGA,GAAQ,EAAGA,IAC5B,IAAK,IAAIsD,EAAa3wC,KAAKsvC,SAAS/e,UAAWogB,GAAc,EAAGA,IAS9D,IARA,IAAyBz7C,OAAS,EAO9BqE,GANAo3C,GACFz7C,EAASy6C,EAAU3vC,KAAKsvC,SAASn6C,QAASw7C,EAAa,GAAGl6C,YACxCtB,QAEP6K,KAAKsvC,SAASn6C,SAENsB,WACZm6C,EAAgB5wC,KAAK5J,MAAOw6C,GAAiB,EAAGA,IAAiB,CACxE,IAAI95C,EAAMkJ,KAAKuvC,SAASqB,GAClB97C,EAAOgC,EAAIhC,KACX+C,EAAQf,EAAIe,MACZuC,OAAO,EAAUy2C,OAAS,EAIhC,GAAY,GAARxD,IAAc9zC,EAAQ1B,EAAMqC,UAAUX,EAAMzE,QAAU+7C,EAASh5C,EAAM++B,WAAW,UAAcr9B,IAAQ,IACtFzE,EAAK6E,kBAAkBzE,EAAOJ,OAC9C,MAAO,CAAC67C,WAAYA,EAAYC,cAAeA,EAAe17C,OAAQA,EAAQ27C,OAAQA,GAGrF,GAAY,GAARxD,GAAa9zC,IAAUa,EAAOvC,EAAMoC,aAAaV,EAAMzE,OAC5D,MAAO,CAAC67C,WAAYA,EAAYC,cAAeA,EAAe17C,OAAQA,EAAQkF,KAAMA,GAGxF,GAAIlF,GAAU2C,EAAMqC,UAAUhF,EAAOJ,MAAS,QAMtD25C,EAAOhwC,UAAU4xC,SAAW,WAC1B,IAAIv5C,EAAMkJ,KAAKsvC,SACTn6C,EAAU2B,EAAI3B,QACdo7B,EAAYz5B,EAAIy5B,UAChBC,EAAU15B,EAAI05B,QAChBphB,EAAQugC,EAAUx6C,EAASo7B,GAC/B,SAAKnhB,EAAMxY,YAAcwY,EAAM3Y,WAAWgwB,UAC1CzmB,KAAKsvC,SAAW,IAAI,KAAMn6C,EAASo7B,EAAY,EACrBlvB,KAAKC,IAAIkvB,EAASphB,EAAMha,KAAOm7B,GAAap7B,EAAQC,KAAOo7B,EAAUD,EAAY,EAAI,KACxG,IAGTke,EAAOhwC,UAAU6xC,SAAW,WAC1B,IAAIx5C,EAAMkJ,KAAKsvC,SACTn6C,EAAU2B,EAAI3B,QACdo7B,EAAYz5B,EAAIy5B,UAChBC,EAAU15B,EAAI05B,QAChBphB,EAAQugC,EAAUx6C,EAASo7B,GAC/B,GAAInhB,EAAMxY,YAAc,GAAK25B,EAAY,EAAG,CAC1C,IAAIugB,EAAY37C,EAAQC,KAAOm7B,GAAaA,EAAYnhB,EAAMha,KAC9D4K,KAAKsvC,SAAW,IAAI,KAAME,EAAiBr6C,EAASo7B,EAAY,EAAG,GAAIA,EAAY,EACzDugB,EAAYvgB,EAAY,EAAIC,QAEtDxwB,KAAKsvC,SAAW,IAAI,KAAME,EAAiBr6C,EAASo7B,EAAW,GAAIA,EAAWC,IAQlFie,EAAOhwC,UAAU2xC,WAAa,SAAqBt5C,GAOjD,IANE,IAAI65C,EAAa75C,EAAI65C,WACjBC,EAAgB95C,EAAI85C,cACpB17C,EAAS4B,EAAI5B,OACb27C,EAAS/5C,EAAI+5C,OACbz2C,EAAOtD,EAAIsD,KAEV4F,KAAK5J,MAAQw6C,GAAiB5wC,KAAK+wC,oBAC1C,GAAI32C,EAAQ,IAAK,IAAInD,EAAI,EAAGA,EAAImD,EAAKC,OAAQpD,IAAO+I,KAAKgxC,iBAAiB52C,EAAKnD,IAE/E,IAAIxB,EAAQuK,KAAKsvC,SAAUj3B,EAAWnjB,EAASA,EAAOC,QAAUM,EAAMN,QAClEo7B,EAAY96B,EAAM86B,UAAYogB,EAC9BM,EAAQ,EAAGtN,EAAM,GACjBhT,EAAQ3wB,KAAKuvC,SAASqB,GACpB/4C,EAAQ84B,EAAM94B,MACd/C,EAAO67B,EAAM77B,KACnB,GAAI+7C,EAAQ,CACV,IAAK,IAAI71C,EAAM,EAAGA,EAAM61C,EAAOj6C,WAAYoE,IAAS2oC,EAAI/oC,KAAKi2C,EAAOpzC,MAAMzC,IAC1EnD,EAAQA,EAAMq8B,cAAc2c,GAQ9B,IAHA,IAAIK,EAAgB74B,EAASjjB,KAAOu7C,GAAel7C,EAAMN,QAAQC,KAAOK,EAAM+6B,SAGvEygB,EAAQ54B,EAASzhB,YAAY,CAClC,IAAIm8B,EAAO1a,EAAS5a,MAAMwzC,GAAQp2B,EAAUhjB,EAAMqC,UAAU64B,EAAKj+B,MACjE,IAAK+lB,EAAW,SAChBo2B,EACY,GAAkB,GAAb1gB,GAAkBwC,EAAK59B,QAAQC,QAC9CyC,EAAQgjB,EACR8oB,EAAI/oC,KAAKg1C,EAAe7c,EAAKvtB,KAAK1Q,EAAKqkC,aAAapG,EAAKpuB,QAAkB,GAATssC,EAAa1gB,EAAY,EACnE0gB,GAAS54B,EAASzhB,WAAas6C,GAAgB,KAG3E,IAAIra,EAAQoa,GAAS54B,EAASzhB,WACzBigC,IAASqa,GAAgB,GAE9BlxC,KAAK+vB,OAAS2f,EAAc1vC,KAAK+vB,OAAQ6gB,EAAe,UAAcjN,IACtE3jC,KAAKuvC,SAASqB,GAAe/4C,MAAQA,EAIjCg/B,GAASqa,EAAe,GAAKh8C,GAAUA,EAAOJ,MAAQkL,KAAKuvC,SAASvvC,KAAK5J,OAAOtB,MAAQkL,KAAKuvC,SAASl1C,OAAS,GAC/G2F,KAAK+wC,oBAGT,IAAK,IAAIxzC,EAAM,EAAG64B,EAAM/d,EAAU9a,EAAM2zC,EAAc3zC,IAAO,CAC3D,IAAIjH,EAAO8/B,EAAI1/B,UACfsJ,KAAKuvC,SAAS30C,KAAK,CAAC9F,KAAMwB,EAAKxB,KAAM+C,MAAOvB,EAAK8B,eAAe9B,EAAKM,cACrEw/B,EAAM9/B,EAAKnB,QAMb6K,KAAKsvC,SAAYzY,EACC,GAAd8Z,EAAkB,WAClB,IAAI,KAAMnB,EAAiB/5C,EAAMN,QAASw7C,EAAa,EAAG,GAChDA,EAAa,EAAGO,EAAe,EAAIz7C,EAAM+6B,QAAUmgB,EAAa,GAHrD,IAAI,KAAMnB,EAAiB/5C,EAAMN,QAASw7C,EAAYM,GAAQx7C,EAAM86B,UAAW96B,EAAM+6B,UAMhHie,EAAOhwC,UAAU+xC,eAAiB,WAChC,IAAKxwC,KAAKrH,IAAIzD,OAAOyB,aAAeqJ,KAAKrH,IAAII,OAASiH,KAAKrH,IAAI1C,IAAO,OAAQ,EAC9E,IAAqCotC,EAAjCxY,EAAM7qB,KAAKuvC,SAASvvC,KAAK5J,OAC7B,IAAKy0B,EAAI/1B,KAAK6B,cAAgBk5C,EAAiB7vC,KAAKrH,IAAKqH,KAAKrH,IAAIvC,MAAOy0B,EAAI/1B,KAAM+1B,EAAIhzB,OAAO,IACzFmI,KAAKrH,IAAIvC,OAAS4J,KAAK5J,QAAUitC,EAAQrjC,KAAKmxC,eAAenxC,KAAKrH,OAAS0qC,EAAMjtC,OAAS4J,KAAK5J,MAAU,OAAQ,EAKtH,IAHA,IACMA,EADI4J,KAAKrH,IACGvC,MACZZ,EAAQwK,KAAKrH,IAAInD,MAAMY,GACtBA,EAAQ,GAAKZ,GAASwK,KAAKrH,IAAII,MAAM3C,MAAYZ,EACxD,OAAOA,GAGTi5C,EAAOhwC,UAAU0yC,eAAiB,SAAyBx4C,GACzDy+B,EAAM,IAAK,IAAIngC,EAAIoK,KAAKc,IAAInC,KAAK5J,MAAOuC,EAAIvC,OAAQa,GAAK,EAAGA,IAAK,CAC/D,IAAIH,EAAMkJ,KAAKuvC,SAASt4C,GAClBY,EAAQf,EAAIe,MACZ/C,EAAOgC,EAAIhC,KACbs8C,EAAYn6C,EAAI0B,EAAIvC,OAASuC,EAAII,IAAI9B,EAAI,IAAM0B,EAAI1C,KAAO0C,EAAIvC,OAASa,EAAI,IAC3Ey3C,EAAMmB,EAAiBl3C,EAAK1B,EAAGnC,EAAM+C,EAAOu5C,GAChD,GAAK1C,EAAL,CACA,IAAK,IAAIn+B,EAAItZ,EAAI,EAAGsZ,GAAK,EAAGA,IAAK,CAC/B,IAAIogB,EAAQ3wB,KAAKuvC,SAASh/B,GACpB8gC,EAAU1gB,EAAM94B,MAElBgjB,EAAUg1B,EAAiBl3C,EAAK4X,EADrBogB,EAAM77B,KAC0Bu8C,GAAS,GACxD,IAAKx2B,GAAWA,EAAQjkB,WAAc,SAASwgC,EAEjD,MAAO,CAAChhC,MAAOa,EAAGy3C,IAAKA,EAAK4C,KAAMF,EAAYz4C,EAAIpD,IAAIO,QAAQ6C,EAAInD,MAAMyB,EAAI,IAAM0B,MAItF81C,EAAOhwC,UAAUiyC,MAAQ,SAAgB/3C,GACvC,IAAI+3C,EAAQ1wC,KAAKmxC,eAAex4C,GAChC,IAAK+3C,EAAS,OAAO,KAErB,KAAO1wC,KAAK5J,MAAQs6C,EAAMt6C,OAAS4J,KAAK+wC,oBACpCL,EAAMhC,IAAI93C,aAAcoJ,KAAK+vB,OAAS2f,EAAc1vC,KAAK+vB,OAAQ2gB,EAAMt6C,MAAOs6C,EAAMhC,MACxF/1C,EAAM+3C,EAAMY,KACZ,IAAK,IAAI/gC,EAAImgC,EAAMt6C,MAAQ,EAAGma,GAAK5X,EAAIvC,MAAOma,IAAK,CACjD,IAAIja,EAAOqC,EAAIrC,KAAKia,GAAIozB,EAAMrtC,EAAKxB,KAAK6b,aAAaimB,WAAWtgC,EAAKnB,SAAS,EAAMwD,EAAIzB,MAAMqZ,IAC9FvQ,KAAKgxC,iBAAiB16C,EAAKxB,KAAMwB,EAAKkF,MAAOmoC,GAE/C,OAAOhrC,GAGT81C,EAAOhwC,UAAUuyC,iBAAmB,SAA2Bl8C,EAAM0G,EAAOrG,GAC1E,IAAI01B,EAAM7qB,KAAKuvC,SAASvvC,KAAK5J,OAC7By0B,EAAIhzB,MAAQgzB,EAAIhzB,MAAMqC,UAAUpF,GAChCkL,KAAK+vB,OAAS2f,EAAc1vC,KAAK+vB,OAAQ/vB,KAAK5J,MAAO,UAActB,EAAKwF,OAAOkB,EAAOrG,KACtF6K,KAAKuvC,SAAS30C,KAAK,CAAC9F,KAAMA,EAAM+C,MAAO/C,EAAK6b,gBAG9C89B,EAAOhwC,UAAUsyC,kBAAoB,WACnC,IACIpN,EADO3jC,KAAKuvC,SAASjY,MACVz/B,MAAM++B,WAAW,YAAgB,GAC5C+M,EAAI/sC,aAAcoJ,KAAK+vB,OAAS2f,EAAc1vC,KAAK+vB,OAAQ/vB,KAAKuvC,SAASl1C,OAAQspC,KAGvFnlC,OAAO+wB,iBAAkBkf,EAAOhwC,UAAWgyB,GA2D3CgW,EAAUhoC,UAAU0mC,aAAe,SAASxvC,EAAMD,EAAID,GACpD,IAAKA,EAAML,KAAQ,OAAO4K,KAAKoE,YAAYzO,EAAMD,GAEjD,IAAIgD,EAAQsH,KAAKzK,IAAIO,QAAQH,GAAOgD,EAAMqH,KAAKzK,IAAIO,QAAQJ,GAC3D,GAAI84C,EAAc91C,EAAOC,EAAKlD,GAC1B,OAAOuK,KAAKpK,KAAK,IAAI+1C,EAAYh2C,EAAMD,EAAID,IAE/C,IAAI87C,EAAerB,EAAcx3C,EAAOsH,KAAKzK,IAAIO,QAAQJ,IAEZ,GAAzC67C,EAAaA,EAAal3C,OAAS,IAAWk3C,EAAaja,MAG/D,IAAIka,IAAoB94C,EAAMtC,MAAQ,GACtCm7C,EAAaE,QAAQD,GAKrB,IAAK,IAAIjhC,EAAI7X,EAAMtC,MAAOH,EAAMyC,EAAMzC,IAAM,EAAGsa,EAAI,EAAGA,IAAKta,IAAO,CAChE,IAAIlB,EAAO2D,EAAMpC,KAAKia,GAAGzb,KAAKC,KAC9B,GAAIA,EAAKupB,UAAYvpB,EAAKC,UAAa,MACnCu8C,EAAapxB,QAAQ5P,IAAM,EAAKihC,EAAkBjhC,EAC7C7X,EAAM9D,OAAO2b,IAAMta,GAAOs7C,EAAaxkB,OAAO,EAAG,GAAIxc,GAOhE,IAHA,IAAImhC,EAAuBH,EAAapxB,QAAQqxB,GAE5CG,EAAY,GAAIC,EAAiBn8C,EAAM86B,UAClCp7B,EAAUM,EAAMN,QAAS8B,EAAI,GAAIA,IAAK,CAC7C,IAAIX,EAAOnB,EAAQsB,WAEnB,GADAk7C,EAAU/2C,KAAKtE,GACXW,GAAKxB,EAAM86B,UAAa,MAC5Bp7B,EAAUmB,EAAKnB,QAIby8C,EAAiB,GAAKD,EAAUC,EAAiB,GAAG98C,KAAKC,KAAKupB,UAC9D5lB,EAAMpC,KAAKo7C,GAAsB58C,MAAQ68C,EAAUC,EAAiB,GAAG98C,KACvE88C,GAAkB,EACbA,GAAkB,GAAKD,EAAUC,EAAiB,GAAGj7C,aAAeg7C,EAAUC,EAAiB,GAAG98C,KAAKC,KAAKupB,UAC5G5lB,EAAMpC,KAAKo7C,GAAsB58C,MAAQ68C,EAAUC,EAAiB,GAAG98C,OAC5E88C,GAAkB,GAEtB,IAAK,IAAIh+B,EAAIne,EAAM86B,UAAW3c,GAAK,EAAGA,IAAK,CACzC,IAAIi+B,GAAaj+B,EAAIg+B,EAAiB,IAAMn8C,EAAM86B,UAAY,GAC1D13B,EAAS84C,EAAUE,GACvB,GAAKh5C,EACL,IAAK,IAAImC,EAAM,EAAGA,EAAMu2C,EAAal3C,OAAQW,IAAO,CAGlD,IAAI82C,EAAcP,GAAcv2C,EAAM02C,GAAwBH,EAAal3C,QAAS03C,GAAS,EACzFD,EAAc,IAAKC,GAAS,EAAOD,GAAeA,GACtD,IAAI58C,EAASwD,EAAMpC,KAAKw7C,EAAc,GAAI56C,EAAQwB,EAAMxB,MAAM46C,EAAc,GAC5E,GAAI58C,EAAOmD,eAAenB,EAAOA,EAAO2B,EAAO/D,KAAM+D,EAAO8L,OACxD,OAAO3E,KAAK4Q,QAAQlY,EAAM9D,OAAOk9C,GAAcC,EAASp5C,EAAInD,MAAMs8C,GAAep8C,EAC/D,IAAI,KAAMq6C,EAAct6C,EAAMN,QAAS,EAAGM,EAAM86B,UAAWshB,GACjDA,EAAWp8C,EAAM+6B,WAKrD,IADA,IAAIwhB,EAAahyC,KAAKqJ,MAAMhP,OACnBkD,EAAMg0C,EAAal3C,OAAS,EAAGkD,GAAO,IAC7CyC,KAAK4Q,QAAQjb,EAAMD,EAAID,KACnBuK,KAAKqJ,MAAMhP,OAAS23C,IAFwBz0C,IAAO,CAGvD,IAAInH,EAAQm7C,EAAah0C,GACrBnH,EAAQ,IACZT,EAAO+C,EAAM9D,OAAOwB,GAAQV,EAAKiD,EAAInD,MAAMY,IAE7C,OAAO4J,MAwBTymC,EAAUhoC,UAAU2mC,iBAAmB,SAASzvC,EAAMD,EAAIY,GACxD,IAAKA,EAAK4E,UAAYvF,GAAQD,GAAMsK,KAAKzK,IAAIO,QAAQH,GAAMT,OAAOC,QAAQC,KAAM,CAC9E,IAAI68C,EAhwBR,SAAqB18C,EAAKU,EAAKsF,GAC7B,IAAIvE,EAAOzB,EAAIO,QAAQG,GACvB,GAAIe,EAAK9B,OAAOmD,eAAerB,EAAKE,QAASF,EAAKE,QAASqE,GAAa,OAAOtF,EAE/E,GAAyB,GAArBe,EAAK3C,aACL,IAAK,IAAIkc,EAAIvZ,EAAKZ,MAAQ,EAAGma,GAAK,EAAGA,IAAK,CAC1C,IAAIrZ,EAAQF,EAAKE,MAAMqZ,GACvB,GAAIvZ,EAAKV,KAAKia,GAAGlY,eAAenB,EAAOA,EAAOqE,GAAa,OAAOvE,EAAKpC,OAAO2b,EAAI,GAClF,GAAIrZ,EAAQ,EAAK,OAAO,KAE5B,GAAIF,EAAK3C,cAAgB2C,EAAK9B,OAAOC,QAAQC,KACzC,IAAK,IAAIy4C,EAAM72C,EAAKZ,MAAQ,EAAGy3C,GAAO,EAAGA,IAAO,CAChD,IAAIb,EAAUh2C,EAAKmB,WAAW01C,GAC9B,GAAI72C,EAAKV,KAAKu3C,GAAKx1C,eAAe20C,EAASA,EAASzxC,GAAa,OAAOvE,EAAKxB,MAAMq4C,EAAM,GACzF,GAAIb,EAAUh2C,EAAKV,KAAKu3C,GAAKj3C,WAAc,OAAO,MAkvBxCs7C,CAAYlyC,KAAKzK,IAAKI,EAAMW,EAAKxB,MAChC,MAATm9C,IAAiBt8C,EAAOD,EAAKu8C,GAEnC,OAAOjyC,KAAKmlC,aAAaxvC,EAAMD,EAAI,IAAI,KAAM,UAAcY,GAAO,EAAG,KAMvEmwC,EAAUhoC,UAAU2F,YAAc,SAASzO,EAAMD,GAG/C,IAFA,IAAIgD,EAAQsH,KAAKzK,IAAIO,QAAQH,GAAOgD,EAAMqH,KAAKzK,IAAIO,QAAQJ,GACvDy8C,EAAUjC,EAAcx3C,EAAOC,GAC1B1B,EAAI,EAAGA,EAAIk7C,EAAQ93C,OAAQpD,IAAK,CACvC,IAAIb,EAAQ+7C,EAAQl7C,GAAImS,EAAOnS,GAAKk7C,EAAQ93C,OAAS,EACrD,GAAK+O,GAAiB,GAAThT,GAAesC,EAAMpC,KAAKF,GAAOtB,KAAK6b,aAAaxW,SAC5D,OAAO6F,KAAK3J,OAAOqC,EAAMyC,MAAM/E,GAAQuC,EAAII,IAAI3C,IACnD,GAAIA,EAAQ,IAAMgT,GAAQ1Q,EAAMpC,KAAKF,EAAQ,GAAGwD,WAAWlB,EAAMxB,MAAMd,EAAQ,GAAIuC,EAAIR,WAAW/B,EAAQ,KACtG,OAAO4J,KAAK3J,OAAOqC,EAAM9D,OAAOwB,GAAQuC,EAAInD,MAAMY,IAExD,IAAK,IAAIma,EAAI,EAAGA,GAAK7X,EAAMtC,OAASma,GAAK5X,EAAIvC,MAAOma,IAClD,GAAI5a,EAAO+C,EAAMyC,MAAMoV,IAAM7X,EAAMtC,MAAQma,GAAK7a,EAAKgD,EAAMK,IAAIwX,IAAM5X,EAAII,IAAIwX,GAAK7a,GAAMiD,EAAIvC,MAAQma,EAChG,OAAOvQ,KAAK3J,OAAOqC,EAAM9D,OAAO2b,GAAI7a,GAE1C,OAAOsK,KAAK3J,OAAOV,EAAMD,K,8ICpoDvB2U,EAAS,GAEb,GAAwB,oBAAb9N,WAA+C,oBAAZoK,SAAyB,CACrE,IAAIyrC,EAAU,cAAcz4B,KAAKpd,UAAUmK,WACvC2rC,EAAY,UAAU71C,KAAKD,UAAUmK,WACrC4rC,EAAU,wCAAwC34B,KAAKpd,UAAUmK,WAEjE+kB,EAAKphB,EAAOohB,MAAQ4mB,GAAaC,GAAWF,GAChD/nC,EAAOkoC,WAAaF,EAAY1rC,SAAS6rC,cAAgB,EAAIF,GAAWA,EAAQ,GAAKF,GAAWA,EAAQ,GAAK,KAC7G/nC,EAAOkhB,OAASE,GAAM,gBAAgBjvB,KAAKD,UAAUmK,WACrD2D,EAAOooC,cAAgBpoC,EAAOkhB,SAAW,iBAAiB5R,KAAKpd,UAAUmK,YAAc,CAAC,EAAG,IAAI,GAC/F,IAAI0kB,GAAUK,GAAM,gBAAgB9R,KAAKpd,UAAUmK,WACnD2D,EAAO+gB,SAAWA,EAClB/gB,EAAOqoC,eAAiBtnB,IAAWA,EAAO,GAE1C/gB,EAAOghB,QAAUI,GAAM,iBAAiBjvB,KAAKD,UAAU+uB,QACvDjhB,EAAOsoC,IAAMtoC,EAAOghB,SAAW,cAAc7uB,KAAKD,UAAUmK,YAAcnK,UAAUq2C,eAAiB,GACrGvoC,EAAOmhB,IAAMnhB,EAAOsoC,KAAO,MAAMn2C,KAAKD,UAAUE,UAChD4N,EAAOwoC,QAAU,aAAar2C,KAAKD,UAAUmK,WAC7C2D,EAAOyoC,OAAS,wBAAyBnsC,SAASosC,gBAAgBz1B,MAClEjT,EAAO2oC,eAAiB3oC,EAAOyoC,UAAY,uBAAuBn5B,KAAKpd,UAAUmK,YAAc,CAAC,EAAG,IAAI,GAGzG,IAAIusC,EAAW,SAAS38C,GACtB,IAAK,IAAIY,EAAQ,GAAIA,IAEnB,KADAZ,EAAOA,EAAKiqC,iBACC,OAAOrpC,GAIpBwnC,EAAa,SAASpoC,GACxB,IAAIpB,EAASoB,EAAK48C,cAAgB58C,EAAKooC,WACvC,OAAOxpC,GAA6B,IAAnBA,EAAOqG,SAAiBrG,EAAOi+C,KAAOj+C,GAGrDk+C,EAAc,KAKdC,EAAY,SAAS/8C,EAAMX,EAAMD,GACnC,IAAIlB,EAAQ4+C,IAAgBA,EAAczsC,SAAS2sC,eAGnD,OAFA9+C,EAAM++C,OAAOj9C,EAAY,MAANZ,EAAaY,EAAK+pC,UAAUhmC,OAAS3E,GACxDlB,EAAMg/C,SAASl9C,EAAMX,GAAQ,GACtBnB,GAMLi/C,EAAuB,SAASn9C,EAAMurB,EAAK6xB,EAAYC,GACzD,OAAOD,IAAeE,EAAQt9C,EAAMurB,EAAK6xB,EAAYC,GAAY,IAC3CC,EAAQt9C,EAAMurB,EAAK6xB,EAAYC,EAAW,KAG9DE,EAAe,gCAEnB,SAASD,EAAQt9C,EAAMurB,EAAK6xB,EAAYC,EAAWrO,GACjD,OAAS,CACP,GAAIhvC,GAAQo9C,GAAc7xB,GAAO8xB,EAAa,OAAO,EACrD,GAAI9xB,IAAQyjB,EAAM,EAAI,EAAIpvC,EAASI,IAAQ,CACzC,IAAIpB,EAASoB,EAAKooC,WAClB,IAAKxpC,GAA6B,GAAnBA,EAAOqG,UAAiBu4C,EAAax9C,IAASu9C,EAAar3C,KAAKlG,EAAKqoC,WACxD,SAAxBroC,EAAKy9C,gBACL,OAAO,EACXlyB,EAAMoxB,EAAS38C,IAASgvC,EAAM,EAAI,EAAI,GACtChvC,EAAOpB,MACF,IAAqB,GAAjBoB,EAAKiF,SAKd,OAAO,EAHP,GAA4B,UAD5BjF,EAAOA,EAAK4rC,WAAWrgB,GAAOyjB,EAAM,GAAK,EAAI,KACpCyO,gBAA8B,OAAO,EAC9ClyB,EAAMyjB,EAAM,EAAIpvC,EAASI,GAAQ,IAOvC,SAASJ,EAASI,GAChB,OAAwB,GAAjBA,EAAKiF,SAAgBjF,EAAK+pC,UAAUhmC,OAAS/D,EAAK4rC,WAAW7nC,OActE,SAASy5C,EAAapxC,GAEpB,IADA,IAAI8kC,EACKpR,EAAM1zB,EAAK0zB,KAAiCoR,EAAOpR,EAAI4d,YAAvC5d,EAAMA,EAAIsI,YACnC,OAAO8I,GAAQA,EAAKlxC,MAAQkxC,EAAKlxC,KAAK4C,UAAYsuC,EAAK9kC,KAAOA,GAAO8kC,EAAK3iB,YAAcniB,GAK1F,IAAIuxC,EAAqB,SAASC,GAChC,IAAIC,EAAYD,EAAOE,YAGvB,OAFID,GAAa9pC,EAAO+gB,QAAU8oB,EAAOG,aAAeH,EAAOI,WAAW,GAAGH,YACzEA,GAAY,GACTA,GAGT,SAASI,EAASroB,EAAS9vB,GACzB,IAAIoO,EAAQ7D,SAAS6tC,YAAY,SAIjC,OAHAhqC,EAAMiqC,UAAU,WAAW,GAAM,GACjCjqC,EAAM0hB,QAAUA,EAChB1hB,EAAMpO,IAAMoO,EAAM/S,KAAO2E,EAClBoO,EAGT,SAASkqC,EAAWn/C,GAClB,MAAO,CAACw1B,KAAM,EAAGC,MAAOz1B,EAAIw9C,gBAAgB4B,YACpC9pB,IAAK,EAAGC,OAAQv1B,EAAIw9C,gBAAgB6B,cAG9C,SAASC,EAAQt2C,EAAOhI,GACtB,MAAuB,iBAATgI,EAAoBA,EAAQA,EAAMhI,GAGlD,SAASu+C,EAAWx+C,GAClB,IAAIy+C,EAAOz+C,EAAKgvB,wBAEZ0vB,EAAUD,EAAK9pB,MAAQ30B,EAAK2+C,aAAgB,EAC5CC,EAAUH,EAAK7pB,OAAS50B,EAAK6+C,cAAiB,EAElD,MAAO,CAACpqB,KAAMgqB,EAAKhqB,KAAMC,MAAO+pB,EAAKhqB,KAAOz0B,EAAKq+C,YAAcK,EACvDnqB,IAAKkqB,EAAKlqB,IAAKC,OAAQiqB,EAAKlqB,IAAMv0B,EAAKs+C,aAAeM,GAGhE,SAASE,EAAmBlhD,EAAM6gD,EAAMM,GAGtC,IAFA,IAAIC,EAAkBphD,EAAKgX,SAAS,oBAAsB,EAAGqqC,EAAerhD,EAAKgX,SAAS,iBAAmB,EACzG3V,EAAMrB,EAAKwO,IAAIg/B,cACVxsC,EAASmgD,GAAYnhD,EAAKwO,IAC5BxN,EADkCA,EAASwpC,EAAWxpC,GAE3D,GAAuB,GAAnBA,EAAOqG,SAAX,CACA,IAAIi6C,EAAQtgD,GAAUK,EAAI4S,MAA2B,GAAnBjT,EAAOqG,SACrCk6C,EAAWD,EAAQd,EAAWn/C,GAAOu/C,EAAW5/C,GAChDwgD,EAAQ,EAAGC,EAAQ,EASvB,GARIZ,EAAKlqB,IAAM4qB,EAAS5qB,IAAMgqB,EAAQS,EAAiB,OACnDK,IAAUF,EAAS5qB,IAAMkqB,EAAKlqB,IAAMgqB,EAAQU,EAAc,QACrDR,EAAKjqB,OAAS2qB,EAAS3qB,OAAS+pB,EAAQS,EAAiB,YAC9DK,EAAQZ,EAAKjqB,OAAS2qB,EAAS3qB,OAAS+pB,EAAQU,EAAc,WAC9DR,EAAKhqB,KAAO0qB,EAAS1qB,KAAO8pB,EAAQS,EAAiB,QACrDI,IAAUD,EAAS1qB,KAAOgqB,EAAKhqB,KAAO8pB,EAAQU,EAAc,SACvDR,EAAK/pB,MAAQyqB,EAASzqB,MAAQ6pB,EAAQS,EAAiB,WAC5DI,EAAQX,EAAK/pB,MAAQyqB,EAASzqB,MAAQ6pB,EAAQU,EAAc,UAC5DG,GAASC,EACX,GAAIH,EACFjgD,EAAIqgD,YAAYC,SAASH,EAAOC,OAC3B,CACL,IAAIG,EAAS5gD,EAAO6gD,WAAYC,EAAS9gD,EAAO+gD,UAC5CN,IAASzgD,EAAO+gD,WAAaN,GAC7BD,IAASxgD,EAAO6gD,YAAcL,GAClC,IAAIQ,EAAKhhD,EAAO6gD,WAAaD,EAAQK,EAAKjhD,EAAO+gD,UAAYD,EAC7DjB,EAAO,CAAChqB,KAAMgqB,EAAKhqB,KAAOmrB,EAAIrrB,IAAKkqB,EAAKlqB,IAAMsrB,EAAInrB,MAAO+pB,EAAK/pB,MAAQkrB,EAAIprB,OAAQiqB,EAAKjqB,OAASqrB,GAGpG,GAAIX,EAAS,OAyBjB,SAASY,EAAY1zC,GAEnB,IADA,IAAI2zC,EAAQ,GAAI9gD,EAAMmN,EAAIg/B,cACnBh/B,IACL2zC,EAAMz7C,KAAK,CAAC8H,IAAKA,EAAKmoB,IAAKnoB,EAAIuzC,UAAWlrB,KAAMroB,EAAIqzC,aAChDrzC,GAAOnN,GAFDmN,EAAMg8B,EAAWh8B,IAI7B,OAAO2zC,EAcT,SAASC,EAAmBD,EAAOE,GACjC,IAAK,IAAIt/C,EAAI,EAAGA,EAAIo/C,EAAMh8C,OAAQpD,IAAK,CACrC,IAAIH,EAAMu/C,EAAMp/C,GACZyL,EAAM5L,EAAI4L,IACVmoB,EAAM/zB,EAAI+zB,IACVE,EAAOj0B,EAAIi0B,KACXroB,EAAIuzC,WAAaprB,EAAM0rB,IAAQ7zC,EAAIuzC,UAAYprB,EAAM0rB,GACrD7zC,EAAIqzC,YAAchrB,IAAQroB,EAAIqzC,WAAahrB,IAInD,IAAIyrB,EAAyB,KAoB7B,SAASC,EAAiBngD,EAAMogD,GAG9B,IAFA,IAAIxxB,EAA0ByxB,EAAjBC,EAAY,IAAoBlxC,EAAS,EAClDmxC,EAASH,EAAO7rB,IAAKisB,EAASJ,EAAO7rB,IAChCptB,EAAQnH,EAAKG,WAAYsgD,EAAa,EAAGt5C,EAAOA,EAAQA,EAAMqjC,YAAaiW,IAAc,CAChG,IAAIC,OAAQ,EACZ,GAAsB,GAAlBv5C,EAAMlC,SAAiBy7C,EAAQv5C,EAAMw5C,qBACpC,IAAsB,GAAlBx5C,EAAMlC,SACR,SADyBy7C,EAAQ3D,EAAU51C,GAAOw5C,iBAGzD,IAAK,IAAIhgD,EAAI,EAAGA,EAAI+/C,EAAM38C,OAAQpD,IAAK,CACrC,IAAI89C,EAAOiC,EAAM//C,GACjB,GAAI89C,EAAKlqB,KAAOgsB,GAAU9B,EAAKjqB,QAAUgsB,EAAQ,CAC/CD,EAASx1C,KAAKC,IAAIyzC,EAAKjqB,OAAQ+rB,GAC/BC,EAASz1C,KAAKc,IAAI4yC,EAAKlqB,IAAKisB,GAC5B,IAAII,EAAKnC,EAAKhqB,KAAO2rB,EAAO3rB,KAAOgqB,EAAKhqB,KAAO2rB,EAAO3rB,KAChDgqB,EAAK/pB,MAAQ0rB,EAAO3rB,KAAO2rB,EAAO3rB,KAAOgqB,EAAK/pB,MAAQ,EAC5D,GAAIksB,EAAKN,EAAW,CAClB1xB,EAAUznB,EACVm5C,EAAYM,EACZP,EAAgBO,GAA0B,GAApBhyB,EAAQ3pB,SAAgB,CAACwvB,KAAMgqB,EAAK/pB,MAAQ0rB,EAAO3rB,KAAOgqB,EAAK/pB,MAAQ+pB,EAAKhqB,KAAMF,IAAK6rB,EAAO7rB,KAAO6rB,EACrG,GAAlBj5C,EAAMlC,UAAiB27C,IACvBxxC,EAASqxC,GAAcL,EAAO3rB,OAASgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,EAAI,IAC7E,WAGC9F,IAAYwxB,EAAO3rB,MAAQgqB,EAAK/pB,OAAS0rB,EAAO7rB,KAAOkqB,EAAKlqB,KAChD6rB,EAAO3rB,MAAQgqB,EAAKhqB,MAAQ2rB,EAAO7rB,KAAOkqB,EAAKjqB,UAC5DplB,EAASqxC,EAAa,IAG9B,OAAI7xB,GAA+B,GAApBA,EAAQ3pB,SAKzB,SAA0BjF,EAAMogD,GAG9B,IAFA,IAAI56C,EAAMxF,EAAK+pC,UAAUhmC,OACrB7F,EAAQmS,SAAS2sC,cACZr8C,EAAI,EAAGA,EAAI6E,EAAK7E,IAAK,CAC5BzC,EAAM++C,OAAOj9C,EAAMW,EAAI,GACvBzC,EAAMg/C,SAASl9C,EAAMW,GACrB,IAAI89C,EAAOoC,EAAW3iD,EAAO,GAC7B,GAAIugD,EAAKlqB,KAAOkqB,EAAKjqB,QACjBssB,EAAOV,EAAQ3B,GACf,MAAO,CAACz+C,KAAMA,EAAMoP,OAAQzO,GAAKy/C,EAAO3rB,OAASgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,EAAI,IAEzF,MAAO,CAAC10B,KAAMA,EAAMoP,OAAQ,GAhBmB2xC,CAAiBnyB,EAASyxB,IACpEzxB,GAAY0xB,GAAiC,GAApB1xB,EAAQ3pB,SAAyB,CAACjF,KAAMA,EAAMoP,OAAQA,GAC7E+wC,EAAiBvxB,EAASyxB,GAiBnC,SAASS,EAAOV,EAAQ3B,GACtB,OAAO2B,EAAO3rB,MAAQgqB,EAAKhqB,KAAO,GAAK2rB,EAAO3rB,MAAQgqB,EAAK/pB,MAAQ,GACjE0rB,EAAO7rB,KAAOkqB,EAAKlqB,IAAM,GAAK6rB,EAAO7rB,KAAOkqB,EAAKjqB,OAAS,EA6C9D,SAASwsB,EAAiBt1B,EAAS00B,EAAQa,GACzC,IAAIz7C,EAAMkmB,EAAQkgB,WAAW7nC,OAC7B,GAAIyB,GAAOy7C,EAAI1sB,IAAM0sB,EAAIzsB,OACvB,IAAK,IAAI0sB,EAASn2C,KAAKC,IAAI,EAAGD,KAAKc,IAAIrG,EAAM,EAAGuF,KAAKo2C,MAAM37C,GAAO46C,EAAO7rB,IAAM0sB,EAAI1sB,MAAQ0sB,EAAIzsB,OAASysB,EAAI1sB,MAAQ,IAAK5zB,EAAIugD,IAAU,CACrI,IAAI/5C,EAAQukB,EAAQkgB,WAAWjrC,GAC/B,GAAsB,GAAlBwG,EAAMlC,SAER,IADA,IAAIy7C,EAAQv5C,EAAMw5C,iBACTrjC,EAAI,EAAGA,EAAIojC,EAAM38C,OAAQuZ,IAAK,CACrC,IAAImhC,EAAOiC,EAAMpjC,GACjB,GAAIwjC,EAAOV,EAAQ3B,GAAS,OAAOuC,EAAiB75C,EAAOi5C,EAAQ3B,GAGvE,IAAK99C,GAAKA,EAAI,GAAK6E,IAAQ07C,EAAU,MAGzC,OAAOx1B,EAIT,SAAS01B,EAAYxjD,EAAMwiD,GACzB,IAAIt3C,EAAQu4C,EAEsBrhD,EAAMoP,EAApCnQ,EAAMrB,EAAKwO,IAAIg/B,cACnB,GAAInsC,EAAIqiD,uBACN,IACE,IAAIC,EAAQtiD,EAAIqiD,uBAAuBlB,EAAO3rB,KAAM2rB,EAAO7rB,KACvDgtB,IAA2BvhD,GAAhB8I,EAASy4C,GAAqBC,WAAYpyC,EAAStG,EAAOsG,QACzE,MAAOkkB,IAEX,IAAKtzB,GAAQf,EAAIwiD,oBAAqB,CACpC,IAAIvjD,EAAQe,EAAIwiD,oBAAoBrB,EAAO3rB,KAAM2rB,EAAO7rB,KACpDr2B,IAA6B8B,GAAlBqhD,EAAWnjD,GAAuBwjD,eAAgBtyC,EAASiyC,EAASptB,aAGrF,IAAwGt0B,EAApGgiD,GAAO/jD,EAAKgkD,KAAKZ,iBAAmBpjD,EAAKgkD,KAAO3iD,GAAK+hD,iBAAiBZ,EAAO3rB,KAAM2rB,EAAO7rB,IAAM,GACpG,IAAKotB,IAAQ/jD,EAAKwO,IAAI4Y,SAAyB,GAAhB28B,EAAI18C,SAAgB08C,EAAIvZ,WAAauZ,GAAM,CACxE,IAAIV,EAAMrjD,EAAKwO,IAAI4iB,wBACnB,IAAK8xB,EAAOV,EAAQa,GAAQ,OAAO,KAEnC,KADAU,EAAMX,EAAiBpjD,EAAKwO,IAAKg0C,EAAQa,IAC7B,OAAO,KAGrB,GAAIltC,EAAOghB,OACT,IAAK,IAAIwD,EAAIopB,EAAK3hD,GAAQu4B,EAAGA,EAAI6P,EAAW7P,GACpCA,EAAExQ,YAAa/nB,EAAOoP,EAAS,MAGzC,GADAuyC,EAxFF,SAAsBv1C,EAAKg0C,GACzB,IAAIxhD,EAASwN,EAAIg8B,WACjB,OAAIxpC,GAAU,QAAQsH,KAAKtH,EAAOypC,WAAa+X,EAAO3rB,KAAOroB,EAAI4iB,wBAAwByF,KAC9E71B,EACJwN,EAoFDy1C,CAAaF,EAAKvB,GACpBpgD,EAAM,CACR,GAAI+T,EAAOkhB,OAA0B,GAAjBj1B,EAAKiF,WAGvBmK,EAASrE,KAAKc,IAAIuD,EAAQpP,EAAK4rC,WAAW7nC,SAG7B/D,EAAK4rC,WAAW7nC,OAAQ,CACnC,IAAoC+9C,EAAhCrlB,EAAOz8B,EAAK4rC,WAAWx8B,GACN,OAAjBqtB,EAAK4L,WAAsByZ,EAAQrlB,EAAKzN,yBAAyB0F,OAAS0rB,EAAO3rB,MACjFqtB,EAAMttB,OAAS4rB,EAAO7rB,KACtBnlB,IAKJpP,GAAQpC,EAAKwO,KAAOgD,GAAUpP,EAAK4rC,WAAW7nC,OAAS,GAAgC,GAA3B/D,EAAKI,UAAU6E,UAC3Em7C,EAAO7rB,IAAMv0B,EAAKI,UAAU4uB,wBAAwBwF,OACpD70B,EAAM/B,EAAKP,MAAM4B,IAAIJ,QAAQC,KAId,GAAVsQ,GAAgC,GAAjBpP,EAAKiF,UAAyD,MAAxCjF,EAAK4rC,WAAWx8B,EAAS,GAAGi5B,WACtE1oC,EA7FR,SAAsB/B,EAAMoC,EAAMoP,EAAQgxC,GAQxC,IADA,IAAI2B,GAAW,EACNjiB,EAAM9/B,EACT8/B,GAAOliC,EAAKwO,KADK,CAErB,IAAI8kC,EAAOtzC,EAAKkwB,QAAQk0B,YAAYliB,GAAK,GACzC,IAAKoR,EAAQ,OAAO,KACpB,GAAIA,EAAKlxC,KAAK4C,SAAWsuC,EAAKtyC,OAAQ,CACpC,IAAI6/C,EAAOvN,EAAK9kC,IAAI4iB,wBACpB,GAAIyvB,EAAKhqB,KAAO2rB,EAAO3rB,MAAQgqB,EAAKlqB,IAAM6rB,EAAO7rB,IAAOwtB,EAAU7Q,EAAK+Q,cAClE,MAAIxD,EAAK/pB,MAAQ0rB,EAAO3rB,MAAQgqB,EAAKjqB,OAAS4rB,EAAO7rB,KACnD,MAD0DwtB,EAAU7Q,EAAKgR,UAGlFpiB,EAAMoR,EAAK9kC,IAAIg8B,WAEjB,OAAO2Z,GAAW,EAAIA,EAAUnkD,EAAKkwB,QAAQq0B,WAAWniD,EAAMoP,GAyElDgzC,CAAaxkD,EAAMoC,EAAMoP,EAAQgxC,IAElC,MAAPzgD,IAAeA,EA3GrB,SAAwB/B,EAAM+jD,EAAKvB,GACjC,IAAI5/C,EAAM2/C,EAAiBwB,EAAKvB,GAC5BpgD,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACbyD,GAAQ,EACZ,GAAqB,GAAjB7S,EAAKiF,WAAkBjF,EAAKG,WAAY,CAC1C,IAAIs+C,EAAOz+C,EAAKgvB,wBAChBnc,EAAO4rC,EAAKhqB,MAAQgqB,EAAK/pB,OAAS0rB,EAAO3rB,MAAQgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,GAAK,EAEtF,OAAO92B,EAAKkwB,QAAQq0B,WAAWniD,EAAMoP,EAAQyD,GAkGpBwvC,CAAezkD,EAAM+jD,EAAKvB,IAEnD,IAAIlP,EAAOtzC,EAAKkwB,QAAQk0B,YAAYL,GAAK,GACzC,MAAO,CAAChiD,IAAKA,EAAKw2C,OAAQjF,EAAOA,EAAKoR,WAAapR,EAAKqR,QAAU,GAGpE,SAAS1B,EAAW1Z,EAAQt0B,GAC1B,IAAI6tC,EAAQvZ,EAAOwZ,iBACnB,OAAQD,EAAM38C,OAA0C28C,EAAM7tC,EAAO,EAAI,EAAI6tC,EAAM38C,OAAS,GAArEojC,EAAOnY,wBAGhC,IAAIwzB,EAAO,4CAKX,SAASluB,EAAY12B,EAAM+B,EAAKM,GAC9B,IAAIO,EAAM5C,EAAKkwB,QAAQ20B,WAAW9iD,EAAKM,EAAO,GAAK,EAAI,GACnDD,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OAEbszC,EAAoB3uC,EAAOyoC,QAAUzoC,EAAOkhB,MAChD,GAAqB,GAAjBj1B,EAAKiF,SAAe,CAGtB,IAAIy9C,IAAsBF,EAAKt8C,KAAKlG,EAAK+pC,aAAe9pC,EAAO,EAAKmP,EAASA,GAAUpP,EAAK+pC,UAAUhmC,QAc/F,CACL,IAAI1E,EAAO+P,EAAQhQ,EAAKgQ,EAAQuzC,EAAW1iD,EAAO,EAAI,GAAK,EAK3D,OAJIA,EAAO,IAAMmP,GAAUhQ,IAAMujD,GAAY,GACpC1iD,GAAQ,GAAKmP,GAAUpP,EAAK+pC,UAAUhmC,QAAU1E,IAAQsjD,EAAW,GACnE1iD,EAAO,EAAKZ,IACdD,IACAwjD,EAAS/B,EAAW9D,EAAU/8C,EAAMX,EAAMD,GAAKujD,GAAWA,EAAW,GAnB5E,IAAIlE,EAAOoC,EAAW9D,EAAU/8C,EAAMoP,EAAQA,GAASnP,GAIvD,GAAI8T,EAAOkhB,OAAS7lB,GAAU,KAAKlJ,KAAKlG,EAAK+pC,UAAU36B,EAAS,KAAOA,EAASpP,EAAK+pC,UAAUhmC,OAAQ,CACrG,IAAI8+C,EAAahC,EAAW9D,EAAU/8C,EAAMoP,EAAS,EAAGA,EAAS,IAAK,GACtE,GAAIyzC,EAAWtuB,KAAOkqB,EAAKlqB,IAAK,CAC9B,IAAIuuB,EAAYjC,EAAW9D,EAAU/8C,EAAMoP,EAAQA,EAAS,IAAK,GACjE,GAAI0zC,EAAUvuB,KAAOkqB,EAAKlqB,IACtB,OAAOquB,EAASE,EAAWA,EAAUruB,KAAOouB,EAAWpuB,OAG/D,OAAOgqB,EAYX,IAAK7gD,EAAKP,MAAM4B,IAAIO,QAAQG,GAAKf,OAAO0D,cAAe,CACrD,GAAI8M,IAAWnP,EAAO,GAAKmP,GAAUxP,EAASI,IAAQ,CACpD,IAAI1B,EAAS0B,EAAK4rC,WAAWx8B,EAAS,GACtC,GAAuB,GAAnB9Q,EAAO2G,SAAiB,OAAO89C,EAASzkD,EAAO0wB,yBAAyB,GAE9E,GAAI5f,EAASxP,EAASI,GAAO,CAC3B,IAAId,EAAQc,EAAK4rC,WAAWx8B,GAC5B,GAAsB,GAAlBlQ,EAAM+F,SAAiB,OAAO89C,EAAS7jD,EAAM8vB,yBAAyB,GAE5E,OAAO+zB,EAAS/iD,EAAKgvB,wBAAyB/uB,GAAQ,GAIxD,GAAImP,IAAWnP,EAAO,GAAKmP,GAAUxP,EAASI,IAAQ,CACpD,IAAIgjD,EAAWhjD,EAAK4rC,WAAWx8B,EAAS,GACpChR,EAA8B,GAArB4kD,EAAS/9C,SAAgB83C,EAAUiG,EAAUpjD,EAASojD,IAAaN,EAAoB,EAAI,IAG7E,GAArBM,EAAS/9C,UAAuC,MAArB+9C,EAAS3a,UAAqB2a,EAASxY,YAA0B,KAAXwY,EACvF,GAAI5kD,EAAU,OAAOwkD,EAAS/B,EAAWziD,EAAQ,IAAI,GAEvD,GAAIgR,EAASxP,EAASI,GAAO,CAE3B,IADA,IAAIijD,EAAUjjD,EAAK4rC,WAAWx8B,GACvB6zC,EAAQvF,YAAcuF,EAAQvF,WAAWwF,iBAAmBD,EAAUA,EAAQzY,YACrF,IAAI2Y,EAAYF,EAAqC,GAApBA,EAAQh+C,SAAgB83C,EAAUkG,EAAS,EAAIP,EAAoB,EAAI,GAC9E,GAApBO,EAAQh+C,SAAgBg+C,EAAU,KADd,KAE1B,GAAIE,EAAY,OAAOP,EAAS/B,EAAWsC,GAAW,IAAI,GAG5D,OAAOP,EAAS/B,EAA4B,GAAjB7gD,EAAKiF,SAAgB83C,EAAU/8C,GAAQA,GAAOC,GAAOA,GAAQ,GAG1F,SAAS2iD,EAASnE,EAAMhqB,GACtB,GAAkB,GAAdgqB,EAAK9pB,MAAc,OAAO8pB,EAC9B,IAAI5vB,EAAI4F,EAAOgqB,EAAKhqB,KAAOgqB,EAAK/pB,MAChC,MAAO,CAACH,IAAKkqB,EAAKlqB,IAAKC,OAAQiqB,EAAKjqB,OAAQC,KAAM5F,EAAG6F,MAAO7F,GAG9D,SAASk0B,EAAStE,EAAMlqB,GACtB,GAAmB,GAAfkqB,EAAK7pB,OAAe,OAAO6pB,EAC/B,IAAI3vB,EAAIyF,EAAMkqB,EAAKlqB,IAAMkqB,EAAKjqB,OAC9B,MAAO,CAACD,IAAKzF,EAAG0F,OAAQ1F,EAAG2F,KAAMgqB,EAAKhqB,KAAMC,MAAO+pB,EAAK/pB,OAG1D,SAAS0uB,EAAiBxlD,EAAMP,EAAOwX,GACrC,IAAIwuC,EAAYzlD,EAAKP,MAAOujC,EAAShjC,EAAKgkD,KAAK0B,cAC3CD,GAAahmD,GAASO,EAAKkvB,YAAYzvB,GACvCujC,GAAUhjC,EAAKwO,KAAOxO,EAAKkT,QAC/B,IACE,OAAO+D,IACP,QACIwuC,GAAahmD,GAASO,EAAKkvB,YAAYu2B,GACvCziB,GAAUhjC,EAAKwO,KAAOw0B,GAAUA,EAAO9vB,SAqC/C,IAAIyyC,EAAW,kBAiCf,IAAIC,EAAc,KAAMC,EAAY,KAAMC,GAAe,EACzD,SAAS5lD,EAAeF,EAAMP,EAAO2xC,GACnC,OAAIwU,GAAenmD,GAASomD,GAAazU,EAAc0U,GACvDF,EAAcnmD,EAAOomD,EAAYzU,EAC1B0U,EAAsB,MAAP1U,GAAsB,QAAPA,EAnEvC,SAAgCpxC,EAAMP,EAAO2xC,GAC3C,IAAI7sC,EAAM9E,EAAME,UACZmD,EAAc,MAAPsuC,EAAc7sC,EAAIC,MAAQD,EAAIE,IACzC,OAAO+gD,EAAiBxlD,EAAMP,GAAO,WAGnC,IAFA,IACI+O,EADMxO,EAAKkwB,QAAQ20B,WAAW/hD,EAAKf,IAAY,MAAPqvC,GAAe,EAAI,GACjDhvC,OACL,CACP,IAAI2jD,EAAU/lD,EAAKkwB,QAAQk0B,YAAY51C,GAAK,GAC5C,IAAKu3C,EAAW,MAChB,GAAIA,EAAQ3jD,KAAK4C,QAAS,CAAEwJ,EAAMu3C,EAAQv3C,IAAK,MAC/CA,EAAMu3C,EAAQv3C,IAAIg8B,WAGpB,IADA,IAAIgY,EAAS9rB,EAAY12B,EAAM8C,EAAKf,IAAK,GAChCwH,EAAQiF,EAAIjM,WAAYgH,EAAOA,EAAQA,EAAMqjC,YAAa,CACjE,IAAIoZ,OAAQ,EACZ,GAAsB,GAAlBz8C,EAAMlC,SAAiB2+C,EAAQz8C,EAAMw5C,qBACpC,IAAsB,GAAlBx5C,EAAMlC,SACR,SADyB2+C,EAAQ7G,EAAU51C,EAAO,EAAGA,EAAM4iC,UAAUhmC,QAAQ48C,iBAEpF,IAAK,IAAIhgD,EAAI,EAAGA,EAAIijD,EAAM7/C,OAAQpD,IAAK,CACrC,IAAIsgD,EAAM2C,EAAMjjD,GAChB,GAAIsgD,EAAIzsB,OAASysB,EAAI1sB,IAAM,IACf,MAAPya,EAAcoR,EAAO7rB,IAAM0sB,EAAI1sB,IAAkC,GAA3B0sB,EAAIzsB,OAAS4rB,EAAO7rB,KACxD0sB,EAAIzsB,OAAS4rB,EAAO5rB,OAAqC,GAA3B4rB,EAAO5rB,OAASysB,EAAI1sB,MACrD,OAAO,GAGf,OAAO,KA0CLsvB,CAAuBjmD,EAAMP,EAAO2xC,GApC1C,SAAkCpxC,EAAMP,EAAO2xC,GAC7C,IACIvuC,EADMpD,EAAME,UACAkD,MAChB,IAAKA,EAAM7B,OAAOyB,YAAe,OAAO,EACxC,IAAI+O,EAAS3O,EAAM1C,aAAc6J,GAAWwH,EAAQvM,EAAQuM,GAAU3O,EAAM7B,OAAOC,QAAQC,KACvFqD,EAAMvE,EAAKgkD,KAAKt1C,eAGpB,OAAKi3C,EAASr9C,KAAKzF,EAAM7B,OAAOuhB,cAAiBhe,EAAI2hD,OAG9CV,EAAiBxlD,EAAMP,GAAO,WAMnC,IAAIm2B,EAAWrxB,EAAI67C,WAAW,GAAI+F,EAAU5hD,EAAI6hD,UAAWC,EAAS9hD,EAAI+hD,YACpEC,EAAehiD,EAAIiiD,eACvBjiD,EAAI2hD,OAAO,OAAQ9U,EAAK,aACxB,IACIj7B,IADYtT,EAAMX,MAAQlC,EAAKkwB,QAAQu2B,YAAY5jD,EAAMnC,UAAYV,EAAKwO,KACtD4Y,SAAmC,GAA1B7iB,EAAI6hD,UAAU/+C,SAAgB9C,EAAI6hD,UAAY7hD,EAAI6hD,UAAU5b,aACxF2b,GAAW5hD,EAAI6hD,WAAaC,GAAU9hD,EAAI+hD,YAK/C,OAHA/hD,EAAIoK,kBACJpK,EAAIq5B,SAAShI,GACO,MAAhB2wB,IAAwBhiD,EAAIiiD,eAAiBD,GAC1CpwC,KAlBS,QAAPi7B,GAAwB,YAAPA,EAAoBpnC,EAAU/E,EA4BtDyhD,CAAyB1mD,EAAMP,EAAO2xC,IAwF5C,IAIIuV,EAAW,SAAkB3lD,EAAQ4lD,EAAUp4C,EAAKmiB,GACtD7kB,KAAK9K,OAASA,EACd8K,KAAK86C,SAAWA,EAChB96C,KAAK0C,IAAMA,EAGXA,EAAIsxC,WAAah0C,KAGjBA,KAAK6kB,WAAaA,EAClB7kB,KAAK+6C,MAdS,GAiBZ9sB,EAAqB,CAAE74B,KAAM,CAAE84B,cAAc,GAAO2qB,OAAQ,CAAE3qB,cAAc,GAAOqqB,UAAW,CAAErqB,cAAc,GAAO0qB,WAAY,CAAE1qB,cAAc,GAAOsqB,SAAU,CAAEtqB,cAAc,GAAO8sB,SAAU,CAAE9sB,cAAc,GAAO+sB,YAAa,CAAE/sB,cAAc,GAAOgtB,QAAS,CAAEhtB,cAAc,GAAOsrB,gBAAiB,CAAEtrB,cAAc,IAInU2sB,EAASp8C,UAAU08C,cAAgB,WAA4B,OAAO,GACtEN,EAASp8C,UAAU28C,YAAc,WAA0B,OAAO,GAClEP,EAASp8C,UAAU48C,YAAc,WAA0B,OAAO,GAClER,EAASp8C,UAAU68C,YAAc,SAAsBC,GAAa,OAAO,GAM3EV,EAASp8C,UAAU4e,UAAY,WAAwB,OAAO,MAK9Dw9B,EAASp8C,UAAUimB,UAAY,WAAwB,OAAO,GAG9DuJ,EAAmB74B,KAAKs3B,IAAM,WAE5B,IADA,IAAIt3B,EAAO,EACF6B,EAAI,EAAGA,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAO7B,GAAQ4K,KAAK86C,SAAS7jD,GAAG7B,KAC1E,OAAOA,GAKT64B,EAAmB4qB,OAAOnsB,IAAM,WAAc,OAAO,GAErDmuB,EAASp8C,UAAU+c,QAAU,WAC3Bxb,KAAK9K,OAAS,KACV8K,KAAK0C,IAAIsxC,YAAch0C,OAAQA,KAAK0C,IAAIsxC,WAAa,MACzD,IAAK,IAAI/8C,EAAI,EAAGA,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IACtC+I,KAAK86C,SAAS7jD,GAAGukB,WAGvBq/B,EAASp8C,UAAU+8C,eAAiB,SAAyB/9C,GAC3D,IAAK,IAAIxG,EAAI,EAAGhB,EAAM+J,KAAK44C,WAAY3hD,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAK,CACpE,IAAIm/B,EAAMp2B,KAAK86C,SAAS7jD,GACxB,GAAIm/B,GAAO34B,EAAS,OAAOxH,EAC3BA,GAAOmgC,EAAIhhC,OAIf64B,EAAmBsqB,UAAU7rB,IAAM,WACjC,OAAO1sB,KAAK9K,OAAOsmD,eAAex7C,OAGpCiuB,EAAmB2qB,WAAWlsB,IAAM,WAClC,OAAO1sB,KAAK9K,OAAS8K,KAAK9K,OAAOsmD,eAAex7C,MAAQA,KAAK64C,OAAS,GAGxE5qB,EAAmBuqB,SAAS9rB,IAAM,WAChC,OAAO1sB,KAAKu4C,UAAYv4C,KAAK5K,MAG/B64B,EAAmB+sB,SAAStuB,IAAM,WAChC,OAAO1sB,KAAK44C,WAAa54C,KAAK5K,KAAO,EAAI4K,KAAK64C,QAIhDgC,EAASp8C,UAAUg9C,gBAAkB,SAA0B/4C,EAAKgD,EAAQyD,GAG1E,GAAInJ,KAAK6kB,YAAc7kB,KAAK6kB,WAAWvJ,SAAyB,GAAhB5Y,EAAInH,SAAgBmH,EAAMA,EAAIg8B,YAAa,CACzF,GAAIv1B,EAAO,EAAG,CACZ,IAAIuyC,EAAWlU,EACf,GAAI9kC,GAAO1C,KAAK6kB,WACd62B,EAAYh5C,EAAIw/B,WAAWx8B,EAAS,OAC/B,CACL,KAAOhD,EAAIg8B,YAAc1+B,KAAK6kB,YAAcniB,EAAMA,EAAIg8B,WACtDgd,EAAYh5C,EAAI69B,gBAElB,KAAOmb,MAAgBlU,EAAOkU,EAAU1H,aAAexM,EAAKtyC,QAAU8K,OAAS07C,EAAYA,EAAUnb,gBACrG,OAAOmb,EAAY17C,KAAKw7C,eAAehU,GAAQA,EAAKpyC,KAAO4K,KAAK44C,WAEhE,IAAI+C,EAAUC,EACd,GAAIl5C,GAAO1C,KAAK6kB,WACd82B,EAAWj5C,EAAIw/B,WAAWx8B,OACrB,CACL,KAAOhD,EAAIg8B,YAAc1+B,KAAK6kB,YAAcniB,EAAMA,EAAIg8B,WACtDid,EAAWj5C,EAAIo+B,YAEjB,KAAO6a,MAAeC,EAASD,EAAS3H,aAAe4H,EAAO1mD,QAAU8K,OAAS27C,EAAWA,EAAS7a,YACrG,OAAO6a,EAAW37C,KAAKw7C,eAAeI,GAAU57C,KAAKg7C,SAMzD,IAAI7hD,EACJ,GAAIuJ,GAAO1C,KAAK0C,KAAO1C,KAAK6kB,WAC1B1rB,EAAQuM,EAASutC,EAASjzC,KAAK6kB,iBAC1B,GAAI7kB,KAAK6kB,YAAc7kB,KAAK6kB,YAAc7kB,KAAK0C,KAAO1C,KAAK0C,IAAI4Y,SAAStb,KAAK6kB,YAClF1rB,EAAuD,EAA/CuJ,EAAIkgC,wBAAwB5iC,KAAK6kB,iBACpC,GAAI7kB,KAAK0C,IAAIjM,WAAY,CAC9B,GAAc,GAAViP,EAAe,IAAK,IAAIkiB,EAASllB,GAAMklB,EAASA,EAAO8W,WAAY,CACrE,GAAI9W,GAAU5nB,KAAK0C,IAAK,CAAEvJ,GAAQ,EAAO,MACzC,GAAIyuB,EAAO8W,WAAWjoC,YAAcmxB,EAAU,MAEhD,GAAa,MAATzuB,GAAiBuM,GAAUhD,EAAIw/B,WAAW7nC,OAAU,IAAK,IAAIwhD,EAAWn5C,GAAMm5C,EAAWA,EAASnd,WAAY,CAChH,GAAImd,GAAY77C,KAAK0C,IAAK,CAAEvJ,GAAQ,EAAM,MAC1C,GAAI0iD,EAASnd,WAAWhoC,WAAamlD,EAAY,OAGrD,OAAiB,MAAT1iD,EAAgBgQ,EAAO,EAAIhQ,GAAS6G,KAAKg7C,SAAWh7C,KAAK44C,YAKnEiC,EAASp8C,UAAU65C,YAAc,SAAsB51C,EAAKo5C,GAC1D,IAAK,IAAIviD,GAAQ,EAAM68B,EAAM1zB,EAAK0zB,EAAKA,EAAMA,EAAIsI,WAAY,CAC3D,IAAI8I,EAAOxnC,KAAK+7C,QAAQ3lB,GACxB,GAAIoR,KAAUsU,GAAatU,EAAKlxC,MAAO,CAErC,IAAIiD,IAASiuC,EAAKwU,UACa,GAAzBxU,EAAKwU,QAAQzgD,SAAgBisC,EAAKwU,QAAQ1gC,SAAyB,GAAhB5Y,EAAInH,SAAgBmH,EAAMA,EAAIg8B,YAAc8I,EAAKwU,SAAWt5C,GAGjH,OAAO8kC,EAFPjuC,GAAQ,KAOlBshD,EAASp8C,UAAUs9C,QAAU,SAAkBr5C,GAE7C,IADA,IAAI8kC,EAAO9kC,EAAIsxC,WACN5d,EAAMoR,EAAMpR,EAAKA,EAAMA,EAAIlhC,OAAU,GAAIkhC,GAAOp2B,KAAQ,OAAOwnC,GAG1EqT,EAASp8C,UAAUg6C,WAAa,SAAqB/1C,EAAKgD,EAAQyD,GAChE,IAAK,IAAIiuB,EAAO10B,EAAK00B,EAAMA,EAAOA,EAAKsH,WAAY,CACjD,IAAI8I,EAAOxnC,KAAK+7C,QAAQ3kB,GACxB,GAAIoQ,EAAQ,OAAOA,EAAKiU,gBAAgB/4C,EAAKgD,EAAQyD,GAEvD,OAAQ,GAMV0xC,EAASp8C,UAAUw9C,OAAS,SAAiBhmD,GAC3C,IAAK,IAAIgB,EAAI,EAAGyO,EAAS,EAAGzO,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK86C,SAAS7jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIsQ,GAAUzP,GAAO8C,GAAO2M,EAAQ,CAClC,MAAQjI,EAAMo7C,QAAUp7C,EAAMq9C,SAASzgD,QAAUoD,EAAQA,EAAMq9C,SAAS,GACxE,OAAOr9C,EAET,GAAIxH,EAAM8C,EAAO,OAAO0E,EAAMw+C,OAAOhmD,EAAMyP,EAASjI,EAAMo7C,QAC1DnzC,EAAS3M,IAKb8hD,EAASp8C,UAAUs6C,WAAa,SAAqB9iD,EAAKM,GACxD,IAAKyJ,KAAK6kB,WAAc,MAAO,CAACvuB,KAAM0J,KAAK0C,IAAKgD,OAAQ,GAGxD,IADA,IAAIzO,EAAI,EAAGyO,EAAS,EACXwpB,EAAS,EAAGj4B,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAK,CAClD,IAAIwG,EAAQuC,KAAK86C,SAAS7jD,GAAI8B,EAAMm2B,EAASzxB,EAAMrI,KACnD,GAAI2D,EAAM9C,GAAOwH,aAAiBy+C,GAAsB,CAAEx2C,EAASzP,EAAMi5B,EAAQ,MACjFA,EAASn2B,EAGX,GAAI2M,EAAU,OAAO1F,KAAK86C,SAAS7jD,GAAG8hD,WAAWrzC,EAAS1F,KAAK86C,SAAS7jD,GAAG4hD,OAAQtiD,GAEnF,IAAK,IAAI2jB,OAAO,EAAUjjB,KAAOijB,EAAOla,KAAK86C,SAAS7jD,EAAI,IAAI7B,MAAQ8kB,aAAgBiiC,GAAkBjiC,EAAKkiC,OAAOtnD,KAAKyB,MAAQ,EAAGU,KAEpI,GAAIV,GAAQ,EAAG,CAEb,IADA,IAAI8lD,EAAQ93C,GAAQ,GAElB83C,EAASplD,EAAI+I,KAAK86C,SAAS7jD,EAAI,GAAK,OACrBolD,EAAO35C,IAAIg8B,YAAc1+B,KAAK6kB,WAFvC5tB,IAAKsN,GAAQ,GAIrB,OAAI83C,GAAU9lD,GAAQgO,IAAU83C,EAAOxD,SAAWwD,EAAOnB,QAAkBmB,EAAOtD,WAAWsD,EAAOjnD,KAAMmB,GACnG,CAACD,KAAM0J,KAAK6kB,WAAYnf,OAAQ22C,EAASpJ,EAASoJ,EAAO35C,KAAO,EAAI,GAG3E,IADA,IAAIqwB,EAAMzuB,GAAU,GAElByuB,EAAO97B,EAAI+I,KAAK86C,SAASzgD,OAAS2F,KAAK86C,SAAS7jD,GAAK,OACxC87B,EAAKrwB,IAAIg8B,YAAc1+B,KAAK6kB,WAFnC5tB,IAAKqN,GAAU,GAIvB,OAAIyuB,GAAQzuB,IAAYyuB,EAAK8lB,SAAW9lB,EAAKmoB,QAAkBnoB,EAAKgmB,WAAW,EAAGxiD,GAC3E,CAACD,KAAM0J,KAAK6kB,WAAYnf,OAAQqtB,EAAOkgB,EAASlgB,EAAKrwB,KAAO1C,KAAK6kB,WAAWqd,WAAW7nC,SAMlGwgD,EAASp8C,UAAU69C,WAAa,SAAqB3mD,EAAMD,EAAIy1B,GAG7D,QAFgB,IAATA,IAAkBA,EAAO,GAEJ,GAAxBnrB,KAAK86C,SAASzgD,OACd,MAAO,CAAC/D,KAAM0J,KAAK6kB,WAAYlvB,KAAMA,EAAMD,GAAIA,EAAI6mD,WAAY,EAAGC,SAAUx8C,KAAK6kB,WAAWqd,WAAW7nC,QAG3G,IADA,IAAIkiD,GAAc,EAAGC,GAAY,EACxB92C,EAASylB,EAAMl0B,EAAI,GAAIA,IAAK,CACnC,IAAIwG,EAAQuC,KAAK86C,SAAS7jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,IAAmB,GAAfmnD,GAAoB5mD,GAAQoD,EAAK,CACnC,IAAI0jD,EAAY/2C,EAASjI,EAAMo7C,OAE/B,GAAIljD,GAAQ8mD,GAAa/mD,GAAMqD,EAAM0E,EAAMo7C,QAAUp7C,EAAMnH,MACvDmH,EAAMonB,YAAc7kB,KAAK6kB,WAAWvJ,SAAS7d,EAAMonB,YACnD,OAAOpnB,EAAM6+C,WAAW3mD,EAAMD,EAAI+mD,GAEtC9mD,EAAO+P,EACP,IAAK,IAAIkO,EAAI3c,EAAG2c,EAAI,EAAGA,IAAK,CAC1B,IAAIsG,EAAOla,KAAK86C,SAASlnC,EAAI,GAC7B,GAAIsG,EAAK9kB,MAAQ8kB,EAAKxX,IAAIg8B,YAAc1+B,KAAK6kB,aAAe3K,EAAKwiC,aAAa,GAAI,CAChFH,EAAatJ,EAAS/4B,EAAKxX,KAAO,EAClC,MAEF/M,GAAQukB,EAAK9kB,MAEI,GAAfmnD,IAAoBA,EAAa,GAEvC,GAAIA,GAAc,IAAMxjD,EAAMrD,GAAMuB,GAAK+I,KAAK86C,SAASzgD,OAAS,GAAI,CAClE3E,EAAKqD,EACL,IAAK,IAAI4jD,EAAM1lD,EAAI,EAAG0lD,EAAM38C,KAAK86C,SAASzgD,OAAQsiD,IAAO,CACvD,IAAI5pB,EAAO/yB,KAAK86C,SAAS6B,GACzB,GAAI5pB,EAAK39B,MAAQ29B,EAAKrwB,IAAIg8B,YAAc1+B,KAAK6kB,aAAekO,EAAK2pB,cAAc,GAAI,CACjFF,EAAWvJ,EAASlgB,EAAKrwB,KACzB,MAEFhN,GAAMq9B,EAAK39B,MAEI,GAAbonD,IAAkBA,EAAWx8C,KAAK6kB,WAAWqd,WAAW7nC,QAC5D,MAEFqL,EAAS3M,EAEX,MAAO,CAACzC,KAAM0J,KAAK6kB,WAAYlvB,KAAMA,EAAMD,GAAIA,EAAI6mD,WAAYA,EAAYC,SAAUA,IAGvF3B,EAASp8C,UAAUi+C,aAAe,SAAuBnmD,GACvD,GAAIyJ,KAAK64C,SAAW74C,KAAK6kB,aAAe7kB,KAAK86C,SAASzgD,OAAU,OAAO,EACvE,IAAIoD,EAAQuC,KAAK86C,SAASvkD,EAAO,EAAI,EAAIyJ,KAAK86C,SAASzgD,OAAS,GAChE,OAAqB,GAAdoD,EAAMrI,MAAaqI,EAAMi/C,aAAanmD,IAI/CskD,EAASp8C,UAAUk8C,YAAc,SAAsB1kD,GACrD,IAAIa,EAAMkJ,KAAK+4C,WAAW9iD,EAAK,GACzBK,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACnB,GAAqB,GAAjBpP,EAAKiF,UAAiBmK,GAAUpP,EAAK4rC,WAAW7nC,OAChD,MAAM,IAAIs0B,WAAW,qBAAuB14B,GAChD,OAAOK,EAAK4rC,WAAWx8B,IASzBm1C,EAASp8C,UAAU5I,aAAe,SAAuBkvC,EAAQvH,EAAM0a,EAAM0E,GAG3E,IADA,IAAIjnD,EAAO0L,KAAKc,IAAI4iC,EAAQvH,GAAO9nC,EAAK2L,KAAKC,IAAIyjC,EAAQvH,GAChDvmC,EAAI,EAAGyO,EAAS,EAAGzO,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK86C,SAAS7jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIO,EAAO+P,GAAUhQ,EAAKqD,EACtB,OAAO0E,EAAM5H,aAAakvC,EAASr/B,EAASjI,EAAMo7C,OAAQrb,EAAO93B,EAASjI,EAAMo7C,OAAQX,EAAM0E,GAClGl3C,EAAS3M,EAGX,IAAI8jD,EAAY78C,KAAK+4C,WAAWhU,EAAQA,GAAU,EAAI,GAClD+X,EAAUtf,GAAQuH,EAAS8X,EAAY78C,KAAK+4C,WAAWvb,EAAMA,GAAQ,EAAI,GACzE0W,EAASgE,EAAKt1C,eAEdm6C,GAAW,EAKf,IAAK1yC,EAAOkhB,OAASlhB,EAAOghB,SAAW0Z,GAAUvH,EAAM,CACrD,IAAIlnC,EAAOumD,EAAUvmD,KACf0mD,EAAWH,EAAUn3C,OAC3B,GAAqB,GAAjBpP,EAAKiF,UAGP,IAFAwhD,EAAWC,GAA4C,MAAhC1mD,EAAK+pC,UAAU2c,EAAW,KAEjCA,GAAY1mD,EAAK+pC,UAAUhmC,OACzC,IAAK,IAAI+8B,EAAO9gC,EAAMd,OAAQ,EAAU4hC,EAAMA,EAAOA,EAAKsH,WAAY,CACpE,GAAIlpC,EAAQ4hC,EAAK0J,YAAa,CACN,MAAlBtrC,EAAMmpC,WACNke,EAAYC,EAAU,CAACxmD,KAAMd,EAAMkpC,WAAYh5B,OAAQutC,EAASz9C,GAAS,IAC7E,MAEF,IAAIgyC,EAAOpQ,EAAK4c,WAChB,GAAIxM,GAAQA,EAAKlxC,MAAQkxC,EAAKlxC,KAAK4C,QAAW,WAG7C,CACL,IAAIghB,EAAO5jB,EAAK4rC,WAAW8a,EAAW,GACtCD,EAAW7iC,IAA0B,MAAjBA,EAAKykB,UAA4C,SAAxBzkB,EAAK65B,kBAKtD,GAAI1pC,EAAOkhB,OAAS2oB,EAAOoG,WAAapG,EAAOoG,WAAawC,EAAQxmD,MAAqC,GAA7B49C,EAAOoG,UAAU/+C,SAAe,CAC1G,IAAIg+C,EAAUrF,EAAOoG,UAAUpY,WAAWgS,EAAOsG,aAC7CjB,GAAsC,SAA3BA,EAAQxF,kBAA8B6I,GAAQ,GAG/D,GAAMA,GAASG,GAAY1yC,EAAOghB,SAC9BooB,EAAqBoJ,EAAUvmD,KAAMumD,EAAUn3C,OAAQwuC,EAAO+I,WAAY/I,EAAOgJ,gBACjFzJ,EAAqBqJ,EAAQxmD,KAAMwmD,EAAQp3C,OAAQwuC,EAAOoG,UAAWpG,EAAOsG,aAFhF,CAQA,IAAI2C,GAAiB,EACrB,IAAKjJ,EAAOxzC,QAAUqkC,GAAUvH,KAAUuf,EAAU,CAClD7I,EAAOkJ,SAASP,EAAUvmD,KAAMumD,EAAUn3C,QAC1C,IACMq/B,GAAUvH,GAAQ0W,EAAOxzC,OAAOo8C,EAAQxmD,KAAMwmD,EAAQp3C,QAC1Dy3C,GAAiB,EACjB,MAAOvtB,GAKP,KAAMA,aAAeytB,cAAiB,MAAMztB,GAIhD,IAAKutB,EAAgB,CACnB,GAAIpY,EAASvH,EAAM,CAAE,IAAI3K,EAAMgqB,EAAWA,EAAYC,EAASA,EAAUjqB,EACzE,IAAIr+B,EAAQmS,SAAS2sC,cACrB9+C,EAAM++C,OAAOuJ,EAAQxmD,KAAMwmD,EAAQp3C,QACnClR,EAAMg/C,SAASqJ,EAAUvmD,KAAMumD,EAAUn3C,QACzCwuC,EAAOrxC,kBACPqxC,EAAOpiB,SAASt9B,MAKpBqmD,EAASp8C,UAAUkmB,eAAiB,SAAyB6B,GAC3D,OAAQxmB,KAAK6kB,YAA+B,aAAjB2B,EAAS1xB,MAGtCm5B,EAAmBgtB,YAAYvuB,IAAM,WACnC,OAAO1sB,KAAK6kB,YAAc7kB,KAAK6kB,YAAc7kB,KAAK0C,MAAQ1C,KAAK0C,IAAI4Y,SAAStb,KAAK6kB,aAKnFg2B,EAASp8C,UAAU6+C,UAAY,SAAoB3nD,EAAMD,GACvD,IAAK,IAAIgQ,EAAS,EAAGzO,EAAI,EAAGA,EAAI+I,KAAK86C,SAASzgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK86C,SAAS7jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIsQ,GAAU3M,EAAMpD,GAAQoD,GAAOrD,GAAMgQ,EAAS/P,EAAOoD,GAAOrD,EAAKgQ,EAAQ,CAC3E,IAAI63C,EAAc73C,EAASjI,EAAMo7C,OAAQ2E,EAAYzkD,EAAM0E,EAAMo7C,OACjE,GAAIljD,GAAQ4nD,GAAe7nD,GAAM8nD,EAK/B,OAJAx9C,KAAK+6C,MAAQplD,GAAQ+P,GAAUhQ,GAAMqD,EApXO,EAAnB,OAqXrBpD,GAAQ4nD,GAAe7nD,GAAM8nD,IAC5B//C,EAAMw9C,aAAex9C,EAAMiF,IAAIg8B,YAAc1+B,KAAK6kB,WAChDpnB,EAAM6/C,UAAU3nD,EAAO4nD,EAAa7nD,EAAK6nD,GADsB9/C,EAAMs9C,MAtXhB,GA0X5Dt9C,EAAMs9C,MAAQt9C,EAAMiF,KAAOjF,EAAMonB,YAAcpnB,EAAMiF,IAAIg8B,YAAc1+B,KAAK6kB,YAAepnB,EAAMq9C,SAASzgD,OA1X9C,EAAhB,EA8XhDqL,EAAS3M,EAEXiH,KAAK+6C,MAhY6C,GAmYpDF,EAASp8C,UAAUg/C,iBAAmB,WAEpC,IADA,IAAIpa,EAAQ,EACH/sC,EAAO0J,KAAK9K,OAAQoB,EAAMA,EAAOA,EAAKpB,OAAQmuC,IAAS,CAC9D,IAAI0X,EAAiB,GAAT1X,EAtYoC,EAAnB,EAuYzB/sC,EAAKykD,MAAQA,IAASzkD,EAAKykD,MAAQA,KAI3C9sB,EAAmBitB,QAAQxuB,IAAM,WAAc,OAAO,GAEtDuB,EAAmBurB,gBAAgB9sB,IAAM,WAAc,OAAO,GAE9DluB,OAAO+wB,iBAAkBsrB,EAASp8C,UAAWwvB,GAI7C,IAAIyvB,EAAU,GAIVvB,EAA+B,SAAUtB,GAC3C,SAASsB,EAAejnD,EAAQknD,EAAQloD,EAAM+B,GAC5C,IAAI42B,EAAMnqB,EAAM05C,EAAOtnD,KAAK0pB,MAK5B,GAJkB,mBAAP9b,IAAqBA,EAAMA,EAAIxO,GAAM,WAC9C,OAAK24B,EACDA,EAAK33B,OAAiB23B,EAAK33B,OAAOsmD,eAAe3uB,QAArD,EADoB52B,OAGjBmmD,EAAOtnD,KAAKC,KAAK4oD,IAAK,CACzB,GAAoB,GAAhBj7C,EAAInH,SAAe,CACrB,IAAInB,EAAOuM,SAASgS,cAAc,QAClCve,EAAKwe,YAAYlW,GACjBA,EAAMtI,EAERsI,EAAIqxC,iBAAkB,EACtBrxC,EAAIk7C,UAAUja,IAAI,sBAEpBkX,EAASl8C,KAAKqB,KAAM9K,EAAQwoD,EAASh7C,EAAK,MAC1C1C,KAAKo8C,OAASA,EACdvvB,EAAO7sB,KAGJ66C,IAAWsB,EAAe75C,UAAYu4C,GAC3CsB,EAAe19C,UAAYD,OAAOlE,OAAQugD,GAAYA,EAASp8C,WAC/D09C,EAAe19C,UAAUI,YAAcs9C,EAEvC,IAAI1rB,EAAuB,CAAEyqB,QAAS,CAAEhtB,cAAc,IA0BtD,OAxBAiuB,EAAe19C,UAAU08C,cAAgB,SAAwBiB,GAC/D,OAnbY,GAmbLp8C,KAAK+6C,OAAsBqB,EAAOtnD,KAAK0S,GAAGxH,KAAKo8C,OAAOtnD,OAG/DqnD,EAAe19C,UAAU4e,UAAY,WAAwB,MAAO,CAAC4jB,QAAQ,IAE7Ekb,EAAe19C,UAAUimB,UAAY,SAAoBla,GACvD,IAAIqzC,EAAO79C,KAAKo8C,OAAOrnD,KAAK2vB,UAC5B,QAAOm5B,GAAOA,EAAKrzC,IAGrB2xC,EAAe19C,UAAUkmB,eAAiB,SAAyB6B,GACjE,MAAwB,aAAjBA,EAAS1xB,MAAuBkL,KAAKo8C,OAAOrnD,KAAK+oD,iBAG1D3B,EAAe19C,UAAU+c,QAAU,WACjCxb,KAAKo8C,OAAOtnD,KAAK0mB,QAAQxb,KAAK0C,KAC9Bm4C,EAASp8C,UAAU+c,QAAQ7c,KAAKqB,OAGlCywB,EAAqByqB,QAAQxuB,IAAM,WAAc,OAAO,GAExDluB,OAAO+wB,iBAAkB4sB,EAAe19C,UAAWgyB,GAE5C0rB,EAnDyB,CAoDhCtB,GAEEkD,EAAoC,SAAUlD,GAChD,SAASkD,EAAoB7oD,EAAQwN,EAAKs7C,EAASh9C,GACjD65C,EAASl8C,KAAKqB,KAAM9K,EAAQwoD,EAASh7C,EAAK,MAC1C1C,KAAKg+C,QAAUA,EACfh+C,KAAKgB,KAAOA,EAGT65C,IAAWkD,EAAoBz7C,UAAYu4C,GAChDkD,EAAoBt/C,UAAYD,OAAOlE,OAAQugD,GAAYA,EAASp8C,WACpEs/C,EAAoBt/C,UAAUI,YAAck/C,EAE5C,IAAIvrB,EAAuB,CAAEp9B,KAAM,CAAE84B,cAAc,IAmBnD,OAjBAsE,EAAqBp9B,KAAKs3B,IAAM,WAAc,OAAO1sB,KAAKgB,KAAK3G,QAE/D0jD,EAAoBt/C,UAAUg9C,gBAAkB,SAA0B/4C,EAAKgD,GAC7E,OAAIhD,GAAO1C,KAAKg+C,QAAkBh+C,KAAK44C,YAAclzC,EAAS1F,KAAK5K,KAAO,GACnE4K,KAAK44C,WAAalzC,GAG3Bq4C,EAAoBt/C,UAAUs6C,WAAa,SAAqB9iD,GAC9D,MAAO,CAACK,KAAM0J,KAAKg+C,QAASt4C,OAAQzP,IAGtC8nD,EAAoBt/C,UAAUkmB,eAAiB,SAAyBs5B,GACtE,MAAoB,kBAAbA,EAAInpD,MAA4BmpD,EAAIvpD,OAAO2rC,WAAa4d,EAAIC,UAGrE1/C,OAAO+wB,iBAAkBwuB,EAAoBt/C,UAAW+zB,GAEjDurB,EA9B8B,CA+BrClD,GAOEsD,EAA6B,SAAUtD,GACzC,SAASsD,EAAajpD,EAAQsQ,EAAM9C,EAAKmiB,GACvCg2B,EAASl8C,KAAKqB,KAAM9K,EAAQ,GAAIwN,EAAKmiB,GACrC7kB,KAAKwF,KAAOA,EA2Cd,OAxCKq1C,IAAWsD,EAAa77C,UAAYu4C,GACzCsD,EAAa1/C,UAAYD,OAAOlE,OAAQugD,GAAYA,EAASp8C,WAC7D0/C,EAAa1/C,UAAUI,YAAcs/C,EAErCA,EAAa7jD,OAAS,SAAiBpF,EAAQsQ,EAAM0Y,EAAQhqB,GAC3D,IAAIkqD,EAASlqD,EAAKqtB,UAAU/b,EAAK1Q,KAAKmL,MAClClL,EAAOqpD,GAAUA,EAAO54C,EAAMtR,EAAMgqB,GAGxC,OAFKnpB,GAASA,EAAK2N,MACf3N,EAAO,gBAAyB4R,SAAUnB,EAAK1Q,KAAKC,KAAKypB,MAAMhZ,EAAM0Y,KAClE,IAAIigC,EAAajpD,EAAQsQ,EAAMzQ,EAAK2N,IAAK3N,EAAK8vB,YAAc9vB,EAAK2N,MAG1Ey7C,EAAa1/C,UAAU4e,UAAY,WACjC,OAtgBgE,EAsgB3Drd,KAAK+6C,OAAuB/6C,KAAKwF,KAAK1Q,KAAKC,KAAKspD,cAAwB,KACtE,CAAC74C,KAAMxF,KAAKwF,KAAK1Q,KAAKmL,KAAMzE,MAAOwE,KAAKwF,KAAKhK,MAAOwmC,eAAgBhiC,KAAK6kB,aAGlFs5B,EAAa1/C,UAAU28C,YAAc,SAAsB51C,GAAQ,OA1gBD,GA0gBQxF,KAAK+6C,OAAuB/6C,KAAKwF,KAAKgC,GAAGhC,IAEnH24C,EAAa1/C,UAAU6+C,UAAY,SAAoB3nD,EAAMD,GAG3D,GAFAmlD,EAASp8C,UAAU6+C,UAAU3+C,KAAKqB,KAAMrK,EAAMD,GA7gBlC,GA+gBRsK,KAAK+6C,MAAoB,CAE3B,IADA,IAAI7lD,EAAS8K,KAAK9K,QACVA,EAAOoB,MAAQpB,EAASA,EAAOA,OACnCA,EAAO6lD,MAAQ/6C,KAAK+6C,QAAS7lD,EAAO6lD,MAAQ/6C,KAAK+6C,OACrD/6C,KAAK+6C,MAnhBK,IAuhBdoD,EAAa1/C,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIxB,GACvD,IAAIqG,EAAO4jD,EAAa7jD,OAAO0F,KAAK9K,OAAQ8K,KAAKwF,MAAM,EAAMtR,GACzDyN,EAAQ3B,KAAK86C,SAAU1lD,EAAO4K,KAAK5K,KACnCM,EAAKN,IAAQuM,EAAQ28C,GAAa38C,EAAOjM,EAAIN,EAAMlB,IACnDyB,EAAO,IAAKgM,EAAQ28C,GAAa38C,EAAO,EAAGhM,EAAMzB,IACrD,IAAK,IAAI+C,EAAI,EAAGA,EAAI0K,EAAMtH,OAAQpD,IAAO0K,EAAM1K,GAAG/B,OAASqF,EAE3D,OADAA,EAAKugD,SAAWn5C,EACTpH,GAGF4jD,EA9CuB,CA+C9BtD,GAKE0D,EAA6B,SAAU1D,GACzC,SAAS0D,EAAarpD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKmiB,EAAYm3B,EAAS9nD,EAAM+B,GACxF4kD,EAASl8C,KAAKqB,KAAM9K,EAAQoB,EAAKmwB,OAASi3B,EAAU,GAAIh7C,EAAKmiB,GAC7D7kB,KAAKg8C,QAAUA,EACfh8C,KAAK1J,KAAOA,EACZ0J,KAAKw+C,UAAYA,EACjBx+C,KAAKy+C,UAAYA,EACb55B,GAAc7kB,KAAK0+C,eAAexqD,EAAM+B,GAGzC4kD,IAAW0D,EAAaj8C,UAAYu4C,GACzC0D,EAAa9/C,UAAYD,OAAOlE,OAAQugD,GAAYA,EAASp8C,WAC7D8/C,EAAa9/C,UAAUI,YAAc0/C,EAErC,IAAI5qB,EAAuB,CAAEv+B,KAAM,CAAE84B,cAAc,GAAO2qB,OAAQ,CAAE3qB,cAAc,GAAOgtB,QAAS,CAAEhtB,cAAc,IAqNlH,OA1MAqwB,EAAajkD,OAAS,SAAiBpF,EAAQoB,EAAMkoD,EAAWC,EAAWvqD,EAAM+B,GAC/E,IAAImJ,EAEyCu/C,EAAzCP,EAASlqD,EAAKqtB,UAAUjrB,EAAKxB,KAAKmL,MAClClL,EAAOqpD,GAAUA,EAAO9nD,EAAMpC,GAAM,WAGtC,OAAKyqD,EACDA,EAAQzpD,OAAiBypD,EAAQzpD,OAAOsmD,eAAemD,QAA3D,EADuB1oD,IAEtBuoD,EAAWC,GAEV/7C,EAAM3N,GAAQA,EAAK2N,IAAKmiB,EAAa9vB,GAAQA,EAAK8vB,WACtD,GAAIvuB,EAAK8K,OACP,GAAKsB,GACA,GAAoB,GAAhBA,EAAInH,SAAiB,MAAM,IAAIozB,WAAW,iDADvCjsB,EAAMiE,SAASg7B,eAAerrC,EAAK0K,WAErC0B,IAC2DA,GAAzEtD,EAAS,gBAAyBuH,SAAUrQ,EAAKxB,KAAKC,KAAKypB,MAAMloB,KAAqBoM,IAAKmiB,EAAazlB,EAAOylB,YAExGA,GAAevuB,EAAK8K,QAA0B,MAAhBsB,EAAIi8B,WAChCj8B,EAAIk8C,aAAa,qBAAsBl8C,EAAIqxC,iBAAkB,GAC9Dz9C,EAAKxB,KAAKC,KAAKspB,YAAa3b,EAAI2b,WAAY,IAGlD,IAAI29B,EAAUt5C,EAGd,OAFAA,EAAMm8C,GAAen8C,EAAK87C,EAAWloD,GAEjCvB,EACO4pD,EAAU,IAAIG,GAAmB5pD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKmiB,EAAYm3B,EACvDjnD,EAAMb,EAAM+B,EAAM,GACnDK,EAAK8K,OACH,IAAI29C,EAAa7pD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKs5C,EAAS9nD,GAEnE,IAAIqqD,EAAarpD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKmiB,EAAYm3B,EAAS9nD,EAAM+B,EAAM,IAGxGsoD,EAAa9/C,UAAU4e,UAAY,WACjC,IAAI+c,EAASp6B,KAGb,GAAIA,KAAK1J,KAAKxB,KAAKC,KAAKspD,cAAiB,OAAO,KAKhD,IAAI3kC,EAAO,CAACpjB,KAAM0J,KAAK1J,KAAKxB,KAAKmL,KAAMzE,MAAOwE,KAAK1J,KAAKkF,OAIxD,MAHiC,OAA7BwE,KAAK1J,KAAKxB,KAAKikC,aAAuBrf,EAAK7Q,mBAAqB,QAChE7I,KAAK6kB,aAAe7kB,KAAKi7C,YAAevhC,EAAKsoB,eAAiBhiC,KAAK6kB,WAChEnL,EAAKqoB,WAAa,WAAc,OAAO3H,EAAOvV,WAAa,WAAiBuV,EAAO9jC,KAAKnB,SACxFukB,GAGT6kC,EAAa9/C,UAAU48C,YAAc,SAAsB/kD,EAAMkoD,EAAWC,GAC1E,OApnBY,GAonBLz+C,KAAK+6C,OAAsBzkD,EAAKkR,GAAGxH,KAAK1J,OAC7C0oD,GAAcR,EAAWx+C,KAAKw+C,YAAcC,EAAUj3C,GAAGxH,KAAKy+C,YAGlE9qB,EAAqBv+B,KAAKs3B,IAAM,WAAc,OAAO1sB,KAAK1J,KAAKJ,UAE/Dy9B,EAAqBklB,OAAOnsB,IAAM,WAAc,OAAO1sB,KAAK1J,KAAKmwB,OAAS,EAAI,GAM9E83B,EAAa9/C,UAAUigD,eAAiB,SAAyBxqD,EAAM+B,GACrE,IAAImkC,EAASp6B,KAETke,EAASle,KAAK1J,KAAKsC,cAAeipB,EAAM5rB,EACxCgpD,EAAc/qD,EAAKqlB,WAAavZ,KAAKk/C,qBAAqBhrD,EAAM+B,GAChEkpD,EAAmBF,GAAeA,EAAYhpD,KAAO,EAAIgpD,EAAc,KACvEG,EAAqBH,GAAeA,EAAYhpD,IAAM,EACtDopD,EAAU,IAAIC,GAAgBt/C,KAAMm/C,GAAoBA,EAAiB7oD,OAopBjF,SAAkBpB,EAAQqqD,EAAMC,EAAUC,GACxC,IAAIC,EAASH,EAAKG,OAAOxqD,GAASwQ,EAAS,EAE3C,GAAqB,GAAjBg6C,EAAOrlD,OAAa,CACtB,IAAK,IAAIpD,EAAI,EAAGA,EAAI/B,EAAO0B,WAAYK,IAAK,CAC1C,IAAIwG,EAAQvI,EAAOuI,MAAMxG,GACzBwoD,EAAOhiD,EAAOiiD,EAAQH,EAAKI,SAASj6C,EAAQjI,GAAQxG,GACpDyO,GAAUjI,EAAMvH,SAElB,OAIF,IADA,IAAI0pD,EAAY,EAAG1oB,EAAS,GAAI2oB,EAAW,KAClCC,EAAc,IAAK,CAC1B,GAAIF,EAAYF,EAAOrlD,QAAUqlD,EAAOE,GAAWlqD,IAAMgQ,EAAQ,CAE/D,IADA,IAAI02C,EAASsD,EAAOE,KAAcG,OAAU,EACrCH,EAAYF,EAAOrlD,QAAUqlD,EAAOE,GAAWlqD,IAAMgQ,IACvDq6C,IAAYA,EAAU,CAAC3D,KAAUxhD,KAAK8kD,EAAOE,MAClD,GAAIG,EAAS,CACXA,EAAQjgC,KAAKkgC,IACb,IAAK,IAAIhlD,EAAM,EAAGA,EAAM+kD,EAAQ1lD,OAAQW,IAASwkD,EAASO,EAAQ/kD,GAAM8kD,IAAeD,QAEvFL,EAASpD,EAAQ0D,IAAeD,GAIpC,IAAII,OAAU,EAAU/oD,OAAQ,EAChC,GAAI2oD,EACF3oD,GAAS,EACT+oD,EAAUJ,EACVA,EAAW,SACN,MAAIC,EAAc5qD,EAAO0B,YAI9B,MAHAM,EAAQ4oD,EACRG,EAAU/qD,EAAOuI,MAAMqiD,KAKzB,IAAK,IAAIviD,EAAM,EAAGA,EAAM25B,EAAO78B,OAAQkD,IAAa25B,EAAO35B,GAAK7H,IAAMgQ,GAAUwxB,EAAOnK,OAAOxvB,IAAO,GACrG,KAAOqiD,EAAYF,EAAOrlD,QAAUqlD,EAAOE,GAAWjqD,MAAQ+P,GAAUg6C,EAAOE,GAAWlqD,GAAKgQ,GAC3FwxB,EAAOt8B,KAAK8kD,EAAOE,MAEvB,IAAI7mD,EAAM2M,EAASu6C,EAAQ/pD,SAC3B,GAAI+pD,EAAQ7+C,OAAQ,CAClB,IAAI8+C,EAAQnnD,EACR6mD,EAAYF,EAAOrlD,QAAUqlD,EAAOE,GAAWjqD,KAAOuqD,IAASA,EAAQR,EAAOE,GAAWjqD,MAC7F,IAAK,IAAIwqD,EAAM,EAAGA,EAAMjpB,EAAO78B,OAAQ8lD,IAAajpB,EAAOipB,GAAKzqD,GAAKwqD,IAASA,EAAQhpB,EAAOipB,GAAKzqD,IAC9FwqD,EAAQnnD,IACV8mD,EAAWI,EAAQ1xB,IAAI2xB,EAAQx6C,GAC/Bu6C,EAAUA,EAAQ1xB,IAAI,EAAG2xB,EAAQx6C,GACjC3M,EAAMmnD,EACNhpD,GAAS,GAObuoD,EAAOQ,EAHU/oB,EAAO78B,OAClB4lD,EAAQ/kD,WAAa+kD,EAAQx5B,OAASyQ,EAAOt1B,QAAO,SAAU2O,GAAK,OAAQA,EAAE2N,UAC7EgZ,EAAOzhC,QAFoBioD,EAGN6B,EAAKI,SAASj6C,EAAQu6C,GAAU/oD,GAC3DwO,EAAS3M,GA9sBTqnD,CAASpgD,KAAK1J,KAAM0J,KAAKy+C,WAAW,SAAUrC,EAAQnlD,EAAGopD,GACnDjE,EAAOrnD,KAAK4P,MACZ06C,EAAQiB,YAAYlE,EAAOrnD,KAAK4P,MAAOuZ,EAAQhqB,GAC1CkoD,EAAOtnD,KAAKyB,MAAQ,IAAM8pD,GAC/BhB,EAAQiB,YAAYrpD,GAAKmjC,EAAO9jC,KAAKM,WAAa,UAAYwjC,EAAO9jC,KAAKmH,MAAMxG,GAAG0N,MAAOuZ,EAAQhqB,GAGtGmrD,EAAQkB,YAAYnE,EAAQloD,EAAM2tB,MACjC,SAAUpkB,EAAO+gD,EAAWC,EAAWxnD,GAIxC,IAAIupD,EAFJnB,EAAQiB,YAAY7iD,EAAMkH,MAAOuZ,EAAQhqB,GAGrCmrD,EAAQoB,cAAchjD,EAAO+gD,EAAWC,EAAWxnD,IAAemoD,GAAsBlrD,EAAKP,MAAME,UAAU8B,KAAOksB,GAC7G3tB,EAAKP,MAAME,UAAU6B,GAAKmsB,EAAMpkB,EAAMvH,WACrCsqD,EAAYnB,EAAQqB,mBAAmBzB,EAAY3oD,QAAU,GAC9D+oD,EAAQsB,aAAaljD,EAAO+gD,EAAWC,EAAW+B,EAAWtsD,IAAkBmrD,EAAQuB,eAAenjD,EAAO+gD,EAAWC,EAAWvqD,EAAM+C,IAElJooD,EAAQxtB,QAAQp0B,EAAO+gD,EAAWC,EAAWvqD,EAAM2tB,GAErDA,GAAOpkB,EAAMvH,YAGfmpD,EAAQiB,YAAY5C,EAASx/B,EAAQhqB,GACjC8L,KAAK1J,KAAKK,aAAe0oD,EAAQwB,oBACrCxB,EAAQyB,eAGJzB,EAAQ0B,SApqBoC,GAoqBzB/gD,KAAK+6C,SAEtBoE,GAAoBn/C,KAAKghD,wBAAwB9sD,EAAMirD,GAC3D8B,GAAYjhD,KAAK6kB,WAAY7kB,KAAK86C,SAAU5mD,GACxCmW,EAAOsoC,KAorBjB,SAAkBjwC,GAChB,GAAoB,MAAhBA,EAAIi8B,UAAoC,MAAhBj8B,EAAIi8B,SAAkB,CAChD,IAAIuiB,EAASx+C,EAAI4a,MAAM6jC,QACvBz+C,EAAI4a,MAAM6jC,QAAUD,EAAS,kCAC7Bv+C,OAAOy+C,iBAAiB1+C,GAAK2+C,UAC7B3+C,EAAI4a,MAAM6jC,QAAUD,GAzrBAI,CAASthD,KAAK0C,OAIpC67C,EAAa9/C,UAAUygD,qBAAuB,SAA+BhrD,EAAM+B,GAGjF,IAAIa,EAAM5C,EAAKP,MAAME,UACjB8B,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GACb,OAAMxB,EAAKP,MAAME,qBAAqB,OAAkB8B,EAAOM,GAAOP,EAAKO,EAAM+J,KAAK1J,KAAKnB,QAAQC,MAAnG,CACA,IAAIqD,EAAMvE,EAAKgkD,KAAKt1C,eAChBigC,EAirBR,SAAwBvsC,EAAMoP,GAC5B,OAAS,CACP,GAAqB,GAAjBpP,EAAKiF,SAAiB,OAAOjF,EACjC,GAAqB,GAAjBA,EAAKiF,UAAiBmK,EAAS,EAAG,CACpC,GAAIpP,EAAK4rC,WAAW7nC,OAASqL,GAA8C,GAApCpP,EAAK4rC,WAAWx8B,GAAQnK,SAC3D,OAAOjF,EAAK4rC,WAAWx8B,GAE3BA,EAASxP,EADTI,EAAOA,EAAK4rC,WAAWx8B,EAAS,QAE3B,MAAqB,GAAjBpP,EAAKiF,UAAiBmK,EAASpP,EAAK4rC,WAAW7nC,QAIxD,OAAO,KAHP/D,EAAOA,EAAK4rC,WAAWx8B,GACvBA,EAAS,IA3rBI67C,CAAe9oD,EAAI6hD,UAAW7hD,EAAI+hD,aACjD,GAAK3X,GAAa7iC,KAAK0C,IAAI4Y,SAASunB,EAASnE,YAA7C,CAEA,GAAI1+B,KAAK1J,KAAKsC,cAAe,CAI3B,IAAIoI,EAAO6hC,EAASxC,UAChBmhB,EA2rBV,SAA4B9qB,EAAM11B,EAAMrL,EAAMD,GAC5C,IAAK,IAAIuB,EAAI,EAAGhB,EAAM,EAAGgB,EAAIy/B,EAAK9/B,YAAcX,GAAOP,GAAK,CAC1D,IAAI+H,EAAQi5B,EAAKj5B,MAAMxG,KAAMwqD,EAAaxrD,EAE1C,GADAA,GAAOwH,EAAMvH,SACRuH,EAAM2D,OAAX,CAEA,IADA,IAAI8xB,EAAMz1B,EAAMuD,KACT/J,EAAIy/B,EAAK9/B,YAAY,CAC1B,IAAIm8B,EAAO2D,EAAKj5B,MAAMxG,KAEtB,GADAhB,GAAO88B,EAAK78B,UACP68B,EAAK3xB,OAAU,MACpB8xB,GAAOH,EAAK/xB,KAEd,GAAI/K,GAAON,EAAM,CACf,IAAIyH,EAAQqkD,EAAa/rD,EAAKw9B,EAAI9L,YAAYpmB,EAAMtL,EAAK+rD,EAAa,IAAM,EAC5E,GAAIrkD,GAAS,GAAKA,EAAQ4D,EAAK3G,OAASonD,GAAc9rD,EAClD,OAAO8rD,EAAarkD,EACxB,GAAIzH,GAAQD,GAAMw9B,EAAI74B,QAAW3E,EAAKsL,EAAK3G,OAAUonD,GACjDvuB,EAAIz9B,MAAMC,EAAK+rD,EAAY/rD,EAAK+rD,EAAazgD,EAAK3G,SAAW2G,EAC7D,OAAOtL,IAGf,OAAQ,EAhtBUgsD,CAAmB1hD,KAAK1J,KAAKnB,QAAS6L,EAAMrL,EAAOM,EAAKP,EAAKO,GAC3E,OAAOurD,EAAU,EAAI,KAAO,CAAClrD,KAAMusC,EAAU5sC,IAAKurD,EAASxgD,KAAMA,GAEjE,MAAO,CAAC1K,KAAMusC,EAAU5sC,KAAM,MAIlCsoD,EAAa9/C,UAAUuiD,wBAA0B,SAAkC9sD,EAAM4C,GACvF,IAAIR,EAAOQ,EAAIR,KACXL,EAAMa,EAAIb,IACV+K,EAAOlK,EAAIkK,KAGf,IAAIhB,KAAK+7C,QAAQzlD,GAAjB,CAIA,IADA,IAAIynB,EAAUznB,EAERynB,EAAQ2gB,YAAc1+B,KAAK6kB,WADzB9G,EAAUA,EAAQ2gB,WAAY,CAEpC,KAAO3gB,EAAQwiB,iBAAmBxiB,EAAQ2gB,WAAWijB,YAAY5jC,EAAQwiB,iBACzE,KAAOxiB,EAAQ+iB,aAAe/iB,EAAQ2gB,WAAWijB,YAAY5jC,EAAQ+iB,aACjE/iB,EAAQi2B,aAAcj2B,EAAQi2B,WAAa,MAEjD,IAAIxM,EAAO,IAAIuW,EAAoB/9C,KAAM+d,EAASznB,EAAM0K,GACxD9M,EAAK0tD,iBAAiBhnD,KAAK4sC,GAG3BxnC,KAAK86C,SAAWwD,GAAat+C,KAAK86C,SAAU7kD,EAAKA,EAAM+K,EAAK3G,OAAQnG,EAAMszC,KAM5E+W,EAAa9/C,UAAUkuB,OAAS,SAAiBr2B,EAAMkoD,EAAWC,EAAWvqD,GAC3E,QA9tBgE,GA8tB5D8L,KAAK+6C,QACJzkD,EAAKo3B,WAAW1tB,KAAK1J,SAC1B0J,KAAK6hD,YAAYvrD,EAAMkoD,EAAWC,EAAWvqD,IACtC,IAGTqqD,EAAa9/C,UAAUojD,YAAc,SAAsBvrD,EAAMkoD,EAAWC,EAAWvqD,GACrF8L,KAAK8hD,gBAAgBtD,GACrBx+C,KAAK1J,KAAOA,EACZ0J,KAAKy+C,UAAYA,EACbz+C,KAAK6kB,YAAc7kB,KAAK0+C,eAAexqD,EAAM8L,KAAK44C,YACtD54C,KAAK+6C,MAzuBO,GA4uBdwD,EAAa9/C,UAAUqjD,gBAAkB,SAA0BtD,GACjE,IAAIQ,GAAcR,EAAWx+C,KAAKw+C,WAAlC,CACA,IAAIuD,EAAqC,GAAzB/hD,KAAKg8C,QAAQzgD,SACzBymD,EAAShiD,KAAK0C,IAClB1C,KAAK0C,IAAMu/C,GAAejiD,KAAK0C,IAAK1C,KAAKg8C,QACfkG,GAAiBliD,KAAKw+C,UAAWx+C,KAAK1J,KAAMyrD,GAC5CG,GAAiB1D,EAAWx+C,KAAK1J,KAAMyrD,IAC7D/hD,KAAK0C,KAAOs/C,IACdA,EAAOhO,WAAa,KACpBh0C,KAAK0C,IAAIsxC,WAAah0C,MAExBA,KAAKw+C,UAAYA,IAInBD,EAAa9/C,UAAU0jD,WAAa,WAClCniD,KAAKg8C,QAAQ4B,UAAUja,IAAI,6BACvB3jC,KAAK6kB,YAAe7kB,KAAK1J,KAAKxB,KAAKC,KAAKspB,YAAare,KAAK0C,IAAI2b,WAAY,IAIhFkgC,EAAa9/C,UAAU2jD,aAAe,WACpCpiD,KAAKg8C,QAAQ4B,UAAU9wB,OAAO,6BAC1B9sB,KAAK6kB,YAAe7kB,KAAK1J,KAAKxB,KAAKC,KAAKspB,WAAare,KAAK0C,IAAI2/C,gBAAgB,cAGpF1uB,EAAqBunB,QAAQxuB,IAAM,WAAc,OAAO1sB,KAAK1J,KAAKH,QAElEqI,OAAO+wB,iBAAkBgvB,EAAa9/C,UAAWk1B,GAE1C4qB,EAnOuB,CAoO9B1D,GAIF,SAASyH,EAAY/sD,EAAKipD,EAAWC,EAAW/7C,EAAKxO,GAEnD,OADA2qD,GAAen8C,EAAK87C,EAAWjpD,GACxB,IAAIgpD,EAAa,KAAMhpD,EAAKipD,EAAWC,EAAW/7C,EAAKA,EAAKA,EAAKxO,EAAM,GAGhF,IAAI6qD,EAA6B,SAAUR,GACzC,SAASQ,EAAa7pD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKs5C,EAAS9nD,GACtEqqD,EAAa5/C,KAAKqB,KAAM9K,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAK,KAAMs5C,EAAS9nD,GAG7EqqD,IAAeQ,EAAaz8C,UAAYi8C,GAC7CQ,EAAatgD,UAAYD,OAAOlE,OAAQikD,GAAgBA,EAAa9/C,WACrEsgD,EAAatgD,UAAUI,YAAckgD,EAErC,IAAIlqB,EAAuB,CAAEqmB,QAAS,CAAEhtB,cAAc,IAuDtD,OArDA6wB,EAAatgD,UAAU4e,UAAY,WAEjC,IADA,IAAI8jB,EAAOnhC,KAAKg8C,QAAQtd,WACjByC,GAAQA,GAAQnhC,KAAK0C,MAAQy+B,EAAKohB,UAAYphB,EAAOA,EAAKzC,WACjE,MAAO,CAACyC,KAAMA,IAAQ,IAGxB4d,EAAatgD,UAAUkuB,OAAS,SAAiBr2B,EAAMkoD,EAAW50B,EAAG11B,GACnE,QAtyBgE,GAsyB5D8L,KAAK+6C,OAtyBG,GAsyBqB/6C,KAAK+6C,QAAuB/6C,KAAKwiD,aAC7DlsD,EAAKo3B,WAAW1tB,KAAK1J,SAC1B0J,KAAK8hD,gBAAgBtD,GAxyBT,GAyyBPx+C,KAAK+6C,OAAsBzkD,EAAK0K,MAAQhB,KAAK1J,KAAK0K,MAAS1K,EAAK0K,MAAQhB,KAAKg8C,QAAQ3b,YACxFrgC,KAAKg8C,QAAQ3b,UAAY/pC,EAAK0K,KAC1B9M,EAAKuuD,aAAeziD,KAAKg8C,UAAW9nD,EAAKuuD,YAAc,OAE7DziD,KAAK1J,KAAOA,EACZ0J,KAAK+6C,MA9yBO,GA+yBL,IAGTgE,EAAatgD,UAAU+jD,SAAW,WAEhC,IADA,IAAIE,EAAY1iD,KAAK9K,OAAO2vB,WACnBhU,EAAI7Q,KAAKg8C,QAASnrC,EAAGA,EAAIA,EAAE6tB,WAAc,GAAI7tB,GAAK6xC,EAAa,OAAO,EAC/E,OAAO,GAGT3D,EAAatgD,UAAUs6C,WAAa,SAAqB9iD,GACvD,MAAO,CAACK,KAAM0J,KAAKg8C,QAASt2C,OAAQzP,IAGtC8oD,EAAatgD,UAAUg9C,gBAAkB,SAA0B/4C,EAAKgD,EAAQyD,GAC9E,OAAIzG,GAAO1C,KAAKg8C,QAAkBh8C,KAAK44C,WAAav3C,KAAKc,IAAIuD,EAAQ1F,KAAK1J,KAAK0K,KAAK3G,QAC7EkkD,EAAa9/C,UAAUg9C,gBAAgB98C,KAAKqB,KAAM0C,EAAKgD,EAAQyD,IAGxE41C,EAAatgD,UAAUkmB,eAAiB,SAAyB6B,GAC/D,MAAwB,iBAAjBA,EAAS1xB,MAA4C,aAAjB0xB,EAAS1xB,MAGtDiqD,EAAatgD,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIxB,GACvD,IAAIoC,EAAO0J,KAAK1J,KAAKi4B,IAAI54B,EAAMD,GAAKgN,EAAMiE,SAASg7B,eAAerrC,EAAK0K,MACvE,OAAO,IAAI+9C,EAAa/+C,KAAK9K,OAAQoB,EAAM0J,KAAKw+C,UAAWx+C,KAAKy+C,UAAW/7C,EAAKA,EAAKxO,IAGvF6qD,EAAatgD,UAAU6+C,UAAY,SAAoB3nD,EAAMD,GAC3D6oD,EAAa9/C,UAAU6+C,UAAU3+C,KAAKqB,KAAMrK,EAAMD,GAC9CsK,KAAK0C,KAAO1C,KAAKg8C,SAAoB,GAARrmD,GAAaD,GAAMsK,KAAKg8C,QAAQ3b,UAAUhmC,SACvE2F,KAAK+6C,MA70BuD,IAg1BlElmB,EAAqBqmB,QAAQxuB,IAAM,WAAc,OAAO,GAExDluB,OAAO+wB,iBAAkBwvB,EAAatgD,UAAWo2B,GAE1CkqB,EAhEuB,CAiE9BR,GAIErC,GAAqC,SAAUrB,GACjD,SAASqB,IACPrB,EAAS3lC,MAAMlV,KAAMjE,WAGlB8+C,IAAWqB,EAAqB55C,UAAYu4C,GACjDqB,EAAqBz9C,UAAYD,OAAOlE,OAAQugD,GAAYA,EAASp8C,WACrEy9C,EAAqBz9C,UAAUI,YAAcq9C,EAE7C,IAAIpjB,EAAuB,CAAEoiB,QAAS,CAAEhtB,cAAc,GAAOsrB,gBAAiB,CAAEtrB,cAAc,IAS9F,OAPAguB,EAAqBz9C,UAAU4e,UAAY,WAAwB,MAAO,CAAC4jB,QAAQ,IACnFib,EAAqBz9C,UAAU68C,YAAc,SAAsB3c,GAAY,OAr2BjE,GAq2BwE3+B,KAAK+6C,OAAsB/6C,KAAK0C,IAAIi8B,UAAYA,GACtI7F,EAAqBoiB,QAAQxuB,IAAM,WAAc,OAAO,GACxDoM,EAAqB0gB,gBAAgB9sB,IAAM,WAAc,MAA4B,OAArB1sB,KAAK0C,IAAIi8B,UAEzEngC,OAAO+wB,iBAAkB2sB,EAAqBz9C,UAAWq6B,GAElDojB,EAlB+B,CAmBtCrB,GAKEiE,GAAmC,SAAUP,GAC/C,SAASO,EAAmB5pD,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKmiB,EAAYm3B,EAASjnD,EAAMb,EAAM+B,GACpGsoD,EAAa5/C,KAAKqB,KAAM9K,EAAQoB,EAAMkoD,EAAWC,EAAW/7C,EAAKmiB,EAAYm3B,EAAS9nD,EAAM+B,GAC5F+J,KAAKjL,KAAOA,EAiDd,OA9CKwpD,IAAeO,EAAmBx8C,UAAYi8C,GACnDO,EAAmBrgD,UAAYD,OAAOlE,OAAQikD,GAAgBA,EAAa9/C,WAC3EqgD,EAAmBrgD,UAAUI,YAAcigD,EAK3CA,EAAmBrgD,UAAUkuB,OAAS,SAAiBr2B,EAAMkoD,EAAWC,EAAWvqD,GACjF,GA/3BgE,GA+3B5D8L,KAAK+6C,MAAuB,OAAO,EACvC,GAAI/6C,KAAKjL,KAAK43B,OAAQ,CACpB,IAAItiB,EAASrK,KAAKjL,KAAK43B,OAAOr2B,EAAMkoD,EAAWC,GAE/C,OADIp0C,GAAUrK,KAAK6hD,YAAYvrD,EAAMkoD,EAAWC,EAAWvqD,GACpDmW,EACF,SAAKrK,KAAK6kB,aAAevuB,EAAKmwB,SAG5B83B,EAAa9/C,UAAUkuB,OAAOhuB,KAAKqB,KAAM1J,EAAMkoD,EAAWC,EAAWvqD,IAIhF4qD,EAAmBrgD,UAAU0jD,WAAa,WACxCniD,KAAKjL,KAAKotD,WAAaniD,KAAKjL,KAAKotD,aAAe5D,EAAa9/C,UAAU0jD,WAAWxjD,KAAKqB,OAGzF8+C,EAAmBrgD,UAAU2jD,aAAe,WAC1CpiD,KAAKjL,KAAKqtD,aAAepiD,KAAKjL,KAAKqtD,eAAiB7D,EAAa9/C,UAAU2jD,aAAazjD,KAAKqB,OAG/F8+C,EAAmBrgD,UAAU5I,aAAe,SAAuBkvC,EAAQvH,EAAM0a,EAAM0E,GACrF58C,KAAKjL,KAAKc,aAAemK,KAAKjL,KAAKc,aAAakvC,EAAQvH,EAAM0a,GAC1DqG,EAAa9/C,UAAU5I,aAAa8I,KAAKqB,KAAM+kC,EAAQvH,EAAM0a,EAAM0E,IAGzEkC,EAAmBrgD,UAAU+c,QAAU,WACjCxb,KAAKjL,KAAKymB,SAAWxb,KAAKjL,KAAKymB,UACnC+iC,EAAa9/C,UAAU+c,QAAQ7c,KAAKqB,OAGtC8+C,EAAmBrgD,UAAUimB,UAAY,SAAoBla,GAC3D,QAAOxK,KAAKjL,KAAK2vB,WAAY1kB,KAAKjL,KAAK2vB,UAAUla,IAGnDs0C,EAAmBrgD,UAAUkmB,eAAiB,SAAyB6B,GACrE,OAAOxmB,KAAKjL,KAAK4vB,eAAiB3kB,KAAKjL,KAAK4vB,eAAe6B,GAAY+3B,EAAa9/C,UAAUkmB,eAAehmB,KAAKqB,KAAMwmB,IAGnHs4B,EApD6B,CAqDpCP,GAMF,SAAS0C,GAAYyB,EAAWC,EAAOzuD,GAErC,IADA,IAAIwO,EAAMggD,EAAUjsD,WAAYmsD,GAAU,EACjC3rD,EAAI,EAAGA,EAAI0rD,EAAMtoD,OAAQpD,IAAK,CACrC,IAAIuwC,EAAOmb,EAAM1rD,GAAI4rD,EAAWrb,EAAK9kC,IACrC,GAAImgD,EAASnkB,YAAcgkB,EAAW,CACpC,KAAOG,GAAYngD,GAAOA,EAAMogD,GAAGpgD,GAAMkgD,GAAU,EACnDlgD,EAAMA,EAAIo+B,iBAEV8hB,GAAU,EACVF,EAAUK,aAAaF,EAAUngD,GAEnC,GAAI8kC,aAAgB2W,EAAc,CAChC,IAAIloD,EAAMyM,EAAMA,EAAI69B,gBAAkBmiB,EAAUhsD,UAChDuqD,GAAYzZ,EAAK3iB,WAAY2iB,EAAKsT,SAAU5mD,GAC5CwO,EAAMzM,EAAMA,EAAI6qC,YAAc4hB,EAAUjsD,YAG5C,KAAOiM,GAAOA,EAAMogD,GAAGpgD,GAAMkgD,GAAU,EACnCA,GAAW1uD,EAAKuuD,aAAeC,IAAaxuD,EAAKuuD,YAAc,MAGrE,SAASO,GAAerkB,GAClBA,IAAY3+B,KAAK2+B,SAAWA,GAElCqkB,GAAevkD,UAAYD,OAAOlE,OAAO,MAEzC,IAAI2oD,GAAS,CAAC,IAAID,IAElB,SAASd,GAAiB1D,EAAWloD,EAAMyrD,GACzC,GAAwB,GAApBvD,EAAUnkD,OAAe,OAAO4oD,GAIpC,IAFA,IAAIp4B,EAAMk3B,EAAYkB,GAAO,GAAK,IAAID,GAAgB34C,EAAS,CAACwgB,GAEvD5zB,EAAI,EAAGA,EAAIunD,EAAUnkD,OAAQpD,IAAK,CACzC,IAAIuE,EAAQgjD,EAAUvnD,GAAGnC,KAAK0G,MAC9B,GAAKA,EAIL,IAAK,IAAIyE,KAHLzE,EAAMmjC,UACNt0B,EAAOzP,KAAKiwB,EAAM,IAAIm4B,GAAexnD,EAAMmjC,WAE9BnjC,EAAO,CACtB,IAAIk3B,EAAMl3B,EAAMyE,GACL,MAAPyyB,IACAqvB,GAA8B,GAAjB13C,EAAOhQ,QACpBgQ,EAAOzP,KAAKiwB,EAAM,IAAIm4B,GAAe1sD,EAAK4E,SAAW,OAAS,QACtD,SAAR+E,EAAmB4qB,EAAIq4B,OAASr4B,EAAIq4B,MAAQr4B,EAAIq4B,MAAQ,IAAM,IAAMxwB,EACvD,SAARzyB,EAAmB4qB,EAAIvN,OAASuN,EAAIvN,MAAQuN,EAAIvN,MAAQ,IAAM,IAAMoV,EAC5D,YAARzyB,IAAsB4qB,EAAI5qB,GAAQyyB,KAI/C,OAAOroB,EAGT,SAAS43C,GAAekB,EAAUnH,EAASoH,EAAcC,GAEvD,GAAID,GAAgBH,IAAUI,GAAeJ,GAAU,OAAOjH,EAG9D,IADA,IAAIsH,EAAStH,EACJ/kD,EAAI,EAAGA,EAAIosD,EAAYhpD,OAAQpD,IAAK,CAC3C,IAAIsoD,EAAO8D,EAAYpsD,GAAIijB,EAAOkpC,EAAansD,GAC/C,GAAIA,EAAG,CACL,IAAI/B,OAAS,EACTglB,GAAQA,EAAKykB,UAAY4gB,EAAK5gB,UAAY2kB,GAAUH,IACnDjuD,EAASouD,EAAO5kB,aAAexpC,EAAO2wB,QAAQ+Y,eAAiB2gB,EAAK5gB,YAGvEzpC,EAASyR,SAASgS,cAAc4mC,EAAK5gB,WAC9B4jB,UAAW,EAClBrtD,EAAO0jB,YAAY0qC,GACnBppC,EAAO+oC,GAAO,IALdK,EAASpuD,EASbquD,GAAgBD,EAAQppC,GAAQ+oC,GAAO,GAAI1D,GAE7C,OAAO+D,EAGT,SAASC,GAAgB7gD,EAAKwX,EAAMkc,GAClC,IAAK,IAAIn2B,KAAQia,EACD,SAARja,GAA2B,SAARA,GAA2B,YAARA,GAAwBA,KAAQm2B,GACxE1zB,EAAI2/C,gBAAgBpiD,GAC1B,IAAK,IAAIo7B,KAAUjF,EACD,SAAViF,GAA+B,SAAVA,GAA+B,YAAVA,GAAwBjF,EAAIiF,IAAWnhB,EAAKmhB,IACxF34B,EAAIsgB,aAAaqY,EAAQjF,EAAIiF,IACnC,GAAInhB,EAAKgpC,OAAS9sB,EAAI8sB,MAAO,CAG3B,IAFA,IAAIM,EAAWtpC,EAAKgpC,MAAQhpC,EAAKgpC,MAAMlqD,MAAM,KAAK4I,OAAO6hD,SAAW/F,EAChEgG,EAAUttB,EAAI8sB,MAAQ9sB,EAAI8sB,MAAMlqD,MAAM,KAAK4I,OAAO6hD,SAAW/F,EACxDzmD,EAAI,EAAGA,EAAIusD,EAASnpD,OAAQpD,KAA4C,GAAjCysD,EAAQvjC,QAAQqjC,EAASvsD,KACrEyL,EAAIk7C,UAAU9wB,OAAO02B,EAASvsD,IAClC,IAAK,IAAI+D,EAAM,EAAGA,EAAM0oD,EAAQrpD,OAAQW,KAAgD,GAAnCwoD,EAASrjC,QAAQujC,EAAQ1oD,KAC1E0H,EAAIk7C,UAAUja,IAAI+f,EAAQ1oD,IACF,GAAxB0H,EAAIk7C,UAAUvjD,QACdqI,EAAI2/C,gBAAgB,SAE1B,GAAInoC,EAAKoD,OAAS8Y,EAAI9Y,MAAO,CAC3B,GAAIpD,EAAKoD,MAEP,IADA,IAA4FkX,EAAxFjoB,EAAO,gFACJioB,EAAIjoB,EAAKoN,KAAKO,EAAKoD,QACtB5a,EAAI4a,MAAMqmC,eAAenvB,EAAE,IAE7B4B,EAAI9Y,QACJ5a,EAAI4a,MAAM6jC,SAAW/qB,EAAI9Y,QAIjC,SAASuhC,GAAen8C,EAAK68C,EAAMjpD,GACjC,OAAO2rD,GAAev/C,EAAKA,EAAKugD,GAAQf,GAAiB3C,EAAMjpD,EAAsB,GAAhBoM,EAAInH,WAI3E,SAASyjD,GAAcx+B,EAAGrE,GACxB,GAAIqE,EAAEnmB,QAAU8hB,EAAE9hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIupB,EAAEnmB,OAAQpD,IAAO,IAAKupB,EAAEvpB,GAAGnC,KAAK0S,GAAG2U,EAAEllB,GAAGnC,MAAS,OAAO,EAC5E,OAAO,EAIT,SAASguD,GAAGpgD,GACV,IAAIqwB,EAAOrwB,EAAIo+B,YAEf,OADAp+B,EAAIg8B,WAAWijB,YAAYj/C,GACpBqwB,EAKT,IAAIusB,GAAkB,SAAyBz0B,EAAK+4B,GAClD5jD,KAAK6qB,IAAMA,EACX7qB,KAAK6jD,KAAOD,EAGZ5jD,KAAK9I,MAAQ,EAGb8I,KAAKq2C,MAAQ,GAEbr2C,KAAK+gD,SAAU,EAEf/gD,KAAK8jD,SA4LP,SAAkBptB,EAAMqtB,GACtB,IAAIC,EAAUD,EAAYE,EAAQD,EAAQlJ,SAASzgD,OAC/C6pD,EAAKxtB,EAAK9/B,WAAY4iB,EAAU,IAAI2qC,IAAKtpC,EAAU,GACvD0xB,EAAO,KAAO2X,EAAK,GAAG,CAEpB,IADA,IAAI1c,OAAO,IAET,GAAIyc,EAAO,CACT,IAAIlxB,EAAOixB,EAAQlJ,SAASmJ,EAAQ,GACpC,KAAIlxB,aAAgBorB,GAGb,CACL3W,EAAOzU,EACPkxB,IACA,MALAD,EAAUjxB,EACVkxB,EAAQlxB,EAAK+nB,SAASzgD,WAMnB,IAAI2pD,GAAWD,EACpB,MAAMxX,EAGN0X,EAAQD,EAAQ9uD,OAAO4lD,SAAS36B,QAAQ6jC,GACxCA,EAAUA,EAAQ9uD,OAGtB,IAAIoB,EAAOkxC,EAAKlxC,KAChB,GAAKA,EAAL,CACA,GAAIA,GAAQogC,EAAKj5B,MAAMymD,EAAK,GAAM,QAChCA,EACF1qC,EAAQsW,IAAI0X,EAAM0c,GAClBrpC,EAAQjgB,KAAK4sC,IAEf,MAAO,CAACtwC,MAAOgtD,EAAI1qC,QAASA,EAASqB,QAASA,EAAQ7C,WA3NtC8rC,CAASj5B,EAAIv0B,KAAKnB,QAAS01B,IA8N7C,SAASm1B,GAAYx/B,EAAGrE,GAAK,OAAOqE,EAAE1rB,KAAKyB,KAAO4lB,EAAErnB,KAAKyB,KAgIzD,SAAS+nD,GAAa38C,EAAOhM,EAAMD,EAAIxB,EAAMigC,GAE3C,IADA,IAAI9pB,EAAS,GACJpT,EAAI,EAAG4qB,EAAM,EAAG5qB,EAAI0K,EAAMtH,OAAQpD,IAAK,CAC9C,IAAIwG,EAAQkE,EAAM1K,GAAIkE,EAAQ0mB,EAAK9oB,EAAM8oB,GAAOpkB,EAAMrI,KAClD+F,GAASzF,GAAMqD,GAAOpD,EACxB0U,EAAOzP,KAAK6C,IAERtC,EAAQxF,GAAQ0U,EAAOzP,KAAK6C,EAAMhI,MAAM,EAAGE,EAAOwF,EAAOjH,IACzDigC,IACF9pB,EAAOzP,KAAKu5B,GACZA,EAAc,MAEZp7B,EAAMrD,GAAM2U,EAAOzP,KAAK6C,EAAMhI,MAAMC,EAAKyF,EAAOsC,EAAMrI,KAAMlB,KAGpE,OAAOmW,EAGT,SAAS+5C,GAAiBlwD,EAAMmwD,GAC9B,IAAInQ,EAAShgD,EAAKgkD,KAAKt1C,eAAgBrN,EAAMrB,EAAKP,MAAM4B,IACxD,IAAK2+C,EAAOoG,UAAa,OAAO,KAChC,IAAIhC,EAAcpkD,EAAKkwB,QAAQk0B,YAAYpE,EAAOoG,WAAYgK,EAAWhM,GAAmC,GAApBA,EAAYljD,KAChGooC,EAAOtpC,EAAKkwB,QAAQq0B,WAAWvE,EAAOoG,UAAWpG,EAAOsG,aAC5D,GAAIhd,EAAO,EAAK,OAAO,KACvB,IAA+BhmC,EAAS3D,EAApCkD,EAAQxB,EAAIO,QAAQ0nC,GACxB,GAAIyW,EAAmBC,GAAS,CAE9B,IADA18C,EAAUT,EACHuhD,IAAgBA,EAAYhiD,MAAQgiD,EAAcA,EAAYpjD,OACrE,GAAIojD,GAAeA,EAAYhiD,KAAKH,QAAU,kBAA2BmiD,EAAYhiD,OAASgiD,EAAYpjD,UACjGojD,EAAYhiD,KAAK4E,WAhgE9B,SAAkB5E,EAAMoP,EAAQxQ,GAC9B,IAAK,IAAIgJ,EAAoB,GAAVwH,EAAavM,EAAQuM,GAAUxP,EAASI,GAAO4H,GAAW/E,GAAQ,CACnF,GAAI7C,GAAQpB,EAAU,OAAO,EAC7B,IAAIgC,EAAQ+7C,EAAS38C,GAErB,KADAA,EAAOA,EAAKooC,YACC,OAAO,EACpBxgC,EAAUA,GAAoB,GAAThH,EACrBiC,EAAQA,GAASjC,GAAShB,EAASI,IAy/DGiuD,CAASrQ,EAAOoG,UAAWpG,EAAOsG,YAAalC,EAAY51C,MAAO,CACtG,IAAIzM,EAAMqiD,EAAYC,UACtB1kD,EAAY,IAAI,KAAc2pC,GAAQvnC,EAAMc,EAAQxB,EAAIO,QAAQG,SAE7D,CACL,IAAI8uC,EAAS7wC,EAAKkwB,QAAQq0B,WAAWvE,EAAO+I,WAAY/I,EAAOgJ,cAC/D,GAAInY,EAAS,EAAK,OAAO,KACzBvtC,EAAUjC,EAAIO,QAAQivC,GAGnBlxC,IAEHA,EAAY2wD,GAAiBtwD,EAAMsD,EAAST,EADvB,WAAVstD,GAAwBnwD,EAAKP,MAAME,UAAU2pC,KAAOzmC,EAAMd,MAAQquD,EAAY,GAAK,IAGhG,OAAOzwD,EAGT,SAAS4wD,GAAoBvwD,GAC3B,OAAOA,EAAK0gB,SAAW1gB,EAAKoT,WAC1Bo9C,GAAaxwD,IAASyS,SAASizC,eAAiBjzC,SAASizC,cAAct+B,SAASpnB,EAAKwO,KAGzF,SAASiiD,GAAezwD,EAAM0oD,GAC5B,IAAInkD,EAAMvE,EAAKP,MAAME,UAGrB,GAFA+wD,GAAkB1wD,EAAMuE,GAEnBgsD,GAAoBvwD,GAAzB,CAKA,IAAK0oD,GAAS1oD,EAAK2wD,WAAa3wD,EAAK2wD,UAAUC,cAAgBz6C,EAAO+gB,OAAQ,CAC5E,IAAI8oB,EAAShgD,EAAKgkD,KAAKt1C,eAAgBmiD,EAAS7wD,EAAK8wD,YAAYC,iBACjE,GAAI/Q,EAAO+I,YAAcxJ,EAAqBS,EAAO+I,WAAY/I,EAAOgJ,aAC1B6H,EAAO9H,WAAY8H,EAAO7H,cAGtE,OAFAhpD,EAAK2wD,UAAUK,sBAAuB,OACtChxD,EAAK8wD,YAAYG,kBAOrB,GAFAjxD,EAAK8wD,YAAYI,sBAEblxD,EAAKmxD,eA2EX,SAA6BnxD,GAC3B,IAAIggD,EAAShgD,EAAKgkD,KAAKt1C,eAAgBpO,EAAQmS,SAAS2sC,cACpDh9C,EAAOpC,EAAKmxD,cAAc3iD,IAAK4iD,EAAuB,OAAjBhvD,EAAKqoC,SAC1C2mB,EAAO9wD,EAAM++C,OAAOj9C,EAAKooC,WAAYuU,EAAS38C,GAAQ,GACnD9B,EAAM++C,OAAOj9C,EAAM,GAC1B9B,EAAM4oD,UAAS,GACflJ,EAAOrxC,kBACPqxC,EAAOpiB,SAASt9B,IAMX8wD,IAAQpxD,EAAKP,MAAME,UAAUqyC,SAAW77B,EAAOohB,IAAMphB,EAAOkoC,YAAc,KAC7Ej8C,EAAKivD,UAAW,EAChBjvD,EAAKivD,UAAW,GAzFhBC,CAAoBtxD,OACf,CACL,IAEIuxD,EAAmBC,EAFnB3gB,EAAStsC,EAAIssC,OACbvH,EAAO/kC,EAAI+kC,MAEXmoB,IAAmCltD,aAAe,OAC/CA,EAAIC,MAAMxD,OAAO0D,gBAClB6sD,EAAoBG,GAAwB1xD,EAAMuE,EAAI9C,OACrD8C,EAAI3E,OAAU2E,EAAIC,MAAMxD,OAAO0D,gBAChC8sD,EAAkBE,GAAwB1xD,EAAMuE,EAAI/C,MAE1DxB,EAAKkwB,QAAQvuB,aAAakvC,EAAQvH,EAAMtpC,EAAKgkD,KAAM0E,GAC/C+I,KACEF,GAAqBI,GAAcJ,GACnCC,GAAmBG,GAAcH,IAEnCjtD,EAAIytC,QACNhyC,EAAKwO,IAAIk7C,UAAU9wB,OAAO,8BAE1B54B,EAAKwO,IAAIk7C,UAAUja,IAAI,6BACnB,sBAAuBh9B,UAsCjC,SAAsCzS,GACpC,IAAIqB,EAAMrB,EAAKwO,IAAIg/B,cACnBnsC,EAAIkmB,oBAAoB,kBAAmBvnB,EAAK4xD,oBAChD,IAAI5R,EAAShgD,EAAKgkD,KAAKt1C,eACnBtM,EAAO49C,EAAO+I,WAAYv3C,EAASwuC,EAAOgJ,aAC9C3nD,EAAIgmB,iBAAiB,kBAAmBrnB,EAAK4xD,mBAAqB,WAC5D5R,EAAO+I,YAAc3mD,GAAQ49C,EAAOgJ,cAAgBx3C,IACtDnQ,EAAIkmB,oBAAoB,kBAAmBvnB,EAAK4xD,oBAChDvrC,YAAW,WACJkqC,GAAoBvwD,KAASA,EAAKP,MAAME,UAAUqyC,SACnDhyC,EAAKwO,IAAIk7C,UAAU9wB,OAAO,+BAC7B,OAjDoCi5B,CAA6B7xD,IAIxEA,EAAK8wD,YAAYG,kBACjBjxD,EAAK8wD,YAAYgB,oBA3bnB1G,GAAgB7gD,UAAUwnD,eAAiB,SAAyB9qD,EAAOpC,GACzE,GAAIoC,GAASpC,EAAb,CACA,IAAK,IAAI9B,EAAIkE,EAAOlE,EAAI8B,EAAK9B,IAAO+I,KAAK6qB,IAAIiwB,SAAS7jD,GAAGukB,UACzDxb,KAAK6qB,IAAIiwB,SAAS/tB,OAAO5xB,EAAOpC,EAAMoC,GACtC6E,KAAK+gD,SAAU,IAIjBzB,GAAgB7gD,UAAUqiD,YAAc,WACtC9gD,KAAKimD,eAAejmD,KAAK9I,MAAO8I,KAAK6qB,IAAIiwB,SAASzgD,SAMpDilD,GAAgB7gD,UAAU6hD,YAAc,SAAsB37C,EAAOuZ,EAAQhqB,GAG3E,IAFA,IAAIwvC,EAAO,EAAGttC,EAAQ4J,KAAKq2C,MAAMh8C,QAAU,EACvC6rD,EAAU7kD,KAAKc,IAAI/L,EAAOuO,EAAMtK,QAC7BqpC,EAAOwiB,IACNxiB,GAAQttC,EAAQ,EAAI4J,KAAK6qB,IAAM7qB,KAAKq2C,MAAO3S,EAAO,GAAM,IAAI0X,YAAYz2C,EAAM++B,MAA6C,IAAnC/+B,EAAM++B,GAAM5uC,KAAKC,KAAK8pB,UAClH6kB,IAEJ,KAAOA,EAAOttC,GACZ4J,KAAK8gD,cACL9gD,KAAK6qB,IAAIkwB,MAnlCG,EAolCZ/6C,KAAK9I,MAAQ8I,KAAKq2C,MAAM/e,MACxBt3B,KAAK6qB,IAAM7qB,KAAKq2C,MAAM/e,MACtBlhC,IAEF,KAAOA,EAAQuO,EAAMtK,QAAQ,CAC3B2F,KAAKq2C,MAAMz7C,KAAKoF,KAAK6qB,IAAK7qB,KAAK9I,MAAQ,GAEvC,IADA,IAAIkG,GAAS,EACJnG,EAAI+I,KAAK9I,MAAOD,EAAIoK,KAAKc,IAAInC,KAAK9I,MAAQ,EAAG8I,KAAK6qB,IAAIiwB,SAASzgD,QAASpD,IAC/E,GAAI+I,KAAK6qB,IAAIiwB,SAAS7jD,GAAGmkD,YAAYz2C,EAAMvO,IAAS,CAAEgH,EAAQnG,EAAG,MAEnE,GAAImG,GAAS,EACPA,EAAQ4C,KAAK9I,QACf8I,KAAK+gD,SAAU,EACf/gD,KAAKimD,eAAejmD,KAAK9I,MAAOkG,IAElC4C,KAAK6qB,IAAM7qB,KAAK6qB,IAAIiwB,SAAS96C,KAAK9I,WAC7B,CACL,IAAIivD,EAAWhI,EAAa7jD,OAAO0F,KAAK6qB,IAAKlmB,EAAMvO,GAAQ8nB,EAAQhqB,GACnE8L,KAAK6qB,IAAIiwB,SAAS/tB,OAAO/sB,KAAK9I,MAAO,EAAGivD,GACxCnmD,KAAK6qB,IAAMs7B,EACXnmD,KAAK+gD,SAAU,EAEjB/gD,KAAK9I,MAAQ,EACbd,MAOJkpD,GAAgB7gD,UAAUgiD,cAAgB,SAAwBnqD,EAAMkoD,EAAWC,EAAWvnD,GAC5F,IAAgBkvD,EAAZhpD,GAAS,EACb,GAAIlG,GAAS8I,KAAK8jD,SAAS5sD,QACtBkvD,EAAapmD,KAAK8jD,SAASjpC,QAAQ3jB,EAAQ8I,KAAK8jD,SAAS5sD,QAAQhC,QAAU8K,KAAK6qB,KACjFu7B,EAAW/K,YAAY/kD,EAAMkoD,EAAWC,GAC1CrhD,EAAQ4C,KAAK6qB,IAAIiwB,SAAS36B,QAAQimC,EAAYpmD,KAAK9I,YAEnD,IAAK,IAAID,EAAI+I,KAAK9I,MAAOsG,EAAI6D,KAAKc,IAAInC,KAAK6qB,IAAIiwB,SAASzgD,OAAQpD,EAAI,GAAIA,EAAIuG,EAAGvG,IAAK,CAClF,IAAIwG,EAAQuC,KAAK6qB,IAAIiwB,SAAS7jD,GAC9B,GAAIwG,EAAM49C,YAAY/kD,EAAMkoD,EAAWC,KAAez+C,KAAK8jD,SAAStqC,QAAQ6sC,IAAI5oD,GAAQ,CACtFL,EAAQnG,EACR,OAIN,QAAImG,EAAQ,KACZ4C,KAAKimD,eAAejmD,KAAK9I,MAAOkG,GAChC4C,KAAK9I,SACE,IAGTooD,GAAgB7gD,UAAUkiD,aAAe,SAAuBrqD,EAAMkoD,EAAWC,EAAWvnD,EAAOhD,GAEjG,QADY8L,KAAK6qB,IAAIiwB,SAAS5jD,GACnBy1B,OAAOr2B,EAAMkoD,EAAWC,EAAWvqD,KAC9C8L,KAAKimD,eAAejmD,KAAK9I,MAAOA,GAChC8I,KAAK9I,MAAQA,EAAQ,GACd,IAGTooD,GAAgB7gD,UAAUiiD,mBAAqB,SAA6B4F,GAC1E,OAAS,CACP,IAAIpxD,EAASoxD,EAAQ5nB,WACrB,IAAKxpC,EAAU,OAAQ,EACvB,GAAIA,GAAU8K,KAAK6qB,IAAIhG,WAAY,CACjC,IAAI2iB,EAAO8e,EAAQtS,WACnB,GAAIxM,EAAQ,IAAK,IAAIvwC,EAAI+I,KAAK9I,MAAOD,EAAI+I,KAAK6qB,IAAIiwB,SAASzgD,OAAQpD,IACjE,GAAI+I,KAAK6qB,IAAIiwB,SAAS7jD,IAAMuwC,EAAQ,OAAOvwC,EAE7C,OAAQ,EAEVqvD,EAAUpxD,IAOdoqD,GAAgB7gD,UAAUmiD,eAAiB,SAAyBtqD,EAAMkoD,EAAWC,EAAWvqD,EAAMgD,GACpG,IAAK,IAAID,EAAI+I,KAAK9I,MAAOD,EAAI+I,KAAK6qB,IAAIiwB,SAASzgD,OAAQpD,IAAK,CAC1D,IAAI87B,EAAO/yB,KAAK6qB,IAAIiwB,SAAS7jD,GAC7B,GAAI87B,aAAgBwrB,EAAc,CAChC,IAAIuF,EAAW9jD,KAAK8jD,SAAStqC,QAAQkT,IAAIqG,GACzC,GAAgB,MAAZ+wB,GAAoBA,GAAY5sD,EAAS,OAAO,EACpD,IAAIqvD,EAAUxzB,EAAKrwB,IAQnB,KAHa1C,KAAK6jD,OAAS0C,GAAWvmD,KAAK6jD,MAA4B,GAApB0C,EAAQhrD,UAAiBgrD,EAAQjrC,SAAStb,KAAK6jD,KAAKnlB,gBACjGpoC,EAAK8K,QAAU2xB,EAAKz8B,MAAQy8B,EAAKz8B,KAAK8K,QAAU2xB,EAAKipB,QAAQ3b,WAAa/pC,EAAK0K,MA7qCvB,GA8qCxD+xB,EAAKgoB,OAAuBiE,GAAcR,EAAWzrB,EAAKyrB,cACjDzrB,EAAKpG,OAAOr2B,EAAMkoD,EAAWC,EAAWvqD,GAIrD,OAHA8L,KAAKimD,eAAejmD,KAAK9I,MAAOD,GAC5B87B,EAAKrwB,KAAO6jD,IAAWvmD,KAAK+gD,SAAU,GAC1C/gD,KAAK9I,SACE,EAET,OAGJ,OAAO,GAKTooD,GAAgB7gD,UAAUozB,QAAU,SAAkBv7B,EAAMkoD,EAAWC,EAAWvqD,EAAM+B,GACtF+J,KAAK6qB,IAAIiwB,SAAS/tB,OAAO/sB,KAAK9I,QAAS,EAAGqnD,EAAajkD,OAAO0F,KAAK6qB,IAAKv0B,EAAMkoD,EAAWC,EAAWvqD,EAAM+B,IAC1G+J,KAAK+gD,SAAU,GAGjBzB,GAAgB7gD,UAAU8hD,YAAc,SAAsBnE,EAAQloD,EAAM+B,GAC1E,IAAI88B,EAAO/yB,KAAK9I,MAAQ8I,KAAK6qB,IAAIiwB,SAASzgD,OAAS2F,KAAK6qB,IAAIiwB,SAAS96C,KAAK9I,OAAS,KACnF,IAAI67B,IAAQA,EAAKooB,cAAciB,IAAYA,GAAUrpB,EAAKqpB,QAAWrpB,EAAKqpB,OAAOtnD,KAAK0pB,MAAMkgB,WAErF,CACL,IAAI8I,EAAO,IAAI2U,EAAen8C,KAAK6qB,IAAKuxB,EAAQloD,EAAM+B,GACtD+J,KAAK6qB,IAAIiwB,SAAS/tB,OAAO/sB,KAAK9I,QAAS,EAAGswC,GAC1CxnC,KAAK+gD,SAAU,OAJf/gD,KAAK9I,SAUTooD,GAAgB7gD,UAAUoiD,kBAAoB,WAE5C,IADA,IAAInqD,EAAYsJ,KAAK6qB,IAAIiwB,SAAS96C,KAAK9I,MAAQ,GACxCR,aAAqBynD,GAAgBznD,EAAYA,EAAUokD,SAASpkD,EAAUokD,SAASzgD,OAAS,GAElG3D,GACCA,aAAqBqoD,IACvB,MAAMviD,KAAK9F,EAAUJ,KAAK0K,SAEvBqJ,EAAOghB,QAAUhhB,EAAO+gB,SAAW10B,GAA8C,SAAjCA,EAAUgM,IAAIqxC,iBAC/D/zC,KAAKwmD,YAAY,OACrBxmD,KAAKwmD,YAAY,QAIrBlH,GAAgB7gD,UAAU+nD,YAAc,SAAsB7nB,GAC5D,GAAI3+B,KAAK9I,MAAQ8I,KAAK6qB,IAAIiwB,SAASzgD,QAAU2F,KAAK6qB,IAAIiwB,SAAS96C,KAAK9I,OAAOokD,YAAY3c,GACrF3+B,KAAK9I,YACA,CACL,IAAIwL,EAAMiE,SAASgS,cAAcgmB,GACjB,OAAZA,IACFj8B,EAAI+jD,UAAY,wBAChB/jD,EAAIuH,IAAM,IAEI,MAAZ00B,IAAoBj8B,EAAI+jD,UAAY,6BACxCzmD,KAAK6qB,IAAIiwB,SAAS/tB,OAAO/sB,KAAK9I,QAAS,EAAG,IAAIglD,GAAqBl8C,KAAK6qB,IAAK6yB,EAASh7C,EAAK,OAC3F1C,KAAK+gD,SAAU,IAqRnB,IAAI4E,GAAgCt7C,EAAOghB,QAAUhhB,EAAO+gB,QAAU/gB,EAAOqoC,eAAiB,GAE9F,SAASkT,GAAwB1xD,EAAM+B,GACrC,IAAIa,EAAM5C,EAAKkwB,QAAQ20B,WAAW9iD,EAAK,GACnCK,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACblQ,EAAQkQ,EAASpP,EAAK4rC,WAAW7nC,OAAS/D,EAAK4rC,WAAWx8B,GAAU,KACpE9Q,EAAS8Q,EAASpP,EAAK4rC,WAAWx8B,EAAS,GAAK,KACpD,GAAI2E,EAAOghB,QAAU71B,GAAkC,SAAzBA,EAAMu+C,gBAA8B,OAAO1wB,GAAY7tB,GACrF,KAAMA,GAAkC,SAAzBA,EAAMu+C,iBAAiCn/C,GAAoC,SAA1BA,EAAOm/C,iBAA6B,CAClG,GAAIv+C,EAAS,OAAO6tB,GAAY7tB,GAC3B,GAAIZ,EAAU,OAAOyuB,GAAYzuB,IAI1C,SAASyuB,GAAYrB,GAGnB,OAFAA,EAAQ+xB,gBAAkB,OACtB1pC,EAAOghB,QAAUrJ,EAAQ3D,YAAa2D,EAAQ3D,WAAY,EAAO2D,EAAQ0kC,cAAe,GACrF1kC,EAGT,SAAS6jC,GAAc7jC,GACrBA,EAAQ+xB,gBAAkB,QACtB/xB,EAAQ0kC,eAAgB1kC,EAAQ3D,WAAY,EAAM2D,EAAQ0kC,aAAe,MAsC/E,SAAS9B,GAAkB1wD,EAAMuE,GAC/B,GAAIA,aAAe,KAAe,CAChC,IAAI+uC,EAAOtzC,EAAKkwB,QAAQ63B,OAAOxjD,EAAI9C,MAC/B6xC,GAAQtzC,EAAKyyD,uBACfC,GAAmB1yD,GACfszC,GAAQA,EAAK2a,aACjBjuD,EAAKyyD,qBAAuBnf,QAG9Bof,GAAmB1yD,GAKvB,SAAS0yD,GAAmB1yD,GACtBA,EAAKyyD,uBACHzyD,EAAKyyD,qBAAqBzxD,QAC1BhB,EAAKyyD,qBAAqBvE,eAC9BluD,EAAKyyD,qBAAuB,MAIhC,SAASnC,GAAiBtwD,EAAMsD,EAAST,EAAOoS,GAC9C,OAAOjV,EAAKgX,SAAS,0BAA0B,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsD,EAAST,OACjF,aAAsBS,EAAST,EAAOoS,GAQ7C,SAASu7C,GAAaxwD,GACpB,IAAIuE,EAAMvE,EAAKgkD,KAAKt1C,eACpB,IAAKnK,EAAIwkD,WAAc,OAAO,EAC9B,IAIE,OAAO/oD,EAAKwO,IAAI4Y,SAAoC,GAA3B7iB,EAAIwkD,WAAW1hD,SAAgB9C,EAAIwkD,WAAWve,WAAajmC,EAAIwkD,cACrF/oD,EAAK0gB,UAAY1gB,EAAKwO,IAAI4Y,SAAmC,GAA1B7iB,EAAI6hD,UAAU/+C,SAAgB9C,EAAI6hD,UAAU5b,WAAajmC,EAAI6hD,YACnG,MAAM1wB,GACN,OAAO,GAUX,SAASi9B,GAAmBlzD,EAAO2xC,GACjC,IAAIxuC,EAAMnD,EAAME,UACZ2D,EAAUV,EAAIU,QACdT,EAAQD,EAAIC,MACZ+vD,EAAQxhB,EAAM,EAAI9tC,EAAQ8J,IAAIvK,GAASS,EAAQ2K,IAAIpL,GACnDiH,EAAU8oD,EAAM5xD,OAAO0D,cAAwBkuD,EAAM1wD,MAAQzC,EAAM4B,IAAIO,QAAQwvC,EAAM,EAAIwhB,EAAMtxD,QAAUsxD,EAAMlyD,UAAY,KAApFkyD,EAC3C,OAAO9oD,GAAU,cAAmBA,EAAQsnC,GAG9C,SAASpwB,GAAMhhB,EAAMuE,GAEnB,OADAvE,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa4C,GAAKzE,mBACvC,EAGT,SAAS+yD,GAAmB7yD,EAAMoxC,EAAK0hB,GACrC,IAAIvuD,EAAMvE,EAAKP,MAAME,UACrB,KAAI4E,aAAe,MAuBZ,IAAIA,aAAe,MAAiBA,EAAInC,KAAK4E,SAClD,OAAOga,GAAMhhB,EAAM,IAAI,KAAcoxC,EAAM,EAAI7sC,EAAIE,IAAMF,EAAIC,QAE7D,IAAI29B,EAASwwB,GAAmB3yD,EAAKP,MAAO2xC,GAC5C,QAAIjP,GAAiBnhB,GAAMhhB,EAAMmiC,GA1BjC,IAAK59B,EAAI3E,OAASkzD,EAAK7mC,QAAQ,MAAQ,EACrC,OAAO,EACF,GAAIjsB,EAAKE,eAAekxC,EAAM,EAAI,QAAU,QAAS,CAC1D,IAAIvS,EAAO8zB,GAAmB3yD,EAAKP,MAAO2xC,GAC1C,SAAIvS,GAASA,aAAgB,OAAyB7d,GAAMhhB,EAAM6+B,GAE7D,KAAM1oB,EAAOmhB,KAAOw7B,EAAK7mC,QAAQ,MAAQ,GAAI,CAClD,IAAsGqnB,EAAlGzwC,EAAQ0B,EAAI1B,MAAOT,EAAOS,EAAMi7B,WAAa,KAAOsT,EAAM,EAAIvuC,EAAMlC,WAAakC,EAAMM,UAC3F,IAAKf,GAAQA,EAAK8K,OAAU,OAAO,EACnC,IAAI6lD,EAAU3hB,EAAM,EAAIvuC,EAAMd,IAAMK,EAAKJ,SAAWa,EAAMd,IAC1D,SAAMK,EAAKH,SAAWqxC,EAAOtzC,EAAKkwB,QAAQ63B,OAAOgL,MAAczf,EAAK3iB,cAChE,kBAA2BvuB,GACtB4e,GAAMhhB,EAAM,IAAI,KAAcoxC,EAAM,EAAIpxC,EAAKP,MAAM4B,IAAIO,QAAQiB,EAAMd,IAAMK,EAAKJ,UAAYa,MAC1FsT,EAAOyoC,QAIT59B,GAAMhhB,EAAM,IAAI,KAAcA,EAAKP,MAAM4B,IAAIO,QAAQwvC,EAAM,EAAI2hB,EAAUA,EAAU3wD,EAAKJ,cAcvG,SAASgxD,GAAQ5wD,GACf,OAAwB,GAAjBA,EAAKiF,SAAgBjF,EAAK+pC,UAAUhmC,OAAS/D,EAAK4rC,WAAW7nC,OAGtE,SAAS8sD,GAAYzkD,GACnB,IAAI8kC,EAAO9kC,EAAIsxC,WACf,OAAOxM,GAAqB,GAAbA,EAAKpyC,OAAcsN,EAAIo+B,aAA+B,MAAhBp+B,EAAIi8B,UAK3D,SAASyoB,GAAqBlzD,GAC5B,IAAIuE,EAAMvE,EAAKgkD,KAAKt1C,eAChBtM,EAAOmC,EAAI6hD,UAAW50C,EAASjN,EAAI+hD,YACvC,GAAKlkD,EAAL,CACA,IAAI+wD,EAAUC,EAAY1K,GAAQ,EAKlC,IADIvyC,EAAOkhB,OAA0B,GAAjBj1B,EAAKiF,UAAiBmK,EAASwhD,GAAQ5wD,IAAS6wD,GAAY7wD,EAAK4rC,WAAWx8B,MAAYk3C,GAAQ,KAElH,GAAIl3C,EAAS,EAAG,CACd,GAAqB,GAAjBpP,EAAKiF,SACP,MAEA,IAAI3G,EAAS0B,EAAK4rC,WAAWx8B,EAAS,GACtC,GAAIyhD,GAAYvyD,GACdyyD,EAAW/wD,EACXgxD,IAAe5hD,MACV,IAAuB,GAAnB9Q,EAAO2G,SAGT,MADPmK,GADApP,EAAO1B,GACOyrC,UAAUhmC,YAGvB,IAAIktD,GAAYjxD,GACrB,MAGA,IADA,IAAI4jB,EAAO5jB,EAAKiqC,gBACTrmB,GAAQitC,GAAYjtC,IACzBmtC,EAAW/wD,EAAKooC,WAChB4oB,EAAarU,EAAS/4B,GACtBA,EAAOA,EAAKqmB,gBAEd,GAAKrmB,EAMHxU,EAASwhD,GADT5wD,EAAO4jB,OALE,CAET,IADA5jB,EAAOA,EAAKooC,aACAxqC,EAAKwO,IAAO,MACxBgD,EAAS,GAOXk3C,EAAS4K,GAAYtzD,EAAMuE,EAAKnC,EAAMoP,GACjC2hD,GAAYG,GAAYtzD,EAAMuE,EAAK4uD,EAAUC,IAKxD,SAASG,GAAsBvzD,GAC7B,IAAIuE,EAAMvE,EAAKgkD,KAAKt1C,eAChBtM,EAAOmC,EAAI6hD,UAAW50C,EAASjN,EAAI+hD,YACvC,GAAKlkD,EAAL,CAGA,IAFA,IACI+wD,EAAUC,EADVxrD,EAAMorD,GAAQ5wD,KAGhB,GAAIoP,EAAS5J,EAAK,CAChB,GAAqB,GAAjBxF,EAAKiF,SAAiB,MAE1B,IAAI4rD,GADQ7wD,EAAK4rC,WAAWx8B,IAKrB,MAHL2hD,EAAW/wD,EACXgxD,IAAe5hD,MAGZ,IAAI6hD,GAAYjxD,GACrB,MAGA,IADA,IAAIy8B,EAAOz8B,EAAKwqC,YACT/N,GAAQo0B,GAAYp0B,IACzBs0B,EAAWt0B,EAAK2L,WAChB4oB,EAAarU,EAASlgB,GAAQ,EAC9BA,EAAOA,EAAK+N,YAEd,GAAK/N,EAMHrtB,EAAS,EACT5J,EAAMorD,GAFN5wD,EAAOy8B,OALE,CAET,IADAz8B,EAAOA,EAAKooC,aACAxqC,EAAKwO,IAAO,MACxBgD,EAAS5J,EAAM,GAQjBurD,GAAYG,GAAYtzD,EAAMuE,EAAK4uD,EAAUC,IAGnD,SAASC,GAAY7kD,GACnB,IAAI8kC,EAAO9kC,EAAIsxC,WACf,OAAOxM,GAAQA,EAAKlxC,MAAQkxC,EAAKlxC,KAAK4C,QAGxC,SAASsuD,GAAYtzD,EAAMuE,EAAKnC,EAAMoP,GACpC,GAAIuuC,EAAmBx7C,GAAM,CAC3B,IAAIjE,EAAQmS,SAAS2sC,cACrB9+C,EAAM++C,OAAOj9C,EAAMoP,GACnBlR,EAAMg/C,SAASl9C,EAAMoP,GACrBjN,EAAIoK,kBACJpK,EAAIq5B,SAASt9B,QACJiE,EAAIiI,QACbjI,EAAIiI,OAAOpK,EAAMoP,GAEnBxR,EAAK8wD,YAAYG,kBACjB,IAAIxxD,EAAQO,EAAKP,MAEjB4mB,YAAW,WACLrmB,EAAKP,OAASA,GAASgxD,GAAezwD,KACzC,IAOL,SAASwzD,GAAiBxzD,EAAMoxC,EAAK0hB,GACnC,IAAIvuD,EAAMvE,EAAKP,MAAME,UACrB,GAAI4E,aAAe,OAAkBA,EAAI3E,OAASkzD,EAAK7mC,QAAQ,MAAQ,EAAK,OAAO,EACnF,GAAI9V,EAAOmhB,KAAOw7B,EAAK7mC,QAAQ,MAAQ,EAAK,OAAO,EACnD,IAAIznB,EAAQD,EAAIC,MACZC,EAAMF,EAAIE,IAEd,IAAKD,EAAMxD,OAAO0D,eAAiB1E,EAAKE,eAAekxC,EAAM,EAAI,KAAO,QAAS,CAC/E,IAAIvS,EAAO8zB,GAAmB3yD,EAAKP,MAAO2xC,GAC1C,GAAIvS,GAASA,aAAgB,KACzB,OAAO7d,GAAMhhB,EAAM6+B,GAEzB,IAAKr6B,EAAMxD,OAAO0D,cAAe,CAC/B,IAAIrC,EAAO+uC,EAAM,EAAI5sC,EAAQC,EACzBgvD,EAASlvD,aAAe,KAAe,UAAelC,EAAM+uC,GAAO,cAAmB/uC,EAAM+uC,GAChG,QAAOqiB,GAASzyC,GAAMhhB,EAAMyzD,GAE9B,OAAO,EAGT,SAASC,GAA2B1zD,EAAMoxC,GACxC,KAAMpxC,EAAKP,MAAME,qBAAqB,MAAkB,OAAO,EAC/D,IAAIiD,EAAM5C,EAAKP,MAAME,UACjBkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QACd1D,EAAQgD,EAAIhD,MAChB,IAAKiD,EAAMW,WAAWF,GAAY,OAAO,EACzC,IAAK1D,EAAS,OAAO,EACrB,GAAII,EAAKE,eAAekxC,EAAM,EAAI,UAAY,YAAe,OAAO,EACpE,IAAIuiB,GAAY9wD,EAAMi7B,aAAesT,EAAM,EAAIvuC,EAAMlC,WAAakC,EAAMM,WACxE,GAAIwwD,IAAaA,EAASzmD,OAAQ,CAChC,IAAIrN,EAAKG,EAAKP,MAAMI,GAIpB,OAHIuxC,EAAM,EAAKvxC,EAAGsC,OAAOU,EAAMd,IAAM4xD,EAAS3xD,SAAUa,EAAMd,KACvDlC,EAAGsC,OAAOU,EAAMd,IAAKc,EAAMd,IAAM4xD,EAAS3xD,UACjDhC,EAAKN,SAASG,IACP,EAET,OAAO,EAGT,SAAS+zD,GAAe5zD,EAAMoC,EAAM3C,GAClCO,EAAK8wD,YAAYnH,OACjBvnD,EAAKy9C,gBAAkBpgD,EACvBO,EAAK8wD,YAAY7pD,QAqCnB,SAAS4sD,GAAe7zD,EAAMsW,GAC5B,IAAI/S,EAAO+S,EAAM0hB,QAAS86B,EAV5B,SAAiBx8C,GACf,IAAIH,EAAS,GAKb,OAJIG,EAAMG,UAAWN,GAAU,KAC3BG,EAAMI,UAAWP,GAAU,KAC3BG,EAAME,SAAUL,GAAU,KAC1BG,EAAMK,WAAYR,GAAU,KACzBA,EAI0B29C,CAAQx9C,GACzC,OAAY,GAAR/S,GAAc4S,EAAOmhB,KAAe,IAAR/zB,GAAsB,KAARuvD,EACrCY,GAA2B1zD,GAAO,IAAMkzD,GAAqBlzD,GACnD,IAARuD,GAAe4S,EAAOmhB,KAAe,IAAR/zB,GAAsB,KAARuvD,EAC7CY,GAA2B1zD,EAAM,IAAMuzD,GAAsBvzD,GACnD,IAARuD,GAAsB,IAARA,IAEN,IAARA,EACFsvD,GAAmB7yD,GAAO,EAAG8yD,IAASI,GAAqBlzD,GACjD,IAARuD,EACFsvD,GAAmB7yD,EAAM,EAAG8yD,IAASS,GAAsBvzD,GACjD,IAARuD,EACFiwD,GAAiBxzD,GAAO,EAAG8yD,IAASI,GAAqBlzD,GAC/C,IAARuD,EA3Cb,SAA4BvD,GAC1B,GAAKmW,EAAOghB,UAAUn3B,EAAKP,MAAME,UAAUkD,MAAM1C,aAAe,GAAhE,CACA,IAAIyC,EAAM5C,EAAKgkD,KAAKt1C,eAChB03C,EAAYxjD,EAAIwjD,UAChBE,EAAc1jD,EAAI0jD,YACtB,GAAIF,GAAmC,GAAtBA,EAAU/+C,UAAgC,GAAfi/C,GACxCF,EAAU7jD,YAAsD,SAAxC6jD,EAAU7jD,WAAWs9C,gBAA4B,CAC3E,IAAIt2C,EAAQ68C,EAAU7jD,WACtBqxD,GAAe5zD,EAAMuJ,GAAO,GAC5B8c,YAAW,WAAc,OAAOutC,GAAe5zD,EAAMuJ,GAAO,KAAW,MAmChEwqD,CAAmB/zD,IAASwzD,GAAiBxzD,EAAM,EAAG8yD,IAASS,GAAsBvzD,GACnF8yD,IAAS38C,EAAOmhB,IAAM,IAAM,OACnB,IAAR/zB,GAAsB,IAARA,GAAsB,IAARA,GAAsB,IAARA,IA2DxD,SAASupC,GAAat+B,GACpB,IAAI8kC,EAAO9kC,EAAIsxC,WACf,GAAIxM,EACF,OAAOA,EAAKnqB,YACP,GAAoB,MAAhB3a,EAAIi8B,UAAoBj8B,EAAIg8B,WAAY,CAIjD,GAAIr0B,EAAOghB,QAAU,aAAa7uB,KAAKkG,EAAIg8B,WAAWC,UAAW,CAC/D,IAAIwC,EAAOx6B,SAASgS,cAAc,OAElC,OADAwoB,EAAKvoB,YAAYjS,SAASgS,cAAc,OACjC,CAACwoB,KAAMA,GACT,GAAIz+B,EAAIg8B,WAAWhoC,WAAagM,GAAO2H,EAAOghB,QAAU,gBAAgB7uB,KAAKkG,EAAIg8B,WAAWC,UACjG,MAAO,CAACsC,QAAQ,QAEb,GAAoB,OAAhBv+B,EAAIi8B,UAAqBj8B,EAAIgb,aAAa,oBACnD,MAAO,CAACujB,QAAQ,GAIpB,SAASinB,GAAch0D,EAAMyB,EAAMD,EAAIyyD,EAAUzhC,GAC/C,GAAI/wB,EAAO,EAAX,CACE,IAAI0uD,EAASnwD,EAAKk0D,kBAAoBzhB,KAAKC,MAAQ,GAAK1yC,EAAKm0D,oBAAsB,KAC/EC,EAASlE,GAAiBlwD,EAAMmwD,GACpC,GAAIiE,IAAWp0D,EAAKP,MAAME,UAAU2T,GAAG8gD,GAAS,CAC9C,IAAIC,EAAOr0D,EAAKP,MAAMI,GAAG8B,aAAayyD,GACxB,WAAVjE,EAAuBkE,EAAK36C,QAAQ,WAAW,GAChC,OAAVy2C,GAAmBkE,EAAKv0D,iBACjCE,EAAKN,SAAS20D,QAPlB,CAYA,IAAI52B,EAAUz9B,EAAKP,MAAM4B,IAAIO,QAAQH,GACjC6yD,EAAS72B,EAAQrkB,YAAY5X,GACjCC,EAAOg8B,EAAQ/8B,OAAO4zD,EAAS,GAC/B9yD,EAAKxB,EAAKP,MAAM4B,IAAIO,QAAQJ,GAAIF,MAAMgzD,EAAS,GAE/C,IAAI/vD,EAAMvE,EAAKP,MAAME,UACjB6U,EAtFN,SAAsBxU,EAAMu0D,EAAOC,GACjC,IAAI5xD,EAAM5C,EAAKkwB,QAAQk4B,WAAWmM,EAAOC,GACrCxzD,EAAS4B,EAAIR,KACbimD,EAAazlD,EAAIylD,WACjBC,EAAW1lD,EAAI0lD,SACf7mD,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GAETw+C,EAAShgD,EAAKgkD,KAAKt1C,eAAgBwC,EAAO,KAAM2/B,EAASmP,EAAO+I,WAQpE,GAPIlY,GAAU7wC,EAAKwO,IAAI4Y,SAA4B,GAAnBypB,EAAOxpC,SAAgBwpC,EAASA,EAAOrG,cACrEt5B,EAAO,CAAC,CAAC9O,KAAMyuC,EAAQr/B,OAAQwuC,EAAOgJ,eACjCjJ,EAAmBC,IACpB9uC,EAAKxK,KAAK,CAACtE,KAAM49C,EAAOoG,UAAW50C,OAAQwuC,EAAOsG,eAIpDnwC,EAAO+gB,QAA+B,IAArBl3B,EAAKy0D,YACxB,IAAK,IAAI9mC,EAAM26B,EAAU36B,EAAM06B,EAAY16B,IAAO,CAChD,IAAIvrB,EAAOpB,EAAOgtC,WAAWrgB,EAAM,GAAI2lB,EAAOlxC,EAAK09C,WACnD,GAAqB,MAAjB19C,EAAKqoC,WAAqB6I,EAAM,CAAEgV,EAAW36B,EAAK,MACtD,IAAK2lB,GAAQA,EAAKpyC,KAAQ,MAG9B,IAAIwzD,EAAW10D,EAAKP,MAAM4B,IACtBiT,EAAStU,EAAKgX,SAAS,cAAgB,gBAAqBhX,EAAKP,MAAM6N,QACvE9I,EAAQkwD,EAAS9yD,QAAQH,GAEzB8C,EAAM,KAAMlD,EAAMiT,EAAOE,MAAMxT,EAAQ,CACzC6oB,QAASrlB,EAAMxD,OACf+pC,SAAUvmC,EAAMxD,OAAOkD,eAAeM,EAAMxB,SAC5CyrC,SAAS,EACThtC,KAAM4mD,EACN7mD,GAAI8mD,EACJ3zC,mBAAoD,OAAhCnQ,EAAMxD,OAAOJ,KAAKikC,YAAsB,OAC5D8vB,iBAAiB,EACjB3pB,cAAe95B,EACf47B,aAAcA,GACdzhC,QAAS7G,IAEX,GAAI0M,GAAuB,MAAfA,EAAK,GAAGnP,IAAa,CAC/B,IAAI6yD,EAAW1jD,EAAK,GAAGnP,IAAKunC,EAAOp4B,EAAK,IAAMA,EAAK,GAAGnP,IAC1C,MAARunC,IAAgBA,EAAOsrB,GAC3BrwD,EAAM,CAACssC,OAAQ+jB,EAAWnzD,EAAM6nC,KAAMA,EAAO7nC,GAE/C,MAAO,CAACJ,IAAKA,EAAKkD,IAAKA,EAAK9C,KAAMA,EAAMD,GAAIA,GA0ChCqzD,CAAa70D,EAAMyB,EAAMD,GAIrC,GAAI2U,EAAO+gB,QAAUl3B,EAAKmxD,eAAiB38C,EAAMjQ,KAAOiQ,EAAMjQ,IAAIssC,QAAU7wC,EAAKmxD,cAAc9F,KAAK5pD,KAAM,CACxG,IAAIqL,EAAO9M,EAAKmxD,cAAc9F,KAAKzqD,KAAK0pB,MAAMsiB,YAC1C1rC,EAAO4L,GAAQA,EAAKq/B,UAAYr/B,EAAKq/B,UAAUhmC,OAAS,EAC5DqO,EAAMjQ,IAAM,CAACssC,OAAQr8B,EAAMjQ,IAAIssC,OAAS3vC,EAAMooC,KAAM90B,EAAMjQ,IAAIssC,OAAS3vC,GAGzE,IACI4zD,EAAcC,EADd1zD,EAAMrB,EAAKP,MAAM4B,IAAK2zD,EAAU3zD,EAAIE,MAAMiT,EAAM/S,KAAM+S,EAAMhT,IAGvC,IAArBxB,EAAKy0D,aAAqBhiB,KAAKC,MAAQ,IAAM1yC,EAAKi1D,iBACpDH,EAAe90D,EAAKP,MAAME,UAAU6B,GACpCuzD,EAAgB,QAEhBD,EAAe90D,EAAKP,MAAME,UAAU8B,KACpCszD,EAAgB,SAElB/0D,EAAKy0D,YAAc,KAEnB,IAAIh/B,EAiNN,SAAkBnJ,EAAGrE,EAAGlmB,EAAK+yD,EAAcC,GACzC,IAAI9tD,EAAQqlB,EAAEvE,cAAcE,EAAGlmB,GAC/B,GAAa,MAATkF,EAAiB,OAAO,KAC5B,IAAIrE,EAAM0pB,EAAEtE,YAAYC,EAAGlmB,EAAMuqB,EAAEprB,KAAMa,EAAMkmB,EAAE/mB,MAC7Cg0D,EAAOtyD,EAAI0pB,EACX6oC,EAAOvyD,EAAIqlB,EACf,GAAqB,OAAjB8sC,EAAwB,CAE1BD,GAAgBI,EADH/nD,KAAKC,IAAI,EAAGnG,EAAQkG,KAAKc,IAAIinD,EAAMC,IAChBluD,EAElC,GAAIiuD,EAAOjuD,GAASqlB,EAAEprB,KAAO+mB,EAAE/mB,KAAM,CAGnCi0D,GADAluD,GADW6tD,GAAgB7tD,GAAS6tD,GAAgBI,EAAOjuD,EAAQ6tD,EAAe,IAElEK,EAAOD,GACvBA,EAAOjuD,OACF,GAAIkuD,EAAOluD,EAAO,CAGvBiuD,GADAjuD,GADa6tD,GAAgB7tD,GAAS6tD,GAAgBK,EAAOluD,EAAQ6tD,EAAe,IAEpEI,EAAOC,GACvBA,EAAOluD,EAET,MAAO,CAACA,MAAOA,EAAOiuD,KAAMA,EAAMC,KAAMA,GAtO3BC,CAASJ,EAAQ/zD,QAASuT,EAAMnT,IAAIJ,QAASuT,EAAM/S,KAAMqzD,EAAcC,GACpF,IAAKt/B,EAAQ,CACX,KAAIw+B,GAAY1vD,aAAe,OAAkBA,EAAI3E,OAAS2E,EAAI1B,MAAMW,WAAWe,EAAIjB,WAClFtD,EAAKqlB,WAAe7Q,EAAMjQ,KAAOiQ,EAAMjQ,IAAIssC,QAAUr8B,EAAMjQ,IAAI+kC,KAE7D,KAAKnzB,EAAOsoC,KAAOz+C,EAAKq1D,aAAe5iB,KAAKC,MAAQ,KAAOv8B,EAAOwoC,UAC9DnsB,EAAWrP,MAAK,SAAUxG,GAAK,MAAqB,OAAdA,EAAE8tB,UAAmC,KAAd9tB,EAAE8tB,aAC/DzqC,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,GAAI,aAEnF,YADArgD,EAAKq1D,aAAe,GAGpB,GAAI7gD,EAAMjQ,IAAK,CACb,IAAI+wD,EAAQC,GAAiBv1D,EAAMA,EAAKP,MAAM4B,IAAKmT,EAAMjQ,KACrD+wD,IAAUA,EAAMhiD,GAAGtT,EAAKP,MAAME,YAAcK,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa2zD,IAE3F,OAXA7/B,EAAS,CAACxuB,MAAO1C,EAAI9C,KAAMyzD,KAAM3wD,EAAI/C,GAAI2zD,KAAM5wD,EAAI/C,IAcvDxB,EAAKw1D,iBAIDx1D,EAAKP,MAAME,UAAU8B,KAAOzB,EAAKP,MAAME,UAAU6B,IACjDi0B,EAAOxuB,OAASwuB,EAAO0/B,MACvBn1D,EAAKP,MAAME,qBAAqB,OAC9B81B,EAAOxuB,MAAQjH,EAAKP,MAAME,UAAU8B,MAAQg0B,EAAOxuB,OAASjH,EAAKP,MAAME,UAAU8B,KAAO,GACxFzB,EAAKP,MAAME,UAAU8B,MAAQ+S,EAAM/S,KACrCg0B,EAAOxuB,MAAQjH,EAAKP,MAAME,UAAU8B,KAC3Bg0B,EAAOy/B,KAAOl1D,EAAKP,MAAME,UAAU6B,IAAMi0B,EAAOy/B,MAAQl1D,EAAKP,MAAME,UAAU6B,GAAK,GAClFxB,EAAKP,MAAME,UAAU6B,IAAMgT,EAAMhT,KAC1Ci0B,EAAO0/B,MAASn1D,EAAKP,MAAME,UAAU6B,GAAKi0B,EAAOy/B,KACjDz/B,EAAOy/B,KAAOl1D,EAAKP,MAAME,UAAU6B,KAOnC2U,EAAOohB,IAAMphB,EAAOkoC,YAAc,IAAM5oB,EAAO0/B,MAAQ1/B,EAAOxuB,MAAQ,GACtEwuB,EAAOy/B,MAAQz/B,EAAOxuB,OAASwuB,EAAOxuB,MAAQuN,EAAM/S,MACmC,MAAvF+S,EAAMnT,IAAIoiB,YAAYgS,EAAOxuB,MAAQuN,EAAM/S,KAAO,EAAGg0B,EAAOxuB,MAAQuN,EAAM/S,KAAO,KACnFg0B,EAAOxuB,QACPwuB,EAAOy/B,OACPz/B,EAAO0/B,QAGT,IAGIM,EAHAjxD,EAAQgQ,EAAMnT,IAAI47B,eAAexH,EAAOxuB,MAAQuN,EAAM/S,MACtDgD,EAAM+P,EAAMnT,IAAI47B,eAAexH,EAAO0/B,KAAO3gD,EAAM/S,MACnDi0D,EAAelxD,EAAMhB,WAAWiB,IAAQD,EAAMxD,OAAO0D,cAIzD,IAAMyR,EAAOsoC,KAAOz+C,EAAKq1D,aAAe5iB,KAAKC,MAAQ,OAC7CgjB,GAAgBljC,EAAWrP,MAAK,SAAUxG,GAAK,MAAqB,OAAdA,EAAE8tB,UAAmC,KAAd9tB,EAAE8tB,eAChFirB,GAAgBlxD,EAAMzC,IAAMyS,EAAMnT,IAAIJ,QAAQC,OAC9Cu0D,EAAU,cAAmBjhD,EAAMnT,IAAIO,QAAQ4C,EAAMzC,IAAM,GAAI,GAAG,KACnE0zD,EAAQnsB,MAAQ7kC,EAAI1C,MACtB/B,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,GAAI,aAC5ErgD,EAAKq1D,aAAe,OAItB,GAAIr1D,EAAKP,MAAME,UAAUkxC,OAASpb,EAAOxuB,OA4G3C,SAAuB0uD,EAAK1uD,EAAOpC,EAAK+wD,EAAWC,GACjD,IAAKD,EAAU50D,OAAOyB,aAElBoC,EAAMoC,GAAS4uD,EAAQ9zD,IAAM6zD,EAAU7zD,KAEvC+zD,GAAsBF,GAAW,GAAM,GAASC,EAAQ9zD,IACxD,OAAO,EAEX,IAAI+H,EAAS6rD,EAAI/zD,QAAQqF,GAEzB,GAAI6C,EAAO3J,aAAe2J,EAAO9I,OAAOC,QAAQC,OAAS4I,EAAO9I,OAAOyB,YACnE,OAAO,EACX,IAAIszD,EAAQJ,EAAI/zD,QAAQk0D,GAAsBhsD,GAAQ,GAAM,IAE5D,IAAKisD,EAAM/0D,OAAOyB,aAAeszD,EAAMh0D,IAAM8C,GACzCixD,GAAsBC,GAAO,GAAM,GAASlxD,EAC5C,OAAO,EAGX,OAAO+wD,EAAU50D,OAAOC,QAAQo5B,IAAIu7B,EAAUz1D,cAAcmT,GAAGyiD,EAAM/0D,OAAOC,SA9HxE+0D,CAAc30D,EAAKo0B,EAAOxuB,MAAOwuB,EAAOy/B,KAAM1wD,EAAOC,IACrDzE,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,EAAG,iBACvElqC,EAAOwoC,SAAWxoC,EAAO+gB,QAAUl3B,EAAK8wD,YAAYmF,+BAH1D,CAUI9/C,EAAO+gB,QAAU/gB,EAAOwoC,SAAWlpB,EAAOygC,KAAOzgC,EAAOh0B,OACxDzB,EAAKm2D,kBAAoB1jB,KAAKC,OAU9Bv8B,EAAOwoC,UAAY+W,GAAgBlxD,EAAMyC,SAAWxC,EAAIwC,SAA+B,GAApBxC,EAAItE,cAAqBqE,EAAMtC,OAASuC,EAAIvC,OAC/GsS,EAAMjQ,KAAOiQ,EAAMjQ,IAAIssC,QAAUr8B,EAAMjQ,IAAI+kC,MAAQ90B,EAAMjQ,IAAI+kC,MAAQ7T,EAAOy/B,OAC9Ez/B,EAAO0/B,MAAQ,EACf1wD,EAAM+P,EAAMnT,IAAI47B,eAAexH,EAAO0/B,KAAO3gD,EAAM/S,MACnD4kB,YAAW,WACTrmB,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,GAAI,eACzE,KAGL,IAEIxgD,EAAI0T,EAAa6iD,EAAYC,EAF7BC,EAAS7gC,EAAOxuB,MAAOsvD,EAAO9gC,EAAOy/B,KAGzC,GAAIQ,EACF,GAAIlxD,EAAMzC,KAAO0C,EAAI1C,IAGfoU,EAAOohB,IAAMphB,EAAOkoC,YAAc,IAA4B,GAAtB75C,EAAMrE,eAChDH,EAAK8wD,YAAYmF,2BACjB5vC,YAAW,WAAc,OAAOoqC,GAAezwD,KAAU,KAE3DH,EAAKG,EAAKP,MAAMI,GAAGsC,OAAOm0D,EAAQC,GAClChjD,EAAclS,EAAIO,QAAQ6zB,EAAOxuB,OAAO23B,YAAYv9B,EAAIO,QAAQ6zB,EAAOy/B,YAClE,GACLz/B,EAAOy/B,MAAQz/B,EAAO0/B,OAASkB,EAASh1D,EAAIO,QAAQ6zB,EAAOxuB,UAC1DmvD,EA0CP,SAAsBl0B,EAAKlc,GAGzB,IAFA,IAC2CplB,EAAM0Q,EAAMmnB,EADnD+9B,EAAWt0B,EAAI3/B,WAAWkO,MAAOgmD,EAAYzwC,EAAKzjB,WAAWkO,MAC7DiqC,EAAQ8b,EAAU/b,EAAUgc,EACvB1zD,EAAI,EAAGA,EAAI0zD,EAAUtwD,OAAQpD,IAAO23C,EAAQ+b,EAAU1zD,GAAGg5B,cAAc2e,GAChF,IAAK,IAAI5zC,EAAM,EAAGA,EAAM0vD,EAASrwD,OAAQW,IAAS2zC,EAAU+b,EAAS1vD,GAAKi1B,cAAc0e,GACxF,GAAoB,GAAhBC,EAAMv0C,QAAiC,GAAlBs0C,EAAQt0C,OAC/BmL,EAAOopC,EAAM,GACb95C,EAAO,MACP63B,EAAS,SAAUr2B,GAAQ,OAAOA,EAAKkP,KAAKA,EAAKqqB,SAASv5B,EAAKqO,aAC1D,IAAoB,GAAhBiqC,EAAMv0C,QAAiC,GAAlBs0C,EAAQt0C,OAKtC,OAAO,KAJPmL,EAAOmpC,EAAQ,GACf75C,EAAO,SACP63B,EAAS,SAAUr2B,GAAQ,OAAOA,EAAKkP,KAAKA,EAAKyqB,cAAc35B,EAAKqO,SAKtE,IADA,IAAIoiC,EAAU,GACLxpC,EAAM,EAAGA,EAAM2c,EAAKtjB,WAAY2G,IAASwpC,EAAQnsC,KAAK+xB,EAAOzS,EAAKzc,MAAMF,KACjF,GAAI,UAAcwpC,GAASv/B,GAAG4uB,GAAQ,MAAO,CAAC5wB,KAAMA,EAAM1Q,KAAMA,GA5D9C81D,CAAalyD,EAAMxD,OAAOC,QAAQo5B,IAAI71B,EAAMrE,aAAcsE,EAAItE,cACjDk2D,EAAOr1D,OAAOC,QAAQo5B,IAAIg8B,EAAOl2D,aAAcs1B,EAAOy/B,KAAOmB,EAAOpvD,WAE/FpH,EAAKG,EAAKP,MAAMI,GACO,OAAnBu2D,EAAWx1D,KAAiBf,EAAG6Y,QAAQ49C,EAAQC,EAAMH,EAAW9kD,MAC7DzR,EAAGkgB,WAAWu2C,EAAQC,EAAMH,EAAW9kD,WACzC,GAAI9M,EAAMxD,OAAOuI,MAAM/E,EAAMxB,SAASkK,QAAU1I,EAAMxB,SAAWyB,EAAIzB,SAAWyB,EAAIq5B,WAAa,EAAI,GAAI,CAE9G,IAAImI,EAASzhC,EAAMxD,OAAOyiB,YAAYjf,EAAMrE,aAAcsE,EAAItE,cAC9D,GAAIH,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMs2D,EAAQC,EAAMtwB,MAAe,OAChGpmC,EAAKG,EAAKP,MAAMI,GAAG4D,WAAWwiC,EAAQqwB,EAAQC,GAMlD,GAFK12D,IACDA,EAAKG,EAAKP,MAAMI,GAAG6c,QAAQ45C,EAAQC,EAAM/hD,EAAMnT,IAAIE,MAAMk0B,EAAOxuB,MAAQuN,EAAM/S,KAAMg0B,EAAO0/B,KAAO3gD,EAAM/S,QACxG+S,EAAMjQ,IAAK,CACb,IAAIoyD,EAAQpB,GAAiBv1D,EAAMH,EAAGwB,IAAKmT,EAAMjQ,KAM7CoyD,KAAWxgD,EAAO+gB,QAAU/gB,EAAOwoC,SAAW3+C,EAAKqlB,WAAasxC,EAAM/2D,QAC5D61B,EAAOxuB,OAASwuB,EAAO0/B,MAAQn1D,EAAKm2D,kBAAoB1jB,KAAKC,MAAQ,OACrEikB,EAAMrtB,MAAQgtB,GAAUK,EAAMrtB,MAAQzpC,EAAGgC,QAAQC,IAAIy0D,GAAQ,IAC9DpgD,EAAOohB,IAAMo/B,EAAM/2D,OAAS+2D,EAAMrtB,MAAQgtB,IACnDz2D,EAAG8B,aAAag1D,GAElBpjD,GAAe1T,EAAG4b,YAAYlI,GAClCvT,EAAKN,SAASG,EAAGC,oBAGnB,SAASy1D,GAAiBv1D,EAAMqB,EAAKu1D,GACnC,OAAIzpD,KAAKC,IAAIwpD,EAAU/lB,OAAQ+lB,EAAUttB,MAAQjoC,EAAIJ,QAAQC,KAAe,KACrEovD,GAAiBtwD,EAAMqB,EAAIO,QAAQg1D,EAAU/lB,QAASxvC,EAAIO,QAAQg1D,EAAUttB,OAkDrF,SAASwsB,GAAsBhzD,EAAM+zD,EAASC,GAE5C,IADA,IAAI50D,EAAQY,EAAKZ,MAAO2C,EAAMgyD,EAAU/zD,EAAK+B,MAAQ/B,EAAKf,IACnDG,EAAQ,IAAM20D,GAAW/zD,EAAKmB,WAAW/B,IAAUY,EAAKV,KAAKF,GAAOQ,aACzER,IACA2C,IACAgyD,GAAU,EAEZ,GAAIC,EAEF,IADA,IAAIj4B,EAAO/7B,EAAKV,KAAKF,GAAOw4B,WAAW53B,EAAKmB,WAAW/B,IAChD28B,IAASA,EAAKtM,QACnBsM,EAAOA,EAAKt8B,WACZsC,IAGJ,OAAOA,EA2BT,SAASkyD,GAAsB/2D,EAAMuB,GAKnC,IAJA,IAAI8J,EAAU,GACVpK,EAAUM,EAAMN,QAChBo7B,EAAY96B,EAAM86B,UAClBC,EAAU/6B,EAAM+6B,QACbD,EAAY,GAAKC,EAAU,GAA2B,GAAtBr7B,EAAQyB,YAAoD,GAAjCzB,EAAQsB,WAAWG,YAAiB,CACpG25B,IACAC,IACA,IAAIl6B,EAAOnB,EAAQsB,WACnB8I,EAAQ3E,KAAKtE,EAAKxB,KAAKmL,KAAM3J,EAAKkF,OAASlF,EAAKxB,KAAK8+B,aAAet9B,EAAKkF,MAAQ,MACjFrG,EAAUmB,EAAKnB,QAGjB,IAAI+1D,EAAah3D,EAAKgX,SAAS,wBAA0B,gBAAyBhX,EAAKP,MAAM6N,QACzFjM,EAAM41D,KAAe/wD,EAAO7E,EAAIojB,cAAc,OAClDve,EAAKwe,YAAYsyC,EAAW3yC,kBAAkBpjB,EAAS,CAACwR,SAAUpR,KAGlE,IADA,IAAkCwsD,EAA9BtrD,EAAa2D,EAAK3D,WACfA,GAAqC,GAAvBA,EAAW8E,WAAkBwmD,EAAYqJ,GAAQ30D,EAAWkoC,SAASC,iBAAiB,CACzG,IAAK,IAAI3nC,EAAI8qD,EAAU1nD,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAE9C,IADA,IAAIo0D,EAAU91D,EAAIojB,cAAcopC,EAAU9qD,IACnCmD,EAAK3D,YAAc40D,EAAQzyC,YAAYxe,EAAK3D,YACnD2D,EAAKwe,YAAYyyC,GACG,SAAhBtJ,EAAU9qD,KACZs5B,IACAC,KAGJ/5B,EAAa2D,EAAK3D,WASpB,OANIA,GAAqC,GAAvBA,EAAW8E,UACzB9E,EAAWusB,aAAa,gBAAkBuN,EAAY,IAAMC,EAAU,IAAOvX,KAAKC,UAAU3Z,IAKzF,CAACmD,IAAKtI,EAAM4G,KAHR9M,EAAKgX,SAAS,2BAA2B,SAAUC,GAAK,OAAOA,EAAE1V,OACxEA,EAAMN,QAAQwiB,YAAY,EAAGliB,EAAMN,QAAQC,KAAM,SAOvD,SAASk2D,GAAmBp3D,EAAM8M,EAAM4a,EAAM2vC,EAAWroB,GACvD,IAAIxgC,EAA8CjN,EAAzC+1D,EAAStoB,EAAShuC,OAAOJ,KAAKC,KAAK0C,KAC5C,IAAKmkB,IAAS5a,EAAQ,OAAO,KAC7B,IAAIyqD,EAASzqD,IAASuqD,GAAaC,IAAW5vC,GAC9C,GAAI6vC,EAAQ,CAEV,GADAv3D,EAAKgX,SAAS,uBAAuB,SAAUC,GAAKnK,EAAOmK,EAAEnK,EAAMwqD,GAAUD,MACzEC,EAAU,OAAOxqD,EAAO,IAAI,KAAM,UAAc9M,EAAKP,MAAM6N,OAAOR,KAAKA,EAAK4P,QAAQ,SAAU,QAAS,EAAG,GAAK,WACnH,IAAI86C,EAASx3D,EAAKgX,SAAS,uBAAuB,SAAUC,GAAK,OAAOA,EAAEnK,EAAMkiC,EAAUqoB,MAC1F,GAAIG,EACFj2D,EAAQi2D,MACH,CACL,IAAI/mD,EAAQu+B,EAASv+B,QAEjBnD,EADMtN,EAAKP,MACE6N,OACb0pD,EAAa,gBAAyB1pD,GAC1CkB,EAAMiE,SAASgS,cAAc,OAC7B3X,EAAKhI,MAAM,iBAAiBmG,SAAQ,SAAUojC,GAC5C,IAAI1T,EAAInsB,EAAIkW,YAAYjS,SAASgS,cAAc,MAC3C4pB,GAAS1T,EAAEjW,YAAYsyC,EAAWjnB,cAAcziC,EAAOR,KAAKuhC,EAAO59B,cAI3EzQ,EAAKgX,SAAS,uBAAuB,SAAUC,GAAKyQ,EAAOzQ,EAAEyQ,MAC7DlZ,EA4IJ,SAAkBkZ,GAChB,IAAI+vC,EAAQ,sBAAsBhyC,KAAKiC,GACnC+vC,IAAS/vC,EAAOA,EAAKnmB,MAAMk2D,EAAM,GAAGtxD,SACxC,IAC8CD,EAD1C69C,EAAMkT,KAAcxyC,cAAc,OAClCizC,EAAW,mBAAmBjyC,KAAKiC,IACnCxhB,EAAOwxD,GAAYR,GAAQQ,EAAS,GAAGhtB,kBACvChjB,EAAOxhB,EAAKpE,KAAI,SAAU6a,GAAK,MAAO,IAAMA,EAAI,OAAQ/W,KAAK,IAAM8hB,EAAOxhB,EAAKpE,KAAI,SAAU6a,GAAK,MAAO,KAAOA,EAAI,OAAQmH,UAAUle,KAAK,KAE/I,GADAm+C,EAAIp/B,UAAY+C,EACZxhB,EAAQ,IAAK,IAAInD,EAAI,EAAGA,EAAImD,EAAKC,OAAQpD,IAAOghD,EAAMA,EAAIn1B,cAAc1oB,EAAKnD,KAAOghD,EACxF,OAAOA,EArJC4T,CAASjwC,GACXvR,EAAOyoC,QA4Jf,SAA+BpwC,GAE7B,IADA,IAAIf,EAAQe,EAAIopD,iBAAiBzhD,EAAO+gB,OAAS,iCAAmC,8BAC3En0B,EAAI,EAAGA,EAAI0K,EAAMtH,OAAQpD,IAAK,CACrC,IAAIX,EAAOqL,EAAM1K,GACa,GAA1BX,EAAK4rC,WAAW7nC,QAAmC,KAApB/D,EAAKmgB,aAA2BngB,EAAKooC,YACpEpoC,EAAKooC,WAAWjQ,aAAa/rB,EAAIg/B,cAAcC,eAAe,KAAMrrC,IAjKnDy1D,CAAsBrpD,GAG7C,IAAIspD,EAActpD,GAAOA,EAAIogB,cAAc,mBACvCmpC,EAAYD,GAAe,oBAAoBryC,KAAKqyC,EAAYtuC,aAAa,kBACjF,IAAKjoB,EAAO,CACV,IAAI+S,EAAStU,EAAKgX,SAAS,oBAAsBhX,EAAKgX,SAAS,cAAgB,gBAAqBhX,EAAKP,MAAM6N,QAC/G/L,EAAQ+S,EAAOC,WAAW/F,EAAK,CAC7BmG,sBAAuB4iD,IAAUQ,GACjC1sD,QAAS2jC,EACTlC,aAAc,SAAsBt+B,GAClC,GAAoB,MAAhBA,EAAIi8B,WAAqBj8B,EAAIo+B,aAC7Bp+B,EAAIg8B,aAAewtB,GAAc1vD,KAAKkG,EAAIg8B,WAAWC,UAAa,MAAO,CAACsC,QAAQ,MAI5F,GAAIgrB,EACFx2D,EAoJJ,SAAoBA,EAAO8J,GACzB,IAAK9J,EAAML,KAAQ,OAAOK,EAC1B,IAAmD6zB,EAA/C9nB,EAAS/L,EAAMN,QAAQsB,WAAW3B,KAAK0M,OAC3C,IAAM8nB,EAAQrQ,KAAKvQ,MAAMnJ,GACzB,MAAM/B,GAAK,OAAO/H,EAIlB,IAHA,IAAIN,EAAUM,EAAMN,QAChBo7B,EAAY96B,EAAM86B,UAClBC,EAAU/6B,EAAM+6B,QACXv5B,EAAIqyB,EAAMjvB,OAAS,EAAGpD,GAAK,EAAGA,GAAK,EAAG,CAC7C,IAAInC,EAAO0M,EAAOG,MAAM2nB,EAAMryB,IAC9B,IAAKnC,GAAQA,EAAKkD,mBAAsB,MACxC7C,EAAU,UAAcL,EAAKwF,OAAOgvB,EAAMryB,EAAI,GAAI9B,IAClDo7B,IAAaC,IAEf,OAAO,IAAI,KAAMr7B,EAASo7B,EAAWC,GAlK3B27B,CAAWC,GAAW32D,GAAQw2D,EAAU,IAAKA,EAAU,IAAKA,EAAU,SAG9E,GADAx2D,EAAQ,aAyBZ,SAA2B4iB,EAAU6qB,GACnC,GAAI7qB,EAASzhB,WAAa,EAAK,OAAOyhB,EAsBtC,IArBA,IAAI6d,EAAO,SAAW3lB,GACpB,IACI1Y,EADSqrC,EAAS5sC,KAAKia,GACRnY,eAAe8qC,EAAShsC,MAAMqZ,IAC7C87C,OAAW,EAAUhiD,EAAS,GAelC,GAdAgO,EAASlZ,SAAQ,SAAU7I,GACzB,GAAK+T,EAAL,CACA,IAA0CiiD,EAAtClyD,EAAOvC,EAAMoC,aAAa3D,EAAKxB,MACnC,IAAKsF,EAAQ,OAAOiQ,EAAS,KAC7B,GAAIiiD,EAASjiD,EAAOhQ,QAAUgyD,EAAShyD,QAAUkyD,GAAanyD,EAAMiyD,EAAU/1D,EAAM+T,EAAOA,EAAOhQ,OAAS,GAAI,GAC7GgQ,EAAOA,EAAOhQ,OAAS,GAAKiyD,MACvB,CACDjiD,EAAOhQ,SAAUgQ,EAAOA,EAAOhQ,OAAS,GAAKmyD,GAAWniD,EAAOA,EAAOhQ,OAAS,GAAIgyD,EAAShyD,SAChG,IAAIoyD,EAAUC,GAAap2D,EAAM8D,GACjCiQ,EAAOzP,KAAK6xD,GACZ50D,EAAQA,EAAMqC,UAAUuyD,EAAQ33D,KAAM23D,EAAQjxD,OAC9C6wD,EAAWjyD,OAGXiQ,EAAU,MAAO,CAAEq1B,EAAG,UAAcr1B,KAGjCkG,EAAI2yB,EAAS9sC,MAAOma,GAAK,EAAGA,IAAK,CACxC,IAAIovB,EAAWzJ,EAAM3lB,GAErB,GAAKovB,EAAW,OAAOA,EAASD,EAElC,OAAOrnB,EArDiBs0C,CAAkBl3D,EAAMN,QAAS+tC,IAAW,GAC9DztC,EAAM86B,WAAa96B,EAAM+6B,QAAS,CAEpC,IADA,IAAID,EAAY,EAAGC,EAAU,EACpBl6B,EAAOb,EAAMN,QAAQsB,WAAY85B,EAAY96B,EAAM86B,YAAcj6B,EAAKxB,KAAKC,KAAKC,UACpFu7B,IAAaj6B,EAAOA,EAAKG,YAC9B,IAAK,IAAIm2D,EAASn3D,EAAMN,QAAQuB,UAAW85B,EAAU/6B,EAAM+6B,UAAYo8B,EAAO93D,KAAKC,KAAKC,UACnFw7B,IAAWo8B,EAASA,EAAOl2D,WAChCjB,EAAQ22D,GAAW32D,EAAO86B,EAAWC,GAKzC,OADAt8B,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK1V,EAAQ0V,EAAE1V,MACnDA,EAGT,IAAIy2D,GAAgB,gHAyCpB,SAASQ,GAAap2D,EAAM8D,EAAMzE,QAClB,IAATA,IAAkBA,EAAO,GAE9B,IAAK,IAAIsB,EAAImD,EAAKC,OAAS,EAAGpD,GAAKtB,EAAMsB,IACrCX,EAAO8D,EAAKnD,GAAGqD,OAAO,KAAM,UAAchE,IAC9C,OAAOA,EAKT,SAASi2D,GAAanyD,EAAMiyD,EAAU/1D,EAAMu2D,EAASz2D,GACnD,GAAIA,EAAQgE,EAAKC,QAAUjE,EAAQi2D,EAAShyD,QAAUD,EAAKhE,IAAUi2D,EAASj2D,GAAQ,CACpF,IAAIgZ,EAAQm9C,GAAanyD,EAAMiyD,EAAU/1D,EAAMu2D,EAAQn2D,UAAWN,EAAQ,GAC1E,GAAIgZ,EAAS,OAAOy9C,EAAQtyD,KAAKsyD,EAAQ13D,QAAQs5B,aAAao+B,EAAQj2D,WAAa,EAAGwY,IAEtF,GADYy9C,EAAQz0D,eAAey0D,EAAQj2D,YACjCsD,UAAU9D,GAASgE,EAAKC,OAAS,EAAI/D,EAAKxB,KAAOsF,EAAKhE,EAAQ,IACpE,OAAOy2D,EAAQtyD,KAAKsyD,EAAQ13D,QAAQiJ,OAAO,UAAcsuD,GAAap2D,EAAM8D,EAAMhE,EAAQ,OAIlG,SAASo2D,GAAWl2D,EAAMF,GACxB,GAAa,GAATA,EAAc,OAAOE,EACzB,IAAI+hB,EAAW/hB,EAAKnB,QAAQs5B,aAAan4B,EAAKM,WAAa,EAAG41D,GAAWl2D,EAAKI,UAAWN,EAAQ,IAC7FgoC,EAAO9nC,EAAK8B,eAAe9B,EAAKM,YAAYggC,WAAW,YAAgB,GAC3E,OAAOtgC,EAAKiE,KAAK8d,EAASja,OAAOggC,IAGnC,SAAS0uB,GAAWz0C,EAAU9hB,EAAMZ,EAAMD,EAAIU,EAAOo6B,GACnD,IAAIl6B,EAAOC,EAAO,EAAI8hB,EAAS5hB,WAAa4hB,EAAS3hB,UAAW0Y,EAAQ9Y,EAAKnB,QAK7E,OAJIiB,EAAQV,EAAK,IAAK0Z,EAAQ09C,GAAW19C,EAAO7Y,EAAMZ,EAAMD,EAAIU,EAAQ,EAAGo6B,IACvEp6B,GAAST,IACTyZ,EAAQ7Y,EAAO,EAAID,EAAK8B,eAAe,GAAGw+B,WAAWxnB,EAAOiJ,EAASzhB,WAAa,GAAK45B,GAAWp6B,GAAOgI,OAAOgR,GAC9GA,EAAMhR,OAAO9H,EAAK8B,eAAe9B,EAAKM,YAAYggC,WAAW,YAAgB,KAC5Eve,EAASoW,aAAal4B,EAAO,EAAI,EAAI8hB,EAASzhB,WAAa,EAAGN,EAAKiE,KAAK6U,IAGjF,SAASg9C,GAAW32D,EAAO86B,EAAWC,GAKpC,OAJID,EAAY96B,EAAM86B,YAClB96B,EAAQ,IAAI,KAAMq3D,GAAWr3D,EAAMN,SAAU,EAAGo7B,EAAW96B,EAAM86B,UAAW,EAAG96B,EAAM+6B,SAAUD,EAAW96B,EAAM+6B,UAChHA,EAAU/6B,EAAM+6B,UAChB/6B,EAAQ,IAAI,KAAMq3D,GAAWr3D,EAAMN,QAAS,EAAGq7B,EAAS/6B,EAAM+6B,QAAS,EAAG,GAAI/6B,EAAM86B,UAAWC,IAC5F/6B,EAMT,IAAI21D,GAAU,CACZ2B,MAAO,CAAC,SACRC,MAAO,CAAC,SACR3vB,MAAO,CAAC,SACR4vB,QAAS,CAAC,SACVC,SAAU,CAAC,SACXC,IAAK,CAAC,QAAS,YACfp5D,GAAI,CAAC,QAAS,SACdq5D,GAAI,CAAC,QAAS,QAAS,MACvBC,GAAI,CAAC,QAAS,QAAS,OAGrBC,GAAe,KACnB,SAASnC,KACP,OAAOmC,KAAiBA,GAAe3mD,SAAS8R,eAAeC,mBAAmB,UA8CpF,IAAI60C,GAAiB,CACnBC,WAAW,EACXC,eAAe,EACfC,uBAAuB,EACvBvoD,YAAY,EACZwoD,mBAAmB,EACnBC,SAAS,GAGPC,GAAcxjD,EAAOohB,IAAMphB,EAAOkoC,YAAc,GAEhDub,GAAiB,WACnB9tD,KAAKi9C,WAAaj9C,KAAKk9C,aAAel9C,KAAKs6C,UAAYt6C,KAAKw6C,YAAc,MAG5EsT,GAAervD,UAAUqxB,IAAM,SAAcr3B,GAC3CuH,KAAKi9C,WAAaxkD,EAAIwkD,WAAYj9C,KAAKk9C,aAAezkD,EAAIykD,aAC1Dl9C,KAAKs6C,UAAY7hD,EAAI6hD,UAAWt6C,KAAKw6C,YAAc/hD,EAAI+hD,aAGzDsT,GAAervD,UAAU+I,GAAK,SAAa/O,GACzC,OAAOA,EAAIwkD,YAAcj9C,KAAKi9C,YAAcxkD,EAAIykD,cAAgBl9C,KAAKk9C,cACnEzkD,EAAI6hD,WAAat6C,KAAKs6C,WAAa7hD,EAAI+hD,aAAex6C,KAAKw6C,aAG/D,IAAIuT,GAAc,SAAqB75D,EAAM85D,GAC3C,IAAI5zB,EAASp6B,KAEbA,KAAK9L,KAAOA,EACZ8L,KAAKguD,gBAAkBA,EACvBhuD,KAAKiuD,MAAQ,GACbjuD,KAAKkuD,cAAgB,EACrBluD,KAAKmuD,SAAWxrD,OAAOyrD,kBACrB,IAAIzrD,OAAOyrD,kBAAiB,SAAUC,GACpC,IAAK,IAAIp3D,EAAI,EAAGA,EAAIo3D,EAAUh0D,OAAQpD,IAAOmjC,EAAO6zB,MAAMrzD,KAAKyzD,EAAUp3D,IAKrEoT,EAAOohB,IAAMphB,EAAOkoC,YAAc,IAAM8b,EAAUh3C,MACpD,SAAUmd,GAAK,MAAiB,aAAVA,EAAE1/B,MAAuB0/B,EAAE7N,aAAatsB,QAC/C,iBAAVm6B,EAAE1/B,MAA2B0/B,EAAE0pB,SAAS7jD,OAASm6B,EAAE9/B,OAAO2rC,UAAUhmC,UACvE+/B,EAAOk0B,YAEPl0B,EAAOm0B,WAEfvuD,KAAKilD,iBAAmB,IAAI6I,GACxBD,KACF7tD,KAAKwuD,WAAa,SAAUhxD,GAC1B48B,EAAO6zB,MAAMrzD,KAAK,CAAClG,OAAQ8I,EAAE9I,OAAQI,KAAM,gBAAiBopD,SAAU1gD,EAAEixD,YACxEr0B,EAAOk0B,cAGXtuD,KAAK0uD,kBAAoB1uD,KAAK0uD,kBAAkBjvD,KAAKO,MACrDA,KAAK2uD,6BAA8B,GAGrCZ,GAAYtvD,UAAU6vD,UAAY,WAC9B,IAAIl0B,EAASp6B,KAEXA,KAAKkuD,aAAe,IACpBluD,KAAKkuD,aAAevrD,OAAO4X,YAAW,WAAc6f,EAAO8zB,cAAgB,EAAG9zB,EAAOm0B,UAAY,MAGvGR,GAAYtvD,UAAUmwD,WAAa,WAC7B5uD,KAAKkuD,cAAgB,IACvBvrD,OAAOksD,aAAa7uD,KAAKkuD,cACzBluD,KAAKkuD,cAAgB,EACrBluD,KAAKuuD,UAITR,GAAYtvD,UAAUtD,MAAQ,WACxB6E,KAAKmuD,UACLnuD,KAAKmuD,SAASW,QAAQ9uD,KAAK9L,KAAKwO,IAAK6qD,IACrCM,IACA7tD,KAAK9L,KAAKwO,IAAI6Y,iBAAiB,2BAA4Bvb,KAAKwuD,YACpExuD,KAAKgmD,oBAGP+H,GAAYtvD,UAAUo/C,KAAO,WACzB,IAAIzjB,EAASp6B,KAEf,GAAIA,KAAKmuD,SAAU,CACjB,IAAIY,EAAO/uD,KAAKmuD,SAASa,cACzB,GAAID,EAAK10D,OAAQ,CACf,IAAK,IAAIpD,EAAI,EAAGA,EAAI83D,EAAK10D,OAAQpD,IAAO+I,KAAKiuD,MAAMrzD,KAAKm0D,EAAK93D,IAC7D0L,OAAO4X,YAAW,WAAc,OAAO6f,EAAOm0B,UAAY,IAE5DvuD,KAAKmuD,SAASc,aAEZpB,IAAe7tD,KAAK9L,KAAKwO,IAAI+Y,oBAAoB,2BAA4Bzb,KAAKwuD,YACtFxuD,KAAKolD,uBAGP2I,GAAYtvD,UAAUunD,iBAAmB,WACvChmD,KAAK9L,KAAKwO,IAAIg/B,cAAcnmB,iBAAiB,kBAAmBvb,KAAK0uD,oBAGvEX,GAAYtvD,UAAU2mD,oBAAsB,WAC1CplD,KAAK9L,KAAKwO,IAAIg/B,cAAcjmB,oBAAoB,kBAAmBzb,KAAK0uD,oBAG1EX,GAAYtvD,UAAU0rD,yBAA2B,WAC7C,IAAI/vB,EAASp6B,KAEfA,KAAK2uD,6BAA8B,EACnCp0C,YAAW,WAAc,OAAO6f,EAAOu0B,6BAA8B,IAAU,KAGjFZ,GAAYtvD,UAAUiwD,kBAAoB,WACxC,MA9+B4Bx6D,EA8+BF8L,KAAK9L,MA7+BtB0gB,UAAY1gB,EAAKgkD,KAAK0B,eAAiB1lD,EAAKwO,MAC9CgiD,GAAaxwD,GA4+BpB,CA9+BF,IAA8BA,EA++B5B,GAAI8L,KAAK2uD,4BAA+B,OAAOhK,GAAe3kD,KAAK9L,MAInE,GAAImW,EAAOohB,IAAMphB,EAAOkoC,YAAc,KAAOvyC,KAAK9L,KAAKP,MAAME,UAAUC,MAAO,CAC5E,IAAI2E,EAAMuH,KAAK9L,KAAKgkD,KAAKt1C,eAEzB,GAAInK,EAAI6hD,WAAa7G,EAAqBh7C,EAAI6hD,UAAW7hD,EAAI+hD,YAAa/hD,EAAIwkD,WAAYxkD,EAAIykD,cAC1F,OAAOl9C,KAAKsuD,YAElBtuD,KAAKuuD,UAGPR,GAAYtvD,UAAU0mD,gBAAkB,WACtCnlD,KAAKilD,iBAAiBn1B,IAAI9vB,KAAK9L,KAAKgkD,KAAKt1C,iBAG3CmrD,GAAYtvD,UAAUywD,sBAAwB,SAAgCz2D,GAC5E,GAAsB,GAAlBA,EAAI47C,WAAmB,OAAO,EAClC,IAAI77B,EAAY/f,EAAI67C,WAAW,GAAG6a,wBAC9B3nB,EAAOxnC,KAAK9L,KAAKkwB,QAAQk0B,YAAY9/B,GACzC,OAAIgvB,GAAQA,EAAK7iB,eAAe,CAAC7vB,KAAM,YAAaJ,OAA8B,GAAtB8jB,EAAUjd,SAAgBid,EAAUkmB,WAAalmB,KAC3GxY,KAAKmlD,mBACE,QAFT,GAMF4I,GAAYtvD,UAAU8vD,MAAQ,WAC5B,GAAKvuD,KAAK9L,KAAKkwB,WAAWpkB,KAAKkuD,cAAgB,GAA/C,CACA,IAAIG,EAAYruD,KAAKmuD,SAAWnuD,KAAKmuD,SAASa,cAAgB,GAC1DhvD,KAAKiuD,MAAM5zD,SACbg0D,EAAYruD,KAAKiuD,MAAMhhC,OAAOohC,GAC9BruD,KAAKiuD,MAAM5zD,OAAS,GAGtB,IAAI5B,EAAMuH,KAAK9L,KAAKgkD,KAAKt1C,eACrB0lD,GAAUtoD,KAAK2uD,8BAAgC3uD,KAAKilD,iBAAiBz9C,GAAG/O,IAAQisD,GAAa1kD,KAAK9L,QAAU8L,KAAKkvD,sBAAsBz2D,GAEvI9C,GAAQ,EAAGD,GAAM,EAAGyyD,GAAW,EAAOvZ,EAAQ,GAClD,GAAI5uC,KAAK9L,KAAK0gB,SACZ,IAAK,IAAI3d,EAAI,EAAGA,EAAIo3D,EAAUh0D,OAAQpD,IAAK,CACzC,IAAIm4D,EAAWpvD,KAAKqvD,iBAAiBhB,EAAUp3D,GAAI23C,GAC/CwgB,IACFz5D,EAAOA,EAAO,EAAIy5D,EAASz5D,KAAO0L,KAAKc,IAAIitD,EAASz5D,KAAMA,GAC1DD,EAAKA,EAAK,EAAI05D,EAAS15D,GAAK2L,KAAKC,IAAI8tD,EAAS15D,GAAIA,GAC9C05D,EAASjH,WAAYA,GAAW,IAK1C,GAAI99C,EAAOkhB,OAASqjB,EAAMv0C,OAAS,EAAG,CACpC,IAAIi1D,EAAM1gB,EAAMhtC,QAAO,SAAUiP,GAAK,MAAqB,MAAdA,EAAE8tB,YAC/C,GAAkB,GAAd2wB,EAAIj1D,OAAa,CACnB,IAAImmB,EAAI8uC,EAAI,GACNnzC,EAAImzC,EAAI,GACV9uC,EAAEke,YAAcle,EAAEke,WAAWA,YAAcviB,EAAEuiB,WAAcviB,EAAE2Q,SAC1DtM,EAAEsM,WAITn3B,GAAQ,GAAK2yD,KACX3yD,GAAQ,IACVqK,KAAK9L,KAAKkwB,QAAQk5B,UAAU3nD,EAAMD,GA6DxC,SAAkBxB,GAChB,GAAIq7D,GAAc,OAClBA,IAAa,EACgC,UAAzCnO,iBAAiBltD,EAAKwO,KAAK8sD,YAC3BrvD,QAAc,KAAE,4KAhEhBsvD,CAASzvD,KAAK9L,OAEhB8L,KAAKguD,gBAAgBr4D,EAAMD,EAAIyyD,EAAUvZ,GACrC5uC,KAAK9L,KAAKkwB,SAAWpkB,KAAK9L,KAAKkwB,QAAQ22B,MAAS/6C,KAAK9L,KAAKkvB,YAAYpjB,KAAK9L,KAAKP,OAC1EqM,KAAKilD,iBAAiBz9C,GAAG/O,IAAQksD,GAAe3kD,KAAK9L,MAC/D8L,KAAKilD,iBAAiBn1B,IAAIr3B,MAI9Bs1D,GAAYtvD,UAAU4wD,iBAAmB,SAA2BpR,EAAKrP,GAEvE,GAAIA,EAAMzuB,QAAQ89B,EAAIvpD,SAAW,EAAK,OAAO,KAC7C,IAAI8yC,EAAOxnC,KAAK9L,KAAKkwB,QAAQk0B,YAAY2F,EAAIvpD,QAC7C,GAAgB,cAAZupD,EAAInpD,OACH0yC,GAAQxnC,KAAK9L,KAAKkwB,SAAgC,mBAArB65B,EAAIyR,eAEX,SAArBzR,EAAIyR,gBAA6BzR,EAAIC,WAAaD,EAAIvpD,OAAOgpB,aAAa,UAC5E,OAAO,KACX,IAAK8pB,GAAQA,EAAK7iB,eAAes5B,GAAQ,OAAO,KAEhD,GAAgB,aAAZA,EAAInpD,KAAqB,CAC3B,IAAK,IAAImC,EAAI,EAAGA,EAAIgnD,EAAIv3B,WAAWrsB,OAAQpD,IAAO23C,EAAMh0C,KAAKqjD,EAAIv3B,WAAWzvB,IAC5E,GAAIuwC,EAAK3iB,YAAc2iB,EAAK3iB,YAAc2iB,EAAK9kC,MAAQ8kC,EAAK3iB,WAAWvJ,SAAS2iC,EAAIvpD,QAChF,MAAO,CAACiB,KAAM6xC,EAAK+Q,UAAW7iD,GAAI8xC,EAAKgR,UAC3C,IAAIt+B,EAAO+jC,EAAI1d,gBAAiBxN,EAAOkrB,EAAInd,YAC3C,GAAIz2B,EAAOohB,IAAMphB,EAAOkoC,YAAc,IAAM0L,EAAIv3B,WAAWrsB,OAGzD,IAAK,IAAIW,EAAM,EAAGA,EAAMijD,EAAIv3B,WAAWrsB,OAAQW,IAAO,CACpD,IAAIlE,EAAMmnD,EAAIv3B,WAAW1rB,GACnBulC,EAAkBzpC,EAAIypC,gBACtBO,EAAchqC,EAAIgqC,cACnBP,GAAmBp6B,MAAM1H,UAAU0hB,QAAQxhB,KAAKs/C,EAAIv3B,WAAY6Z,GAAmB,KAAKrmB,EAAOqmB,KAC/FO,GAAe36B,MAAM1H,UAAU0hB,QAAQxhB,KAAKs/C,EAAIv3B,WAAYoa,GAAe,KAAK/N,EAAO+N,GAGhG,IAAIyb,EAAariC,GAAQA,EAAKwkB,YAAcuf,EAAIvpD,OAC1Cu+C,EAAS/4B,GAAQ,EAAI,EACvBvkB,EAAO6xC,EAAKiU,gBAAgBwC,EAAIvpD,OAAQ6nD,GAAa,GACrDC,EAAWzpB,GAAQA,EAAK2L,YAAcuf,EAAIvpD,OACxCu+C,EAASlgB,GAAQkrB,EAAIvpD,OAAOwtC,WAAW7nC,OAE7C,MAAO,CAAC1E,KAAMA,EAAMD,GADX8xC,EAAKiU,gBAAgBwC,EAAIvpD,OAAQ8nD,EAAU,IAE/C,MAAgB,cAAZyB,EAAInpD,KACN,CAACa,KAAM6xC,EAAKoR,WAAapR,EAAKqR,OAAQnjD,GAAI8xC,EAAKwT,SAAWxT,EAAKqR,QAE/D,CACLljD,KAAM6xC,EAAKoR,WACXljD,GAAI8xC,EAAKwT,SAKTmN,SAAUlK,EAAIvpD,OAAO2rC,WAAa4d,EAAIC,WAK5C,IAAIqR,IAAa,EAWjB,IAAI70C,GAAW,GAAIi1C,GAAe,GA4ClC,SAASC,GAAmB17D,EAAMmwD,GAChCnwD,EAAKm0D,oBAAsBhE,EAC3BnwD,EAAKk0D,kBAAoBzhB,KAAKC,MAWhC,SAASipB,GAAgB37D,GACvBA,EAAKgX,SAAS,mBAAmB,SAAU4kD,GACzC,IAAK,IAAIh7D,KAAQg7D,EAAwB57D,EAAK67D,cAAcj7D,IACxDZ,EAAKwO,IAAI6Y,iBAAiBzmB,EAAMZ,EAAK67D,cAAcj7D,GAAQ,SAAU0V,GAAS,OAAOwlD,GAAiB97D,EAAMsW,QAIpH,SAASwlD,GAAiB97D,EAAMsW,GAC9B,OAAOtW,EAAKgX,SAAS,mBAAmB,SAAUwP,GAChD,IAAItB,EAAUsB,EAASlQ,EAAM1V,MAC7B,QAAOskB,IAAUA,EAAQllB,EAAMsW,IAAUA,EAAMylD,qBAyEnD,SAASC,GAAY1lD,GAAS,MAAO,CAACugB,KAAMvgB,EAAM2lD,QAAStlC,IAAKrgB,EAAM4lD,SAOtE,SAASC,GAAoBn8D,EAAMo8D,EAAUr6D,EAAKw2C,EAAQjiC,GACxD,IAAe,GAAXiiC,EAAgB,OAAO,EAQ3B,IAPA,IAAIz1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQ22C,GAC9BvW,EAAO,SAAWj/B,GACpB,GAAI/C,EAAKgX,SAASolD,GAAU,SAAUnlD,GAAK,OAAOlU,EAAID,EAAKZ,MAAQ+U,EAAEjX,EAAM+B,EAAKe,EAAKK,UAAWL,EAAKpC,OAAOqC,GAAIuT,GAAO,GACrEW,EAAEjX,EAAM+B,EAAKe,EAAKV,KAAKW,GAAID,EAAKpC,OAAOqC,GAAIuT,GAAO,MAChG,MAAO,CAAEk1B,GAAG,IAGTzoC,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAI0oC,EAAWzJ,EAAMj/B,GAErB,GAAK0oC,EAAW,OAAOA,EAASD,EAElC,OAAO,EAGT,SAAS92B,GAAgB1U,EAAML,EAAWwwD,GACnCnwD,EAAKq8D,SAAWr8D,EAAKkT,QAC1B,IAAIrT,EAAKG,EAAKP,MAAMI,GAAG8B,aAAahC,GACtB,WAAVwwD,GAAuBtwD,EAAG6Z,QAAQ,WAAW,GACjD1Z,EAAKN,SAASG,GAuChB,SAASy8D,GAAkBt8D,EAAM+B,EAAKw2C,EAAQjiC,EAAO23C,GACnD,OAAOkO,GAAoBn8D,EAAM,gBAAiB+B,EAAKw2C,EAAQjiC,IAC7DtW,EAAKgX,SAAS,eAAe,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,QAC/D23C,EA7BL,SAA2BjuD,EAAMu4C,GAC/B,IAAe,GAAXA,EAAgB,OAAO,EAC3B,IAAgCgkB,EAAcC,EAA1Cj4D,EAAMvE,EAAKP,MAAME,UACjB4E,aAAe,OAAiBg4D,EAAeh4D,EAAInC,MAGvD,IADA,IAAIU,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQ22C,GACzBx1C,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAIX,EAAOW,EAAID,EAAKZ,MAAQY,EAAKK,UAAYL,EAAKV,KAAKW,GACvD,GAAI,kBAA2BX,GAAO,CAGhCo6D,EAFAD,GAAgBh4D,EAAIC,MAAMtC,MAAQ,GAClCa,GAAKwB,EAAIC,MAAMtC,OAASY,EAAKpC,OAAO6D,EAAIC,MAAMtC,MAAQ,IAAMqC,EAAIC,MAAMzC,IAC3De,EAAKpC,OAAO6D,EAAIC,MAAMtC,OAEtBY,EAAKpC,OAAOqC,GAC3B,OAIJ,OAAgB,MAAZy5D,IACF9nD,GAAgB1U,EAAM,YAAqBA,EAAKP,MAAM4B,IAAKm7D,GAAW,YAC/D,GASOC,CAAkBz8D,EAAMu4C,GAvC1C,SAA2Bv4C,EAAMu4C,GAC/B,IAAe,GAAXA,EAAgB,OAAO,EAC3B,IAAIz1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQ22C,GAASn2C,EAAOU,EAAKK,UACvD,SAAIf,GAAQA,EAAKH,QAAU,kBAA2BG,MACpDsS,GAAgB1U,EAAM,IAAI,KAAc8C,GAAO,YACxC,GAkCyC45D,CAAkB18D,EAAMu4C,IAG5E,SAASokB,GAAkB38D,EAAM+B,EAAKw2C,EAAQjiC,GAC5C,OAAO6lD,GAAoBn8D,EAAM,sBAAuB+B,EAAKw2C,EAAQjiC,IACnEtW,EAAKgX,SAAS,qBAAqB,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,MAG1E,SAASsmD,GAAkB58D,EAAM+B,EAAKw2C,EAAQjiC,GAC5C,OAAO6lD,GAAoBn8D,EAAM,sBAAuB+B,EAAKw2C,EAAQjiC,IACnEtW,EAAKgX,SAAS,qBAAqB,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,OAI1E,SAA4BtW,EAAMu4C,EAAQjiC,GACxC,GAAoB,GAAhBA,EAAMumD,OAAe,OAAO,EAChC,IAAIx7D,EAAMrB,EAAKP,MAAM4B,IACrB,IAAe,GAAXk3C,EACF,QAAIl3C,EAAIqD,gBACNgQ,GAAgB1U,EAAM,YAAqBqB,EAAK,EAAGA,EAAIJ,QAAQC,MAAO,YAC/D,GAMX,IADA,IAAI4B,EAAOzB,EAAIO,QAAQ22C,GACdx1C,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAIX,EAAOW,EAAID,EAAKZ,MAAQY,EAAKK,UAAYL,EAAKV,KAAKW,GACnDgwD,EAAUjwD,EAAKpC,OAAOqC,GAC1B,GAAIX,EAAKsC,cACLgQ,GAAgB1U,EAAM,YAAqBqB,EAAK0xD,EAAU,EAAGA,EAAU,EAAI3wD,EAAKnB,QAAQC,MAAO,eAC9F,KAAI,kBAA2BkB,GAGhC,SAFAsS,GAAgB1U,EAAM,YAAqBqB,EAAK0xD,GAAU,WAG9D,OAAO,GAxBP+J,CAAmB98D,EAAMu4C,EAAQjiC,GA4BrC,SAASymD,GAAc/8D,GACrB,OAAOg9D,GAAeh9D,GAnKxBy7D,GAAawB,QAAU,SAAUj9D,EAAMsW,GAErC,GADAtW,EAAK2W,SAA4B,IAAjBL,EAAM0hB,SAAiB1hB,EAAMK,UACzCumD,GAAoBl9D,EAAMsW,KAC9BtW,EAAKy0D,YAAcn+C,EAAM0hB,QACzBh4B,EAAKi1D,gBAAkBxiB,KAAKC,OAIxBv8B,EAAOwoC,UAAWxoC,EAAO+gB,QAA2B,IAAjB5gB,EAAM0hB,SAO7C,GANqB,KAAjB1hB,EAAM0hB,SAAkBh4B,EAAK8wD,YAAY4J,cAMzCvkD,EAAOsoC,KAAwB,IAAjBnoC,EAAM0hB,SAAkB1hB,EAAMG,SAAYH,EAAME,QAAWF,EAAMI,QASxE1W,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsW,OAAcu9C,GAAe7zD,EAAMsW,GACzGA,EAAM8b,iBAENspC,GAAmB17D,EAAM,WAZiE,CAC1F,IAAI0yC,EAAMD,KAAKC,MACf1yC,EAAKq1D,aAAe3iB,EACpB1yC,EAAKm9D,4BAA8B92C,YAAW,WACxCrmB,EAAKq1D,cAAgB3iB,IACvB1yC,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,GAAI,aAC1ErgD,EAAKq1D,aAAe,KAErB,OAQPoG,GAAa2B,MAAQ,SAAUp9D,EAAMsJ,GAClB,IAAbA,EAAE0uB,UAAiBh4B,EAAK2W,UAAW,IAGzC8kD,GAAa4B,SAAW,SAAUr9D,EAAMsW,GACtC,KAAI4mD,GAAoBl9D,EAAMsW,KAAWA,EAAMgnD,UAC3ChnD,EAAMG,UAAYH,EAAME,QAAUL,EAAOmhB,KAAOhhB,EAAMI,SAE1D,GAAI1W,EAAKgX,SAAS,kBAAkB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsW,MAChEA,EAAM8b,qBADR,CAKA,IAAI7tB,EAAMvE,EAAKP,MAAME,UACrB,KAAM4E,aAAe,MAAmBA,EAAIC,MAAMhB,WAAWe,EAAIE,MAAM,CACrE,IAAIqI,EAAO2qB,OAAOC,aAAaphB,EAAMgnD,UAChCt9D,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMuE,EAAIC,MAAMzC,IAAKwC,EAAIE,IAAI1C,IAAK+K,OAC5F9M,EAAKN,SAASM,EAAKP,MAAMI,GAAG4D,WAAWqJ,GAAMhN,kBACjDwW,EAAM8b,oBAqHV,IAAImrC,GAAqBpnD,EAAOmhB,IAAM,UAAY,UAElD9Q,GAASg3C,UAAY,SAAUx9D,EAAMsW,GACnCtW,EAAK2W,SAAWL,EAAMK,SACtB,IAAI8mD,EAAUV,GAAc/8D,GACxB0yC,EAAMD,KAAKC,MAAO9xC,EAAO,cACzB8xC,EAAM1yC,EAAK09D,UAAUlrB,KAAO,KArHlC,SAAgBl8B,EAAOqnD,GACrB,IAAI3a,EAAK2a,EAAM1sC,EAAI3a,EAAM2lD,QAAS2B,EAAKD,EAAMzsC,EAAI5a,EAAM4lD,QACvD,OAAOlZ,EAAKA,EAAK4a,EAAKA,EAAK,IAmHYC,CAAOvnD,EAAOtW,EAAK09D,aAAepnD,EAAMinD,MAClD,eAAvBv9D,EAAK09D,UAAU98D,KAAyBA,EAAO,cACnB,eAAvBZ,EAAK09D,UAAU98D,OAAyBA,EAAO,gBAE1DZ,EAAK09D,UAAY,CAAClrB,KAAME,EAAKzhB,EAAG3a,EAAM2lD,QAAS/qC,EAAG5a,EAAM4lD,QAASt7D,KAAMA,GAEvE,IAAImB,EAAM/B,EAAKwjD,YAAYwY,GAAY1lD,IAClCvU,IAEO,eAARnB,GACEZ,EAAK2wD,WAAa3wD,EAAK2wD,UAAUmN,OACrC99D,EAAK2wD,UAAY,IAAIoN,GAAU/9D,EAAM+B,EAAKuU,EAAOmnD,KAC/B,eAAR78D,EAAwB+7D,GAAoBC,IAAmB58D,EAAM+B,EAAIA,IAAKA,EAAIw2C,OAAQjiC,GACpGA,EAAM8b,iBAENspC,GAAmB17D,EAAM,aAI7B,IAAI+9D,GAAY,SAAmB/9D,EAAM+B,EAAKuU,EAAOmnD,GACnD,IAWIje,EAAYwe,EAXZ93B,EAASp6B,KAYb,GAVAA,KAAK9L,KAAOA,EACZ8L,KAAK4oD,SAAW10D,EAAKP,MAAM4B,IAC3ByK,KAAK/J,IAAMA,EACX+J,KAAKwK,MAAQA,EACbxK,KAAK2xD,QAAUA,EACf3xD,KAAKmiD,WAAa33C,EAAMinD,IACxBzxD,KAAK8kD,aAAet6C,EAAMK,SAC1B7K,KAAKklD,sBAAuB,EAGxBjvD,EAAIw2C,QAAU,EAChBiH,EAAax/C,EAAKP,MAAM4B,IAAImc,OAAOzb,EAAIw2C,QACvCylB,EAAYj8D,EAAIw2C,WACX,CACL,IAAIz1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQG,EAAIA,KACtCy9C,EAAa18C,EAAK9B,OAClBg9D,EAAYl7D,EAAKZ,MAAQY,EAAKpC,SAAW,EAG3CoL,KAAKmyD,UAAY,KAEjB,IAAIz9D,EAASi9D,EAAU,KAAOnnD,EAAM9V,OAChC0xD,EAAa1xD,EAASR,EAAKkwB,QAAQk0B,YAAY5jD,GAAQ,GAAQ,KACnEsL,KAAKtL,OAAS0xD,EAAaA,EAAW1jD,IAAM,KAE5C,IACI7O,EADMK,EAAKP,MACKE,WACA,GAAhB2W,EAAMumD,QACNrd,EAAW5+C,KAAKC,KAAKspB,YAAiD,IAApCq1B,EAAW5+C,KAAKC,KAAKqpB,YACvDvqB,aAAqB,MAAiBA,EAAU8B,MAAQu8D,GAAar+D,EAAU6B,GAAKw8D,KACpFlyD,KAAKmyD,UAAY,CAAC77D,KAAMo9C,EACRz9C,IAAKi8D,EACLE,QAASpyD,KAAKtL,SAAWsL,KAAKtL,OAAO2pB,UACrCg0C,cAAeryD,KAAKtL,QAAU2V,EAAOkhB,QAAUvrB,KAAKtL,OAAOkqD,aAAa,qBAExF5+C,KAAKtL,QAAUsL,KAAKmyD,YAAcnyD,KAAKmyD,UAAUC,SAAWpyD,KAAKmyD,UAAUE,iBAC7EryD,KAAK9L,KAAK8wD,YAAYnH,OAClB79C,KAAKmyD,UAAUC,UAAWpyD,KAAKtL,OAAO2pB,WAAY,GAClDre,KAAKmyD,UAAUE,eACf93C,YAAW,WACP6f,EAAOlmC,KAAK2wD,WAAazqB,GAAUA,EAAO1lC,OAAOsuB,aAAa,kBAAmB,WACpF,IACLhjB,KAAK9L,KAAK8wD,YAAY7pD,SAGxBjH,EAAKgkD,KAAK38B,iBAAiB,UAAWvb,KAAKsyD,GAAKtyD,KAAKsyD,GAAG7yD,KAAKO,OAC7D9L,EAAKgkD,KAAK38B,iBAAiB,YAAavb,KAAKsxC,KAAOtxC,KAAKsxC,KAAK7xC,KAAKO,OACnE4vD,GAAmB17D,EAAM,YAmE3B,SAASk9D,GAAoBl9D,EAAMsW,GACjC,QAAItW,EAAKqlB,cAWLlP,EAAOghB,QAAUhqB,KAAKkxD,IAAI/nD,EAAMgoD,UAAYt+D,EAAKu+D,oBAAsB,OACzEv+D,EAAKu+D,oBAAsB,KACpB,GA9EXR,GAAUxzD,UAAUuzD,KAAO,WACvB,IAAI53B,EAASp6B,KAEfA,KAAK9L,KAAKgkD,KAAKz8B,oBAAoB,UAAWzb,KAAKsyD,IACnDtyD,KAAK9L,KAAKgkD,KAAKz8B,oBAAoB,YAAazb,KAAKsxC,MACjDtxC,KAAKmyD,WAAanyD,KAAKtL,SACzBsL,KAAK9L,KAAK8wD,YAAYnH,OAClB79C,KAAKmyD,UAAUC,SAAWpyD,KAAKtL,OAAO2tD,gBAAgB,aACtDriD,KAAKmyD,UAAUE,eAAiBryD,KAAKtL,OAAO2tD,gBAAgB,mBAChEriD,KAAK9L,KAAK8wD,YAAY7pD,SAEpB6E,KAAKklD,sBAAwB3qC,YAAW,WAAc,OAAOoqC,GAAevqB,EAAOlmC,SACvF8L,KAAK9L,KAAK2wD,UAAY,MAGxBoN,GAAUxzD,UAAU6zD,GAAK,SAAa9nD,GAGpC,GAFAxK,KAAKgyD,OAEAhyD,KAAK9L,KAAKwO,IAAI4Y,SAAkC,GAAzB9Q,EAAM9V,OAAO6G,SAAgBiP,EAAM9V,OAAOgqC,WAAal0B,EAAM9V,QAAzF,CAGA,IAAIuB,EAAM+J,KAAK/J,IACX+J,KAAK9L,KAAKP,MAAM4B,KAAOyK,KAAK4oD,WAAY3yD,EAAM+J,KAAK9L,KAAKwjD,YAAYwY,GAAY1lD,KAEhFxK,KAAK8kD,eAAiB7uD,EACxB25D,GAAmB5vD,KAAK9L,KAAM,WACrBs8D,GAAkBxwD,KAAK9L,KAAM+B,EAAIA,IAAKA,EAAIw2C,OAAQjiC,EAAOxK,KAAKmiD,YACvE33C,EAAM8b,iBACmB,GAAhB9b,EAAMumD,SACL/wD,KAAK2xD,SAEJtnD,EAAOghB,QAAUrrB,KAAKmyD,YAAcnyD,KAAKmyD,UAAU77D,KAAKH,QAQxDkU,EAAO+gB,UAAYprB,KAAK9L,KAAKP,MAAME,qBAAqB,OACxDwN,KAAKc,IAAId,KAAKkxD,IAAIt8D,EAAIA,IAAM+J,KAAK9L,KAAKP,MAAME,UAAU8B,MAC7C0L,KAAKkxD,IAAIt8D,EAAIA,IAAM+J,KAAK9L,KAAKP,MAAME,UAAU6B,MAAQ,IACzEkT,GAAgB5I,KAAK9L,KAAM,UAAe8L,KAAK9L,KAAKP,MAAM4B,IAAIO,QAAQG,EAAIA,MAAO,WACjFuU,EAAM8b,kBAENspC,GAAmB5vD,KAAK9L,KAAM,aAIlC+9D,GAAUxzD,UAAU6yC,KAAO,SAAe9mC,IACnCxK,KAAK8kD,eAAiBzjD,KAAKkxD,IAAIvyD,KAAKwK,MAAM2a,EAAI3a,EAAM2lD,SAAW,GACzC9uD,KAAKkxD,IAAIvyD,KAAKwK,MAAM4a,EAAI5a,EAAM4lD,SAAW,KAChEpwD,KAAK8kD,cAAe,GACxB8K,GAAmB5vD,KAAK9L,KAAM,WACT,GAAjBsW,EAAMkoD,SAAgB1yD,KAAKgyD,QAGjCt3C,GAASi4C,UAAY,SAAUz+D,GAC7B+8D,GAAc/8D,GACd07D,GAAmB17D,EAAM,YAG3BwmB,GAASk4C,YAAc,SAAU1+D,GAAQ,OAAO+8D,GAAc/8D,IAsB9D,IAAI2+D,GAAqBxoD,EAAOwoC,QAAU,KAAQ,EA+ClD,SAASigB,GAAmB5+D,EAAM6+D,GAChClE,aAAa36D,EAAK8+D,kBACdD,GAAS,IAAK7+D,EAAK8+D,iBAAmBz4C,YAAW,WAAc,OAAO22C,GAAeh9D,KAAU6+D,IAGrG,SAASE,GAAiB/+D,GAQ1B,IACMsW,EAJJ,IAJItW,EAAKqlB,YACPrlB,EAAKqlB,WAAY,EACjBrlB,EAAKu+D,qBAMHjoD,EAAQ7D,SAAS6tC,YAAY,UAC3BC,UAAU,SAAS,GAAM,GACxBjqC,EAAMgoD,YANNt+D,EAAK0tD,iBAAiBvnD,OAAS,GAAKnG,EAAK0tD,iBAAiBtqB,MAAMmmB,mBASzE,SAASyT,GAAeh9D,EAAMg/D,GAC5B,KAAI7oD,EAAOwoC,SAAW3+C,EAAK8wD,YAAYkJ,cAAgB,GAAvD,CAGA,GAFAh6D,EAAK8wD,YAAY4J,aACjBqE,GAAiB/+D,GACbg/D,GAAeh/D,EAAKkwB,SAAWlwB,EAAKkwB,QAAQ22B,MAAO,CACrD,IAAItiD,EAAM2rD,GAAiBlwD,GAG3B,OAFIuE,IAAQA,EAAI+O,GAAGtT,EAAKP,MAAME,WAAcK,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa4C,IAC9EvE,EAAKkvB,YAAYlvB,EAAKP,QACtB,EAET,OAAO,GA1ETg8D,GAAawD,iBAAmBxD,GAAayD,kBAAoB,SAAUl/D,GACzE,IAAKA,EAAKqlB,UAAW,CACnBrlB,EAAK8wD,YAAYuJ,QACjB,IAAI56D,EAAQO,EAAKP,MACbqD,EAAOrD,EAAME,UAAU6E,MAC3B,GAAI/E,EAAME,UAAUC,QACfH,EAAM8T,cACJzQ,EAAKg7B,YAAch7B,EAAK3C,cAAgB2C,EAAKnC,WAAW8P,MAAM0S,MAAK,SAAUmd,GAAK,OAAiC,IAA1BA,EAAE1/B,KAAKC,KAAK6pB,cAE1G1qB,EAAKm/D,WAAan/D,EAAKP,MAAM8T,aAAezQ,EAAK2N,QACjDusD,GAAeh9D,GAAM,GACrBA,EAAKm/D,WAAa,UAMlB,GAJAnC,GAAeh9D,GAIXmW,EAAOkhB,OAAS53B,EAAME,UAAUC,OAASkD,EAAK3C,eAAiB2C,EAAKg7B,YAAch7B,EAAKnC,WAAW8P,MAAMtK,OAE1G,IADA,IAAI5B,EAAMvE,EAAKgkD,KAAKt1C,eACXtM,EAAOmC,EAAI6hD,UAAW50C,EAASjN,EAAI+hD,YAAalkD,GAAyB,GAAjBA,EAAKiF,UAA2B,GAAVmK,GAAc,CACnG,IAAI9Q,EAAS8Q,EAAS,EAAIpP,EAAKI,UAAYJ,EAAK4rC,WAAWx8B,EAAS,GACpE,IAAK9Q,EAAU,MACf,GAAuB,GAAnBA,EAAO2G,SAAe,CACxB9C,EAAI2kD,SAASxoD,EAAQA,EAAOyrC,UAAUhmC,QACtC,MAEA/D,EAAO1B,EACP8Q,GAAU,EAKlBxR,EAAKqlB,WAAY,EAEnBu5C,GAAmB5+D,EAAM2+D,KAG3BlD,GAAar1C,eAAiB,SAAUpmB,EAAMsW,GACxCtW,EAAKqlB,YACPrlB,EAAKqlB,WAAY,EACjBrlB,EAAKu+D,mBAAqBjoD,EAAMgoD,UAChCM,GAAmB5+D,EAAM,MA4D7B,IAAIo/D,GAAsBjpD,EAAOohB,IAAMphB,EAAOkoC,WAAa,IACpDloC,EAAOsoC,KAAOtoC,EAAO2oC,eAAiB,IA0C7C,SAASugB,GAAQr/D,EAAM8M,EAAM4a,EAAMpe,GACjC,IAAI/H,EAAQ61D,GAAmBp3D,EAAM8M,EAAM4a,EAAM1nB,EAAK2W,SAAU3W,EAAKP,MAAME,UAAU6E,OACrF,GAAIxE,EAAKgX,SAAS,eAAe,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsJ,EAAG/H,GAAS,eAAoB,OAAO,EACtG,IAAKA,EAAS,OAAO,EAErB,IAAI+9D,EAxBN,SAAyB/9D,GACvB,OAA0B,GAAnBA,EAAM86B,WAAmC,GAAjB96B,EAAM+6B,SAA4C,GAA5B/6B,EAAMN,QAAQyB,WAAkBnB,EAAMN,QAAQsB,WAAa,KAuB/Fg9D,CAAgBh+D,GAC7B1B,EAAKy/D,EAAat/D,EAAKP,MAAMI,GAAG4Z,qBAAqB6lD,EAAYt/D,EAAK2W,UAAY3W,EAAKP,MAAMI,GAAGszC,iBAAiB5xC,GAErH,OADAvB,EAAKN,SAASG,EAAGC,iBAAiB4Z,QAAQ,SAAS,GAAMA,QAAQ,UAAW,WACrE,EAhDT8M,GAASngB,KAAOo1D,GAAaphC,IAAM,SAAUr6B,EAAMsJ,GACjD,IAAI/E,EAAMvE,EAAKP,MAAME,UAAW06B,EAAgB,OAAV/wB,EAAE1I,KACxC,IAAI2D,EAAI3E,MAAR,CAGA,IAAIgmB,EAAOw5C,GAAqB,KAAO91D,EAAEqe,cAErC/kB,EAAMm0D,GAAsB/2D,EADpBuE,EAAItD,WAEZuN,EAAM5L,EAAI4L,IACV1B,EAAOlK,EAAIkK,KACX8Y,GACFtc,EAAE8oB,iBACFxM,EAAK45C,YACL55C,EAAK65C,QAAQ,YAAajxD,EAAImW,WAC9BiB,EAAK65C,QAAQ,aAAc3yD,IAzC/B,SAAqB9M,EAAMwO,GAGzB,GAAKxO,EAAKwO,IAAIg8B,WAAd,CACA,IAAItkC,EAAOlG,EAAKwO,IAAIg8B,WAAW9lB,YAAYjS,SAASgS,cAAc,QAClEve,EAAKwe,YAAYlW,GACjBtI,EAAKkjB,MAAM6jC,QAAU,6CACrB,IAAI1oD,EAAMmK,eAAgBpO,EAAQmS,SAAS2sC,cAC3C9+C,EAAMo/D,mBAAmBlxD,GAIzBxO,EAAKwO,IAAIH,OACT9J,EAAIoK,kBACJpK,EAAIq5B,SAASt9B,GACb+lB,YAAW,WACLngB,EAAKskC,YAActkC,EAAKskC,WAAWijB,YAAYvnD,GACnDlG,EAAKkT,UACJ,KAyBDysD,CAAY3/D,EAAMwO,GAEhB6rB,GAAOr6B,EAAKN,SAASM,EAAKP,MAAMI,GAAGL,kBAAkBM,iBAAiB4Z,QAAQ,UAAW,UAiC/F+hD,GAAah0C,MAAQ,SAAUznB,EAAMsJ,GAKnC,IAAItJ,EAAKqlB,WAAclP,EAAOwoC,QAA9B,CACA,IAAI/4B,EAAOw5C,GAAqB,KAAO91D,EAAEqe,cACrC/B,GAAQy5C,GAAQr/D,EAAM4lB,EAAKgC,QAAQ,cAAehC,EAAKgC,QAAQ,aAActe,GAAMA,EAAE8oB,iBAjC3F,SAAsBpyB,EAAMsJ,GAC1B,GAAKtJ,EAAKwO,IAAIg8B,WAAd,CACA,IAAI6sB,EAAYr3D,EAAK2W,UAAY3W,EAAKP,MAAME,UAAU6E,MAAMxD,OAAOJ,KAAKC,KAAK0C,KACzE/C,EAASR,EAAKwO,IAAIg8B,WAAW9lB,YAAYjS,SAASgS,cAAc4yC,EAAY,WAAa,QACxFA,IAAa72D,EAAOq/C,gBAAkB,QAC3Cr/C,EAAO4oB,MAAM6jC,QAAU,6CACvBzsD,EAAO0S,QACPmT,YAAW,WACTrmB,EAAKkT,QACD1S,EAAOgqC,YAAchqC,EAAOgqC,WAAWijB,YAAYjtD,GACnD62D,EAAagI,GAAQr/D,EAAMQ,EAAO6J,MAAO,KAAMf,GAC5C+1D,GAAQr/D,EAAMQ,EAAO+hB,YAAa/hB,EAAOmkB,UAAWrb,KAC1D,KAsBIs2D,CAAa5/D,EAAMsJ,KAG5B,IAAIu2D,GAAW,SAAkBt+D,EAAO67C,GACtCtxC,KAAKvK,MAAQA,EACbuK,KAAKsxC,KAAOA,GAGV0iB,GAAmB3pD,EAAOmhB,IAAM,SAAW,UA0I/C,IAAK,IAAIjf,MAxITmO,GAASu5C,UAAY,SAAU//D,EAAMsJ,GACnC,IAAIqnD,EAAY3wD,EAAK2wD,UAErB,GADIA,GAAaA,EAAUmN,OACtBx0D,EAAEkoB,aAAP,CAEA,IAAIjtB,EAAMvE,EAAKP,MAAME,UACjBoC,EAAMwC,EAAI3E,MAAQ,KAAOI,EAAKwjD,YAAYwY,GAAY1yD,IAC1D,GAAIvH,GAAOA,EAAIA,KAAOwC,EAAI9C,MAAQM,EAAIA,MAAQwC,aAAe,KAAgBA,EAAI/C,GAAK,EAAG+C,EAAI/C,UAAY,GAAImvD,GAAaA,EAAUsN,UAClIj+D,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa,YAAqB3B,EAAKP,MAAM4B,IAAKsvD,EAAUsN,UAAUl8D,YAC7F,GAAIuH,EAAE9I,QAA+B,GAArB8I,EAAE9I,OAAO6G,SAAe,CAC7C,IAAIisC,EAAOtzC,EAAKkwB,QAAQk0B,YAAY96C,EAAE9I,QAAQ,GAC1C8yC,GAAQA,EAAKlxC,KAAKxB,KAAKC,KAAKspB,WAAampB,GAAQtzC,EAAKkwB,SACtDlwB,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa,YAAqB3B,EAAKP,MAAM4B,IAAKiyC,EAAK+Q,aAEzF,IAAI9iD,EAAQvB,EAAKP,MAAME,UAAUsB,UAC7B2B,EAAMm0D,GAAsB/2D,EAAMuB,GAClCiN,EAAM5L,EAAI4L,IACV1B,EAAOlK,EAAIkK,KACfxD,EAAEkoB,aAAaguC,YACfl2D,EAAEkoB,aAAaiuC,QAAQL,GAAqB,OAAS,YAAa5wD,EAAImW,WAEtErb,EAAEkoB,aAAawuC,cAAgB,WAC1BZ,IAAsB91D,EAAEkoB,aAAaiuC,QAAQ,aAAc3yD,GAChE9M,EAAKigE,SAAW,IAAIJ,GAASt+D,GAAQ+H,EAAEw2D,OAGzCt5C,GAAS05C,QAAU,SAAUlgE,GAC3B,IAAIigE,EAAWjgE,EAAKigE,SACpBxxD,OAAO4X,YAAW,WACZrmB,EAAKigE,UAAYA,IAAajgE,EAAKigE,SAAW,QACjD,KAGLxE,GAAa0E,SAAW1E,GAAa2E,UAAY,SAAU1qC,EAAGpsB,GAAK,OAAOA,EAAE8oB,kBAE5EqpC,GAAaj0C,KAAO,SAAUxnB,EAAMsJ,GAClC,IAAI22D,EAAWjgE,EAAKigE,SAGpB,GAFAjgE,EAAKigE,SAAW,KAEX32D,EAAEkoB,aAAP,CAEA,IAAI6uC,EAAWrgE,EAAKwjD,YAAYwY,GAAY1yD,IAC5C,GAAK+2D,EAAL,CACA,IAAIC,EAAStgE,EAAKP,MAAM4B,IAAIO,QAAQy+D,EAASt+D,KAC7C,GAAKu+D,EAAL,CACA,IAAI/+D,EAAQ0+D,GAAYA,EAAS1+D,MAC7BA,EACFvB,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK1V,EAAQ0V,EAAE1V,MAE1DA,EAAQ61D,GAAmBp3D,EAAMsJ,EAAEkoB,aAAa5J,QAAQw3C,GAAqB,OAAS,cAC3DA,GAAqB,KAAO91D,EAAEkoB,aAAa5J,QAAQ,cAAc,EAAO04C,GAErG,IAAIljB,EAAO6iB,IAAa32D,EAAEw2D,IAC1B,GAAI9/D,EAAKgX,SAAS,cAAc,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsJ,EAAG/H,GAAS,WAAa67C,MACrF9zC,EAAE8oB,sBAGJ,GAAK7wB,EAAL,CAEA+H,EAAE8oB,iBACF,IAAIgnB,EAAY73C,GAAQ,QAAUvB,EAAKP,MAAM4B,IAAKi/D,EAAOv+D,IAAKR,GAAS++D,EAAOv+D,IAC7D,MAAbq3C,IAAqBA,EAAYknB,EAAOv+D,KAE5C,IAAIlC,EAAKG,EAAKP,MAAMI,GAChBu9C,GAAQv9C,EAAGL,kBAEf,IAAIuC,EAAMlC,EAAGgC,QAAQC,IAAIs3C,GACrBmnB,EAA4B,GAAnBh/D,EAAM86B,WAAmC,GAAjB96B,EAAM+6B,SAA4C,GAA5B/6B,EAAMN,QAAQyB,WACrE89D,EAAe3gE,EAAGwB,IAKtB,GAJIk/D,EACA1gE,EAAGqxC,iBAAiBnvC,EAAKA,EAAKR,EAAMN,QAAQsB,YAE5C1C,EAAGoxC,aAAalvC,EAAKA,EAAKR,IAC1B1B,EAAGwB,IAAIiS,GAAGktD,GAAd,CAEA,IAAI19D,EAAOjD,EAAGwB,IAAIO,QAAQG,GAC1B,GAAIw+D,GAAU,kBAA2Bh/D,EAAMN,QAAQsB,aACnDO,EAAKK,WAAaL,EAAKK,UAAUq2B,WAAWj4B,EAAMN,QAAQsB,YAC5D1C,EAAG8B,aAAa,IAAI,KAAcmB,QAC7B,CACL,IAAI+B,EAAMhF,EAAGgC,QAAQC,IAAIs3C,GACzBv5C,EAAGgC,QAAQuT,KAAKvV,EAAGgC,QAAQuT,KAAKjP,OAAS,GAAG8E,SAAQ,SAAUoK,EAAOC,EAAKC,EAAUC,GAAS,OAAO3Q,EAAM2Q,KAC1G3V,EAAG8B,aAAa2uD,GAAiBtwD,EAAM8C,EAAMjD,EAAGwB,IAAIO,QAAQiD,KAE9D7E,EAAKkT,QACLlT,EAAKN,SAASG,EAAG6Z,QAAQ,UAAW,eAGtC8M,GAAStT,MAAQ,SAAUlT,GACpBA,EAAKq8D,UACRr8D,EAAK8wD,YAAYnH,OACjB3pD,EAAKwO,IAAIk7C,UAAUja,IAAI,uBACvBzvC,EAAK8wD,YAAY7pD,QACjBjH,EAAKq8D,SAAU,EACfh2C,YAAW,WACLrmB,EAAKkwB,SAAWlwB,EAAKoT,aAAepT,EAAK8wD,YAAYC,iBAAiBz9C,GAAGtT,EAAKgkD,KAAKt1C,iBACnF+hD,GAAezwD,KAClB,MAIPwmB,GAASnY,KAAO,SAAUrO,EAAMsJ,GAC1BtJ,EAAKq8D,UACPr8D,EAAK8wD,YAAYnH,OACjB3pD,EAAKwO,IAAIk7C,UAAU9wB,OAAO,uBAC1B54B,EAAK8wD,YAAY7pD,QACbqC,EAAEm3D,eAAiBzgE,EAAKwO,IAAI4Y,SAAS9d,EAAEm3D,gBACvCzgE,EAAK8wD,YAAYC,iBAAiBn1B,IAAI,IAC1C57B,EAAKq8D,SAAU,IAInB71C,GAASk6C,YAAc,SAAU1gE,EAAMsW,GAMrC,GAAIH,EAAO+gB,QAAU/gB,EAAOwoC,SAA8B,yBAAnBroC,EAAMqqD,UAAsC,CACjF3gE,EAAK8wD,YAAYsJ,YACjB,IAAI5E,EAAiBx1D,EAAKw1D,eAC1BnvC,YAAW,WACT,GAAIrmB,EAAKw1D,gBAAkBA,IAE3Bx1D,EAAKwO,IAAIH,OACTrO,EAAKkT,SACDlT,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMqgD,EAAS,EAAG,kBAA7E,CACA,IACIpgD,EADMD,EAAKP,MAAME,UACHM,QAEdA,GAAWA,EAAQ8B,IAAM,GAAK/B,EAAKN,SAASM,EAAKP,MAAMI,GAAGsC,OAAOlC,EAAQ8B,IAAM,EAAG9B,EAAQ8B,KAAKjC,qBAClG,MAKU27D,GAAgBj1C,GAASnO,IAAQojD,GAAapjD,IAE/D,SAASuoD,GAAYt0C,EAAGrE,GACtB,GAAIqE,GAAKrE,EAAK,OAAO,EACrB,IAAK,IAAI0S,KAAKrO,EAAK,GAAIA,EAAEqO,KAAO1S,EAAE0S,GAAM,OAAO,EAC/C,IAAK,IAAIY,KAAOtT,EAAK,KAAMsT,KAAOjP,GAAM,OAAO,EAC/C,OAAO,EAGT,IAAIu0C,GAAa,SAAoBv2C,EAAOzpB,GAC1CiL,KAAKjL,KAAOA,GAAQigE,GACpBh1D,KAAKzJ,KAAOyJ,KAAKjL,KAAKwB,MAAQ,EAC9ByJ,KAAKwe,MAAQA,GAGfu2C,GAAWt2D,UAAUzI,IAAM,SAAcD,EAASk/D,EAAMvvD,EAAQwvD,GAC9D,IAAIp+D,EAAMf,EAAQixB,UAAUiuC,EAAKt/D,KAAOu/D,EAAWl1D,KAAKzJ,KAAO,GAAK,EAAI,GAClEN,EAAMa,EAAIb,IAEhB,OADgBa,EAAIgwB,QACH,KAAO,IAAIquC,GAAWl/D,EAAMyP,EAAQzP,EAAMyP,EAAQ1F,OAGrE+0D,GAAWt2D,UAAU22D,MAAQ,WAAoB,OAAO,GAExDL,GAAWt2D,UAAU+I,GAAK,SAAa6mB,GACrC,OAAOruB,MAAQquB,GACZA,aAAiB0mC,KAChB/0D,KAAKjL,KAAKqH,KAAO4D,KAAKjL,KAAKqH,KAAOiyB,EAAMt5B,KAAKqH,KAC7C4D,KAAKwe,OAAS6P,EAAM7P,OAASs2C,GAAY90D,KAAKjL,KAAMs5B,EAAMt5B,QAGhEggE,GAAWt2D,UAAU+c,QAAU,SAAkBllB,GAC3C0J,KAAKjL,KAAKymB,SAAWxb,KAAKjL,KAAKymB,QAAQllB,IAG7C,IAAI++D,GAAa,SAAoB75D,EAAOzG,GAC1CiL,KAAKjL,KAAOA,GAAQigE,GACpBh1D,KAAKxE,MAAQA,GAGf65D,GAAW52D,UAAUzI,IAAM,SAAcD,EAASk/D,EAAMvvD,EAAQwvD,GAC9D,IAAIv/D,EAAOI,EAAQC,IAAIi/D,EAAKt/D,KAAOu/D,EAAWl1D,KAAKjL,KAAKugE,gBAAkB,EAAI,GAAK5vD,EAC/EhQ,EAAKK,EAAQC,IAAIi/D,EAAKv/D,GAAKw/D,EAAWl1D,KAAKjL,KAAKwgE,aAAe,GAAK,GAAK7vD,EAC7E,OAAO/P,GAAQD,EAAK,KAAO,IAAIy/D,GAAWx/D,EAAMD,EAAIsK,OAGtDq1D,GAAW52D,UAAU22D,MAAQ,SAAgBxrC,EAAGqrC,GAAQ,OAAOA,EAAKt/D,KAAOs/D,EAAKv/D,IAEhF2/D,GAAW52D,UAAU+I,GAAK,SAAa6mB,GACrC,OAAOruB,MAAQquB,GACZA,aAAiBgnC,IAAcP,GAAY90D,KAAKxE,MAAO6yB,EAAM7yB,QAC7Ds5D,GAAY90D,KAAKjL,KAAMs5B,EAAMt5B,OAGlCsgE,GAAWG,GAAK,SAAaP,GAAQ,OAAOA,EAAKngE,gBAAgBugE,IAEjE,IAAIz8B,GAAW,SAAkBp9B,EAAOzG,GACtCiL,KAAKjL,KAAOA,GAAQigE,GACpBh1D,KAAKxE,MAAQA,GAGfo9B,GAASn6B,UAAUzI,IAAM,SAAcD,EAASk/D,EAAMvvD,EAAQwvD,GAC5D,IAAIv/D,EAAOI,EAAQixB,UAAUiuC,EAAKt/D,KAAOu/D,EAAW,GACpD,GAAIv/D,EAAKmxB,QAAW,OAAO,KAC3B,IAAIpxB,EAAKK,EAAQixB,UAAUiuC,EAAKv/D,GAAKw/D,GAAY,GACjD,OAAIx/D,EAAGoxB,SAAWpxB,EAAGO,KAAON,EAAKM,IAAc,KACxC,IAAIk/D,GAAWx/D,EAAKM,IAAMyP,EAAQhQ,EAAGO,IAAMyP,EAAQ1F,OAG5D44B,GAASn6B,UAAU22D,MAAQ,SAAgB9+D,EAAM2+D,GAC/C,IAGMx3D,EAHF3G,EAAMR,EAAKnB,QAAQ45B,UAAUkmC,EAAKt/D,MAChCuB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OAEnB,OAAOA,GAAUuvD,EAAKt/D,QAAU8H,EAAQnH,EAAKmH,MAAMvG,IAAQkK,QAAUsE,EAASjI,EAAMvH,UAAY++D,EAAKv/D,IAGvGkjC,GAASn6B,UAAU+I,GAAK,SAAa6mB,GACnC,OAAOruB,MAAQquB,GACZA,aAAiBuK,IAAYk8B,GAAY90D,KAAKxE,MAAO6yB,EAAM7yB,QAC3Ds5D,GAAY90D,KAAKjL,KAAMs5B,EAAMt5B,OAMlC,IAAIogE,GAAa,SAAoBx/D,EAAMD,EAAIZ,GAG7CkL,KAAKrK,KAAOA,EAIZqK,KAAKtK,GAAKA,EACVsK,KAAKlL,KAAOA,GAGV27B,GAAuB,CAAE17B,KAAM,CAAEm5B,cAAc,GAAOhQ,OAAQ,CAAEgQ,cAAc,IAElFinC,GAAW12D,UAAUlE,KAAO,SAAe5E,EAAMD,GAC/C,OAAO,IAAIy/D,GAAWx/D,EAAMD,EAAIsK,KAAKlL,OAGvCqgE,GAAW12D,UAAU+I,GAAK,SAAa6mB,EAAO3oB,GAG5C,YAFkB,IAAXA,IAAoBA,EAAS,GAE7B1F,KAAKlL,KAAK0S,GAAG6mB,EAAMv5B,OAASkL,KAAKrK,KAAO+P,GAAU2oB,EAAM14B,MAAQqK,KAAKtK,GAAKgQ,GAAU2oB,EAAM34B,IAGnGy/D,GAAW12D,UAAUzI,IAAM,SAAcD,EAAS2P,EAAQwvD,GACxD,OAAOl1D,KAAKlL,KAAKkB,IAAID,EAASiK,KAAM0F,EAAQwvD,IAwD9CC,GAAW/Y,OAAS,SAAiBnmD,EAAKuoB,EAAOzpB,GAC/C,OAAO,IAAIogE,GAAWl/D,EAAKA,EAAK,IAAI8+D,GAAWv2C,EAAOzpB,KAoBxDogE,GAAWj3C,OAAS,SAAiBvoB,EAAMD,EAAI8F,EAAOzG,GACpD,OAAO,IAAIogE,GAAWx/D,EAAMD,EAAI,IAAI2/D,GAAW75D,EAAOzG,KAYxDogE,GAAW7+D,KAAO,SAAeX,EAAMD,EAAI8F,EAAOzG,GAChD,OAAO,IAAIogE,GAAWx/D,EAAMD,EAAI,IAAIkjC,GAASp9B,EAAOzG,KAMtD07B,GAAqB17B,KAAK23B,IAAM,WAAc,OAAO1sB,KAAKlL,KAAKC,MAE/D07B,GAAqBvS,OAAOwO,IAAM,WAAc,OAAO1sB,KAAKlL,gBAAgBugE,IAE5E72D,OAAO+wB,iBAAkB4lC,GAAW12D,UAAWgyB,IAkB/C,IAAIJ,GAAO,GAAI2kC,GAAS,GAOpBS,GAAgB,SAAuBC,EAAO5a,GAChD96C,KAAK01D,MAAQA,GAASA,EAAMr7D,OAASq7D,EAAQrlC,GAC7CrwB,KAAK86C,SAAWA,GAAYA,EAASzgD,OAASygD,EAAWzqB,IAM3DolC,GAAcn7D,OAAS,SAAiB/E,EAAKmsB,GAC3C,OAAOA,EAAYrnB,OAASs7D,GAAUj0C,EAAansB,EAAK,EAAGy/D,IAAUlhE,IAUvE2hE,GAAch3D,UAAU2G,KAAO,SAAejK,EAAOpC,EAAKiY,GACxD,IAAI3G,EAAS,GAEb,OADArK,KAAK41D,UAAmB,MAATz6D,EAAgB,EAAIA,EAAc,MAAPpC,EAAc,IAAMA,EAAKsR,EAAQ,EAAG2G,GACvE3G,GAGTorD,GAAch3D,UAAUm3D,UAAY,SAAoBz6D,EAAOpC,EAAKsR,EAAQ3E,EAAQsL,GAClF,IAAK,IAAI/Z,EAAI,EAAGA,EAAI+I,KAAK01D,MAAMr7D,OAAQpD,IAAK,CAC1C,IAAIg+D,EAAOj1D,KAAK01D,MAAMz+D,GAClBg+D,EAAKt/D,MAAQoD,GAAOk8D,EAAKv/D,IAAMyF,KAAW6V,GAAaA,EAAUikD,EAAKlgE,QACtEsV,EAAOzP,KAAKq6D,EAAK16D,KAAK06D,EAAKt/D,KAAO+P,EAAQuvD,EAAKv/D,GAAKgQ,IAE1D,IAAK,IAAI1K,EAAM,EAAGA,EAAMgF,KAAK86C,SAASzgD,OAAQW,GAAO,EACnD,GAAIgF,KAAK86C,SAAS9/C,GAAOjC,GAAOiH,KAAK86C,SAAS9/C,EAAM,GAAKG,EAAO,CAC9D,IAAI06D,EAAW71D,KAAK86C,SAAS9/C,GAAO,EACpCgF,KAAK86C,SAAS9/C,EAAM,GAAG46D,UAAUz6D,EAAQ06D,EAAU98D,EAAM88D,EAAUxrD,EAAQ3E,EAASmwD,EAAU7kD,KAepGykD,GAAch3D,UAAUzI,IAAM,SAAcD,EAASR,EAAK8K,GACxD,OAAIL,MAAQlM,IAAgC,GAAvBiC,EAAQuT,KAAKjP,OAAsB2F,KACjDA,KAAK81D,SAAS//D,EAASR,EAAK,EAAG,EAAG8K,GAAW20D,KAGtDS,GAAch3D,UAAUq3D,SAAW,SAAmB//D,EAASO,EAAMoP,EAAQwvD,EAAW70D,GAEtF,IADA,IAAI01D,EACK9+D,EAAI,EAAGA,EAAI+I,KAAK01D,MAAMr7D,OAAQpD,IAAK,CAC1C,IAAIw2C,EAASztC,KAAK01D,MAAMz+D,GAAGjB,IAAID,EAAS2P,EAAQwvD,GAC5CznB,GAAUA,EAAO34C,KAAKsgE,MAAM9+D,EAAMm3C,IAAYsoB,IAAaA,EAAW,KAAKn7D,KAAK6yC,GAC3EptC,EAAQ21D,UAAY31D,EAAQ21D,SAASh2D,KAAK01D,MAAMz+D,GAAGlC,MAG9D,OAAIiL,KAAK86C,SAASzgD,OAmNpB,SAAqB47D,EAAaF,EAAUhgE,EAASO,EAAMoP,EAAQwvD,EAAW70D,GAiB5E,IAhBA,IAAIy6C,EAAWmb,EAAYxgE,QAIvB0U,EAAQ,SAAUigB,EAAUC,EAAQH,EAAUC,GAChD,IAAK,IAAIlzB,EAAI,EAAGA,EAAI6jD,EAASzgD,OAAQpD,GAAK,EAAG,CAC3C,IAAI8B,EAAM+hD,EAAS7jD,EAAI,GAAIi/D,OAAQ,GACvB,GAARn9D,GAAaqxB,EAAWrxB,EAAMm8D,IAC9B7qC,GAAUywB,EAAS7jD,GAAKi+D,EAC1Bpa,EAAS7jD,EAAI,IAAM,EACVizB,GAAYxkB,IAAWwwD,EAAS/rC,EAASD,GAAaG,EAASD,MACxE0wB,EAAS7jD,IAAMi/D,EACfpb,EAAS7jD,EAAI,IAAMi/D,MAIhBj/D,EAAI,EAAGA,EAAIlB,EAAQuT,KAAKjP,OAAQpD,IAAOlB,EAAQuT,KAAKrS,GAAGkI,QAAQgL,GAKxE,IADA,IAAIgsD,GAAc,EACTn7D,EAAM,EAAGA,EAAM8/C,EAASzgD,OAAQW,GAAO,EAAK,IAA0B,GAAtB8/C,EAAS9/C,EAAM,GAAU,CAChF,IAAIrF,EAAOI,EAAQC,IAAIigE,EAAYj7D,GAAOk6D,GAAYkB,EAAYzgE,EAAO+P,EACzE,GAAI0wD,EAAY,GAAKA,GAAa9/D,EAAKnB,QAAQC,KAAM,CACnD+gE,GAAc,EACd,SAGF,IAA4DE,EAAnDtgE,EAAQC,IAAIigE,EAAYj7D,EAAM,GAAKk6D,GAAY,GAAmBxvD,EACvE5O,EAAMR,EAAKnB,QAAQ45B,UAAUqnC,GAC7Bl/D,EAAQJ,EAAII,MACZo/D,EAAcx/D,EAAI4O,OAClB6wD,EAAYjgE,EAAKs4B,WAAW13B,GAChC,GAAIq/D,GAAaD,GAAeF,GAAaE,EAAcC,EAAUrgE,UAAYmgE,EAAS,CACxF,IAAI5oB,EAASqN,EAAS9/C,EAAM,GAAG86D,SAAS//D,EAASwgE,EAAW5gE,EAAO,EAAGsgE,EAAYj7D,GAAOk6D,EAAY,EAAG70D,GACpGotC,GAAU35C,IACZgnD,EAAS9/C,GAAOo7D,EAChBtb,EAAS9/C,EAAM,GAAKq7D,EACpBvb,EAAS9/C,EAAM,GAAKyyC,IAEpBqN,EAAS9/C,EAAM,IAAM,EACrBm7D,GAAc,QAGhBA,GAAc,EAKlB,GAAIA,EAAa,CACf,IAAIz0C,EA4BR,SAA0Co5B,EAAUmb,EAAav0C,EAAa3rB,EAAS2P,EAAQwvD,EAAW70D,GAExG,SAASm2D,EAAO1mC,EAAKolC,GACnB,IAAK,IAAIj+D,EAAI,EAAGA,EAAI64B,EAAI4lC,MAAMr7D,OAAQpD,IAAK,CACzC,IAAIw2C,EAAS3d,EAAI4lC,MAAMz+D,GAAGjB,IAAID,EAAS2P,EAAQwvD,GAC3CznB,EAAU/rB,EAAY9mB,KAAK6yC,GACtBptC,EAAQ21D,UAAY31D,EAAQ21D,SAASlmC,EAAI4lC,MAAMz+D,GAAGlC,MAE7D,IAAK,IAAIiG,EAAM,EAAGA,EAAM80B,EAAIgrB,SAASzgD,OAAQW,GAAO,EAChDw7D,EAAO1mC,EAAIgrB,SAAS9/C,EAAM,GAAI80B,EAAIgrB,SAAS9/C,GAAOk6D,EAAY,GAEpE,IAAK,IAAIj+D,EAAI,EAAGA,EAAI6jD,EAASzgD,OAAQpD,GAAK,GAA6B,GAApB6jD,EAAS7jD,EAAI,IAC5Du/D,EAAO1b,EAAS7jD,EAAI,GAAIg/D,EAAYh/D,GAAKi+D,EAAY,GAEzD,OAAOxzC,EA1Ca+0C,CAAiC3b,EAAUmb,EAAaF,GAAY,GAAIhgE,EACvC2P,EAAQwvD,EAAW70D,GAClEi4B,EAAQq9B,GAAUj0C,EAAaprB,EAAM,EAAG+J,GAC5C01D,EAAWz9B,EAAMo9B,MACjB,IAAK,IAAIn4D,EAAM,EAAGA,EAAMu9C,EAASzgD,OAAQkD,GAAO,EAASu9C,EAASv9C,EAAM,GAAK,IAC3Eu9C,EAAS/tB,OAAOxvB,EAAK,GACrBA,GAAO,GAET,IAAK,IAAI4iD,EAAM,EAAGvsC,EAAI,EAAGusC,EAAM7nB,EAAMwiB,SAASzgD,OAAQ8lD,GAAO,EAAG,CAE9D,IADA,IAAIuW,EAASp+B,EAAMwiB,SAASqF,GACrBvsC,EAAIknC,EAASzgD,QAAUygD,EAASlnC,GAAK8iD,GAAU9iD,GAAK,EAC3DknC,EAAS/tB,OAAOnZ,EAAG,EAAG0kB,EAAMwiB,SAASqF,GAAM7nB,EAAMwiB,SAASqF,EAAM,GAAI7nB,EAAMwiB,SAASqF,EAAM,KAI7F,OAAO,IAAIsV,GAAcM,GAAYA,EAASj2C,KAAK62C,IAAQ7b,GApRhD8b,CAAY52D,KAAK86C,SAAUib,EAAUhgE,EAASO,EAAMoP,EAAQwvD,EAAW70D,GAEvE01D,EAAW,IAAIN,GAAcM,EAASj2C,KAAK62C,KAAU7iE,IAOlE2hE,GAAch3D,UAAUklC,IAAM,SAAcpuC,EAAKmsB,GAC/C,OAAKA,EAAYrnB,OACb2F,MAAQlM,GAAgB2hE,GAAcn7D,OAAO/E,EAAKmsB,GAC/C1hB,KAAK62D,SAASthE,EAAKmsB,EAAa,GAFL1hB,MAKpCy1D,GAAch3D,UAAUo4D,SAAW,SAAmBthE,EAAKmsB,EAAahc,GACpE,IAEEo1C,EAFE1gB,EAASp6B,KAED+2C,EAAa,EAC3BxhD,EAAI4J,SAAQ,SAAUo3D,EAAWD,GAC/B,IAAuCl5D,EAAnC05D,EAAaR,EAAc5wD,EAC/B,GAAMtI,EAAQ25D,GAAiBr1C,EAAa60C,EAAWO,GAAvD,CAGA,IADKhc,IAAYA,EAAW1gB,EAAO0gB,SAASrlD,SACrCshD,EAAa+D,EAASzgD,QAAUygD,EAAS/D,GAAcuf,GAAevf,GAAc,EACvF+D,EAAS/D,IAAeuf,EACxBxb,EAAS/D,EAAa,GAAK+D,EAAS/D,EAAa,GAAG8f,SAASN,EAAWn5D,EAAO05D,EAAa,GAE5Fhc,EAAS/tB,OAAOgqB,EAAY,EAAGuf,EAAaA,EAAcC,EAAUrgE,SAAUy/D,GAAUv4D,EAAOm5D,EAAWO,EAAa,EAAG9B,KAC9Hje,GAAc,MAIhB,IADA,IAAI2e,EAAQsB,GAAUjgB,EAAakgB,GAAav1C,GAAeA,GAAchc,GACpEzO,EAAI,EAAGA,EAAIy+D,EAAMr7D,OAAQpD,IAAYy+D,EAAMz+D,GAAGnC,KAAKsgE,MAAM7/D,EAAKmgE,EAAMz+D,KAAOy+D,EAAM3oC,OAAO91B,IAAK,GAEtG,OAAO,IAAIw+D,GAAcC,EAAMr7D,OAAS2F,KAAK01D,MAAMzoC,OAAOyoC,GAAO51C,KAAK62C,IAAS32D,KAAK01D,MAC3D5a,GAAY96C,KAAK86C,WAM5C2a,GAAch3D,UAAUquB,OAAS,SAAiBpL,GAChD,OAA0B,GAAtBA,EAAYrnB,QAAe2F,MAAQlM,GAAgBkM,KAChDA,KAAKk3D,YAAYx1C,EAAa,IAGvC+zC,GAAch3D,UAAUy4D,YAAc,SAAsBx1C,EAAahc,GAEvE,IADA,IAAIo1C,EAAW96C,KAAK86C,SAAU4a,EAAQ11D,KAAK01D,MAClCz+D,EAAI,EAAGA,EAAI6jD,EAASzgD,OAAQpD,GAAK,EAAG,CAE3C,IADA,IAAImG,OAAQ,EAAUzH,EAAOmlD,EAAS7jD,GAAKyO,EAAQhQ,EAAKolD,EAAS7jD,EAAI,GAAKyO,EACjEkO,EAAI,EAAGqhD,OAAO,EAAUrhD,EAAI8N,EAAYrnB,OAAQuZ,KAAWqhD,EAAOvzC,EAAY9N,KACjFqhD,EAAKt/D,KAAOA,GAAQs/D,EAAKv/D,GAAKA,IAChCgsB,EAAY9N,GAAK,MACfxW,IAAUA,EAAQ,KAAKxC,KAAKq6D,IAGlC,GAAK73D,EAAL,CACI09C,GAAY96C,KAAK86C,WAAYA,EAAW96C,KAAK86C,SAASrlD,SAC1D,IAAIk5C,EAAUmM,EAAS7jD,EAAI,GAAGigE,YAAY95D,EAAOzH,EAAO,GACpDg5C,GAAW76C,GACbgnD,EAAS7jD,EAAI,GAAK03C,GAElBmM,EAAS/tB,OAAO91B,EAAG,GACnBA,GAAK,IAGT,GAAIy+D,EAAMr7D,OAAU,IAAK,IAAIW,EAAM,EAAGm8D,OAAS,EAAUn8D,EAAM0mB,EAAYrnB,OAAQW,IAAS,GAAIm8D,EAASz1C,EAAY1mB,GACnH,IAAK,IAAI2hD,EAAM,EAAGA,EAAM+Y,EAAMr7D,OAAQsiD,IAAa+Y,EAAM/Y,GAAKn1C,GAAG2vD,EAAQzxD,KACnEgwD,GAAS11D,KAAK01D,QAASA,EAAQ11D,KAAK01D,MAAMjgE,SAC9CigE,EAAM3oC,OAAO4vB,IAAO,IAGxB,OAAI7B,GAAY96C,KAAK86C,UAAY4a,GAAS11D,KAAK01D,MAAgB11D,KACxD01D,EAAMr7D,QAAUygD,EAASzgD,OAAS,IAAIo7D,GAAcC,EAAO5a,GAAYhnD,IAGhF2hE,GAAch3D,UAAUkhD,SAAW,SAAmBj6C,EAAQpP,GAC5D,GAAI0J,MAAQlM,GAAS,OAAOkM,KAC5B,GAAI1J,EAAKmwB,OAAU,OAAOgvC,GAAc3hE,MAGxC,IADA,IAAI2J,EAAOi4D,EACFz+D,EAAI,EAAGA,EAAI+I,KAAK86C,SAASzgD,OAAQpD,GAAK,EAAK,GAAI+I,KAAK86C,SAAS7jD,IAAMyO,EAAQ,CAC9E1F,KAAK86C,SAAS7jD,IAAMyO,IAAUjI,EAAQuC,KAAK86C,SAAS7jD,EAAI,IAC5D,MAGF,IADA,IAAIkE,EAAQuK,EAAS,EAAG3M,EAAMoC,EAAQ7E,EAAKnB,QAAQC,KAC1C4F,EAAM,EAAGA,EAAMgF,KAAK01D,MAAMr7D,OAAQW,IAAO,CAChD,IAAIo8D,EAAMp3D,KAAK01D,MAAM16D,GACrB,GAAIo8D,EAAIzhE,KAAOoD,GAAOq+D,EAAI1hE,GAAKyF,GAAUi8D,EAAItiE,gBAAgBugE,GAAa,CACxE,IAAI1/D,EAAO0L,KAAKC,IAAInG,EAAOi8D,EAAIzhE,MAAQwF,EAAOzF,EAAK2L,KAAKc,IAAIpJ,EAAKq+D,EAAI1hE,IAAMyF,EACvExF,EAAOD,IAAOggE,IAAUA,EAAQ,KAAK96D,KAAKw8D,EAAI78D,KAAK5E,EAAMD,KAGjE,GAAIggE,EAAO,CACT,IAAI2B,EAAW,IAAI5B,GAAcC,EAAM51C,KAAK62C,KAC5C,OAAOl5D,EAAQ,IAAI65D,GAAgB,CAACD,EAAU55D,IAAU45D,EAE1D,OAAO55D,GAAS3J,IAGlB2hE,GAAch3D,UAAU+I,GAAK,SAAa6mB,GACxC,GAAIruB,MAAQquB,EAAS,OAAO,EAC5B,KAAMA,aAAiBonC,KACnBz1D,KAAK01D,MAAMr7D,QAAUg0B,EAAMqnC,MAAMr7D,QACjC2F,KAAK86C,SAASzgD,QAAUg0B,EAAMysB,SAASzgD,OAAU,OAAO,EAC5D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAK01D,MAAMr7D,OAAQpD,IACnC,IAAK+I,KAAK01D,MAAMz+D,GAAGuQ,GAAG6mB,EAAMqnC,MAAMz+D,IAAO,OAAO,EACpD,IAAK,IAAI+D,EAAM,EAAGA,EAAMgF,KAAK86C,SAASzgD,OAAQW,GAAO,EACjD,GAAIgF,KAAK86C,SAAS9/C,IAAQqzB,EAAMysB,SAAS9/C,IACvCgF,KAAK86C,SAAS9/C,EAAM,IAAMqzB,EAAMysB,SAAS9/C,EAAM,KAC9CgF,KAAK86C,SAAS9/C,EAAM,GAAGwM,GAAG6mB,EAAMysB,SAAS9/C,EAAM,IAAO,OAAO,EACpE,OAAO,GAGTy6D,GAAch3D,UAAUihD,OAAS,SAAiBppD,GAChD,OAAOihE,GAAcv3D,KAAKw3D,YAAYlhE,KAGxCm/D,GAAch3D,UAAU+4D,YAAc,SAAsBlhE,GAC1D,GAAI0J,MAAQlM,GAAS,OAAOu8B,GAC5B,GAAI/5B,EAAKsC,gBAAkBoH,KAAK01D,MAAMr+C,KAAKg+C,GAAWG,IAAO,OAAOx1D,KAAK01D,MAEzE,IADA,IAAIrrD,EAAS,GACJpT,EAAI,EAAGA,EAAI+I,KAAK01D,MAAMr7D,OAAQpD,IAC/B+I,KAAK01D,MAAMz+D,GAAGnC,gBAAgBugE,IAChChrD,EAAOzP,KAAKoF,KAAK01D,MAAMz+D,IAE7B,OAAOoT,GAYT,IAAIvW,GAAQ,IAAI2hE,GAIhBA,GAAc3hE,MAAQA,GAEtB2hE,GAAc8B,cAAgBA,GAK9B,IAAID,GAAkB,SAAyBG,GAC7Cz3D,KAAKy3D,QAAUA,GAgIjB,SAAST,GAAUU,EAAOhyD,GACxB,IAAKA,IAAWgyD,EAAMr9D,OAAU,OAAOq9D,EAEvC,IADA,IAAIrtD,EAAS,GACJpT,EAAI,EAAGA,EAAIygE,EAAMr9D,OAAQpD,IAAK,CACrC,IAAIg+D,EAAOyC,EAAMzgE,GACjBoT,EAAOzP,KAAK,IAAIu6D,GAAWF,EAAKt/D,KAAO+P,EAAQuvD,EAAKv/D,GAAKgQ,EAAQuvD,EAAKngE,OAExE,OAAOuV,EAoBT,SAAS0sD,GAAiBW,EAAOphE,EAAMoP,GACrC,GAAIpP,EAAKmwB,OAAU,OAAO,KAE1B,IADA,IAAI1tB,EAAM2M,EAASpP,EAAKJ,SAAUkH,EAAQ,KACjCnG,EAAI,EAAGg+D,OAAO,EAAUh+D,EAAIygE,EAAMr9D,OAAQpD,KAC5Cg+D,EAAOyC,EAAMzgE,KAAOg+D,EAAKt/D,KAAO+P,GAAUuvD,EAAKv/D,GAAKqD,KAC5DqE,IAAUA,EAAQ,KAAKxC,KAAKq6D,GACvByC,EAAMzgE,GAAK,MAGf,OAAOmG,EAGT,SAAS65D,GAAa3tC,GAEpB,IADA,IAAIjf,EAAS,GACJpT,EAAI,EAAGA,EAAIqyB,EAAMjvB,OAAQpD,IACd,MAAZqyB,EAAMryB,IAAcoT,EAAOzP,KAAK0uB,EAAMryB,IAC9C,OAAOoT,EAQT,SAASsrD,GAAU+B,EAAOphE,EAAMoP,EAAQrF,GACtC,IAAIy6C,EAAW,GAAI6c,GAAW,EAC9BrhE,EAAK6I,SAAQ,SAAUo3D,EAAWqB,GAChC,IAAIx6D,EAAQ25D,GAAiBW,EAAOnB,EAAWqB,EAAalyD,GAC5D,GAAItI,EAAO,CACTu6D,GAAW,EACX,IAAI/J,EAAU+H,GAAUv4D,EAAOm5D,EAAW7wD,EAASkyD,EAAa,EAAGv3D,GAC/DutD,GAAW95D,IACXgnD,EAASlgD,KAAKg9D,EAAYA,EAAarB,EAAUrgE,SAAU03D,OAInE,IADA,IAAIlO,EAASsX,GAAUW,EAAWV,GAAaS,GAASA,GAAQhyD,GAAQoa,KAAK62C,IACpE1/D,EAAI,EAAGA,EAAIyoD,EAAOrlD,OAAQpD,IAAYyoD,EAAOzoD,GAAGnC,KAAKsgE,MAAM9+D,EAAMopD,EAAOzoD,MAC3EoJ,EAAQ21D,UAAY31D,EAAQ21D,SAAStW,EAAOzoD,GAAGlC,MACnD2qD,EAAO3yB,OAAO91B,IAAK,IAErB,OAAOyoD,EAAOrlD,QAAUygD,EAASzgD,OAAS,IAAIo7D,GAAc/V,EAAQ5E,GAAYhnD,GAOlF,SAAS6iE,GAAMn2C,EAAGrE,GAChB,OAAOqE,EAAE7qB,KAAOwmB,EAAExmB,MAAQ6qB,EAAE9qB,GAAKymB,EAAEzmB,GAQrC,SAAS6hE,GAAcG,GAErB,IADA,IAAIG,EAAUH,EACLzgE,EAAI,EAAGA,EAAI4gE,EAAQx9D,OAAS,EAAGpD,IAAK,CAC3C,IAAIg+D,EAAO4C,EAAQ5gE,GACnB,GAAIg+D,EAAKt/D,MAAQs/D,EAAKv/D,GAAM,IAAK,IAAIke,EAAI3c,EAAI,EAAG2c,EAAIikD,EAAQx9D,OAAQuZ,IAAK,CACvE,IAAImf,EAAO8kC,EAAQjkD,GACnB,GAAImf,EAAKp9B,MAAQs/D,EAAKt/D,KAAtB,CAUMo9B,EAAKp9B,KAAOs/D,EAAKv/D,KACfmiE,GAAWH,IAASG,EAAUH,EAAMjiE,SAGxCoiE,EAAQ5gE,GAAKg+D,EAAK16D,KAAK06D,EAAKt/D,KAAMo9B,EAAKp9B,MACvCmiE,GAAYD,EAASjkD,EAAGqhD,EAAK16D,KAAKw4B,EAAKp9B,KAAMs/D,EAAKv/D,MAEpD,MAhBIq9B,EAAKr9B,IAAMu/D,EAAKv/D,KACdmiE,GAAWH,IAASG,EAAUH,EAAMjiE,SAGxCoiE,EAAQjkD,GAAKmf,EAAKx4B,KAAKw4B,EAAKp9B,KAAMs/D,EAAKv/D,IACvCoiE,GAAYD,EAASjkD,EAAI,EAAGmf,EAAKx4B,KAAK06D,EAAKv/D,GAAIq9B,EAAKr9B,OAe5D,OAAOmiE,EAGT,SAASC,GAAYxuC,EAAOryB,EAAGsoD,GAC7B,KAAOtoD,EAAIqyB,EAAMjvB,QAAUs8D,GAAMpX,EAAMj2B,EAAMryB,IAAM,GAAKA,IACxDqyB,EAAMyD,OAAO91B,EAAG,EAAGsoD,GAKrB,SAASwY,GAAgB7jE,GACvB,IAAIkJ,EAAQ,GAOZ,OANAlJ,EAAKgX,SAAS,eAAe,SAAUC,GACrC,IAAId,EAASc,EAAEjX,EAAKP,OAChB0W,GAAUA,GAAUvW,IAASsJ,EAAMxC,KAAKyP,MAE1CnW,EAAKmxD,eACLjoD,EAAMxC,KAAK66D,GAAcn7D,OAAOpG,EAAKP,MAAM4B,IAAK,CAACrB,EAAKmxD,cAAc9F,QACjE+X,GAAgB3hE,KAAKyH,GA7P9Bk6D,GAAgB74D,UAAUzI,IAAM,SAAcD,EAASR,GACrD,IAAIyiE,EAAch4D,KAAKy3D,QAAQzhE,KAC7B,SAAUiiE,GAAU,OAAOA,EAAOjiE,IAAID,EAASR,EAAKy/D,OAEtD,OAAOsC,GAAgB3hE,KAAKqiE,IAG9BV,GAAgB74D,UAAUkhD,SAAW,SAAmBj6C,EAAQjI,GAC9D,GAAIA,EAAMgpB,OAAU,OAAOgvC,GAAc3hE,MAEzC,IADA,IAAIsJ,EAAQ,GACHnG,EAAI,EAAGA,EAAI+I,KAAKy3D,QAAQp9D,OAAQpD,IAAK,CAC5C,IAAIoT,EAASrK,KAAKy3D,QAAQxgE,GAAG0oD,SAASj6C,EAAQjI,GAC1C4M,GAAUvW,KACVuW,aAAkBitD,GAAmBl6D,EAAQA,EAAM6vB,OAAO5iB,EAAOotD,SAC9Dr6D,EAAMxC,KAAKyP,IAEpB,OAAOitD,GAAgB3hE,KAAKyH,IAG9Bk6D,GAAgB74D,UAAU+I,GAAK,SAAa6mB,GAC1C,KAAMA,aAAiBipC,KACnBjpC,EAAMopC,QAAQp9D,QAAU2F,KAAKy3D,QAAQp9D,OAAU,OAAO,EAC1D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAKy3D,QAAQp9D,OAAQpD,IACrC,IAAK+I,KAAKy3D,QAAQxgE,GAAGuQ,GAAG6mB,EAAMopC,QAAQxgE,IAAO,OAAO,EACxD,OAAO,GAGTqgE,GAAgB74D,UAAUihD,OAAS,SAAiBppD,GAElD,IADA,IAAI+T,EAAQ6tD,GAAS,EACZjhE,EAAI,EAAGA,EAAI+I,KAAKy3D,QAAQp9D,OAAQpD,IAAK,CAC5C,IAAIyoD,EAAS1/C,KAAKy3D,QAAQxgE,GAAGugE,YAAYlhE,GACzC,GAAKopD,EAAOrlD,OACZ,GAAKgQ,EAEE,CACD6tD,IACF7tD,EAASA,EAAO5U,QAChByiE,GAAS,GAEX,IAAK,IAAItkD,EAAI,EAAGA,EAAI8rC,EAAOrlD,OAAQuZ,IAAOvJ,EAAOzP,KAAK8kD,EAAO9rC,SAN7DvJ,EAASq1C,EASb,OAAOr1C,EAASktD,GAAcW,EAAS7tD,EAASA,EAAOyV,KAAK62C,KAAUtmC,IAMxEinC,GAAgB3hE,KAAO,SAAe8hE,GACpC,OAAQA,EAAQp9D,QACd,KAAK,EAAG,OAAOvG,GACf,KAAK,EAAG,OAAO2jE,EAAQ,GACvB,QAAS,OAAO,IAAIH,GAAgBG,KA+MxC,IAAIU,GAAa,SAAoB/qC,EAAO5tB,GAC1CQ,KAAKo4D,OAAS54D,EAGdQ,KAAKrM,MAAQ6L,EAAM7L,MAEnBqM,KAAKq4D,cAAgB74D,EAAM6T,SAAW,GACtCrT,KAAKq4D,cAAcl5D,QAAQm5D,IAE3Bt4D,KAAKpM,SAAWoM,KAAKpM,SAAS6L,KAAKO,MAEnCA,KAAKu4D,MAAQ,KACbv4D,KAAKuwD,SAAU,EAEfvwD,KAAKyiD,YAAc,KAKnBziD,KAAK0C,IAAO0qB,GAASA,EAAMxI,OAAUje,SAASgS,cAAc,OACxDyU,IACEA,EAAMxU,YAAewU,EAAMxU,YAAY5Y,KAAK0C,KACvC0qB,EAAMlY,MAASkY,EAAMptB,KAAK0C,KAC1B0qB,EAAMxI,QAAS5kB,KAAKw4D,SAAU,IAKzCx4D,KAAK4U,SAAW6jD,GAAYz4D,MAC5BA,KAAKqzD,WAAa,KAClBrzD,KAAKqlD,cAAgB,KACrBqT,GAAoB14D,MACpBA,KAAKuhB,UAAYo3C,GAAe34D,MAChCA,KAAKokB,QAAUk+B,EAAYtiD,KAAKrM,MAAM4B,IAAKqjE,GAAe54D,MAAO+3D,GAAgB/3D,MAAOA,KAAK0C,IAAK1C,MAElGA,KAAK2mD,qBAAuB,KAK5B3mD,KAAKm0D,SAAW,KAp8ClB,SAAmBjgE,GACjBA,EAAK2W,UAAW,EAChB3W,EAAK2wD,UAAY,KACjB3wD,EAAKy0D,YAAc,KACnBz0D,EAAKi1D,gBAAkB,EACvBj1D,EAAK09D,UAAY,CAAClrB,KAAM,EAAGvhB,EAAG,EAAGC,EAAG,EAAGtwB,KAAM,IAC7CZ,EAAKm0D,oBAAsB,KAC3Bn0D,EAAKk0D,kBAAoB,EAEzBl0D,EAAKq1D,aAAe,EACpBr1D,EAAKm9D,4BAA8B,KACnCn9D,EAAKm2D,kBAAoB,EAEzBn2D,EAAKqlB,WAAY,EACjBrlB,EAAK8+D,iBAAmB,KACxB9+D,EAAK0tD,iBAAmB,GACxB1tD,EAAKu+D,oBAAsB,IAE3Bv+D,EAAK8wD,YAAc,IAAI+I,GAAY75D,GAAM,SAAUyB,EAAMD,EAAIyyD,EAAUvZ,GAAS,OAAOsZ,GAAch0D,EAAMyB,EAAMD,EAAIyyD,EAAUvZ,MAC/H16C,EAAK8wD,YAAY7pD,QAEjBjH,EAAKw1D,eAAiB,EAEtBx1D,EAAK67D,cAAgBvxD,OAAOlE,OAAO,MACnC,IAAI47B,EAAO,SAAW1rB,GACpB,IAAI4O,EAAUsB,GAASlQ,GACvBtW,EAAKwO,IAAI6Y,iBAAiB/Q,EAAOtW,EAAK67D,cAAcvlD,GAAS,SAAUA,IA2C3E,SAA4BtW,EAAMsW,GAChC,IAAKA,EAAMM,QAAW,OAAO,EAC7B,GAAIN,EAAMylD,iBAAoB,OAAO,EACrC,IAAK,IAAI35D,EAAOkU,EAAM9V,OAAQ4B,GAAQpC,EAAKwO,IAAKpM,EAAOA,EAAKooC,WACxD,IAAKpoC,GAAyB,IAAjBA,EAAKiF,UACfjF,EAAK09C,YAAc19C,EAAK09C,WAAWtvB,UAAUla,GAC9C,OAAO,EACb,OAAO,EAjDCquD,CAAmB3kE,EAAMsW,IAAWwlD,GAAiB97D,EAAMsW,KAC1DtW,EAAK0gB,UAAcpK,EAAM1V,QAAQ66D,IAClCv2C,EAAQllB,EAAMsW,MAItB,IAAK,IAAIA,KAASkQ,GAAUwb,EAAM1rB,GAI9BH,EAAOghB,QAAUn3B,EAAKwO,IAAI6Y,iBAAiB,SAAS,WAAc,OAAO,QAE7Es0C,GAAgB37D,GA+5ChB4kE,CAAU94D,MAEVA,KAAK+4D,kBAAoB,GACzB/4D,KAAKg5D,YAAc,GACnBh5D,KAAKi5D,qBAGHzmC,GAAuB,CAAEhzB,MAAO,CAAE0uB,cAAc,GAAOgqB,KAAM,CAAEhqB,cAAc,GAAOzrB,YAAa,CAAEyrB,cAAc,IAmVrH,SAAS0qC,GAAe1kE,GACtB,IAAIsH,EAAQgD,OAAOlE,OAAO,MAkB1B,OAjBAkB,EAAM0nD,MAAQ,cACd1nD,EAAM09D,gBAAkBvtC,OAAOz3B,EAAK0gB,UACpCpZ,EAAM29D,UAAY,KAElBjlE,EAAKgX,SAAS,cAAc,SAAU3M,GAEpC,GADoB,mBAATA,IAAuBA,EAAQA,EAAMrK,EAAKP,QACjD4K,EAAS,IAAK,IAAI45B,KAAQ55B,EAChB,SAAR45B,IACA38B,EAAM0nD,OAAS,IAAM3kD,EAAM45B,IACnB,SAARA,EACF38B,EAAM8hB,OAAS9hB,EAAM8hB,MAAQ9hB,EAAM8hB,MAAQ,IAAM,IAAM/e,EAAM45B,GAErD38B,EAAM28B,IAAiB,mBAARA,GAAqC,YAARA,IAClD38B,EAAM28B,GAAQxM,OAAOptB,EAAM45B,QAI5B,CAACg9B,GAAW7+D,KAAK,EAAGpC,EAAKP,MAAM4B,IAAIJ,QAAQC,KAAMoG,IAG1D,SAASk9D,GAAoBxkE,GAC3B,GAAIA,EAAKm/D,WAAY,CACnB,IAAI3wD,EAAMiE,SAASgS,cAAc,OACjCjW,EAAI+jD,UAAY,wBAChB/jD,EAAIsgB,aAAa,mBAAoB,QACrCtgB,EAAIsgB,aAAa,MAAO,IACxB9uB,EAAKmxD,cAAgB,CAAC3iD,IAAKA,EAAK68C,KAAM4V,GAAW/Y,OAAOloD,EAAKP,MAAME,UAAU2pC,KAAM96B,EAAK,CAACi7C,KAAK,EAAMh5C,MAAOzQ,EAAKm/D,mBAEhHn/D,EAAKmxD,cAAgB,KAIzB,SAASoT,GAAYvkE,GACnB,OAAQA,EAAKgX,SAAS,YAAY,SAAU3M,GAAS,OAA6B,IAAtBA,EAAMrK,EAAKP,UAQzE,SAASglE,GAAezkE,GACtB,IAAImW,EAAS,GAKb,OAJAnW,EAAKgX,SAAS,aAAa,SAAUkB,GACnC,IAAK,IAAIG,KAAQH,EAAY5N,OAAOC,UAAUgrB,eAAe9qB,KAAK0L,EAAQkC,KACtElC,EAAOkC,GAAQH,EAAIG,OAElBlC,EAaT,SAASiuD,GAAoBhlD,GAC3B,GAAIA,EAAOve,KAAKpB,OAAS2f,EAAOve,KAAKgzC,mBAAqBz0B,EAAOve,KAAKkiB,kBAClE,MAAM,IAAI0X,WAAW,uEA1Y3B6D,GAAqBhzB,MAAMktB,IAAM,WAC/B,GAAI1sB,KAAKo4D,OAAOzkE,OAASqM,KAAKrM,MAAO,CACnC,IAAIumB,EAAOla,KAAKo4D,OAEhB,IAAK,IAAIn4D,KADTD,KAAKo4D,OAAS,GACGl+C,EAAQla,KAAKo4D,OAAOn4D,GAAQia,EAAKja,GAClDD,KAAKo4D,OAAOzkE,MAAQqM,KAAKrM,MAE3B,OAAOqM,KAAKo4D,QAMdD,GAAW15D,UAAUkuB,OAAS,SAAiBntB,GACzCA,EAAMsV,iBAAmB9U,KAAKo4D,OAAOtjD,iBAAmB+6C,GAAgB7vD,MAC5EA,KAAKo4D,OAAS54D,EACVA,EAAM6T,UACR7T,EAAM6T,QAAQlU,QAAQm5D,IACtBt4D,KAAKq4D,cAAgB74D,EAAM6T,SAE7BrT,KAAKo5D,iBAAiB55D,EAAM7L,OAAO,IAOrCwkE,GAAW15D,UAAU0kB,SAAW,SAAmB3jB,GACjD,IAAIunC,EAAU,GACd,IAAK,IAAI9mC,KAAQD,KAAKo4D,OAAUrxB,EAAQ9mC,GAAQD,KAAKo4D,OAAOn4D,GAE5D,IAAK,IAAIo7B,KADT0L,EAAQpzC,MAAQqM,KAAKrM,MACF6L,EAASunC,EAAQ1L,GAAU77B,EAAM67B,GACpDr7B,KAAK2sB,OAAOoa,IAMdoxB,GAAW15D,UAAU2kB,YAAc,SAAsBzvB,GACvDqM,KAAKo5D,iBAAiBzlE,EAAOqM,KAAKrM,MAAM0f,SAAW1f,EAAM0f,UAG3D8kD,GAAW15D,UAAU26D,iBAAmB,SAA2BzlE,EAAO0lE,GACtE,IAAIj/B,EAASp6B,KAEXka,EAAOla,KAAKrM,MAAO2lE,GAAS,EAAOC,GAAY,EAQnD,GALI5lE,EAAM8T,aAAezH,KAAKuZ,YAC5B05C,GAAiBjzD,MACjBu5D,GAAY,GAEdv5D,KAAKrM,MAAQA,EACT0lE,EAAc,CAChB,IAAI93C,EAAYo3C,GAAe34D,OAwUnC,SAA0BwgB,EAAGrE,GAC3B,IAAIq9C,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIltD,KAAQiU,EAAG,CAClB,GAAIA,EAAEjU,IAAS4P,EAAE5P,GAAS,OAAO,EACjCitD,IAEF,IAAK,IAAI5vC,KAAKzN,EAAKs9C,IACnB,OAAOD,GAAMC,GA9UPC,CAAiBn4C,EAAWvhB,KAAKuhB,aACnCvhB,KAAKuhB,UAAYA,EACjB+3C,GAAS,GAEXzJ,GAAgB7vD,MAGlBA,KAAK4U,SAAW6jD,GAAYz4D,MAC5B04D,GAAoB14D,MACpB,IAAIy+C,EAAYsZ,GAAgB/3D,MAAOw+C,EAAYoa,GAAe54D,MAE9D25D,EAASN,EAAe,QACtB1lE,EAAMimE,kBAAoB1/C,EAAK0/C,kBAAoB,eAAiB,WACtEC,EAAYP,IAAWt5D,KAAKokB,QAAQi3B,YAAY1nD,EAAM4B,IAAKipD,EAAWC,IACtEob,GAAclmE,EAAME,UAAU2T,GAAG0S,EAAKrmB,aAAc0lE,GAAY,GACpE,IA9nF0BrlE,EACtB2oD,EACA3I,EAs6F2B4lB,EAAMC,EACjC3jE,EA3+JkBU,EAClBkjE,EACAC,EACA5jB,EAEA6jB,EA2rJAC,EAAyB,YAAVR,GAAwBJ,GAA8C,MAAjCv5D,KAAK0C,IAAI4a,MAAM88C,gBA5tJzE,SAAwBlmE,GAGtB,IAFA,IACI8lE,EAAQC,EADRllB,EAAO7gD,EAAKwO,IAAI4iB,wBAAyB0wB,EAAS30C,KAAKC,IAAI,EAAGyzC,EAAKlqB,KAE9D1F,GAAK4vB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAG5F,EAAI4wB,EAAS,EACnD5wB,EAAI/jB,KAAKc,IAAIk4D,YAAatlB,EAAKjqB,QAAS1F,GAAK,EAAG,CACnD,IAAI1iB,EAAMxO,EAAKgkD,KAAKZ,iBAAiBnyB,EAAGC,GACxC,GAAI1iB,GAAOxO,EAAKwO,KAAQxO,EAAKwO,IAAI4Y,SAAS5Y,GAA1C,CACA,IAAI43D,EAAY53D,EAAI4iB,wBACpB,GAAIg1C,EAAUzvC,KAAOmrB,EAAS,GAAI,CAChCgkB,EAASt3D,EACTu3D,EAASK,EAAUzvC,IACnB,QAGJ,MAAO,CAACmvC,OAAQA,EAAQC,OAAQA,EAAQ5jB,MAAOD,EAAYliD,EAAKwO,MA8sJiC63D,CAAev6D,MAEhH,GAAIu5D,EAAW,CACbv5D,KAAKglD,YAAYnH,OAMjB,IAAI2c,EAAiBX,IAAcxvD,EAAOohB,IAAMphB,EAAO+gB,UAAYprB,KAAKuZ,YACnEW,EAAKrmB,UAAUC,QAAUH,EAAME,UAAUC,QAgSjBgmE,EAhSkD5/C,EAAKrmB,UAgSjDkmE,EAhS4DpmE,EAAME,UAiSnGuC,EAAQiL,KAAKc,IAAI23D,EAAKtiE,QAAQ8V,YAAYwsD,EAAKt8B,MAAOu8B,EAAKviE,QAAQ8V,YAAYysD,EAAKv8B,OACjFs8B,EAAKtiE,QAAQ2D,MAAM/E,IAAU2jE,EAAKviE,QAAQ2D,MAAM/E,IAjSrD,GAAIyjE,EAAW,CAKb,IAAIY,EAAepwD,EAAO+gB,OAAUprB,KAAKyiD,YAAcziD,KAAKk4C,KAAKt1C,eAAe03C,UAAa,MACzFgf,GAAWt5D,KAAKokB,QAAQuI,OAAOh5B,EAAM4B,IAAKipD,EAAWC,EAAWz+C,QAClEA,KAAKokB,QAAQ09B,gBAAgB,IAC7B9hD,KAAKokB,QAAQ5I,UACbxb,KAAKokB,QAAUk+B,EAAY3uD,EAAM4B,IAAKipD,EAAWC,EAAWz+C,KAAK0C,IAAK1C,OAEpEy6D,IAAiBz6D,KAAKyiD,cAAe+X,GAAiB,GAMxDA,KACEx6D,KAAK6kD,WAAa7kD,KAAKglD,YAAYC,iBAAiBz9C,GAAGxH,KAAKk4C,KAAKt1C,kBA3pF/C1O,EA2pFqF8L,KA1pF3G68C,EAAY3oD,EAAKkwB,QAAQ20B,WAAW7kD,EAAKP,MAAME,UAAUkxC,OAAQ,GACjEmP,EAAShgD,EAAKgkD,KAAKt1C,eAChB6wC,EAAqBoJ,EAAUvmD,KAAMumD,EAAUn3C,OAAQwuC,EAAO+I,WAAY/I,EAAOgJ,gBAypFpFyH,GAAe3kD,KAAMw6D,IAErB5V,GAAkB5kD,KAAMrM,EAAME,WAC9BmM,KAAKglD,YAAYG,mBAEnBnlD,KAAKglD,YAAY7pD,QAKnB,GAFA6E,KAAKi5D,kBAAkB/+C,GAET,SAAVy/C,EACF35D,KAAK0C,IAAIuzC,UAAY,OAChB,GAAc,gBAAV0jB,EAA0B,CACnC,IAAItkB,EAAWr1C,KAAKk4C,KAAKt1C,eAAe03C,UACpCt6C,KAAKkL,SAAS,2BAA2B,SAAUC,GAAK,OAAOA,EAAEivB,QAE5DzmC,EAAME,qBAAqB,KAChCuhD,EAAmBp1C,KAAMA,KAAKokB,QAAQu2B,YAAYhnD,EAAME,UAAU8B,MAAM2vB,wBAAyB+vB,GAEjGD,EAAmBp1C,KAAMA,KAAK4qB,YAAYj3B,EAAME,UAAU2pC,KAAM,GAAI6X,SAC/D8kB,IAjvJPH,GADkBljE,EAmvJLqjE,GAlvJAH,OACbC,EAASnjE,EAAImjE,OACb5jB,EAAQv/C,EAAIu/C,MAEZ6jB,EAAYF,EAASA,EAAO10C,wBAAwBuF,IAAM,EAC9DyrB,EAAmBD,EAAoB,GAAb6jB,EAAiB,EAAIA,EAAYD,KAivJ7D9B,GAAW15D,UAAUi8D,mBAAqB,WAExC,IADA,IAAIxmE,EACGA,EAAO8L,KAAKg5D,YAAY1hC,OAAapjC,EAAKsnB,SAAWtnB,EAAKsnB,WAGnE28C,GAAW15D,UAAUw6D,kBAAoB,SAA4B0B,GACnE,GAAKA,GAAaA,EAAUtnD,SAAWrT,KAAKrM,MAAM0f,SAAWrT,KAAKq4D,eAAiBr4D,KAAK+4D,kBAYtF,IAAK,IAAIx7D,EAAM,EAAGA,EAAMyC,KAAKg5D,YAAY3+D,OAAQkD,IAAO,CACtD,IAAIq9D,EAAa56D,KAAKg5D,YAAYz7D,GAC9Bq9D,EAAWjuC,QAAUiuC,EAAWjuC,OAAO3sB,KAAM26D,OAdsD,CACzG36D,KAAK+4D,kBAAoB/4D,KAAKq4D,cAC9Br4D,KAAK06D,qBACL,IAAK,IAAIzjE,EAAI,EAAGA,EAAI+I,KAAKq4D,cAAch+D,OAAQpD,IAAK,CAClD,IAAIqc,EAAStT,KAAKq4D,cAAcphE,GAC5Bqc,EAAOve,KAAKb,MAAQ8L,KAAKg5D,YAAYp+D,KAAK0Y,EAAOve,KAAKb,KAAK8L,OAEjE,IAAK,IAAIhF,EAAM,EAAGA,EAAMgF,KAAKrM,MAAM0f,QAAQhZ,OAAQW,IAAO,CACxD,IAAI6/D,EAAW76D,KAAKrM,MAAM0f,QAAQrY,GAC9B6/D,EAAS9lE,KAAKb,MAAQ8L,KAAKg5D,YAAYp+D,KAAKigE,EAAS9lE,KAAKb,KAAK8L,UAiBzEm4D,GAAW15D,UAAUyM,SAAW,SAAmBolD,EAAUnlD,GAC3D,IAAiD5M,EAA7CgO,EAAOvM,KAAKo4D,QAAUp4D,KAAKo4D,OAAO9H,GACtC,GAAY,MAAR/jD,IAAiBhO,EAAQ4M,EAAIA,EAAEoB,GAAQA,GAAS,OAAOhO,EAC3D,IAAK,IAAItH,EAAI,EAAGA,EAAI+I,KAAKq4D,cAAch+D,OAAQpD,IAAK,CAClD,IAAIyiC,EAAS15B,KAAKq4D,cAAcphE,GAAGuI,MAAM8wD,GACzC,GAAc,MAAV52B,IAAmBn7B,EAAQ4M,EAAIA,EAAEuuB,GAAUA,GAAW,OAAOn7B,EAEnE,IAAI8U,EAAUrT,KAAKrM,MAAM0f,QACzB,GAAIA,EAAW,IAAK,IAAIrY,EAAM,EAAGA,EAAMqY,EAAQhZ,OAAQW,IAAO,CAC5D,IAAI8+B,EAASzmB,EAAQrY,GAAKwE,MAAM8wD,GAChC,GAAc,MAAVx2B,IAAmBv7B,EAAQ4M,EAAIA,EAAE2uB,GAAUA,GAAW,OAAOv7B,IAMrE45D,GAAW15D,UAAU6I,SAAW,WAC9B,OAAOtH,KAAKk4C,KAAK0B,eAAiB55C,KAAK0C,KAKzCy1D,GAAW15D,UAAU2I,MAAQ,WAC3BpH,KAAKglD,YAAYnH,OACb79C,KAAK4U,UAxxJX,SAA4BlS,GAC1B,GAAIA,EAAIo4D,UAAa,OAAOp4D,EAAIo4D,YAChC,GAAItkB,EAA0B,OAAO9zC,EAAI0E,MAAMovC,GAE/C,IAAIr8B,EAASi8B,EAAY1zC,GACzBA,EAAI0E,MAAgC,MAA1BovC,EAAiC,CACrCukB,oBAEF,OADAvkB,EAAyB,CAACukB,eAAe,IAClC,SAEPl7D,GACC22C,IACHA,GAAyB,EACzBF,EAAmBn8B,EAAQ,IA2wJR6gD,CAAmBh7D,KAAK0C,KAC7CiiD,GAAe3kD,MACfA,KAAKglD,YAAY7pD,SAQnBq3B,GAAqB0lB,KAAKxrB,IAAM,WAC9B,IAAI4G,EAAStzB,KAAKu4D,MAClB,GAAc,MAAVjlC,EAAkB,IAAK,IAAI1L,EAAS5nB,KAAK0C,IAAIg8B,WAAY9W,EAAQA,EAASA,EAAO8W,WACnF,GAAuB,GAAnB9W,EAAOrsB,UAAqC,IAAnBqsB,EAAOrsB,UAAkBqsB,EAAOurB,KAE3D,OADKvrB,EAAOhlB,eAAgBpE,OAAOM,eAAe8oB,GAAQhlB,aAAe,WAAc,OAAO+D,SAAS/D,iBAChG5C,KAAKu4D,MAAQ3wC,EAGxB,OAAO0L,GAAU3sB,UAWnBwxD,GAAW15D,UAAUi5C,YAAc,SAAwBhB,GACzD,OAAOgB,EAAY13C,KAAM02C,IAU3ByhB,GAAW15D,UAAUmsB,YAAc,SAAwB30B,EAAKM,GAG9D,YAFgB,IAATA,IAAkBA,EAAO,GAEzBq0B,EAAY5qB,KAAM/J,EAAKM,IAYhC4hE,GAAW15D,UAAUw8D,SAAW,SAAmBhlE,EAAKM,GAGtD,YAFgB,IAATA,IAAkBA,EAAO,GAEzByJ,KAAKokB,QAAQ20B,WAAW9iD,EAAKM,IAYtC4hE,GAAW15D,UAAUu9C,QAAU,SAAkB/lD,GAC/C,IAAIuxC,EAAOxnC,KAAKokB,QAAQ63B,OAAOhmD,GAC/B,OAAOuxC,EAAOA,EAAKwU,QAAU,MAY/Bmc,GAAW15D,UAAUy8D,SAAW,SAAmB5kE,EAAMoP,EAAQyD,QAC/C,IAATA,IAAkBA,GAAQ,GAEjC,IAAIlT,EAAM+J,KAAKokB,QAAQq0B,WAAWniD,EAAMoP,EAAQyD,GAChD,GAAW,MAAPlT,EAAe,MAAM,IAAI04B,WAAW,sCACxC,OAAO14B,GAUTkiE,GAAW15D,UAAUrK,eAAiB,SAA2BkxC,EAAK3xC,GACpE,OAAOS,EAAe4L,KAAMrM,GAASqM,KAAKrM,MAAO2xC,IAMnD6yB,GAAW15D,UAAU+c,QAAU,WACxBxb,KAAKokB,WAvsDZ,SAAsBlwB,GAEpB,IAAK,IAAIY,KADTZ,EAAK8wD,YAAYnH,OACA3pD,EAAK67D,cAClB77D,EAAKwO,IAAI+Y,oBAAoB3mB,EAAMZ,EAAK67D,cAAcj7D,IAC1D+5D,aAAa36D,EAAK8+D,kBAClBnE,aAAa36D,EAAKm9D,6BAmsDlB8J,CAAan7D,MACbA,KAAK06D,qBACD16D,KAAKw4D,SACPx4D,KAAKokB,QAAQuI,OAAO3sB,KAAKrM,MAAM4B,IAAK,GAAIwiE,GAAgB/3D,MAAOA,MAC/DA,KAAK0C,IAAI+T,YAAc,IACdzW,KAAK0C,IAAIg8B,YAClB1+B,KAAK0C,IAAIg8B,WAAWijB,YAAY3hD,KAAK0C,KAEvC1C,KAAKokB,QAAQ5I,UACbxb,KAAKokB,QAAU,OAOjBoO,GAAqB/vB,YAAYiqB,IAAM,WACrC,OAAuB,MAAhB1sB,KAAKokB,SAId+zC,GAAW15D,UAAU28D,cAAgB,SAA0B5wD,GAC7D,OA9rDF,SAAuBtW,EAAMsW,GACtBwlD,GAAiB97D,EAAMsW,KAAUkQ,GAASlQ,EAAM1V,QAChDZ,EAAK0gB,UAAcpK,EAAM1V,QAAQ66D,IAClCj1C,GAASlQ,EAAM1V,MAAMZ,EAAMsW,GA2rDxB4wD,CAAcp7D,KAAMwK,IAW7B2tD,GAAW15D,UAAU7K,SAAW,SAAmBG,GACjD,IAAI6vB,EAAsB5jB,KAAKo4D,OAAOx0C,oBAClCA,EAAuBA,EAAoBjlB,KAAKqB,KAAMjM,GACnDiM,KAAKojB,YAAYpjB,KAAKrM,MAAMuhB,MAAMnhB,KAG3CyK,OAAO+wB,iBAAkB4oC,GAAW15D,UAAW+zB","sources":["webpack://oira.prototype/./node_modules/prosemirror-commands/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-schema-list/dist/index.es.js","webpack://oira.prototype/./node_modules/@tiptap/core/dist/tiptap-core.esm.js","webpack://oira.prototype/./node_modules/w3c-keyname/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-keymap/dist/index.es.js","webpack://oira.prototype/./node_modules/orderedmap/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-model/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-state/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-transform/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-view/dist/index.es.js"],"sourcesContent":["import { liftTarget, replaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, AllSelection, TextSelection } from 'prosemirror-state';\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) { return false }\n  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    { return false }\n\n  var $cut = findCutBefore($cursor);\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    var range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null) { return false }\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  var before = $cut.nodeBefore;\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    { return true }\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n        dispatch(tr.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) { return true }\n    if (only && node.childCount != 1) { return false }\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n  if (!empty) { return false }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) { return false }\n    $cut = findCutBefore($head);\n  }\n  var node = $cut && $cut.nodeBefore;\n  if (!node || !NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }\n    if ($pos.node(i).type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    { return false }\n\n  var $cut = findCutAfter($cursor);\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) { return false }\n\n  var after = $cut.nodeAfter;\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) { return true }\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n  if (!empty) { return false }\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      { return false }\n    $cut = findCutAfter($head);\n  }\n  var node = $cut && $cut.nodeAfter;\n  if (!node || !NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    var parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }\n    if (parent.type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nfunction joinUp(state, dispatch) {\n  var sel = state.selection, nodeSel = sel instanceof NodeSelection, point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) { return false }\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n    if (point == null) { return false }\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point);\n    if (nodeSel) { tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nfunction joinDown(state, dispatch) {\n  var sel = state.selection, point;\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) { return false }\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n    if (point == null) { return false }\n  }\n  if (dispatch)\n    { dispatch(state.tr.join(point).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to), target = range && liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  if (dispatch) { dispatch(state.tr.insertText(\"\\n\").scrollIntoView()); }\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var ref = match.edge(i);\n    var type = ref.type;\n    if (type.isTextblock && !type.hasRequiredAttrs()) { return type }\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n  if (!above.canReplaceWith(after, after, type)) { return false }\n  if (dispatch) {\n    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nfunction createParagraphNear(state, dispatch) {\n  var sel = state.selection;\n  var $from = sel.$from;\n  var $to = sel.$to;\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) { return false }\n  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock) { return false }\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || $cursor.parent.content.size) { return false }\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n    if (canSplit(state.doc, before)) {\n      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }\n      return true\n    }\n  }\n  var range = $cursor.blockRange(), target = range && liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) { return false }\n    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }\n    return true\n  }\n\n  if (!$from.parent.isBlock) { return false }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) { tr.deleteSelection(); }\n    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    var types = atEnd && deflt ? [{type: deflt}] : null;\n    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}];\n      can = true;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }\n      }\n    }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (function (tr) {\n    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n    if (marks) { tr.ensureMarks(marks); }\n    dispatch(tr);\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n  if (same == 0) { return false }\n  pos = $from.before(same);\n  if (dispatch) { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos))); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nfunction selectAll(state, dispatch) {\n  if (dispatch) { dispatch(state.tr.setSelection(new AllSelection(state.doc))); }\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    { return false }\n  if (dispatch)\n    { dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView()); }\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n  if (before.type.spec.isolating || after.type.spec.isolating) { return false }\n  if (joinMaybeClear(state, $cut, dispatch)) { return true }\n\n  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize, wrap = Fragment.empty;\n      for (var i = conn.length - 1; i >= 0; i--)\n        { wrap = Fragment.from(conn[i].create(null, wrap)); }\n      wrap = Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n      if (canJoin(tr.doc, joinAt)) { tr.join(joinAt); }\n      dispatch(tr.scrollIntoView());\n    }\n    return true\n  }\n\n  var selAfter = Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    var at = before, wrap$1 = [];\n    for (;;) {\n      wrap$1.push(at);\n      if (at.isTextblock) { break }\n      at = at.lastChild;\n    }\n    var afterText = after, afterDepth = 1;\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) { afterDepth++; }\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        var end$1 = Fragment.empty;\n        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = Fragment.from(wrap$1[i$1].copy(end$1)); }\n        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end$1, wrap$1.length, 0), 0, true));\n        dispatch(tr$1.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n    var depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth) { return false }\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock) { return false }\n    if (dispatch)\n      { dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth)))); }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the start of current text block.\nvar selectTextblockStart = selectTextblockSide(-1);\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the end of current text block.\nvar selectTextblockEnd = selectTextblockSide(1);\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nfunction wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) { return false }\n    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nfunction setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) { return false }\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos), index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n    if (!applicable) { return false }\n    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function ( i ) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) { return false }\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n    if (can) { return { v: true } }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nfunction toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          { dispatch(state.tr.removeStoredMark(markType)); }\n        else\n          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }\n      } else {\n        var has = false, tr = state.tr;\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n          if (has) {\n            tr.removeMark($from$1.pos, $to$1.pos, markType);\n          } else {\n            var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;\n            var spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) { return dispatch(tr) }\n\n    var ranges = [];\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n      for (var j = 0; j < ranges.length; j++)\n        { ranges[j] = map.map(ranges[j]); }\n      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    var joinable = [];\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1], to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n        if (!after) { break }\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after))\n            { joinable.push(pos); }\n        }\n        pos += after.nodeSize;\n      }\n    }\n    // Join the joinable points\n    joinable.sort(function (a, b) { return a - b; });\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }\n    }\n    dispatch(tr);\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };\n  }\n  return function (state, dispatch, view) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view); }\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nfunction chainCommands() {\n  var commands = [], len = arguments.length;\n  while ( len-- ) commands[ len ] = arguments[ len ];\n\n  return function(state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++)\n      { if (commands[i](state, dispatch, view)) { return true } }\n    return false\n  }\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }\n\npcBaseKeymap.Home = selectTextblockStart;\npcBaseKeymap.End = selectTextblockEnd;\n\n// declare global: os, navigator\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };\n//# sourceMappingURL=index.es.js.map\n","import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\n\nvar olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nvar orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n};\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nvar bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM: function toDOM() { return ulDOM }\n};\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nvar listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM: function toDOM() { return liDOM },\n  defining: true\n};\n\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nfunction wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), doJoin = false, outerRange = range;\n    if (!range) { return false }\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) { return false }\n      var $insert = state.doc.resolve(range.start - 2);\n      outerRange = new NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount)\n        { range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }\n      doJoin = true;\n    }\n    var wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap) { return false }\n    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true));\n\n  var found = 0;\n  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }\n  var splitDepth = wrappers.length - found;\n\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(i$2).nodeSize;\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nfunction splitListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) { return false }\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) { return false }\n      if (dispatch) {\n        var wrap = Fragment.empty;\n        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n          { wrap = Fragment.from($from.node(d).copy(wrap)); }\n        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n            : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        var start = $from.before($from.depth - (depthBefore - 1));\n        var tr$1 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n        var sel = -1;\n        tr$1.doc.nodesBetween(start, tr$1.doc.content.size, function (node, pos) {\n          if (sel > -1) { return false }\n          if (node.isTextblock && node.content.size == 0) { sel = pos + 1; }\n        });\n        if (sel > -1) { tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel))); }\n        dispatch(tr$1.scrollIntoView());\n      }\n      return true\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr.delete($from.pos, $to.pos);\n    var types = nextType && [null, {type: nextType}];\n    if (!canSplit(tr.doc, $from.pos, 2, types)) { return false }\n    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nfunction liftListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    if (!dispatch) { return true }\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      { return liftToOuterList(state, dispatch, itemType, range) }\n    else // Outer list node\n      { return liftOutOfList(state, dispatch, range) }\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr, list = range.parent;\n  // Merge the list items into a single big item\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) { return false }\n  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1), indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n    { return false }\n  var start = $start.pos, end = start + item.nodeSize;\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n                                          .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nfunction sinkListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    var startIndex = range.startIndex;\n    if (startIndex == 0) { return false }\n    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) { return false }\n\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),\n                            nestedBefore ? 3 : 1, 0);\n      var before = range.start, after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView());\n    }\n    return true\n  }\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };\n//# sourceMappingURL=index.es.js.map\n","import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit, canJoin, findWrapping, Transform } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$2, deleteSelection as deleteSelection$2, exitCode as exitCode$2, joinBackward as joinBackward$2, joinForward as joinForward$2, lift as lift$2, liftEmptyBlock as liftEmptyBlock$2, newlineInCode as newlineInCode$2, selectNodeBackward as selectNodeBackward$2, selectNodeForward as selectNodeForward$2, selectParentNode as selectParentNode$2, selectTextblockEnd as selectTextblockEnd$2, selectTextblockStart as selectTextblockStart$2, setBlockType, wrapIn as wrapIn$2 } from 'prosemirror-commands';\nimport { Fragment, DOMParser, Slice, DOMSerializer, Schema, Node as Node$1 } from 'prosemirror-model';\nimport { liftListItem as liftListItem$2, sinkListItem as sinkListItem$2, wrapInList as wrapInList$2 } from 'prosemirror-schema-list';\nimport { EditorView } from 'prosemirror-view';\nimport { keymap } from 'prosemirror-keymap';\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\r\nfunction getType(value) {\r\n    return Object.prototype.toString.call(value).slice(8, -1);\r\n}\r\nfunction isPlainObject(value) {\r\n    if (getType(value) !== 'Object') {\r\n        return false;\r\n    }\r\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\r\n}\n\nfunction mergeDeep(target, source) {\r\n    const output = { ...target };\r\n    if (isPlainObject(target) && isPlainObject(source)) {\r\n        Object.keys(source).forEach(key => {\r\n            if (isPlainObject(source[key])) {\r\n                if (!(key in target)) {\r\n                    Object.assign(output, { [key]: source[key] });\r\n                }\r\n                else {\r\n                    output[key] = mergeDeep(target[key], source[key]);\r\n                }\r\n            }\r\n            else {\r\n                Object.assign(output, { [key]: source[key] });\r\n            }\r\n        });\r\n    }\r\n    return output;\r\n}\n\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\r\nfunction callOrReturn(value, context = undefined, ...props) {\r\n    if (isFunction(value)) {\r\n        if (context) {\r\n            return value.bind(context)(...props);\r\n        }\r\n        return value(...props);\r\n    }\r\n    return value;\r\n}\n\nfunction getExtensionField(extension, field, context) {\r\n    if (extension.config[field] === undefined && extension.parent) {\r\n        return getExtensionField(extension.parent, field, context);\r\n    }\r\n    if (typeof extension.config[field] === 'function') {\r\n        const value = extension.config[field].bind({\r\n            ...context,\r\n            parent: extension.parent\r\n                ? getExtensionField(extension.parent, field, context)\r\n                : null,\r\n        });\r\n        return value;\r\n    }\r\n    return extension.config[field];\r\n}\n\nclass Extension {\r\n    constructor(config = {}) {\r\n        this.type = 'extension';\r\n        this.name = 'extension';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Extension(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Extension(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nfunction getTextBetween(startNode, range, options) {\r\n    const { from, to } = range;\r\n    const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n    let text = '';\r\n    let separated = true;\r\n    startNode.nodesBetween(from, to, (node, pos, parent, index) => {\r\n        var _a;\r\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\r\n        if (textSerializer) {\r\n            if (node.isBlock && !separated) {\r\n                text += blockSeparator;\r\n                separated = true;\r\n            }\r\n            text += textSerializer({\r\n                node,\r\n                pos,\r\n                parent,\r\n                index,\r\n            });\r\n        }\r\n        else if (node.isText) {\r\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\r\n            separated = false;\r\n        }\r\n        else if (node.isBlock && !separated) {\r\n            text += blockSeparator;\r\n            separated = true;\r\n        }\r\n    });\r\n    return text;\r\n}\n\nfunction getTextSeralizersFromSchema(schema) {\r\n    return Object.fromEntries(Object\r\n        .entries(schema.nodes)\r\n        .filter(([, node]) => node.spec.toText)\r\n        .map(([name, node]) => [name, node.spec.toText]));\r\n}\n\nconst ClipboardTextSerializer = Extension.create({\r\n    name: 'clipboardTextSerializer',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('clipboardTextSerializer'),\r\n                props: {\r\n                    clipboardTextSerializer: () => {\r\n                        const { editor } = this;\r\n                        const { state, schema } = editor;\r\n                        const { doc, selection } = state;\r\n                        const { ranges } = selection;\r\n                        const from = Math.min(...ranges.map(range => range.$from.pos));\r\n                        const to = Math.max(...ranges.map(range => range.$to.pos));\r\n                        const textSerializers = getTextSeralizersFromSchema(schema);\r\n                        const range = { from, to };\r\n                        return getTextBetween(doc, range, {\r\n                            textSerializers,\r\n                        });\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst blur = () => ({ editor, view }) => {\r\n    requestAnimationFrame(() => {\r\n        var _a;\r\n        if (!editor.isDestroyed) {\r\n            view.dom.blur();\r\n            // Browsers should remove the caret on blur but safari does not.\r\n            // See: https://github.com/ueberdosis/tiptap/issues/2405\r\n            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n        }\r\n    });\r\n    return true;\r\n};\n\nvar blur$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur\n});\n\nconst clearContent = (emitUpdate = false) => ({ commands }) => {\r\n    return commands.setContent('', emitUpdate);\r\n};\n\nvar clearContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearContent: clearContent\n});\n\nconst clearNodes = () => ({ state, tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    ranges.forEach(({ $from, $to }) => {\r\n        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\r\n            if (node.type.isText) {\r\n                return;\r\n            }\r\n            const { doc, mapping } = tr;\r\n            const $mappedFrom = doc.resolve(mapping.map(pos));\r\n            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\r\n            const nodeRange = $mappedFrom.blockRange($mappedTo);\r\n            if (!nodeRange) {\r\n                return;\r\n            }\r\n            const targetLiftDepth = liftTarget(nodeRange);\r\n            if (node.type.isTextblock) {\r\n                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\r\n                tr.setNodeMarkup(nodeRange.start, defaultType);\r\n            }\r\n            if (targetLiftDepth || targetLiftDepth === 0) {\r\n                tr.lift(nodeRange, targetLiftDepth);\r\n            }\r\n        });\r\n    });\r\n    return true;\r\n};\n\nvar clearNodes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearNodes: clearNodes\n});\n\nconst command = fn => props => {\r\n    return fn(props);\r\n};\n\nvar command$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  command: command\n});\n\nconst createParagraphNear = () => ({ state, dispatch }) => {\r\n    return createParagraphNear$2(state, dispatch);\r\n};\n\nvar createParagraphNear$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createParagraphNear: createParagraphNear\n});\n\nfunction getNodeType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.nodes[nameOrType]) {\r\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.nodes[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nconst deleteNode = typeOrName => ({ tr, state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const $pos = tr.selection.$anchor;\r\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\r\n        const node = $pos.node(depth);\r\n        if (node.type === type) {\r\n            if (dispatch) {\r\n                const from = $pos.before(depth);\r\n                const to = $pos.after(depth);\r\n                tr.delete(from, to).scrollIntoView();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar deleteNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteNode: deleteNode\n});\n\nconst deleteRange = range => ({ tr, dispatch }) => {\r\n    const { from, to } = range;\r\n    if (dispatch) {\r\n        tr.delete(from, to);\r\n    }\r\n    return true;\r\n};\n\nvar deleteRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteRange: deleteRange\n});\n\nconst deleteSelection = () => ({ state, dispatch }) => {\r\n    return deleteSelection$2(state, dispatch);\r\n};\n\nvar deleteSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteSelection: deleteSelection\n});\n\nconst enter = () => ({ commands }) => {\r\n    return commands.keyboardShortcut('Enter');\r\n};\n\nvar enter$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enter: enter\n});\n\nconst exitCode = () => ({ state, dispatch }) => {\r\n    return exitCode$2(state, dispatch);\r\n};\n\nvar exitCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  exitCode: exitCode\n});\n\nfunction getMarkType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.marks[nameOrType]) {\r\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.marks[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nfunction isRegExp(value) {\r\n    return Object.prototype.toString.call(value) === '[object RegExp]';\r\n}\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\r\nfunction objectIncludes(object1, object2, options = { strict: true }) {\r\n    const keys = Object.keys(object2);\r\n    if (!keys.length) {\r\n        return true;\r\n    }\r\n    return keys.every(key => {\r\n        if (options.strict) {\r\n            return object2[key] === object1[key];\r\n        }\r\n        if (isRegExp(object2[key])) {\r\n            return object2[key].test(object1[key]);\r\n        }\r\n        return object2[key] === object1[key];\r\n    });\r\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\r\n    return marks.find(item => {\r\n        return item.type === type && objectIncludes(item.attrs, attributes);\r\n    });\r\n}\r\nfunction isMarkInSet(marks, type, attributes = {}) {\r\n    return !!findMarkInSet(marks, type, attributes);\r\n}\r\nfunction getMarkRange($pos, type, attributes = {}) {\r\n    if (!$pos || !type) {\r\n        return;\r\n    }\r\n    const start = $pos.parent.childAfter($pos.parentOffset);\r\n    if (!start.node) {\r\n        return;\r\n    }\r\n    const mark = findMarkInSet(start.node.marks, type, attributes);\r\n    if (!mark) {\r\n        return;\r\n    }\r\n    let startIndex = $pos.index();\r\n    let startPos = $pos.start() + start.offset;\r\n    let endIndex = startIndex + 1;\r\n    let endPos = startPos + start.node.nodeSize;\r\n    findMarkInSet(start.node.marks, type, attributes);\r\n    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\r\n        startIndex -= 1;\r\n        startPos -= $pos.parent.child(startIndex).nodeSize;\r\n    }\r\n    while (endIndex < $pos.parent.childCount\r\n        && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {\r\n        endPos += $pos.parent.child(endIndex).nodeSize;\r\n        endIndex += 1;\r\n    }\r\n    return {\r\n        from: startPos,\r\n        to: endPos,\r\n    };\r\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { doc, selection } = tr;\r\n    const { $from, from, to } = selection;\r\n    if (dispatch) {\r\n        const range = getMarkRange($from, type, attributes);\r\n        if (range && range.from <= from && range.to >= to) {\r\n            const newSelection = TextSelection.create(doc, range.from, range.to);\r\n            tr.setSelection(newSelection);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar extendMarkRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extendMarkRange: extendMarkRange\n});\n\nconst first = commands => props => {\r\n    const items = typeof commands === 'function'\r\n        ? commands(props)\r\n        : commands;\r\n    for (let i = 0; i < items.length; i += 1) {\r\n        if (items[i](props)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar first$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  first: first\n});\n\nfunction isClass(value) {\r\n    var _a;\r\n    if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nfunction isObject(value) {\r\n    return (value\r\n        && typeof value === 'object'\r\n        && !Array.isArray(value)\r\n        && !isClass(value));\r\n}\n\nfunction isTextSelection(value) {\r\n    return isObject(value) && value instanceof TextSelection;\r\n}\n\nfunction isiOS() {\r\n    return [\r\n        'iPad Simulator',\r\n        'iPhone Simulator',\r\n        'iPod Simulator',\r\n        'iPad',\r\n        'iPhone',\r\n        'iPod',\r\n    ].includes(navigator.platform)\r\n        // iPad on iOS 13 detection\r\n        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\r\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\n\nfunction resolveFocusPosition(doc, position = null) {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n    const selectionAtStart = Selection.atStart(doc);\r\n    const selectionAtEnd = Selection.atEnd(doc);\r\n    if (position === 'start' || position === true) {\r\n        return selectionAtStart;\r\n    }\r\n    if (position === 'end') {\r\n        return selectionAtEnd;\r\n    }\r\n    const minPos = selectionAtStart.from;\r\n    const maxPos = selectionAtEnd.to;\r\n    if (position === 'all') {\r\n        return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\r\n    }\r\n    return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\r\n}\n\nconst focus = (position = null, options) => ({ editor, view, tr, dispatch, }) => {\r\n    options = {\r\n        scrollIntoView: true,\r\n        ...options,\r\n    };\r\n    const delayedFocus = () => {\r\n        // focus within `requestAnimationFrame` breaks focus on iOS\r\n        // so we have to call this\r\n        if (isiOS()) {\r\n            view.dom.focus();\r\n        }\r\n        // For React we have to focus asynchronously. Otherwise wild things happen.\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1520\r\n        requestAnimationFrame(() => {\r\n            if (!editor.isDestroyed) {\r\n                view.focus();\r\n                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\r\n                    editor.commands.scrollIntoView();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    if ((view.hasFocus() && position === null) || position === false) {\r\n        return true;\r\n    }\r\n    // we don’t try to resolve a NodeSelection or CellSelection\r\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\r\n        delayedFocus();\r\n        return true;\r\n    }\r\n    const selection = resolveFocusPosition(editor.state.doc, position) || editor.state.selection;\r\n    const isSameSelection = editor.state.selection.eq(selection);\r\n    if (dispatch) {\r\n        if (!isSameSelection) {\r\n            tr.setSelection(selection);\r\n        }\r\n        // `tr.setSelection` resets the stored marks\r\n        // so we’ll restore them if the selection is the same as before\r\n        if (isSameSelection && tr.storedMarks) {\r\n            tr.setStoredMarks(tr.storedMarks);\r\n        }\r\n        delayedFocus();\r\n    }\r\n    return true;\r\n};\n\nvar focus$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  focus: focus\n});\n\nconst forEach = (items, fn) => props => {\r\n    return items.every((item, index) => fn(item, { ...props, index }));\r\n};\n\nvar forEach$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  forEach: forEach\n});\n\nconst insertContent = (value, options) => ({ tr, commands }) => {\r\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\r\n};\n\nvar insertContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContent: insertContent\n});\n\nfunction elementFromString(value) {\r\n    // add a wrapper to preserve leading and trailing whitespace\r\n    const wrappedValue = `<body>${value}</body>`;\r\n    return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\r\n}\n\nfunction createNodeFromContent(content, schema, options) {\r\n    options = {\r\n        slice: true,\r\n        parseOptions: {},\r\n        ...options,\r\n    };\r\n    if (typeof content === 'object' && content !== null) {\r\n        try {\r\n            if (Array.isArray(content)) {\r\n                return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\r\n            }\r\n            return schema.nodeFromJSON(content);\r\n        }\r\n        catch (error) {\r\n            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\r\n            return createNodeFromContent('', schema, options);\r\n        }\r\n    }\r\n    if (typeof content === 'string') {\r\n        const parser = DOMParser.fromSchema(schema);\r\n        return options.slice\r\n            ? parser.parseSlice(elementFromString(content), options.parseOptions).content\r\n            : parser.parse(elementFromString(content), options.parseOptions);\r\n    }\r\n    return createNodeFromContent('', schema, options);\r\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\r\nfunction selectionToInsertionEnd(tr, startLen, bias) {\r\n    const last = tr.steps.length - 1;\r\n    if (last < startLen) {\r\n        return;\r\n    }\r\n    const step = tr.steps[last];\r\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\r\n        return;\r\n    }\r\n    const map = tr.mapping.maps[last];\r\n    let end = 0;\r\n    map.forEach((_from, _to, _newFrom, newTo) => {\r\n        if (end === 0) {\r\n            end = newTo;\r\n        }\r\n    });\r\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\r\n}\n\nconst isFragment = (nodeOrFragment) => {\r\n    return nodeOrFragment.toString().startsWith('<');\r\n};\r\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\r\n    if (dispatch) {\r\n        options = {\r\n            parseOptions: {},\r\n            updateSelection: true,\r\n            ...options,\r\n        };\r\n        const content = createNodeFromContent(value, editor.schema, {\r\n            parseOptions: {\r\n                preserveWhitespace: 'full',\r\n                ...options.parseOptions,\r\n            },\r\n        });\r\n        // don’t dispatch an empty fragment because this can lead to strange errors\r\n        if (content.toString() === '<>') {\r\n            return true;\r\n        }\r\n        let { from, to } = typeof position === 'number'\r\n            ? { from: position, to: position }\r\n            : position;\r\n        let isOnlyTextContent = true;\r\n        let isOnlyBlockContent = true;\r\n        const nodes = isFragment(content)\r\n            ? content\r\n            : [content];\r\n        nodes.forEach(node => {\r\n            // check if added node is valid\r\n            node.check();\r\n            isOnlyTextContent = isOnlyTextContent\r\n                ? node.isText && node.marks.length === 0\r\n                : false;\r\n            isOnlyBlockContent = isOnlyBlockContent\r\n                ? node.isBlock\r\n                : false;\r\n        });\r\n        // check if we can replace the wrapping node by\r\n        // the newly inserted content\r\n        // example:\r\n        // replace an empty paragraph by an inserted image\r\n        // instead of inserting the image below the paragraph\r\n        if (from === to && isOnlyBlockContent) {\r\n            const { parent } = tr.doc.resolve(from);\r\n            const isEmptyTextBlock = parent.isTextblock\r\n                && !parent.type.spec.code\r\n                && !parent.childCount;\r\n            if (isEmptyTextBlock) {\r\n                from -= 1;\r\n                to += 1;\r\n            }\r\n        }\r\n        // if there is only plain text we have to use `insertText`\r\n        // because this will keep the current marks\r\n        if (isOnlyTextContent) {\r\n            tr.insertText(value, from, to);\r\n        }\r\n        else {\r\n            tr.replaceWith(from, to, content);\r\n        }\r\n        // set cursor at end of inserted content\r\n        if (options.updateSelection) {\r\n            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar insertContentAt$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContentAt: insertContentAt\n});\n\nconst joinBackward = () => ({ state, dispatch }) => {\r\n    return joinBackward$2(state, dispatch);\r\n};\n\nvar joinBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinBackward: joinBackward\n});\n\nconst joinForward = () => ({ state, dispatch }) => {\r\n    return joinForward$2(state, dispatch);\r\n};\n\nvar joinForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinForward: joinForward\n});\n\nfunction isMacOS() {\r\n    return typeof navigator !== 'undefined'\r\n        ? /Mac/.test(navigator.platform)\r\n        : false;\r\n}\n\nfunction normalizeKeyName(name) {\r\n    const parts = name.split(/-(?!$)/);\r\n    let result = parts[parts.length - 1];\r\n    if (result === 'Space') {\r\n        result = ' ';\r\n    }\r\n    let alt;\r\n    let ctrl;\r\n    let shift;\r\n    let meta;\r\n    for (let i = 0; i < parts.length - 1; i += 1) {\r\n        const mod = parts[i];\r\n        if (/^(cmd|meta|m)$/i.test(mod)) {\r\n            meta = true;\r\n        }\r\n        else if (/^a(lt)?$/i.test(mod)) {\r\n            alt = true;\r\n        }\r\n        else if (/^(c|ctrl|control)$/i.test(mod)) {\r\n            ctrl = true;\r\n        }\r\n        else if (/^s(hift)?$/i.test(mod)) {\r\n            shift = true;\r\n        }\r\n        else if (/^mod$/i.test(mod)) {\r\n            if (isiOS() || isMacOS()) {\r\n                meta = true;\r\n            }\r\n            else {\r\n                ctrl = true;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(`Unrecognized modifier name: ${mod}`);\r\n        }\r\n    }\r\n    if (alt) {\r\n        result = `Alt-${result}`;\r\n    }\r\n    if (ctrl) {\r\n        result = `Ctrl-${result}`;\r\n    }\r\n    if (meta) {\r\n        result = `Meta-${result}`;\r\n    }\r\n    if (shift) {\r\n        result = `Shift-${result}`;\r\n    }\r\n    return result;\r\n}\r\nconst keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {\r\n    const keys = normalizeKeyName(name).split(/-(?!$)/);\r\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\r\n    const event = new KeyboardEvent('keydown', {\r\n        key: key === 'Space'\r\n            ? ' '\r\n            : key,\r\n        altKey: keys.includes('Alt'),\r\n        ctrlKey: keys.includes('Ctrl'),\r\n        metaKey: keys.includes('Meta'),\r\n        shiftKey: keys.includes('Shift'),\r\n        bubbles: true,\r\n        cancelable: true,\r\n    });\r\n    const capturedTransaction = editor.captureTransaction(() => {\r\n        view.someProp('handleKeyDown', f => f(view, event));\r\n    });\r\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\r\n        const newStep = step.map(tr.mapping);\r\n        if (newStep && dispatch) {\r\n            tr.maybeStep(newStep);\r\n        }\r\n    });\r\n    return true;\r\n};\n\nvar keyboardShortcut$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  keyboardShortcut: keyboardShortcut\n});\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\r\n    const { from, to, empty } = state.selection;\r\n    const type = typeOrName\r\n        ? getNodeType(typeOrName, state.schema)\r\n        : null;\r\n    const nodeRanges = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (node.isText) {\r\n            return;\r\n        }\r\n        const relativeFrom = Math.max(from, pos);\r\n        const relativeTo = Math.min(to, pos + node.nodeSize);\r\n        nodeRanges.push({\r\n            node,\r\n            from: relativeFrom,\r\n            to: relativeTo,\r\n        });\r\n    });\r\n    const selectionRange = to - from;\r\n    const matchedNodeRanges = nodeRanges\r\n        .filter(nodeRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === nodeRange.node.type.name;\r\n    })\r\n        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\r\n    if (empty) {\r\n        return !!matchedNodeRanges.length;\r\n    }\r\n    const range = matchedNodeRanges\r\n        .reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\r\n    return range >= selectionRange;\r\n}\n\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (!isActive) {\r\n        return false;\r\n    }\r\n    return lift$2(state, dispatch);\r\n};\n\nvar lift$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lift: lift\n});\n\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\r\n    return liftEmptyBlock$2(state, dispatch);\r\n};\n\nvar liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftEmptyBlock: liftEmptyBlock\n});\n\nconst liftListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return liftListItem$2(type)(state, dispatch);\r\n};\n\nvar liftListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftListItem: liftListItem\n});\n\nconst newlineInCode = () => ({ state, dispatch }) => {\r\n    return newlineInCode$2(state, dispatch);\r\n};\n\nvar newlineInCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  newlineInCode: newlineInCode\n});\n\nfunction getSchemaTypeNameByName(name, schema) {\r\n    if (schema.nodes[name]) {\r\n        return 'node';\r\n    }\r\n    if (schema.marks[name]) {\r\n        return 'mark';\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\r\nfunction deleteProps(obj, propOrProps) {\r\n    const props = typeof propOrProps === 'string'\r\n        ? [propOrProps]\r\n        : propOrProps;\r\n    return Object\r\n        .keys(obj)\r\n        .reduce((newObj, prop) => {\r\n        if (!props.includes(prop)) {\r\n            newObj[prop] = obj[prop];\r\n        }\r\n        return newObj;\r\n    }, {});\r\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar resetAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetAttributes: resetAttributes\n});\n\nconst scrollIntoView = () => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar scrollIntoView$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  scrollIntoView: scrollIntoView\n});\n\nconst selectAll = () => ({ tr, commands }) => {\r\n    return commands.setTextSelection({\r\n        from: 0,\r\n        to: tr.doc.content.size,\r\n    });\r\n};\n\nvar selectAll$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectAll: selectAll\n});\n\nconst selectNodeBackward = () => ({ state, dispatch }) => {\r\n    return selectNodeBackward$2(state, dispatch);\r\n};\n\nvar selectNodeBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeBackward: selectNodeBackward\n});\n\nconst selectNodeForward = () => ({ state, dispatch }) => {\r\n    return selectNodeForward$2(state, dispatch);\r\n};\n\nvar selectNodeForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeForward: selectNodeForward\n});\n\nconst selectParentNode = () => ({ state, dispatch }) => {\r\n    return selectParentNode$2(state, dispatch);\r\n};\n\nvar selectParentNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectParentNode: selectParentNode\n});\n\n// @ts-ignore\r\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\r\n    return selectTextblockEnd$2(state, dispatch);\r\n};\n\nvar selectTextblockEnd$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectTextblockEnd: selectTextblockEnd\n});\n\n// @ts-ignore\r\nconst selectTextblockStart = () => ({ state, dispatch }) => {\r\n    return selectTextblockStart$2(state, dispatch);\r\n};\n\nvar selectTextblockStart$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectTextblockStart: selectTextblockStart\n});\n\nfunction createDocument(content, schema, parseOptions = {}) {\r\n    return createNodeFromContent(content, schema, { slice: false, parseOptions });\r\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\r\n    const { doc } = tr;\r\n    const document = createDocument(content, editor.schema, parseOptions);\r\n    const selection = TextSelection.create(doc, 0, doc.content.size);\r\n    if (dispatch) {\r\n        tr.setSelection(selection)\r\n            .replaceSelectionWith(document, false)\r\n            .setMeta('preventUpdate', !emitUpdate);\r\n    }\r\n    return true;\r\n};\n\nvar setContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setContent: setContent\n});\n\nfunction getMarkAttributes(state, typeOrName) {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { from, to, empty } = state.selection;\r\n    const marks = [];\r\n    if (empty) {\r\n        if (state.storedMarks) {\r\n            marks.push(...state.storedMarks);\r\n        }\r\n        marks.push(...state.selection.$head.marks());\r\n    }\r\n    else {\r\n        state.doc.nodesBetween(from, to, node => {\r\n            marks.push(...node.marks);\r\n        });\r\n    }\r\n    const mark = marks.find(markItem => markItem.type.name === type.name);\r\n    if (!mark) {\r\n        return {};\r\n    }\r\n    return { ...mark.attrs };\r\n}\n\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    if (dispatch) {\r\n        if (empty) {\r\n            const oldAttributes = getMarkAttributes(state, type);\r\n            tr.addStoredMark(type.create({\r\n                ...oldAttributes,\r\n                ...attributes,\r\n            }));\r\n        }\r\n        else {\r\n            ranges.forEach(range => {\r\n                const from = range.$from.pos;\r\n                const to = range.$to.pos;\r\n                state.doc.nodesBetween(from, to, (node, pos) => {\r\n                    const trimmedFrom = Math.max(pos, from);\r\n                    const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                    const someHasMark = node.marks.find(mark => mark.type === type);\r\n                    // if there is already a mark of this type\r\n                    // we know that we have to merge its attributes\r\n                    // otherwise we add a fresh new mark\r\n                    if (someHasMark) {\r\n                        node.marks.forEach(mark => {\r\n                            if (type === mark.type) {\r\n                                tr.addMark(trimmedFrom, trimmedTo, type.create({\r\n                                    ...mark.attrs,\r\n                                    ...attributes,\r\n                                }));\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar setMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMark: setMark\n});\n\nconst setMeta = (key, value) => ({ tr }) => {\r\n    tr.setMeta(key, value);\r\n    return true;\r\n};\n\nvar setMeta$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMeta: setMeta\n});\n\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    // TODO: use a fallback like insertContent?\r\n    if (!type.isTextblock) {\r\n        console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\r\n        return false;\r\n    }\r\n    return chain()\r\n        // try to convert node to default node if needed\r\n        .command(({ commands }) => {\r\n        const canSetBlock = setBlockType(type, attributes)(state);\r\n        if (canSetBlock) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .command(({ state: updatedState }) => {\r\n        return setBlockType(type, attributes)(updatedState, dispatch);\r\n    })\r\n        .run();\r\n};\n\nvar setNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNode: setNode\n});\n\nconst setNodeSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const minPos = Selection.atStart(doc).from;\r\n        const maxPos = Selection.atEnd(doc).to;\r\n        const resolvedPos = minMax(position, minPos, maxPos);\r\n        const selection = NodeSelection.create(doc, resolvedPos);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nvar setNodeSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNodeSelection: setNodeSelection\n});\n\nconst setTextSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const { from, to } = typeof position === 'number'\r\n            ? { from: position, to: position }\r\n            : position;\r\n        const minPos = TextSelection.atStart(doc).from;\r\n        const maxPos = TextSelection.atEnd(doc).to;\r\n        const resolvedFrom = minMax(from, minPos, maxPos);\r\n        const resolvedEnd = minMax(to, minPos, maxPos);\r\n        const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nvar setTextSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setTextSelection: setTextSelection\n});\n\nconst sinkListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return sinkListItem$2(type)(state, dispatch);\r\n};\n\nvar sinkListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sinkListItem: sinkListItem\n});\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\r\n    return Object.fromEntries(Object\r\n        .entries(attributes)\r\n        .filter(([name]) => {\r\n        const extensionAttribute = extensionAttributes.find(item => {\r\n            return item.type === typeName && item.name === name;\r\n        });\r\n        if (!extensionAttribute) {\r\n            return false;\r\n        }\r\n        return extensionAttribute.attribute.keepOnSplit;\r\n    }));\r\n}\n\nfunction defaultBlockAt$1(match) {\r\n    for (let i = 0; i < match.edgeCount; i += 1) {\r\n        const { type } = match.edge(i);\r\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction ensureMarks(state, splittableMarks) {\r\n    const marks = state.storedMarks\r\n        || (state.selection.$to.parentOffset && state.selection.$from.marks());\r\n    if (marks) {\r\n        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\r\n        state.tr.ensureMarks(filteredMarks);\r\n    }\r\n}\r\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {\r\n    const { selection, doc } = tr;\r\n    const { $from, $to } = selection;\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\r\n        if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            if (keepMarks) {\r\n                ensureMarks(state, editor.extensionManager.splittableMarks);\r\n            }\r\n            tr.split($from.pos).scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    if (!$from.parent.isBlock) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        const atEnd = $to.parentOffset === $to.parent.content.size;\r\n        if (selection instanceof TextSelection) {\r\n            tr.deleteSelection();\r\n        }\r\n        const deflt = $from.depth === 0\r\n            ? undefined\r\n            : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));\r\n        let types = atEnd && deflt\r\n            ? [{\r\n                    type: deflt,\r\n                    attrs: newAttributes,\r\n                }]\r\n            : undefined;\r\n        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\r\n        if (!types\r\n            && !can\r\n            && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\r\n            can = true;\r\n            types = deflt\r\n                ? [{\r\n                        type: deflt,\r\n                        attrs: newAttributes,\r\n                    }]\r\n                : undefined;\r\n        }\r\n        if (can) {\r\n            tr.split(tr.mapping.map($from.pos), 1, types);\r\n            if (deflt\r\n                && !atEnd\r\n                && !$from.parentOffset\r\n                && $from.parent.type !== deflt) {\r\n                const first = tr.mapping.map($from.before());\r\n                const $first = tr.doc.resolve(first);\r\n                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\r\n                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\r\n                }\r\n            }\r\n        }\r\n        if (keepMarks) {\r\n            ensureMarks(state, editor.extensionManager.splittableMarks);\r\n        }\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar splitBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitBlock: splitBlock\n});\n\nconst splitListItem = typeOrName => ({ tr, state, dispatch, editor, }) => {\r\n    var _a;\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { $from, $to } = state.selection;\r\n    // @ts-ignore\r\n    // eslint-disable-next-line\r\n    const node = state.selection.node;\r\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\r\n        return false;\r\n    }\r\n    const grandParent = $from.node(-1);\r\n    if (grandParent.type !== type) {\r\n        return false;\r\n    }\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\r\n        // In an empty block. If this is a nested list, the wrapping\r\n        // list item should be split. Otherwise, bail out and let next\r\n        // command handle lifting.\r\n        if ($from.depth === 2\r\n            || $from.node(-3).type !== type\r\n            || $from.index(-2) !== $from.node(-2).childCount - 1) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            let wrap = Fragment.empty;\r\n            // eslint-disable-next-line\r\n            const depthBefore = $from.index(-1)\r\n                ? 1\r\n                : $from.index(-2)\r\n                    ? 2\r\n                    : 3;\r\n            // Build a fragment containing empty versions of the structure\r\n            // from the outer list item to the parent node of the cursor\r\n            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\r\n                wrap = Fragment.from($from.node(d).copy(wrap));\r\n            }\r\n            // eslint-disable-next-line\r\n            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount\r\n                ? 1\r\n                : $from.indexAfter(-2) < $from.node(-3).childCount\r\n                    ? 2\r\n                    : 3;\r\n            // Add a second list item with an empty default start node\r\n            const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\r\n            wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\r\n            const start = $from.before($from.depth - (depthBefore - 1));\r\n            tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\r\n            let sel = -1;\r\n            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\r\n                if (sel > -1) {\r\n                    return false;\r\n                }\r\n                if (n.isTextblock && n.content.size === 0) {\r\n                    sel = pos + 1;\r\n                }\r\n            });\r\n            if (sel > -1) {\r\n                tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\r\n            }\r\n            tr.scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    const nextType = $to.pos === $from.end()\r\n        ? grandParent.contentMatchAt(0).defaultType\r\n        : null;\r\n    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\r\n    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    tr.delete($from.pos, $to.pos);\r\n    const types = nextType\r\n        ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]\r\n        : [{ type, attrs: newTypeAttributes }];\r\n    if (!canSplit(tr.doc, $from.pos, 2)) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        tr.split($from.pos, 2, types).scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar splitListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitListItem: splitListItem\n});\n\nfunction findParentNodeClosestToPos($pos, predicate) {\r\n    for (let i = $pos.depth; i > 0; i -= 1) {\r\n        const node = $pos.node(i);\r\n        if (predicate(node)) {\r\n            return {\r\n                pos: i > 0 ? $pos.before(i) : 0,\r\n                start: $pos.start(i),\r\n                depth: i,\r\n                node,\r\n            };\r\n        }\r\n    }\r\n}\n\nfunction findParentNode(predicate) {\r\n    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\r\n}\n\nfunction splitExtensions(extensions) {\r\n    const baseExtensions = extensions.filter(extension => extension.type === 'extension');\r\n    const nodeExtensions = extensions.filter(extension => extension.type === 'node');\r\n    const markExtensions = extensions.filter(extension => extension.type === 'mark');\r\n    return {\r\n        baseExtensions,\r\n        nodeExtensions,\r\n        markExtensions,\r\n    };\r\n}\n\nfunction isList(name, extensions) {\r\n    const { nodeExtensions } = splitExtensions(extensions);\r\n    const extension = nodeExtensions.find(item => item.name === name);\r\n    if (!extension) {\r\n        return false;\r\n    }\r\n    const context = {\r\n        name: extension.name,\r\n        options: extension.options,\r\n        storage: extension.storage,\r\n    };\r\n    const group = callOrReturn(getExtensionField(extension, 'group', context));\r\n    if (typeof group !== 'string') {\r\n        return false;\r\n    }\r\n    return group.split(' ').includes('list');\r\n}\n\nconst joinListBackwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\r\n    if (before === undefined) {\r\n        return true;\r\n    }\r\n    const nodeBefore = tr.doc.nodeAt(before);\r\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type)\r\n        && canJoin(tr.doc, list.pos);\r\n    if (!canJoinBackwards) {\r\n        return true;\r\n    }\r\n    tr.join(list.pos);\r\n    return true;\r\n};\r\nconst joinListForwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const after = tr.doc.resolve(list.start).after(list.depth);\r\n    if (after === undefined) {\r\n        return true;\r\n    }\r\n    const nodeAfter = tr.doc.nodeAt(after);\r\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type)\r\n        && canJoin(tr.doc, after);\r\n    if (!canJoinForwards) {\r\n        return true;\r\n    }\r\n    tr.join(after);\r\n    return true;\r\n};\r\nconst toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {\r\n    const { extensions } = editor.extensionManager;\r\n    const listType = getNodeType(listTypeOrName, state.schema);\r\n    const itemType = getNodeType(itemTypeOrName, state.schema);\r\n    const { selection } = state;\r\n    const { $from, $to } = selection;\r\n    const range = $from.blockRange($to);\r\n    if (!range) {\r\n        return false;\r\n    }\r\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\r\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\r\n        // remove list\r\n        if (parentList.node.type === listType) {\r\n            return commands.liftListItem(itemType);\r\n        }\r\n        // change list type\r\n        if (isList(parentList.node.type.name, extensions)\r\n            && listType.validContent(parentList.node.content)\r\n            && dispatch) {\r\n            return chain()\r\n                .command(() => {\r\n                tr.setNodeMarkup(parentList.pos, listType);\r\n                return true;\r\n            })\r\n                .command(() => joinListBackwards(tr, listType))\r\n                .command(() => joinListForwards(tr, listType))\r\n                .run();\r\n        }\r\n    }\r\n    return chain()\r\n        // try to convert node to default node if needed\r\n        .command(() => {\r\n        const canWrapInList = can().wrapInList(listType);\r\n        if (canWrapInList) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .wrapInList(listType)\r\n        .command(() => joinListBackwards(tr, listType))\r\n        .command(() => joinListForwards(tr, listType))\r\n        .run();\r\n};\n\nvar toggleList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleList: toggleList\n});\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\r\n    const { empty, ranges } = state.selection;\r\n    const type = typeOrName\r\n        ? getMarkType(typeOrName, state.schema)\r\n        : null;\r\n    if (empty) {\r\n        return !!(state.storedMarks || state.selection.$from.marks())\r\n            .filter(mark => {\r\n            if (!type) {\r\n                return true;\r\n            }\r\n            return type.name === mark.type.name;\r\n        })\r\n            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));\r\n    }\r\n    let selectionRange = 0;\r\n    const markRanges = [];\r\n    ranges.forEach(({ $from, $to }) => {\r\n        const from = $from.pos;\r\n        const to = $to.pos;\r\n        state.doc.nodesBetween(from, to, (node, pos) => {\r\n            if (!node.isText && !node.marks.length) {\r\n                return;\r\n            }\r\n            const relativeFrom = Math.max(from, pos);\r\n            const relativeTo = Math.min(to, pos + node.nodeSize);\r\n            const range = relativeTo - relativeFrom;\r\n            selectionRange += range;\r\n            markRanges.push(...node.marks.map(mark => ({\r\n                mark,\r\n                from: relativeFrom,\r\n                to: relativeTo,\r\n            })));\r\n        });\r\n    });\r\n    if (selectionRange === 0) {\r\n        return false;\r\n    }\r\n    // calculate range of matched mark\r\n    const matchedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === markRange.mark.type.name;\r\n    })\r\n        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // calculate range of marks that excludes the searched mark\r\n    // for example `code` doesn’t allow any other marks\r\n    const excludedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return markRange.mark.type !== type\r\n            && markRange.mark.type.excludes(type);\r\n    })\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // we only include the result of `excludedRange`\r\n    // if there is a match at all\r\n    const range = matchedRange > 0\r\n        ? matchedRange + excludedRange\r\n        : matchedRange;\r\n    return range >= selectionRange;\r\n}\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const isActive = isMarkActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.unsetMark(type, { extendEmptyMarkRange });\r\n    }\r\n    return commands.setMark(type, attributes);\r\n};\n\nvar toggleMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleMark: toggleMark\n});\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.setNode(toggleType);\r\n    }\r\n    return commands.setNode(type, attributes);\r\n};\n\nvar toggleNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleNode: toggleNode\n});\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.lift(type);\r\n    }\r\n    return commands.wrapIn(type, attributes);\r\n};\n\nvar toggleWrap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleWrap: toggleWrap\n});\n\nconst undoInputRule = () => ({ state, dispatch }) => {\r\n    const plugins = state.plugins;\r\n    for (let i = 0; i < plugins.length; i += 1) {\r\n        const plugin = plugins[i];\r\n        let undoable;\r\n        // @ts-ignore\r\n        // eslint-disable-next-line\r\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\r\n            if (dispatch) {\r\n                const tr = state.tr;\r\n                const toUndo = undoable.transform;\r\n                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\r\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\r\n                }\r\n                if (undoable.text) {\r\n                    const marks = tr.doc.resolve(undoable.from).marks();\r\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\r\n                }\r\n                else {\r\n                    tr.delete(undoable.from, undoable.to);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar undoInputRule$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  undoInputRule: undoInputRule\n});\n\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    if (empty) {\r\n        return true;\r\n    }\r\n    if (dispatch) {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos);\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar unsetAllMarks$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetAllMarks: unsetAllMarks\n});\n\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\r\n    var _a;\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const { selection } = tr;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { $from, empty, ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    if (empty && extendEmptyMarkRange) {\r\n        let { from, to } = selection;\r\n        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\r\n        const range = getMarkRange($from, type, attrs);\r\n        if (range) {\r\n            from = range.from;\r\n            to = range.to;\r\n        }\r\n        tr.removeMark(from, to, type);\r\n    }\r\n    else {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos, type);\r\n        });\r\n    }\r\n    tr.removeStoredMark(type);\r\n    return true;\r\n};\n\nvar unsetMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetMark: unsetMark\n});\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            const from = range.$from.pos;\r\n            const to = range.$to.pos;\r\n            state.doc.nodesBetween(from, to, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, {\r\n                        ...node.attrs,\r\n                        ...attributes,\r\n                    });\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            const trimmedFrom = Math.max(pos, from);\r\n                            const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\r\n                                ...mark.attrs,\r\n                                ...attributes,\r\n                            }));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar updateAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  updateAttributes: updateAttributes\n});\n\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return wrapIn$2(type, attributes)(state, dispatch);\r\n};\n\nvar wrapIn$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapIn: wrapIn\n});\n\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return wrapInList$2(type, attributes)(state, dispatch);\r\n};\n\nvar wrapInList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapInList: wrapInList\n});\n\nconst Commands = Extension.create({\r\n    name: 'commands',\r\n    addCommands() {\r\n        return {\r\n            ...blur$1,\r\n            ...clearContent$1,\r\n            ...clearNodes$1,\r\n            ...command$1,\r\n            ...createParagraphNear$1,\r\n            ...deleteNode$1,\r\n            ...deleteRange$1,\r\n            ...deleteSelection$1,\r\n            ...enter$1,\r\n            ...exitCode$1,\r\n            ...extendMarkRange$1,\r\n            ...first$1,\r\n            ...focus$1,\r\n            ...forEach$1,\r\n            ...insertContent$1,\r\n            ...insertContentAt$1,\r\n            ...joinBackward$1,\r\n            ...joinForward$1,\r\n            ...keyboardShortcut$1,\r\n            ...lift$1,\r\n            ...liftEmptyBlock$1,\r\n            ...liftListItem$1,\r\n            ...newlineInCode$1,\r\n            ...resetAttributes$1,\r\n            ...scrollIntoView$1,\r\n            ...selectAll$1,\r\n            ...selectNodeBackward$1,\r\n            ...selectNodeForward$1,\r\n            ...selectParentNode$1,\r\n            ...selectTextblockEnd$1,\r\n            ...selectTextblockStart$1,\r\n            ...setContent$1,\r\n            ...setMark$1,\r\n            ...setMeta$1,\r\n            ...setNode$1,\r\n            ...setNodeSelection$1,\r\n            ...setTextSelection$1,\r\n            ...sinkListItem$1,\r\n            ...splitBlock$1,\r\n            ...splitListItem$1,\r\n            ...toggleList$1,\r\n            ...toggleMark$1,\r\n            ...toggleNode$1,\r\n            ...toggleWrap$1,\r\n            ...undoInputRule$1,\r\n            ...unsetAllMarks$1,\r\n            ...unsetMark$1,\r\n            ...updateAttributes$1,\r\n            ...wrapIn$1,\r\n            ...wrapInList$1,\r\n        };\r\n    },\r\n});\n\nconst Editable = Extension.create({\r\n    name: 'editable',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('editable'),\r\n                props: {\r\n                    editable: () => this.editor.options.editable,\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst FocusEvents = Extension.create({\r\n    name: 'focusEvents',\r\n    addProseMirrorPlugins() {\r\n        const { editor } = this;\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('focusEvents'),\r\n                props: {\r\n                    handleDOMEvents: {\r\n                        focus: (view, event) => {\r\n                            editor.isFocused = true;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('focus', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                        blur: (view, event) => {\r\n                            editor.isFocused = false;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('blur', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nfunction createChainableState(config) {\r\n    const { state, transaction } = config;\r\n    let { selection } = transaction;\r\n    let { doc } = transaction;\r\n    let { storedMarks } = transaction;\r\n    return {\r\n        ...state,\r\n        schema: state.schema,\r\n        plugins: state.plugins,\r\n        apply: state.apply.bind(state),\r\n        applyTransaction: state.applyTransaction.bind(state),\r\n        reconfigure: state.reconfigure.bind(state),\r\n        toJSON: state.toJSON.bind(state),\r\n        get storedMarks() {\r\n            return storedMarks;\r\n        },\r\n        get selection() {\r\n            return selection;\r\n        },\r\n        get doc() {\r\n            return doc;\r\n        },\r\n        get tr() {\r\n            selection = transaction.selection;\r\n            doc = transaction.doc;\r\n            storedMarks = transaction.storedMarks;\r\n            return transaction;\r\n        },\r\n    };\r\n}\n\nclass CommandManager {\r\n    constructor(props) {\r\n        this.editor = props.editor;\r\n        this.rawCommands = this.editor.extensionManager.commands;\r\n        this.customState = props.state;\r\n    }\r\n    get hasCustomState() {\r\n        return !!this.customState;\r\n    }\r\n    get state() {\r\n        return this.customState || this.editor.state;\r\n    }\r\n    get commands() {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const { tr } = state;\r\n        const props = this.buildProps(tr);\r\n        return Object.fromEntries(Object\r\n            .entries(rawCommands)\r\n            .map(([name, command]) => {\r\n            const method = (...args) => {\r\n                const callback = command(...args)(props);\r\n                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\r\n                    view.dispatch(tr);\r\n                }\r\n                return callback;\r\n            };\r\n            return [name, method];\r\n        }));\r\n    }\r\n    get chain() {\r\n        return () => this.createChain();\r\n    }\r\n    get can() {\r\n        return () => this.createCan();\r\n    }\r\n    createChain(startTr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const callbacks = [];\r\n        const hasStartTransaction = !!startTr;\r\n        const tr = startTr || state.tr;\r\n        const run = () => {\r\n            if (!hasStartTransaction\r\n                && shouldDispatch\r\n                && !tr.getMeta('preventDispatch')\r\n                && !this.hasCustomState) {\r\n                view.dispatch(tr);\r\n            }\r\n            return callbacks.every(callback => callback === true);\r\n        };\r\n        const chain = {\r\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n                const chainedCommand = (...args) => {\r\n                    const props = this.buildProps(tr, shouldDispatch);\r\n                    const callback = command(...args)(props);\r\n                    callbacks.push(callback);\r\n                    return chain;\r\n                };\r\n                return [name, chainedCommand];\r\n            })),\r\n            run,\r\n        };\r\n        return chain;\r\n    }\r\n    createCan(startTr) {\r\n        const { rawCommands, state } = this;\r\n        const dispatch = undefined;\r\n        const tr = startTr || state.tr;\r\n        const props = this.buildProps(tr, dispatch);\r\n        const formattedCommands = Object.fromEntries(Object\r\n            .entries(rawCommands)\r\n            .map(([name, command]) => {\r\n            return [name, (...args) => command(...args)({ ...props, dispatch })];\r\n        }));\r\n        return {\r\n            ...formattedCommands,\r\n            chain: () => this.createChain(tr, dispatch),\r\n        };\r\n    }\r\n    buildProps(tr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        if (state.storedMarks) {\r\n            tr.setStoredMarks(state.storedMarks);\r\n        }\r\n        const props = {\r\n            tr,\r\n            editor,\r\n            view,\r\n            state: createChainableState({\r\n                state,\r\n                transaction: tr,\r\n            }),\r\n            dispatch: shouldDispatch\r\n                ? () => undefined\r\n                : undefined,\r\n            chain: () => this.createChain(tr),\r\n            can: () => this.createCan(tr),\r\n            get commands() {\r\n                return Object.fromEntries(Object\r\n                    .entries(rawCommands)\r\n                    .map(([name, command]) => {\r\n                    return [name, (...args) => command(...args)(props)];\r\n                }));\r\n            },\r\n        };\r\n        return props;\r\n    }\r\n}\n\nconst Keymap = Extension.create({\r\n    name: 'keymap',\r\n    addKeyboardShortcuts() {\r\n        const handleBackspace = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.undoInputRule(),\r\n            // maybe convert first text block node to default node\r\n            () => commands.command(({ tr }) => {\r\n                const { selection, doc } = tr;\r\n                const { empty, $anchor } = selection;\r\n                const { pos, parent } = $anchor;\r\n                const isAtStart = Selection.atStart(doc).from === pos;\r\n                if (!empty\r\n                    || !isAtStart\r\n                    || !parent.type.isTextblock\r\n                    || parent.textContent.length) {\r\n                    return false;\r\n                }\r\n                return commands.clearNodes();\r\n            }),\r\n            () => commands.deleteSelection(),\r\n            () => commands.joinBackward(),\r\n            () => commands.selectNodeBackward(),\r\n        ]);\r\n        const handleDelete = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.deleteSelection(),\r\n            () => commands.joinForward(),\r\n            () => commands.selectNodeForward(),\r\n        ]);\r\n        const handleEnter = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.newlineInCode(),\r\n            () => commands.createParagraphNear(),\r\n            () => commands.liftEmptyBlock(),\r\n            () => commands.splitBlock(),\r\n        ]);\r\n        const baseKeymap = {\r\n            Enter: handleEnter,\r\n            'Mod-Enter': () => this.editor.commands.exitCode(),\r\n            Backspace: handleBackspace,\r\n            'Mod-Backspace': handleBackspace,\r\n            'Shift-Backspace': handleBackspace,\r\n            Delete: handleDelete,\r\n            'Mod-Delete': handleDelete,\r\n            'Mod-a': () => this.editor.commands.selectAll(),\r\n        };\r\n        const pcKeymap = {\r\n            ...baseKeymap,\r\n            Home: () => this.editor.commands.selectTextblockStart(),\r\n            End: () => this.editor.commands.selectTextblockEnd(),\r\n        };\r\n        const macKeymap = {\r\n            ...baseKeymap,\r\n            'Ctrl-h': handleBackspace,\r\n            'Alt-Backspace': handleBackspace,\r\n            'Ctrl-d': handleDelete,\r\n            'Ctrl-Alt-Backspace': handleDelete,\r\n            'Alt-Delete': handleDelete,\r\n            'Alt-d': handleDelete,\r\n            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\r\n            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\r\n        };\r\n        if (isiOS() || isMacOS()) {\r\n            return macKeymap;\r\n        }\r\n        return pcKeymap;\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            // With this plugin we check if the whole document was selected and deleted.\r\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\r\n            // to a paragraph if necessary.\r\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\r\n            // with many other commands.\r\n            new Plugin({\r\n                key: new PluginKey('clearDocument'),\r\n                appendTransaction: (transactions, oldState, newState) => {\r\n                    const docChanges = transactions.some(transaction => transaction.docChanged)\r\n                        && !oldState.doc.eq(newState.doc);\r\n                    if (!docChanges) {\r\n                        return;\r\n                    }\r\n                    const { empty, from, to } = oldState.selection;\r\n                    const allFrom = Selection.atStart(oldState.doc).from;\r\n                    const allEnd = Selection.atEnd(oldState.doc).to;\r\n                    const allWasSelected = from === allFrom && to === allEnd;\r\n                    const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\r\n                    if (empty || !allWasSelected || !isEmpty) {\r\n                        return;\r\n                    }\r\n                    const tr = newState.tr;\r\n                    const state = createChainableState({\r\n                        state: newState,\r\n                        transaction: tr,\r\n                    });\r\n                    const { commands } = new CommandManager({\r\n                        editor: this.editor,\r\n                        state,\r\n                    });\r\n                    commands.clearNodes();\r\n                    if (!tr.steps.length) {\r\n                        return;\r\n                    }\r\n                    return tr;\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst Tabindex = Extension.create({\r\n    name: 'tabindex',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('tabindex'),\r\n                props: {\r\n                    attributes: () => {\r\n                        if (this.editor.isEditable) {\r\n                            return {\r\n                                tabindex: '0',\r\n                            };\r\n                        }\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\n\nfunction getNodeAttributes(state, typeOrName) {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { from, to } = state.selection;\r\n    const nodes = [];\r\n    state.doc.nodesBetween(from, to, node => {\r\n        nodes.push(node);\r\n    });\r\n    const node = nodes\r\n        .reverse()\r\n        .find(nodeItem => nodeItem.type.name === type.name);\r\n    if (!node) {\r\n        return {};\r\n    }\r\n    return { ...node.attrs };\r\n}\n\nfunction getAttributes(state, typeOrName) {\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return getNodeAttributes(state, typeOrName);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return getMarkAttributes(state, typeOrName);\r\n    }\r\n    return {};\r\n}\n\nfunction isActive(state, name, attributes = {}) {\r\n    if (!name) {\r\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\r\n    }\r\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return isNodeActive(state, name, attributes);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return isMarkActive(state, name, attributes);\r\n    }\r\n    return false;\r\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\r\n    const documentFragment = DOMSerializer\r\n        .fromSchema(schema)\r\n        .serializeFragment(fragment);\r\n    const temporaryDocument = document.implementation.createHTMLDocument();\r\n    const container = temporaryDocument.createElement('div');\r\n    container.appendChild(documentFragment);\r\n    return container.innerHTML;\r\n}\n\nfunction getText(node, options) {\r\n    const range = {\r\n        from: 0,\r\n        to: node.content.size,\r\n    };\r\n    return getTextBetween(node, range, options);\r\n}\n\nfunction isNodeEmpty(node) {\r\n    var _a;\r\n    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\r\n    const content = node.toJSON();\r\n    return JSON.stringify(defaultContent) === JSON.stringify(content);\r\n}\n\nfunction createStyleTag(style) {\r\n    const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\r\n    if (tipTapStyleTag !== null) {\r\n        return tipTapStyleTag;\r\n    }\r\n    const styleNode = document.createElement('style');\r\n    styleNode.setAttribute('data-tiptap-style', '');\r\n    styleNode.innerHTML = style;\r\n    document.getElementsByTagName('head')[0].appendChild(styleNode);\r\n    return styleNode;\r\n}\n\nclass InputRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst inputRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return find.exec(text);\r\n    }\r\n    const inputRuleMatch = find(text);\r\n    if (!inputRuleMatch) {\r\n        return null;\r\n    }\r\n    const result = [];\r\n    result.push(inputRuleMatch.text);\r\n    result.index = inputRuleMatch.index;\r\n    result.input = text;\r\n    result.data = inputRuleMatch.data;\r\n    if (inputRuleMatch.replaceWith) {\r\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\r\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\r\n        }\r\n        result.push(inputRuleMatch.replaceWith);\r\n    }\r\n    return result;\r\n};\r\nfunction run$1(config) {\r\n    var _a;\r\n    const { editor, from, to, text, rules, plugin, } = config;\r\n    const { view } = editor;\r\n    if (view.composing) {\r\n        return false;\r\n    }\r\n    const $from = view.state.doc.resolve(from);\r\n    if (\r\n    // check for code node\r\n    $from.parent.type.spec.code\r\n        // check for code mark\r\n        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\r\n        return false;\r\n    }\r\n    let matched = false;\r\n    const maxMatch = 500;\r\n    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, undefined, ' ') + text;\r\n    rules.forEach(rule => {\r\n        if (matched) {\r\n            return;\r\n        }\r\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\r\n        if (!match) {\r\n            return;\r\n        }\r\n        const tr = view.state.tr;\r\n        const state = createChainableState({\r\n            state: view.state,\r\n            transaction: tr,\r\n        });\r\n        const range = {\r\n            from: from - (match[0].length - text.length),\r\n            to,\r\n        };\r\n        const { commands, chain, can } = new CommandManager({\r\n            editor,\r\n            state,\r\n        });\r\n        const handler = rule.handler({\r\n            state,\r\n            range,\r\n            match,\r\n            commands,\r\n            chain,\r\n            can,\r\n        });\r\n        // stop if there are no changes\r\n        if (handler === null || !tr.steps.length) {\r\n            return;\r\n        }\r\n        // store transform as meta data\r\n        // so we can undo input rules within the `undoInputRules` command\r\n        tr.setMeta(plugin, {\r\n            transform: tr,\r\n            from,\r\n            to,\r\n            text,\r\n        });\r\n        view.dispatch(tr);\r\n        matched = true;\r\n    });\r\n    return matched;\r\n}\r\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction inputRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    const plugin = new Plugin({\r\n        state: {\r\n            init() {\r\n                return null;\r\n            },\r\n            apply(tr, prev) {\r\n                const stored = tr.getMeta(this);\r\n                if (stored) {\r\n                    return stored;\r\n                }\r\n                return tr.selectionSet || tr.docChanged\r\n                    ? null\r\n                    : prev;\r\n            },\r\n        },\r\n        props: {\r\n            handleTextInput(view, from, to, text) {\r\n                return run$1({\r\n                    editor,\r\n                    from,\r\n                    to,\r\n                    text,\r\n                    rules,\r\n                    plugin,\r\n                });\r\n            },\r\n            handleDOMEvents: {\r\n                compositionend: view => {\r\n                    setTimeout(() => {\r\n                        const { $cursor } = view.state.selection;\r\n                        if ($cursor) {\r\n                            run$1({\r\n                                editor,\r\n                                from: $cursor.pos,\r\n                                to: $cursor.pos,\r\n                                text: '',\r\n                                rules,\r\n                                plugin,\r\n                            });\r\n                        }\r\n                    });\r\n                    return false;\r\n                },\r\n            },\r\n            // add support for input rules to trigger on enter\r\n            // this is useful for example for code blocks\r\n            handleKeyDown(view, event) {\r\n                if (event.key !== 'Enter') {\r\n                    return false;\r\n                }\r\n                const { $cursor } = view.state.selection;\r\n                if ($cursor) {\r\n                    return run$1({\r\n                        editor,\r\n                        from: $cursor.pos,\r\n                        to: $cursor.pos,\r\n                        text: '\\n',\r\n                        rules,\r\n                        plugin,\r\n                    });\r\n                }\r\n                return false;\r\n            },\r\n        },\r\n        // @ts-ignore\r\n        isInputRules: true,\r\n    });\r\n    return plugin;\r\n}\n\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\n\nclass PasteRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst pasteRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return [...text.matchAll(find)];\r\n    }\r\n    const matches = find(text);\r\n    if (!matches) {\r\n        return [];\r\n    }\r\n    return matches.map(pasteRuleMatch => {\r\n        const result = [];\r\n        result.push(pasteRuleMatch.text);\r\n        result.index = pasteRuleMatch.index;\r\n        result.input = text;\r\n        result.data = pasteRuleMatch.data;\r\n        if (pasteRuleMatch.replaceWith) {\r\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\r\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\r\n            }\r\n            result.push(pasteRuleMatch.replaceWith);\r\n        }\r\n        return result;\r\n    });\r\n};\r\nfunction run(config) {\r\n    const { editor, state, from, to, rule, } = config;\r\n    const { commands, chain, can } = new CommandManager({\r\n        editor,\r\n        state,\r\n    });\r\n    const handlers = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (!node.isTextblock || node.type.spec.code) {\r\n            return;\r\n        }\r\n        const resolvedFrom = Math.max(from, pos);\r\n        const resolvedTo = Math.min(to, pos + node.content.size);\r\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\r\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\r\n        matches.forEach(match => {\r\n            if (match.index === undefined) {\r\n                return;\r\n            }\r\n            const start = resolvedFrom + match.index + 1;\r\n            const end = start + match[0].length;\r\n            const range = {\r\n                from: state.tr.mapping.map(start),\r\n                to: state.tr.mapping.map(end),\r\n            };\r\n            const handler = rule.handler({\r\n                state,\r\n                range,\r\n                match,\r\n                commands,\r\n                chain,\r\n                can,\r\n            });\r\n            handlers.push(handler);\r\n        });\r\n    });\r\n    const success = handlers.every(handler => handler !== null);\r\n    return success;\r\n}\r\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction pasteRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    let dragSourceElement = null;\r\n    let isPastedFromProseMirror = false;\r\n    let isDroppedFromProseMirror = false;\r\n    const plugins = rules.map(rule => {\r\n        return new Plugin({\r\n            // we register a global drag handler to track the current drag source element\r\n            view(view) {\r\n                const handleDragstart = (event) => {\r\n                    var _a;\r\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))\r\n                        ? view.dom.parentElement\r\n                        : null;\r\n                };\r\n                window.addEventListener('dragstart', handleDragstart);\r\n                return {\r\n                    destroy() {\r\n                        window.removeEventListener('dragstart', handleDragstart);\r\n                    },\r\n                };\r\n            },\r\n            props: {\r\n                handleDOMEvents: {\r\n                    drop: view => {\r\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\r\n                        return false;\r\n                    },\r\n                    paste: (view, event) => {\r\n                        var _a;\r\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\r\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\r\n                        return false;\r\n                    },\r\n                },\r\n            },\r\n            appendTransaction: (transactions, oldState, state) => {\r\n                const transaction = transactions[0];\r\n                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\r\n                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\r\n                if (!isPaste && !isDrop) {\r\n                    return;\r\n                }\r\n                // stop if there is no changed range\r\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\r\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\r\n                if (!isNumber(from) || !to || from === to.b) {\r\n                    return;\r\n                }\r\n                // build a chainable state\r\n                // so we can use a single transaction for all paste rules\r\n                const tr = state.tr;\r\n                const chainableState = createChainableState({\r\n                    state,\r\n                    transaction: tr,\r\n                });\r\n                const handler = run({\r\n                    editor,\r\n                    state: chainableState,\r\n                    from: Math.max(from - 1, 0),\r\n                    to: to.b,\r\n                    rule,\r\n                });\r\n                // stop if there are no changes\r\n                if (!handler || !tr.steps.length) {\r\n                    return;\r\n                }\r\n                return tr;\r\n            },\r\n        });\r\n    });\r\n    return plugins;\r\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\r\nfunction getAttributesFromExtensions(extensions) {\r\n    const extensionAttributes = [];\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\r\n    const defaultAttribute = {\r\n        default: null,\r\n        rendered: true,\r\n        renderHTML: null,\r\n        parseHTML: null,\r\n        keepOnSplit: true,\r\n    };\r\n    extensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\r\n        if (!addGlobalAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as GlobalAttributes`\r\n        const globalAttributes = addGlobalAttributes();\r\n        globalAttributes.forEach(globalAttribute => {\r\n            globalAttribute.types.forEach(type => {\r\n                Object\r\n                    .entries(globalAttribute.attributes)\r\n                    .forEach(([name, attribute]) => {\r\n                    extensionAttributes.push({\r\n                        type,\r\n                        name,\r\n                        attribute: {\r\n                            ...defaultAttribute,\r\n                            ...attribute,\r\n                        },\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    });\r\n    nodeAndMarkExtensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addAttributes = getExtensionField(extension, 'addAttributes', context);\r\n        if (!addAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as Attributes`\r\n        const attributes = addAttributes();\r\n        Object\r\n            .entries(attributes)\r\n            .forEach(([name, attribute]) => {\r\n            extensionAttributes.push({\r\n                type: extension.name,\r\n                name,\r\n                attribute: {\r\n                    ...defaultAttribute,\r\n                    ...attribute,\r\n                },\r\n            });\r\n        });\r\n    });\r\n    return extensionAttributes;\r\n}\n\nfunction mergeAttributes(...objects) {\r\n    return objects\r\n        .filter(item => !!item)\r\n        .reduce((items, item) => {\r\n        const mergedAttributes = { ...items };\r\n        Object.entries(item).forEach(([key, value]) => {\r\n            const exists = mergedAttributes[key];\r\n            if (!exists) {\r\n                mergedAttributes[key] = value;\r\n                return;\r\n            }\r\n            if (key === 'class') {\r\n                mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\r\n            }\r\n            else if (key === 'style') {\r\n                mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\r\n            }\r\n            else {\r\n                mergedAttributes[key] = value;\r\n            }\r\n        });\r\n        return mergedAttributes;\r\n    }, {});\r\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\r\n    return extensionAttributes\r\n        .filter(item => item.attribute.rendered)\r\n        .map(item => {\r\n        if (!item.attribute.renderHTML) {\r\n            return {\r\n                [item.name]: nodeOrMark.attrs[item.name],\r\n            };\r\n        }\r\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\r\n    })\r\n        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\r\n}\n\nfunction isEmptyObject(value = {}) {\r\n    return Object.keys(value).length === 0 && value.constructor === Object;\r\n}\n\nfunction fromString(value) {\r\n    if (typeof value !== 'string') {\r\n        return value;\r\n    }\r\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\r\n        return Number(value);\r\n    }\r\n    if (value === 'true') {\r\n        return true;\r\n    }\r\n    if (value === 'false') {\r\n        return false;\r\n    }\r\n    return value;\r\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\r\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\r\n    if (parseRule.style) {\r\n        return parseRule;\r\n    }\r\n    return {\r\n        ...parseRule,\r\n        getAttrs: node => {\r\n            const oldAttributes = parseRule.getAttrs\r\n                ? parseRule.getAttrs(node)\r\n                : parseRule.attrs;\r\n            if (oldAttributes === false) {\r\n                return false;\r\n            }\r\n            const newAttributes = extensionAttributes.reduce((items, item) => {\r\n                const value = item.attribute.parseHTML\r\n                    ? item.attribute.parseHTML(node)\r\n                    : fromString(node.getAttribute(item.name));\r\n                if (value === null || value === undefined) {\r\n                    return items;\r\n                }\r\n                return {\r\n                    ...items,\r\n                    [item.name]: value,\r\n                };\r\n            }, {});\r\n            return { ...oldAttributes, ...newAttributes };\r\n        },\r\n    };\r\n}\n\nfunction cleanUpSchemaItem(data) {\r\n    return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\r\n        if (key === 'attrs' && isEmptyObject(value)) {\r\n            return false;\r\n        }\r\n        return value !== null && value !== undefined;\r\n    }));\r\n}\r\nfunction getSchemaByResolvedExtensions(extensions) {\r\n    var _a;\r\n    const allAttributes = getAttributesFromExtensions(extensions);\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\r\n    const nodes = Object.fromEntries(nodeExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const extraNodeFields = extensions.reduce((fields, e) => {\r\n            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraNodeFields,\r\n            content: callOrReturn(getExtensionField(extension, 'content', context)),\r\n            marks: callOrReturn(getExtensionField(extension, 'marks', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            inline: callOrReturn(getExtensionField(extension, 'inline', context)),\r\n            atom: callOrReturn(getExtensionField(extension, 'atom', context)),\r\n            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\r\n            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            defining: callOrReturn(getExtensionField(extension, 'defining', context)),\r\n            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML\r\n                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = node => renderHTML({\r\n                node,\r\n                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\r\n            });\r\n        }\r\n        const renderText = getExtensionField(extension, 'renderText', context);\r\n        if (renderText) {\r\n            schema.toText = renderText;\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    const marks = Object.fromEntries(markExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const extraMarkFields = extensions.reduce((fields, e) => {\r\n            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraMarkFields,\r\n            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\r\n            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML\r\n                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = mark => renderHTML({\r\n                mark,\r\n                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\r\n            });\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    return new Schema({\r\n        topNode,\r\n        nodes,\r\n        marks,\r\n    });\r\n}\n\nfunction getSchemaTypeByName(name, schema) {\r\n    return schema.nodes[name] || schema.marks[name] || null;\r\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\r\n    if (Array.isArray(enabled)) {\r\n        return enabled.some(enabledExtension => {\r\n            const name = typeof enabledExtension === 'string'\r\n                ? enabledExtension\r\n                : enabledExtension.name;\r\n            return name === extension.name;\r\n        });\r\n    }\r\n    return enabled;\r\n}\n\nfunction findDuplicates(items) {\r\n    const filtered = items.filter((el, index) => items.indexOf(el) !== index);\r\n    return [...new Set(filtered)];\r\n}\n\nclass ExtensionManager {\r\n    constructor(extensions, editor) {\r\n        this.splittableMarks = [];\r\n        this.editor = editor;\r\n        this.extensions = ExtensionManager.resolve(extensions);\r\n        this.schema = getSchemaByResolvedExtensions(this.extensions);\r\n        this.extensions.forEach(extension => {\r\n            var _a;\r\n            // store extension storage in editor\r\n            this.editor.extensionStorage[extension.name] = extension.storage;\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            if (extension.type === 'mark') {\r\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\r\n                if (keepOnSplit) {\r\n                    this.splittableMarks.push(extension.name);\r\n                }\r\n            }\r\n            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\r\n            if (onBeforeCreate) {\r\n                this.editor.on('beforeCreate', onBeforeCreate);\r\n            }\r\n            const onCreate = getExtensionField(extension, 'onCreate', context);\r\n            if (onCreate) {\r\n                this.editor.on('create', onCreate);\r\n            }\r\n            const onUpdate = getExtensionField(extension, 'onUpdate', context);\r\n            if (onUpdate) {\r\n                this.editor.on('update', onUpdate);\r\n            }\r\n            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\r\n            if (onSelectionUpdate) {\r\n                this.editor.on('selectionUpdate', onSelectionUpdate);\r\n            }\r\n            const onTransaction = getExtensionField(extension, 'onTransaction', context);\r\n            if (onTransaction) {\r\n                this.editor.on('transaction', onTransaction);\r\n            }\r\n            const onFocus = getExtensionField(extension, 'onFocus', context);\r\n            if (onFocus) {\r\n                this.editor.on('focus', onFocus);\r\n            }\r\n            const onBlur = getExtensionField(extension, 'onBlur', context);\r\n            if (onBlur) {\r\n                this.editor.on('blur', onBlur);\r\n            }\r\n            const onDestroy = getExtensionField(extension, 'onDestroy', context);\r\n            if (onDestroy) {\r\n                this.editor.on('destroy', onDestroy);\r\n            }\r\n        });\r\n    }\r\n    static resolve(extensions) {\r\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\r\n        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\r\n        if (duplicatedNames.length) {\r\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\r\n        }\r\n        return resolvedExtensions;\r\n    }\r\n    static flatten(extensions) {\r\n        return extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n            };\r\n            const addExtensions = getExtensionField(extension, 'addExtensions', context);\r\n            if (addExtensions) {\r\n                return [\r\n                    extension,\r\n                    ...this.flatten(addExtensions()),\r\n                ];\r\n            }\r\n            return extension;\r\n        })\r\n            // `Infinity` will break TypeScript so we set a number that is probably high enough\r\n            .flat(10);\r\n    }\r\n    static sort(extensions) {\r\n        const defaultPriority = 100;\r\n        return extensions.sort((a, b) => {\r\n            const priorityA = getExtensionField(a, 'priority') || defaultPriority;\r\n            const priorityB = getExtensionField(b, 'priority') || defaultPriority;\r\n            if (priorityA > priorityB) {\r\n                return -1;\r\n            }\r\n            if (priorityA < priorityB) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n    get commands() {\r\n        return this.extensions.reduce((commands, extension) => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const addCommands = getExtensionField(extension, 'addCommands', context);\r\n            if (!addCommands) {\r\n                return commands;\r\n            }\r\n            return {\r\n                ...commands,\r\n                ...addCommands(),\r\n            };\r\n        }, {});\r\n    }\r\n    get plugins() {\r\n        const { editor } = this;\r\n        // With ProseMirror, first plugins within an array are executed first.\r\n        // In tiptap, we provide the ability to override plugins,\r\n        // so it feels more natural to run plugins at the end of an array first.\r\n        // That’s why we have to reverse the `extensions` array and sort again\r\n        // based on the `priority` option.\r\n        const extensions = ExtensionManager.sort([...this.extensions].reverse());\r\n        const inputRules = [];\r\n        const pasteRules = [];\r\n        const allPlugins = extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const plugins = [];\r\n            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\r\n            if (addKeyboardShortcuts) {\r\n                const bindings = Object.fromEntries(Object\r\n                    .entries(addKeyboardShortcuts())\r\n                    .map(([shortcut, method]) => {\r\n                    return [shortcut, () => method({ editor })];\r\n                }));\r\n                const keyMapPlugin = keymap(bindings);\r\n                plugins.push(keyMapPlugin);\r\n            }\r\n            const addInputRules = getExtensionField(extension, 'addInputRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\r\n                inputRules.push(...addInputRules());\r\n            }\r\n            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\r\n                pasteRules.push(...addPasteRules());\r\n            }\r\n            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\r\n            if (addProseMirrorPlugins) {\r\n                const proseMirrorPlugins = addProseMirrorPlugins();\r\n                plugins.push(...proseMirrorPlugins);\r\n            }\r\n            return plugins;\r\n        })\r\n            .flat();\r\n        return [\r\n            inputRulesPlugin({\r\n                editor,\r\n                rules: inputRules,\r\n            }),\r\n            ...pasteRulesPlugin({\r\n                editor,\r\n                rules: pasteRules,\r\n            }),\r\n            ...allPlugins,\r\n        ];\r\n    }\r\n    get attributes() {\r\n        return getAttributesFromExtensions(this.extensions);\r\n    }\r\n    get nodeViews() {\r\n        const { editor } = this;\r\n        const { nodeExtensions } = splitExtensions(this.extensions);\r\n        return Object.fromEntries(nodeExtensions\r\n            .filter(extension => !!getExtensionField(extension, 'addNodeView'))\r\n            .map(extension => {\r\n            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getNodeType(extension.name, this.schema),\r\n            };\r\n            const addNodeView = getExtensionField(extension, 'addNodeView', context);\r\n            if (!addNodeView) {\r\n                return [];\r\n            }\r\n            const nodeview = (node, view, getPos, decorations) => {\r\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\r\n                return addNodeView()({\r\n                    editor,\r\n                    node,\r\n                    getPos,\r\n                    decorations,\r\n                    HTMLAttributes,\r\n                    extension,\r\n                });\r\n            };\r\n            return [extension.name, nodeview];\r\n        }));\r\n    }\r\n}\n\nclass EventEmitter {\r\n    constructor() {\r\n        this.callbacks = {};\r\n    }\r\n    on(event, fn) {\r\n        if (!this.callbacks[event]) {\r\n            this.callbacks[event] = [];\r\n        }\r\n        this.callbacks[event].push(fn);\r\n        return this;\r\n    }\r\n    emit(event, ...args) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            callbacks.forEach(callback => callback.apply(this, args));\r\n        }\r\n        return this;\r\n    }\r\n    off(event, fn) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            if (fn) {\r\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\r\n            }\r\n            else {\r\n                delete this.callbacks[event];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    removeAllListeners() {\r\n        this.callbacks = {};\r\n    }\r\n}\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nclass Editor extends EventEmitter {\r\n    constructor(options = {}) {\r\n        super();\r\n        this.isFocused = false;\r\n        this.extensionStorage = {};\r\n        this.options = {\r\n            element: document.createElement('div'),\r\n            content: '',\r\n            injectCSS: true,\r\n            extensions: [],\r\n            autofocus: false,\r\n            editable: true,\r\n            editorProps: {},\r\n            parseOptions: {},\r\n            enableInputRules: true,\r\n            enablePasteRules: true,\r\n            enableCoreExtensions: true,\r\n            onBeforeCreate: () => null,\r\n            onCreate: () => null,\r\n            onUpdate: () => null,\r\n            onSelectionUpdate: () => null,\r\n            onTransaction: () => null,\r\n            onFocus: () => null,\r\n            onBlur: () => null,\r\n            onDestroy: () => null,\r\n        };\r\n        this.isCapturingTransaction = false;\r\n        this.capturedTransaction = null;\r\n        this.setOptions(options);\r\n        this.createExtensionManager();\r\n        this.createCommandManager();\r\n        this.createSchema();\r\n        this.on('beforeCreate', this.options.onBeforeCreate);\r\n        this.emit('beforeCreate', { editor: this });\r\n        this.createView();\r\n        this.injectCSS();\r\n        this.on('create', this.options.onCreate);\r\n        this.on('update', this.options.onUpdate);\r\n        this.on('selectionUpdate', this.options.onSelectionUpdate);\r\n        this.on('transaction', this.options.onTransaction);\r\n        this.on('focus', this.options.onFocus);\r\n        this.on('blur', this.options.onBlur);\r\n        this.on('destroy', this.options.onDestroy);\r\n        window.setTimeout(() => {\r\n            if (this.isDestroyed) {\r\n                return;\r\n            }\r\n            this.commands.focus(this.options.autofocus);\r\n            this.emit('create', { editor: this });\r\n        }, 0);\r\n    }\r\n    /**\r\n     * Returns the editor storage.\r\n     */\r\n    get storage() {\r\n        return this.extensionStorage;\r\n    }\r\n    /**\r\n     * An object of all registered commands.\r\n     */\r\n    get commands() {\r\n        return this.commandManager.commands;\r\n    }\r\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */\r\n    chain() {\r\n        return this.commandManager.chain();\r\n    }\r\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */\r\n    can() {\r\n        return this.commandManager.can();\r\n    }\r\n    /**\r\n     * Inject CSS styles.\r\n     */\r\n    injectCSS() {\r\n        if (this.options.injectCSS && document) {\r\n            this.css = createStyleTag(style);\r\n        }\r\n    }\r\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */\r\n    setOptions(options = {}) {\r\n        this.options = {\r\n            ...this.options,\r\n            ...options,\r\n        };\r\n        if (!this.view || !this.state || this.isDestroyed) {\r\n            return;\r\n        }\r\n        if (this.options.editorProps) {\r\n            this.view.setProps(this.options.editorProps);\r\n        }\r\n        this.view.updateState(this.state);\r\n    }\r\n    /**\r\n     * Update editable state of the editor.\r\n     */\r\n    setEditable(editable) {\r\n        this.setOptions({ editable });\r\n    }\r\n    /**\r\n     * Returns whether the editor is editable.\r\n     */\r\n    get isEditable() {\r\n        // since plugins are applied after creating the view\r\n        // `editable` is always `true` for one tick.\r\n        // that’s why we also have to check for `options.editable`\r\n        return this.options.editable\r\n            && this.view\r\n            && this.view.editable;\r\n    }\r\n    /**\r\n     * Returns the editor state.\r\n     */\r\n    get state() {\r\n        return this.view.state;\r\n    }\r\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */\r\n    registerPlugin(plugin, handlePlugins) {\r\n        const plugins = isFunction(handlePlugins)\r\n            ? handlePlugins(plugin, this.state.plugins)\r\n            : [...this.state.plugins, plugin];\r\n        const state = this.state.reconfigure({ plugins });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param nameOrPluginKey The plugins name\r\n     */\r\n    unregisterPlugin(nameOrPluginKey) {\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n        const name = typeof nameOrPluginKey === 'string'\r\n            ? `${nameOrPluginKey}$`\r\n            // @ts-ignore\r\n            : nameOrPluginKey.key;\r\n        const state = this.state.reconfigure({\r\n            // @ts-ignore\r\n            plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\r\n        });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Creates an extension manager.\r\n     */\r\n    createExtensionManager() {\r\n        const coreExtensions = this.options.enableCoreExtensions\r\n            ? Object.values(extensions)\r\n            : [];\r\n        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\r\n            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\r\n        });\r\n        this.extensionManager = new ExtensionManager(allExtensions, this);\r\n    }\r\n    /**\r\n     * Creates an command manager.\r\n     */\r\n    createCommandManager() {\r\n        this.commandManager = new CommandManager({\r\n            editor: this,\r\n        });\r\n    }\r\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */\r\n    createSchema() {\r\n        this.schema = this.extensionManager.schema;\r\n    }\r\n    /**\r\n     * Creates a ProseMirror view.\r\n     */\r\n    createView() {\r\n        const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\r\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\r\n        this.view = new EditorView(this.options.element, {\r\n            ...this.options.editorProps,\r\n            dispatchTransaction: this.dispatchTransaction.bind(this),\r\n            state: EditorState.create({\r\n                doc,\r\n                selection,\r\n            }),\r\n        });\r\n        // `editor.view` is not yet available at this time.\r\n        // Therefore we will add all plugins and node views directly afterwards.\r\n        const newState = this.state.reconfigure({\r\n            plugins: this.extensionManager.plugins,\r\n        });\r\n        this.view.updateState(newState);\r\n        this.createNodeViews();\r\n        // Let’s store the editor instance in the DOM element.\r\n        // So we’ll have access to it for tests.\r\n        const dom = this.view.dom;\r\n        dom.editor = this;\r\n    }\r\n    /**\r\n     * Creates all node views.\r\n     */\r\n    createNodeViews() {\r\n        this.view.setProps({\r\n            nodeViews: this.extensionManager.nodeViews,\r\n        });\r\n    }\r\n    captureTransaction(fn) {\r\n        this.isCapturingTransaction = true;\r\n        fn();\r\n        this.isCapturingTransaction = false;\r\n        const tr = this.capturedTransaction;\r\n        this.capturedTransaction = null;\r\n        return tr;\r\n    }\r\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */\r\n    dispatchTransaction(transaction) {\r\n        if (this.isCapturingTransaction) {\r\n            if (!this.capturedTransaction) {\r\n                this.capturedTransaction = transaction;\r\n                return;\r\n            }\r\n            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });\r\n            return;\r\n        }\r\n        const state = this.state.apply(transaction);\r\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\r\n        this.view.updateState(state);\r\n        this.emit('transaction', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n        if (selectionHasChanged) {\r\n            this.emit('selectionUpdate', {\r\n                editor: this,\r\n                transaction,\r\n            });\r\n        }\r\n        const focus = transaction.getMeta('focus');\r\n        const blur = transaction.getMeta('blur');\r\n        if (focus) {\r\n            this.emit('focus', {\r\n                editor: this,\r\n                event: focus.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (blur) {\r\n            this.emit('blur', {\r\n                editor: this,\r\n                event: blur.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\r\n            return;\r\n        }\r\n        this.emit('update', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n    }\r\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */\r\n    getAttributes(nameOrType) {\r\n        return getAttributes(this.state, nameOrType);\r\n    }\r\n    isActive(nameOrAttributes, attributesOrUndefined) {\r\n        const name = typeof nameOrAttributes === 'string'\r\n            ? nameOrAttributes\r\n            : null;\r\n        const attributes = typeof nameOrAttributes === 'string'\r\n            ? attributesOrUndefined\r\n            : nameOrAttributes;\r\n        return isActive(this.state, name, attributes);\r\n    }\r\n    /**\r\n     * Get the document as JSON.\r\n     */\r\n    getJSON() {\r\n        return this.state.doc.toJSON();\r\n    }\r\n    /**\r\n     * Get the document as HTML.\r\n     */\r\n    getHTML() {\r\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\r\n    }\r\n    /**\r\n     * Get the document as text.\r\n     */\r\n    getText(options) {\r\n        const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n        return getText(this.state.doc, {\r\n            blockSeparator,\r\n            textSerializers: {\r\n                ...textSerializers,\r\n                ...getTextSeralizersFromSchema(this.schema),\r\n            },\r\n        });\r\n    }\r\n    /**\r\n     * Check if there is no content.\r\n     */\r\n    get isEmpty() {\r\n        return isNodeEmpty(this.state.doc);\r\n    }\r\n    /**\r\n     * Get the number of characters for the current document.\r\n     *\r\n     * @deprecated\r\n     */\r\n    getCharacterCount() {\r\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\r\n        return this.state.doc.content.size - 2;\r\n    }\r\n    /**\r\n     * Destroy the editor.\r\n     */\r\n    destroy() {\r\n        this.emit('destroy');\r\n        if (this.view) {\r\n            this.view.destroy();\r\n        }\r\n        this.removeAllListeners();\r\n    }\r\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */\r\n    get isDestroyed() {\r\n        var _a;\r\n        // @ts-ignore\r\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\r\n    }\r\n}\n\nclass Node {\r\n    constructor(config = {}) {\r\n        this.type = 'node';\r\n        this.name = 'node';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Node(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Node(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nclass Mark {\r\n    constructor(config = {}) {\r\n        this.type = 'mark';\r\n        this.name = 'mark';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Mark(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Mark(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nclass NodeView {\r\n    constructor(component, props, options) {\r\n        this.isDragging = false;\r\n        this.component = component;\r\n        this.editor = props.editor;\r\n        this.options = {\r\n            stopEvent: null,\r\n            ignoreMutation: null,\r\n            ...options,\r\n        };\r\n        this.extension = props.extension;\r\n        this.node = props.node;\r\n        this.decorations = props.decorations;\r\n        this.getPos = props.getPos;\r\n        this.mount();\r\n    }\r\n    mount() {\r\n        // eslint-disable-next-line\r\n        return;\r\n    }\r\n    get dom() {\r\n        return null;\r\n    }\r\n    get contentDOM() {\r\n        return null;\r\n    }\r\n    onDragStart(event) {\r\n        var _a, _b, _c;\r\n        const { view } = this.editor;\r\n        const target = event.target;\r\n        // get the drag handle element\r\n        // `closest` is not available for text nodes so we may have to use its parent\r\n        const dragHandle = target.nodeType === 3\r\n            ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')\r\n            : target.closest('[data-drag-handle]');\r\n        if (!this.dom\r\n            || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target))\r\n            || !dragHandle) {\r\n            return;\r\n        }\r\n        let x = 0;\r\n        let y = 0;\r\n        // calculate offset for drag element if we use a different drag handle element\r\n        if (this.dom !== dragHandle) {\r\n            const domBox = this.dom.getBoundingClientRect();\r\n            const handleBox = dragHandle.getBoundingClientRect();\r\n            x = handleBox.x - domBox.x + event.offsetX;\r\n            y = handleBox.y - domBox.y + event.offsetY;\r\n        }\r\n        (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y);\r\n        // we need to tell ProseMirror that we want to move the whole node\r\n        // so we create a NodeSelection\r\n        const selection = NodeSelection.create(view.state.doc, this.getPos());\r\n        const transaction = view.state.tr.setSelection(selection);\r\n        view.dispatch(transaction);\r\n    }\r\n    stopEvent(event) {\r\n        var _a;\r\n        if (!this.dom) {\r\n            return false;\r\n        }\r\n        if (typeof this.options.stopEvent === 'function') {\r\n            return this.options.stopEvent({ event });\r\n        }\r\n        const target = event.target;\r\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\r\n        // any event from child nodes should be handled by ProseMirror\r\n        if (!isInElement) {\r\n            return false;\r\n        }\r\n        const isDropEvent = event.type === 'drop';\r\n        const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)\r\n            || target.isContentEditable;\r\n        // any input event within node views should be ignored by ProseMirror\r\n        if (isInput && !isDropEvent) {\r\n            return true;\r\n        }\r\n        const { isEditable } = this.editor;\r\n        const { isDragging } = this;\r\n        const isDraggable = !!this.node.type.spec.draggable;\r\n        const isSelectable = NodeSelection.isSelectable(this.node);\r\n        const isCopyEvent = event.type === 'copy';\r\n        const isPasteEvent = event.type === 'paste';\r\n        const isCutEvent = event.type === 'cut';\r\n        const isClickEvent = event.type === 'mousedown';\r\n        const isDragEvent = event.type.startsWith('drag');\r\n        // ProseMirror tries to drag selectable nodes\r\n        // even if `draggable` is set to `false`\r\n        // this fix prevents that\r\n        if (!isDraggable && isSelectable && isDragEvent) {\r\n            event.preventDefault();\r\n        }\r\n        if (isDraggable && isDragEvent && !isDragging) {\r\n            event.preventDefault();\r\n            return false;\r\n        }\r\n        // we have to store that dragging started\r\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\r\n            const dragHandle = target.closest('[data-drag-handle]');\r\n            const isValidDragHandle = dragHandle\r\n                && (this.dom === dragHandle || (this.dom.contains(dragHandle)));\r\n            if (isValidDragHandle) {\r\n                this.isDragging = true;\r\n                document.addEventListener('dragend', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n                document.addEventListener('mouseup', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n            }\r\n        }\r\n        // these events are handled by prosemirror\r\n        if (isDragging\r\n            || isDropEvent\r\n            || isCopyEvent\r\n            || isPasteEvent\r\n            || isCutEvent\r\n            || (isClickEvent && isSelectable)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        if (!this.dom || !this.contentDOM) {\r\n            return true;\r\n        }\r\n        if (typeof this.options.ignoreMutation === 'function') {\r\n            return this.options.ignoreMutation({ mutation });\r\n        }\r\n        // a leaf/atom node is like a black box for ProseMirror\r\n        // and should be fully handled by the node view\r\n        if (this.node.isLeaf || this.node.isAtom) {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any selections\r\n        if (mutation.type === 'selection') {\r\n            return false;\r\n        }\r\n        // try to prevent a bug on iOS that will break node views on enter\r\n        // this is because ProseMirror can’t preventDispatch on enter\r\n        // this will lead to a re-render of the node view on enter\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\r\n        if (this.dom.contains(mutation.target)\r\n            && mutation.type === 'childList'\r\n            && isiOS()\r\n            && this.editor.isFocused) {\r\n            const changedNodes = [\r\n                ...Array.from(mutation.addedNodes),\r\n                ...Array.from(mutation.removedNodes),\r\n            ];\r\n            // we’ll check if every changed node is contentEditable\r\n            // to make sure it’s probably mutated by ProseMirror\r\n            if (changedNodes.every(node => node.isContentEditable)) {\r\n                return false;\r\n            }\r\n        }\r\n        // we will allow mutation contentDOM with attributes\r\n        // so we can for example adding classes within our node view\r\n        if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any changes within contentDOM\r\n        if (this.contentDOM.contains(mutation.target)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    updateAttributes(attributes) {\r\n        this.editor.commands.command(({ tr }) => {\r\n            const pos = this.getPos();\r\n            tr.setNodeMarkup(pos, undefined, {\r\n                ...this.node.attrs,\r\n                ...attributes,\r\n            });\r\n            return true;\r\n        });\r\n    }\r\n    deleteNode() {\r\n        const from = this.getPos();\r\n        const to = from + this.node.nodeSize;\r\n        this.editor.commands.deleteRange({ from, to });\r\n    }\r\n}\n\nclass Tracker {\r\n    constructor(transaction) {\r\n        this.transaction = transaction;\r\n        this.currentStep = this.transaction.steps.length;\r\n    }\r\n    map(position) {\r\n        let deleted = false;\r\n        const mappedPosition = this.transaction.steps\r\n            .slice(this.currentStep)\r\n            .reduce((newPosition, step) => {\r\n            const mapResult = step\r\n                .getMap()\r\n                .mapResult(newPosition);\r\n            if (mapResult.deleted) {\r\n                deleted = true;\r\n            }\r\n            return mapResult.pos;\r\n        }, position);\r\n        return {\r\n            position: mappedPosition,\r\n            deleted,\r\n        };\r\n    }\r\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\r\nfunction nodeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const { tr } = state;\r\n            const start = range.from;\r\n            let end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                let matchStart = start + offset;\r\n                if (matchStart > end) {\r\n                    matchStart = end;\r\n                }\r\n                else {\r\n                    end = matchStart + match[1].length;\r\n                }\r\n                // insert last typed character\r\n                const lastChar = match[0][match[0].length - 1];\r\n                tr.insertText(lastChar, start + match[0].length - 1);\r\n                // insert node from input rule\r\n                tr.replaceWith(matchStart, end, config.type.create(attributes));\r\n            }\r\n            else if (match[0]) {\r\n                tr.replaceWith(start, end, config.type.create(attributes));\r\n            }\r\n        },\r\n    });\r\n}\n\nfunction getMarksBetween(from, to, doc) {\r\n    const marks = [];\r\n    // get all inclusive marks on empty selection\r\n    if (from === to) {\r\n        doc\r\n            .resolve(from)\r\n            .marks()\r\n            .forEach(mark => {\r\n            const $pos = doc.resolve(from - 1);\r\n            const range = getMarkRange($pos, mark.type);\r\n            if (!range) {\r\n                return;\r\n            }\r\n            marks.push({\r\n                mark,\r\n                ...range,\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        doc.nodesBetween(from, to, (node, pos) => {\r\n            marks.push(...node.marks.map(mark => ({\r\n                from: pos,\r\n                to: pos + node.nodeSize,\r\n                mark,\r\n            })));\r\n        });\r\n    }\r\n    return marks;\r\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\r\nfunction markInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            let markEnd = range.to;\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\r\nfunction textblockTypeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const $start = state.doc.resolve(range.from);\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\r\n                return null;\r\n            }\r\n            state.tr\r\n                .delete(range.from, range.to)\r\n                .setBlockType(range.from, range.from, config.type, attributes);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\r\nfunction textInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\r\nfunction wrappingInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const tr = state.tr.delete(range.from, range.to);\r\n            const $start = tr.doc.resolve(range.from);\r\n            const blockRange = $start.blockRange();\r\n            const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\r\n            if (!wrapping) {\r\n                return null;\r\n            }\r\n            tr.wrap(blockRange, wrapping);\r\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\r\n            if (before\r\n                && before.type === config.type\r\n                && canJoin(tr.doc, range.from - 1)\r\n                && (!config.joinPredicate || config.joinPredicate(match, before))) {\r\n                tr.join(range.from - 1);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\r\nfunction markPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            let markEnd = range.to;\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\r\nfunction textPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\n// source: https://stackoverflow.com/a/6969486\r\nfunction escapeForRegEx(string) {\r\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\r\nfunction combineTransactionSteps(oldDoc, transactions) {\r\n    const transform = new Transform(oldDoc);\r\n    transactions.forEach(transaction => {\r\n        transaction.steps.forEach(step => {\r\n            transform.step(step);\r\n        });\r\n    });\r\n    return transform;\r\n}\n\nfunction defaultBlockAt(match) {\r\n    for (let i = 0; i < match.edgeCount; i += 1) {\r\n        const { type } = match.edge(i);\r\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}\n\nfunction findChildren(node, predicate) {\r\n    const nodesWithPos = [];\r\n    node.descendants((child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\r\nfunction findChildrenInRange(node, range, predicate) {\r\n    const nodesWithPos = [];\r\n    // if (range.from === range.to) {\r\n    //   const nodeAt = node.nodeAt(range.from)\r\n    //   if (nodeAt) {\r\n    //     nodesWithPos.push({\r\n    //       node: nodeAt,\r\n    //       pos: range.from,\r\n    //     })\r\n    //   }\r\n    // }\r\n    node.nodesBetween(range.from, range.to, (child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\nfunction getSchema(extensions) {\r\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\r\n    return getSchemaByResolvedExtensions(resolvedExtensions);\r\n}\n\nfunction generateHTML(doc, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const contentNode = Node$1.fromJSON(schema, doc);\r\n    return getHTMLFromFragment(contentNode.content, schema);\r\n}\n\nfunction generateJSON(html, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const dom = elementFromString(html);\r\n    return DOMParser.fromSchema(schema)\r\n        .parse(dom)\r\n        .toJSON();\r\n}\n\nfunction generateText(doc, extensions, options) {\r\n    const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n    const schema = getSchema(extensions);\r\n    const contentNode = Node$1.fromJSON(schema, doc);\r\n    return getText(contentNode, {\r\n        blockSeparator,\r\n        textSerializers: {\r\n            ...textSerializers,\r\n            ...getTextSeralizersFromSchema(schema),\r\n        },\r\n    });\r\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\r\nfunction removeDuplicates(array, by = JSON.stringify) {\r\n    const seen = {};\r\n    return array.filter(item => {\r\n        const key = by(item);\r\n        return Object.prototype.hasOwnProperty.call(seen, key)\r\n            ? false\r\n            : (seen[key] = true);\r\n    });\r\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\r\nfunction simplifyChangedRanges(changes) {\r\n    const uniqueChanges = removeDuplicates(changes);\r\n    return uniqueChanges.length === 1\r\n        ? uniqueChanges\r\n        : uniqueChanges.filter((change, index) => {\r\n            const rest = uniqueChanges.filter((_, i) => i !== index);\r\n            return !rest.some(otherChange => {\r\n                return change.oldRange.from >= otherChange.oldRange.from\r\n                    && change.oldRange.to <= otherChange.oldRange.to\r\n                    && change.newRange.from >= otherChange.newRange.from\r\n                    && change.newRange.to <= otherChange.newRange.to;\r\n            });\r\n        });\r\n}\r\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\r\nfunction getChangedRanges(transform) {\r\n    const { mapping, steps } = transform;\r\n    const changes = [];\r\n    mapping.maps.forEach((stepMap, index) => {\r\n        const ranges = [];\r\n        // This accounts for step changes where no range was actually altered\r\n        // e.g. when setting a mark, node attribute, etc.\r\n        // @ts-ignore\r\n        if (!stepMap.ranges.length) {\r\n            const { from, to } = steps[index];\r\n            if (from === undefined || to === undefined) {\r\n                return;\r\n            }\r\n            ranges.push({ from, to });\r\n        }\r\n        else {\r\n            stepMap.forEach((from, to) => {\r\n                ranges.push({ from, to });\r\n            });\r\n        }\r\n        ranges.forEach(({ from, to }) => {\r\n            const newStart = mapping.slice(index).map(from, -1);\r\n            const newEnd = mapping.slice(index).map(to);\r\n            const oldStart = mapping.invert().map(newStart, -1);\r\n            const oldEnd = mapping.invert().map(newEnd);\r\n            changes.push({\r\n                oldRange: {\r\n                    from: oldStart,\r\n                    to: oldEnd,\r\n                },\r\n                newRange: {\r\n                    from: newStart,\r\n                    to: newEnd,\r\n                },\r\n            });\r\n        });\r\n    });\r\n    return simplifyChangedRanges(changes);\r\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\r\n    const isTopNode = node.type === node.type.schema.topNodeType;\r\n    const increment = isTopNode ? 0 : 1;\r\n    const from = startOffset;\r\n    const to = from + node.nodeSize;\r\n    const marks = node.marks.map(mark => {\r\n        const output = {\r\n            type: mark.type.name,\r\n        };\r\n        if (Object.keys(mark.attrs).length) {\r\n            output.attrs = { ...mark.attrs };\r\n        }\r\n        return output;\r\n    });\r\n    const attrs = { ...node.attrs };\r\n    const output = {\r\n        type: node.type.name,\r\n        from,\r\n        to,\r\n    };\r\n    if (Object.keys(attrs).length) {\r\n        output.attrs = attrs;\r\n    }\r\n    if (marks.length) {\r\n        output.marks = marks;\r\n    }\r\n    if (node.content.childCount) {\r\n        output.content = [];\r\n        node.forEach((child, offset) => {\r\n            var _a;\r\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\r\n        });\r\n    }\r\n    if (node.text) {\r\n        output.text = node.text;\r\n    }\r\n    return output;\r\n}\n\nfunction isNodeSelection(value) {\r\n    return isObject(value) && value instanceof NodeSelection;\r\n}\n\nfunction posToDOMRect(view, from, to) {\r\n    const minPos = 0;\r\n    const maxPos = view.state.doc.content.size;\r\n    const resolvedFrom = minMax(from, minPos, maxPos);\r\n    const resolvedEnd = minMax(to, minPos, maxPos);\r\n    const start = view.coordsAtPos(resolvedFrom);\r\n    const end = view.coordsAtPos(resolvedEnd, -1);\r\n    const top = Math.min(start.top, end.top);\r\n    const bottom = Math.max(start.bottom, end.bottom);\r\n    const left = Math.min(start.left, end.left);\r\n    const right = Math.max(start.right, end.right);\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n    const x = left;\r\n    const y = top;\r\n    const data = {\r\n        top,\r\n        bottom,\r\n        left,\r\n        right,\r\n        width,\r\n        height,\r\n        x,\r\n        y,\r\n    };\r\n    return {\r\n        ...data,\r\n        toJSON: () => data,\r\n    };\r\n}\n\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, defaultBlockAt, escapeForRegEx, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, generateText, getAttributes, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getSchema, getText, getTextBetween, inputRulesPlugin, isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, pasteRulesPlugin, posToDOMRect, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };\n//# sourceMappingURL=tiptap-core.esm.js.map\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\n\n// declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n  if (result == \"Space\") { result = \" \"; }\n  var alt, ctrl, shift, meta;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { result = \"Alt-\" + result; }\n  if (ctrl) { result = \"Ctrl-\" + result; }\n  if (meta) { result = \"Meta-\" + result; }\n  if (shift) { result = \"Shift-\" + result; }\n  return result\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) { name = \"Alt-\" + name; }\n  if (event.ctrlKey) { name = \"Ctrl-\" + name; }\n  if (event.metaKey) { name = \"Meta-\" + name; }\n  if (shift !== false && event.shiftKey) { name = \"Shift-\" + name; }\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nfunction keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap)), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function(view, event) {\n    var name = keyName(event), isChar = name.length == 1 && name != \" \", baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n    if (direct && direct(view.state, view.dispatch, view)) { return true }\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      var fromCode = map[modifiers(baseName, event, true)];\n      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      var withShift = map[modifiers(name, event, true)];\n      if (withShift && withShift(view.state, view.dispatch, view)) { return true }\n    }\n    return false\n  }\n}\n\nexport { keydownHandler, keymap };\n//# sourceMappingURL=index.es.js.map\n","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node): leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\nprototypeAccessors$2.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2.doc.get = function () { return this.node(0) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted to separate text\n// from different block nodes. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3 );\n\nvar TextNode = /*@__PURE__*/(function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2 = { next: { configurable: true } };\n\nprototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true },whitespace: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: union<\"pre\", \"normal\">\n// The node type's [whitespace](#view.NodeSpec.whitespace) option.\nprototypeAccessors$5.whitespace.get = function () { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") };\n\n// :: () → bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n\n  // Only normalize list elements when lists in the schema can't directly contain themselves\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) { return false }\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node)\n  });\n};\n\n// :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema) → [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1();\n  return result\n};\n\n// :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) { return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0) }\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = wsOptionsFor(type, preserveWS, top.options);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n\n  return target\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\n// :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNodeInner(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n(wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {\n    if ( xmlNS === void 0 ) xmlNS = null;\n\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  if (structure.dom && structure.dom.nodeType != null)\n    { return structure }\n  var tagName = structure[0], space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) { if (attrs[name] != null) {\n      var space$1 = name.indexOf(\" \");\n      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }\n      else { dom.setAttribute(name, attrs[name]); }\n    } }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };\n//# sourceMappingURL=index.es.js.map\n","import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nvar classesById = Object.create(null);\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nvar Selection = function Selection($anchor, $head, ranges) {\n  // :: [SelectionRange]\n  // The ranges covered by the selection.\n  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  // :: ResolvedPos\n  // The resolved anchor of the selection (the side that stays in\n  // place when the selection is modified).\n  this.$anchor = $anchor;\n  // :: ResolvedPos\n  // The resolved head of the selection (the side that moves when\n  // the selection is modified).\n  this.$head = $head;\n};\n\nvar prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };\n\n// :: number\n// The selection's anchor, as an unresolved position.\nprototypeAccessors.anchor.get = function () { return this.$anchor.pos };\n\n// :: number\n// The selection's head.\nprototypeAccessors.head.get = function () { return this.$head.pos };\n\n// :: number\n// The lower bound of the selection's main range.\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection's main range.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\n// :: ResolvedPos\n// The resolved lowerbound of the selection's main range.\nprototypeAccessors.$from.get = function () {\n  return this.ranges[0].$from\n};\n\n// :: ResolvedPos\n// The resolved upper bound of the selection's main range.\nprototypeAccessors.$to.get = function () {\n  return this.ranges[0].$to\n};\n\n// :: bool\n// Indicates whether the selection contains any content.\nprototypeAccessors.empty.get = function () {\n  var ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++)\n    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }\n  return true\n};\n\n// eq:: (Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document to which we are mapping.\n\n// :: () → Slice\n// Get the content of this selection as a slice.\nSelection.prototype.content = function content () {\n  return this.$from.node(0).slice(this.from, this.to, true)\n};\n\n// :: (Transaction, ?Slice)\n// Replace the selection with a slice or, if no slice is given,\n// delete the selection. Will append to the given transaction.\nSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n  // Put the new selection at the position after the inserted\n  // content. When that ended in an inline node, search backwards,\n  // to get the position after that node. If not, search forward.\n  var lastNode = content.content.lastChild, lastParent = null;\n  for (var i = 0; i < content.openEnd; i++) {\n    lastParent = lastNode;\n    lastNode = lastNode.lastChild;\n  }\n\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n    var ref = ranges[i$1];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content);\n    if (i$1 == 0)\n      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }\n  }\n};\n\n// :: (Transaction, Node)\n// Replace the selection with the given node, appending the changes\n// to the given transaction.\nSelection.prototype.replaceWith = function replaceWith (tr, node) {\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++) {\n    var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    var from = mapping.map($from.pos), to = mapping.map($to.pos);\n    if (i) {\n      tr.deleteRange(from, to);\n    } else {\n      tr.replaceRangeWith(from, to, node);\n      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n    }\n  }\n};\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation. When implementing\n// this for a custom selection class, make sure to give the object a\n// `type` property whose value matches the ID under which you\n// [registered](#state.Selection^jsonID) your class.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// positive. When `textOnly` is true, only consider cursor\n// selections. Will return null when no valid selection position is\n// found.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.inlineContent ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. Will return an\n// [`AllSelection`](#state.AllSelection) if no valid position\n// exists.\nSelection.atStart = function atStart (doc) {\n  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the end of the\n// given document.\nSelection.atEnd = function atEnd (doc) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n};\n\n// :: (Node, Object) → Selection\n// Deserialize the JSON representation of a selection. Must be\n// implemented for custom classes (as a static class method).\nSelection.fromJSON = function fromJSON (doc, json) {\n  if (!json || !json.type) { throw new RangeError(\"Invalid input for Selection.fromJSON\") }\n  var cls = classesById[json.type];\n  if (!cls) { throw new RangeError((\"No selection type \" + (json.type) + \" defined\")) }\n  return cls.fromJSON(doc, json)\n};\n\n// :: (string, constructor<Selection>)\n// To be able to deserialize selections from JSON, custom selection\n// classes must register themselves with an ID string, so that they\n// can be disambiguated. Try to pick something that's unlikely to\n// clash with classes from other modules.\nSelection.jsonID = function jsonID (id, selectionClass) {\n  if (id in classesById) { throw new RangeError(\"Duplicate use of selection JSON ID \" + id) }\n  classesById[id] = selectionClass;\n  selectionClass.prototype.jsonID = id;\n  return selectionClass\n};\n\n// :: () → SelectionBookmark\n// Get a [bookmark](#state.SelectionBookmark) for this selection,\n// which is a value that can be mapped without having access to a\n// current document, and later resolved to a real selection for a\n// given document again. (This is used mostly by the history to\n// track and restore old selections.) The default implementation of\n// this method just converts the selection to a text selection and\n// returns the bookmark for that.\nSelection.prototype.getBookmark = function getBookmark () {\n  return TextSelection.between(this.$anchor, this.$head).getBookmark()\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true;\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nvar SelectionRange = function SelectionRange($from, $to) {\n  // :: ResolvedPos\n  // The lower bound of the range.\n  this.$from = $from;\n  // :: ResolvedPos\n  // The upper bound of the range.\n  this.$to = $to;\n};\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nvar TextSelection = /*@__PURE__*/(function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    Selection.call(this, $anchor, $head);\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { $cursor: { configurable: true } };\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    Selection.prototype.replace.call(this, tr, content);\n    if (content == Slice.empty) {\n      var marks = this.$from.marksAcross(this.$to);\n      if (marks) { tr.ensureMarks(marks); }\n    }\n  };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  };\n\n  TextSelection.prototype.getBookmark = function getBookmark () {\n    return new TextBookmark(this.anchor, this.head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  };\n\n  TextSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      { throw new RangeError(\"Invalid input for TextSelection.fromJSON\") }\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  TextSelection.between = function between ($anchor, $head, bias) {\n    var dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }\n    if (!$head.parent.inlineContent) {\n      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) { $head = found.$head; }\n      else { return Selection.near($head, bias) }\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }\n      }\n    }\n    return new TextSelection($anchor, $head)\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function TextBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nTextBookmark.prototype.map = function map (mapping) {\n  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nTextBookmark.prototype.resolve = function resolve (doc) {\n  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n};\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nvar NodeSelection = /*@__PURE__*/(function (Selection) {\n  function NodeSelection($pos) {\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    Selection.call(this, $pos, $end);\n    // :: Node The selected node.\n    this.node = node;\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n    var $pos = doc.resolve(pos);\n    if (deleted) { return Selection.near($pos) }\n    return new NodeSelection($pos)\n  };\n\n  NodeSelection.prototype.content = function content () {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  };\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {type: \"node\", anchor: this.anchor}\n  };\n\n  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };\n\n  NodeSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\")\n      { throw new RangeError(\"Invalid input for NodeSelection.fromJSON\") }\n    return new NodeSelection(doc.resolve(json.anchor))\n  };\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\n\nNodeSelection.prototype.visible = false;\n\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function NodeBookmark(anchor) {\n  this.anchor = anchor;\n};\nNodeBookmark.prototype.map = function map (mapping) {\n  var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n};\nNodeBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }\n  return Selection.near($pos)\n};\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nvar AllSelection = /*@__PURE__*/(function (Selection) {\n  function AllSelection(doc) {\n    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  if ( Selection ) AllSelection.__proto__ = Selection;\n  AllSelection.prototype = Object.create( Selection && Selection.prototype );\n  AllSelection.prototype.constructor = AllSelection;\n\n  AllSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      var sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }\n    } else {\n      Selection.prototype.replace.call(this, tr, content);\n    }\n  };\n\n  AllSelection.prototype.toJSON = function toJSON () { return {type: \"all\"} };\n\n  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };\n\n  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };\n\n  return AllSelection;\n}(Selection));\n\nSelection.jsonID(\"all\", AllSelection);\n\nvar AllBookmark = {\n  map: function map() { return this },\n  resolve: function resolve(doc) { return new AllSelection(doc) }\n};\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) { return }\n  var step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) { return }\n  var map = tr.mapping.maps[last], end;\n  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nvar Transaction = /*@__PURE__*/(function (Transform) {\n  function Transaction(state) {\n    Transform.call(this, state.doc);\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n  }\n\n  if ( Transform ) Transaction.__proto__ = Transform;\n  Transaction.prototype = Object.create( Transform && Transform.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    if (selection.$from.doc != this.doc)\n      { throw new RangeError(\"Selection passed to setSelection must point at the current document\") }\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return (this.updated & UPDATED_SEL) > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this\n  };\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  Transaction.prototype.ensureMarks = function ensureMarks (marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      { this.setStoredMarks(marks); }\n    return this\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return (this.updated & UPDATED_MARKS) > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform.prototype.addStep.call(this, step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time;\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    this.selection.replace(this, slice);\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var selection = this.selection;\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none))); }\n    selection.replaceWith(this, node);\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    this.selection.replace(this);\n    return this\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var marks = this.storedMarks;\n      if (!marks) {\n        var $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }\n      return this\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  prototypeAccessors.isGeneric.get = function () {\n    for (var _ in this.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL;\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return (this.updated & UPDATED_SCROLL) > 0\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(Transform));\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init(config) { return config.storedMarks || null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n];\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1 = this;\n\n  this.schema = schema;\n  this.fields = baseFields.concat();\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1.plugins.push(plugin);\n    this$1.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state)\n      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }\n  }); }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nvar EditorState = function EditorState(config) {\n  this.config = config;\n};\n\nvar prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next input. Will be null when\n// no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors$1.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors$1.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → bool\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this.config.plugins[i];\n    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](#state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](#state.PluginSpec.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (rootTr) {\n  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }\n\n  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n   for (;;) {\n    var haveNew = false;\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this.config.plugins[i];\n      if (plugin.spec.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n        var tr = n < trs.length &&\n            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n        if (tr && newState.filterTransaction(tr, i)) {\n          tr.setMeta(\"appendedTransaction\", rootTr);\n          if (!seen) {\n            seen = [];\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }\n          }\n          trs.push(tr);\n          newState = newState.applyInner(tr);\n          haveNew = true;\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length}; }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields;\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors$1.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a new state.\n//\n// config::- Configuration options. Must contain `schema` or `doc` (or both).\n//\n//    schema:: ?Schema\n//    The schema to use (only relevant if no `doc` is specified).\n//\n//    doc:: ?Node\n//    The starting document.\n//\n//    selection:: ?Selection\n//    A valid selection in the document.\n//\n//    storedMarks:: ?[Mark]\n//    The initial set of [stored marks](#state.EditorState.storedMarks).\n//\n//    plugins:: ?[Plugin]\n//    The plugins that should be active in this state.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n  var instance = new EditorState($config);\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\n//\n// config::- configuration options\n//\n//   plugins:: [Plugin]\n//   New set of active plugins.\nEditorState.prototype.reconfigure = function reconfigure (config) {\n  var $config = new Configuration(this.schema, config.plugins);\n  var fields = $config.fields, instance = new EditorState($config);\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name;\n    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n  }\n  return instance\n};\n\n// :: (?union<Object<Plugin>, string, number>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects. The argument may also be\n// a string or number, in which case it is ignored, to support the\n// way `JSON.stringify` calls `toString` methods.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};\n  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }\n  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.spec.state;\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\n//\n// config::- configuration options\n//\n//   schema:: Schema\n//   The schema to use.\n//\n//   plugins:: ?[Plugin]\n//   The set of active plugins.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!json) { throw new RangeError(\"Invalid input for EditorState.fromJSON\") }\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins);\n  var instance = new EditorState($config);\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = Node.fromJSON(config.schema, json.doc);\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection);\n    } else if (field.name == \"storedMarks\") {\n      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.spec.state;\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance);\n    }\n  });\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\n//\n// FIXME this is no longer needed as of prosemirror-view 1.9.0,\n// though due to backwards-compat we should probably keep it around\n// for a while (if only as a no-op)\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f);\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f);\n  if (found > -1) { applyListeners.splice(found, 1); }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors$1 );\n\nvar applyListeners = [];\n\n// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) { val = val.bind(self); }\n    else if (prop == \"handleDOMEvents\") { val = bindProps(val, self, {}); }\n    target[prop] = val;\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nvar Plugin = function Plugin(spec) {\n  // :: EditorProps\n  // The [props](#view.EditorProps) exported by this plugin.\n  this.props = {};\n  if (spec.props) { bindProps(spec.props, this, this.props); }\n  // :: Object\n  // The plugin's [spec object](#state.PluginSpec).\n  this.spec = spec;\n  this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n};\n\n// :: (EditorState) → any\n// Extract the plugin's state field from an editor state.\nPlugin.prototype.getState = function getState (state) { return state[this.key] };\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nvar keys = Object.create(null);\n\nfunction createKey(name) {\n  if (name in keys) { return name + \"$\" + ++keys[name] }\n  keys[name] = 0;\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nvar PluginKey = function PluginKey(name) {\nif ( name === void 0 ) name = \"key\";\n this.key = createKey(name); };\n\n// :: (EditorState) → ?Plugin\n// Get the active plugin with this key, if any, from an editor\n// state.\nPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\n// :: (EditorState) → ?any\n// Get the plugin's state from an editor state.\nPluginKey.prototype.getState = function getState (state) { return state[this.key] };\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n//# sourceMappingURL=index.es.js.map\n","import { ReplaceError, Slice, Fragment, MarkType } from 'prosemirror-model';\n\n// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  if (!ranges.length && StepMap.empty) { return StepMap.empty }\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover (value) {\n  var diff = 0, index = recoverIndex(value);\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// : (number, ?number) → MapResult\nStepMap.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\n// : (number, ?number) → number\nStepMap.prototype.map = function map (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n      if (simple) { return result }\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize;\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n  var diff = 0, index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n    if (pos <= end && i == index * 3) { return true }\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\n\n// :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\nStepMap.offset = function offset (n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n};\n\nStepMap.empty = new StepMap([]);\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || [];\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0;\n  // :: number\n  // The end position in the `maps` array.\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n};\n\n// :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map);\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n};\n\n// :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\nMapping.prototype.getMirror = function getMirror (n) {\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = []; }\n  this.mirror.push(n, m);\n};\n\n// :: (Mapping)\n// Append the inverse of the given mapping to this one.\nMapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n};\n\n// :: () → Mapping\n// Create an inverted version of this mapping.\nMapping.prototype.invert = function invert () {\n  var inverse = new Mapping;\n  inverse.appendMappingInverted(this);\n  return inverse\n};\n\n// : (number, ?number) → number\n// Map a position through this mapping.\nMapping.prototype.map = function map (pos, assoc) {\n    if ( assoc === void 0 ) assoc = 1;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this.maps[i].map(pos, assoc); }\n  return pos\n};\n\n// : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i], result = map.mapResult(pos, assoc);\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue\n      }\n    }\n\n    if (result.deleted) { deleted = true; }\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc;\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = [];\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = [];\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping;\n};\n\nvar prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };\n\n// :: Node The starting document.\nprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object);\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc);\n  if (!result.failed) { this.addStep(step, result.doc); }\n  return result\n};\n\n// :: bool\n// True when the document has been changed (when there are any\n// steps).\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors );\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null);\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\nStep.prototype.toJSON = function toJSON () { return mustOverride() };\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  if (!json || !json.stepType) { throw new RangeError(\"Invalid input for Step.fromJSON\") }\n  var type = stepsByID[json.stepType];\n  if (!type) { throw new RangeError((\"No step type \" + (json.stepType) + \" defined\")) }\n  return type.fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass\n};\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc;\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed;\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = /*@__PURE__*/(function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\") }\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\n\nStep.jsonID(\"replace\", ReplaceStep);\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = /*@__PURE__*/(function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom;\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\") }\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      { return depth }\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  var start = gapStart, end = gapEnd;\n\n  var before = Fragment.empty, openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    } }\n  var after = Fragment.empty, openEnd = 0;\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n};\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if ( innerRange === void 0 ) innerRange = range;\n\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) { return null }\n  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type: type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) { return null }\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) { return null }\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++)\n    { innerMatch = innerMatch.matchType(parent.child(i).type); }\n  if (!innerMatch || !innerMatch.validEnd) { return null }\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd)\n        { throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\") }\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  var start = range.start, end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n};\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false\n    }\n  });\n  return this\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type; }\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }\n\n  if (!type.validContent(node.content))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n};\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = doc.resolve(pos), base = $pos.depth - depth;\n  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    { return false }\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d), index$1 = $pos.index(d);\n    if (node.type.spec.isolating) { return false }\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = (typesAfter && typesAfter[i]) || node;\n    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))\n      { return false }\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n};\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos, dir) {\n  if ( dir === void 0 ) dir = -1;\n\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = (void 0), after = (void 0), index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) { return pos }\n    if (d == 0) { break }\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step)\n};\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) { return pos }\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d), fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits)\n        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n    }\n  }\n  return null\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }\n    if (child.isInline) { child = f(child, parent, i); }\n    mapped.push(child);\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = /*@__PURE__*/(function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the marked range.\n    this.from = from;\n    // :: number\n    // The end of the marked range.\n    this.to = to;\n    // :: Mark\n    // The mark to add.\n    this.mark = mark;\n  }\n\n  if ( Step ) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }\n      return node.mark(this$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\") }\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = /*@__PURE__*/(function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the unmarked range.\n    this.from = from;\n    // :: number\n    // The end of the unmarked range.\n    this.to = to;\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark;\n  }\n\n  if ( Step ) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\") }\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) { return }\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            { removing.to = end; }\n          else\n            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }\n        }\n      }\n\n      if (adding && adding.to == start)\n        { adding.to = end; }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)); }\n    }\n  });\n\n  removed.forEach(function (s) { return this$1.step(s); });\n  added.forEach(function (s) { return this$1.step(s); });\n  return this\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++;\n    var toRemove = null;\n    if (mark instanceof MarkType) {\n      var set = node.marks, found;\n      while (found = mark.isInSet(set)) {\n(toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark]; }\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0);\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }\n        }\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n  return this\n};\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match) {\n  if ( match === void 0 ) match = parentType.contentMatch;\n\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [], cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))\n        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }\n  return this\n};\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice);\n  if (step) { this.step(step); }\n  return this\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n\n  this.frontier = [];\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n  for (var i$1 = $from.depth; i$1 > 0; i$1--)\n    { this.placed = Fragment.from($from.node(i$1).copy(this.placed)); }\n};\n\nvar prototypeAccessors$1 = { depth: { configurable: true } };\n\nprototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };\n\nFitter.prototype.fit = function fit () {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n    if (fit) { this.placeNodes(fit); }\n    else { this.openMore() || this.dropNode(); }\n  }\n  // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n  if (!$to) { return null }\n\n  // If closing to `$to` succeeded, create a step\n  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--; openEnd--;\n  }\n  var slice = new Slice(content, openStart, openEnd);\n  if (moveInline > -1)\n    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    { return new ReplaceStep($from.pos, $to.pos, slice) }\n};\n\n// Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\nFitter.prototype.findFittable = function findFittable () {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = (void 0), parent = (void 0);\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n      var first = fragment.firstChild;\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n          var type = ref.type;\n          var match = ref.match;\n          var wrap = (void 0), inject = (void 0);\n        // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                          : type.compatibleContent(parent.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }\n        // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }\n        // Don't continue looking further up if the parent node\n        // would fit here.\n        if (parent && match.matchType(parent.type)) { break }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (!inner.childCount || inner.firstChild.isLeaf) { return false }\n  this.unplaced = new Slice(content, openStart + 1,\n                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true\n};\n\nFitter.prototype.dropNode = function dropNode () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                              openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n};\n\n// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\nFitter.prototype.placeNodes = function placeNodes (ref) {\n    var sliceDepth = ref.sliceDepth;\n    var frontierDepth = ref.frontierDepth;\n    var parent = ref.parent;\n    var inject = ref.inject;\n    var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) { this.closeFrontierNode(); }\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }\n\n  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0, add = [];\n  var ref$1 = this.frontier[frontierDepth];\n    var match = ref$1.match;\n    var type = ref$1.type;\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }\n    match = match.matchFragment(inject);\n  }\n  // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n  // Scan over the fragment, fitting as many child nodes as\n  // possible.\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken), matches = match.matchType(next.type);\n    if (!matches) { break }\n    taken++;\n    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                              taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n  var toEnd = taken == fragment.childCount;\n  if (!toEnd) { openEndCount = -1; }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match;\n\n  // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n    { this.closeFrontierNode(); }\n\n  // Add new frontier nodes for any open nodes at the end.\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});\n    cur = node.content;\n  }\n\n  // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n    : sliceDepth == 0 ? Slice.empty\n    : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline () {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }\n  var top = this.frontier[this.depth], level;\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }\n\n  var ref = this.$to;\n    var depth = ref.depth;\n    var after = this.$to.after(depth);\n  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }\n  return after\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel ($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n      var match = ref.match;\n      var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n    if (!fit) { continue }\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n        var match$1 = ref$1.match;\n        var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n      if (!matches || matches.childCount) { continue scan }\n    }\n    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n  }\n};\n\nFitter.prototype.close = function close ($to) {\n  var close = this.findCloseLevel($to);\n  if (!close) { return null }\n\n  while (this.depth > close.depth) { this.closeFrontierNode(); }\n  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }\n  $to = close.move;\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n  return $to\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({type: type, match: type.contentMatch});\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode () {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }\n};\n\nObject.defineProperties( Fitter.prototype, prototypeAccessors$1 );\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) { return fragment.cutByIndex(count) }\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) { return fragment.append(content) }\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) { return node }\n  var frag = node.content;\n  if (openStart > 1)\n    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true)); }\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++)\n    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.isolating) { break }\n    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }\n    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n\n  var leftNodes = [], preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) { break }\n    content = node.content;\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    { preferredDepth -= 1; }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    { preferredDepth -= 2; }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }\n      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd)) }\n    }\n  }\n\n  var startSteps = this.steps.length;\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n    if (this.steps.length > startSteps) { break }\n    var depth = targetDepths[i$2];\n    if (depth < 0) { continue }\n    from = $from.before(depth); to = $to.after(depth);\n  }\n  return this\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n    if (point != null) { from = to = point; }\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i], last = i == covered.length - 1;\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      { return this.delete($from.start(depth), $to.end(depth)) }\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      { return this.delete($from.before(depth), $to.after(depth)) }\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      { return this.delete($from.before(d), to) }\n  }\n  return this.delete(from, to)\n};\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) { break }\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      { result.push(d); }\n  }\n  return result\n}\n\nexport { AddMarkStep, MapResult, Mapping, RemoveMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep };\n//# sourceMappingURL=index.es.js.map\n","import { TextSelection, NodeSelection, Selection, AllSelection } from 'prosemirror-state';\nimport { DOMSerializer, Fragment, Mark, DOMParser, Slice } from 'prosemirror-model';\nimport { dropPoint } from 'prosemirror-transform';\n\nvar result = {};\n\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  var ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent);\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\n  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent);\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n  var chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\n  result.chrome = !!chrome;\n  result.chrome_version = chrome && +chrome[1];\n  // Is true for both iOS and iPadOS for convenience\n  result.safari = !ie && /Apple Computer/.test(navigator.vendor);\n  result.ios = result.safari && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\n  result.mac = result.ios || /Mac/.test(navigator.platform);\n  result.android = /Android \\d/.test(navigator.userAgent);\n  result.webkit = \"webkitFontSmoothing\" in document.documentElement.style;\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n}\n\nvar domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) { return index }\n  }\n};\n\nvar parentNode = function(node) {\n  var parent = node.assignedSlot || node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent\n};\n\nvar reusedRange = null;\n\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nvar textRange = function(node, from, to) {\n  var range = reusedRange || (reusedRange = document.createRange());\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range\n};\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nvar isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n};\n\nvar atomElements = /^(img|br|input|textarea|hr)$/i;\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) { return true }\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      var parent = node.parentNode;\n      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||\n          node.contentEditable == \"false\")\n        { return false }\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.contentEditable == \"false\") { return false }\n      off = dir < 0 ? nodeSize(node) : 0;\n    } else {\n      return false\n    }\n  }\n}\n\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isOnEdge(node, offset, parent) {\n  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) { return true }\n    var index = domIndex(node);\n    node = node.parentNode;\n    if (!node) { return false }\n    atStart = atStart && index == 0;\n    atEnd = atEnd && index == nodeSize(node);\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  var desc;\n  for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nvar selectionCollapsed = function(domSel) {\n  var collapsed = domSel.isCollapsed;\n  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    { collapsed = false; }\n  return collapsed\n};\n\nfunction keyEvent(keyCode, key) {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event\n}\n\nfunction windowRect(doc) {\n  return {left: 0, right: doc.documentElement.clientWidth,\n          top: 0, bottom: doc.documentElement.clientHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction clientRect(node) {\n  var rect = node.getBoundingClientRect();\n  // Adjust for elements with style \"transform: scale()\"\n  var scaleX = (rect.width / node.offsetWidth) || 1;\n  var scaleY = (rect.height / node.offsetHeight) || 1;\n  // Make sure scrollbar width isn't included in the rectangle\n  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,\n          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}\n}\n\nfunction scrollRectIntoView(view, rect, startDOM) {\n  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  var doc = view.dom.ownerDocument;\n  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) { break }\n    if (parent.nodeType != 1) { continue }\n    var atTop = parent == doc.body || parent.nodeType != 1;\n    var bounding = atTop ? windowRect(doc) : clientRect(parent);\n    var moveX = 0, moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\")); }\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\"); }\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\")); }\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      { moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\"); }\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY);\n      } else {\n        var startX = parent.scrollLeft, startY = parent.scrollTop;\n        if (moveY) { parent.scrollTop += moveY; }\n        if (moveX) { parent.scrollLeft += moveX; }\n        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;\n        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};\n      }\n    }\n    if (atTop) { break }\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n  var refDOM, refTop;\n  for (var x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    var dom = view.root.elementFromPoint(x, y);\n    if (dom == view.dom || !view.dom.contains(dom)) { continue }\n    var localRect = dom.getBoundingClientRect();\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break\n    }\n  }\n  return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}\n}\n\nfunction scrollStack(dom) {\n  var stack = [], doc = dom.ownerDocument;\n  for (; dom; dom = parentNode(dom)) {\n    stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});\n    if (dom == doc) { break }\n  }\n  return stack\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos(ref) {\n  var refDOM = ref.refDOM;\n  var refTop = ref.refTop;\n  var stack = ref.stack;\n\n  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (var i = 0; i < stack.length; i++) {\n    var ref = stack[i];\n    var dom = ref.dom;\n    var top = ref.top;\n    var left = ref.left;\n    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }\n    if (dom.scrollLeft != left) { dom.scrollLeft = left; }\n  }\n}\n\nvar preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) { return dom.setActive() } // in IE\n  if (preventScrollSupported) { return dom.focus(preventScrollSupported) }\n\n  var stored = scrollStack(dom);\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {preventScroll: true};\n      return true\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    restoreScrollStack(stored, 0);\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  var closest, dxClosest = 2e8, coordsClosest, offset = 0;\n  var rowBot = coords.top, rowTop = coords.top;\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = (void 0);\n    if (child.nodeType == 1) { rects = child.getClientRects(); }\n    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }\n    else { continue }\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        var dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;\n          if (child.nodeType == 1 && dx)\n            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        { offset = childIndex + 1; }\n    }\n  }\n  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }\n  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = singleRect(range, 1);\n    if (rect.top == rect.bottom) { continue }\n    if (inRect(coords, rect))\n      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }\n  }\n  return {node: node, offset: 0}\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&\n    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1\n}\n\nfunction targetKludge(dom, coords) {\n  var parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    { return parent }\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  var ref = findOffsetInNode(elt, coords);\n  var node = ref.node;\n  var offset = ref.offset;\n  var bias = -1;\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  var outside = -1;\n  for (var cur = node;;) {\n    if (cur == view.dom) { break }\n    var desc = view.docView.nearestDesc(cur, true);\n    if (!desc) { return null }\n    if (desc.node.isBlock && desc.parent) {\n      var rect = desc.dom.getBoundingClientRect();\n      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }\n      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }\n      else { break }\n    }\n    cur = desc.dom.parentNode;\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\nfunction elementFromPoint(element, coords, box) {\n  var len = element.childNodes.length;\n  if (len && box.top < box.bottom) {\n    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      var child = element.childNodes[i];\n      if (child.nodeType == 1) {\n        var rects = child.getClientRects();\n        for (var j = 0; j < rects.length; j++) {\n          var rect = rects[j];\n          if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }\n        }\n      }\n      if ((i = (i + 1) % len) == startI) { break }\n    }\n  }\n  return element\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n  var assign, assign$1;\n\n  var doc = view.dom.ownerDocument, node, offset;\n  if (doc.caretPositionFromPoint) {\n    try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n      var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);\n      if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }\n    } catch (_) {}\n  }\n  if (!node && doc.caretRangeFromPoint) {\n    var range = doc.caretRangeFromPoint(coords.left, coords.top);\n    if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }\n  }\n\n  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    var box = view.dom.getBoundingClientRect();\n    if (!inRect(coords, box)) { return null }\n    elt = elementFromPoint(view.dom, coords, box);\n    if (!elt) { return null }\n  }\n  // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n  if (result.safari) {\n    for (var p = elt; node && p; p = parentNode(p))\n      { if (p.draggable) { node = offset = null; } }\n  }\n  elt = targetKludge(elt, coords);\n  if (node) {\n    if (result.gecko && node.nodeType == 1) {\n      // Firefox will sometimes return offsets into <input> nodes, which\n      // have no actual children, from caretPositionFromPoint (#953)\n      offset = Math.min(offset, node.childNodes.length);\n      // It'll also move the returned position before image nodes,\n      // even if those are behind it.\n      if (offset < node.childNodes.length) {\n        var next = node.childNodes[offset], box$1;\n        if (next.nodeName == \"IMG\" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&\n            box$1.bottom > coords.top)\n          { offset++; }\n      }\n    }\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      { pos = view.state.doc.content.size; }\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately placed\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      { pos = posFromCaret(view, node, offset, coords); }\n  }\n  if (pos == null) { pos = posFromElement(view, elt, coords); }\n\n  var desc = view.docView.nearestDesc(elt, true);\n  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects();\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nvar BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\n// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n  var node = ref.node;\n  var offset = ref.offset;\n\n  var supportEmptyRange = result.webkit || result.gecko;\n  if (node.nodeType == 3) {\n    // These browsers support querying empty text ranges. Prefer that in\n    // bidi context or when at the end of a node.\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      var rect = singleRect(textRange(node, offset, offset), side);\n      // Firefox returns bad results (the position before the space)\n      // when querying a position directly after line-broken\n      // whitespace. Detect this situation and and kludge around it\n      if (result.gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n        if (rectBefore.top == rect.top) {\n          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n          if (rectAfter.top != rect.top)\n            { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }\n        }\n      }\n      return rect\n    } else {\n      var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n      if (side < 0 && !offset) { to++; takeSide = -1; }\n      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }\n      else if (side < 0) { from--; }\n      else { to ++; }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)\n    }\n  }\n\n  // Return a horizontal line in block context\n  if (!view.state.doc.resolve(pos).parent.inlineContent) {\n    if (offset && (side < 0 || offset == nodeSize(node))) {\n      var before = node.childNodes[offset - 1];\n      if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }\n    }\n    if (offset < nodeSize(node)) {\n      var after = node.childNodes[offset];\n      if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0)\n  }\n\n  // Inline, not in text node (this is not Bidi-safe)\n  if (offset && (side < 0 || offset == nodeSize(node))) {\n    var before$1 = node.childNodes[offset - 1];\n    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))\n        // BR nodes tend to only return the rectangle before them.\n        // Only use them if they are the last element in their parent\n        : before$1.nodeType == 1 && (before$1.nodeName != \"BR\" || !before$1.nextSibling) ? before$1 : null;\n    if (target) { return flattenV(singleRect(target, 1), false) }\n  }\n  if (offset < nodeSize(node)) {\n    var after$1 = node.childNodes[offset];\n    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) { after$1 = after$1.nextSibling; }\n    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))\n        : after$1.nodeType == 1 ? after$1 : null;\n    if (target$1) { return flattenV(singleRect(target$1, -1), true) }\n  }\n  // All else failed, just try to get a rectangle for the target node\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) { return rect }\n  var x = left ? rect.left : rect.right;\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) { return rect }\n  var y = top ? rect.top : rect.bottom;\n  return {top: y, bottom: y, left: rect.left, right: rect.right}\n}\n\nfunction withFlushedState(view, state, f) {\n  var viewState = view.state, active = view.root.activeElement;\n  if (viewState != state) { view.updateState(state); }\n  if (active != view.dom) { view.focus(); }\n  try {\n    return f()\n  } finally {\n    if (viewState != state) { view.updateState(viewState); }\n    if (active != view.dom && active) { active.focus(); }\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  var sel = state.selection;\n  var $pos = dir == \"up\" ? sel.$from : sel.$to;\n  return withFlushedState(view, state, function () {\n    var ref = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n    var dom = ref.node;\n    for (;;) {\n      var nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest) { break }\n      if (nearest.node.isBlock) { dom = nearest.dom; break }\n      dom = nearest.dom.parentNode;\n    }\n    var coords = coordsAtPos(view, $pos.pos, 1);\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      var boxes = (void 0);\n      if (child.nodeType == 1) { boxes = child.getClientRects(); }\n      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }\n      else { continue }\n      for (var i = 0; i < boxes.length; i++) {\n        var box = boxes[i];\n        if (box.bottom > box.top + 1 &&\n            (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2\n             : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n          { return false }\n      }\n    }\n    return true\n  })\n}\n\nvar maybeRTL = /[\\u0590-\\u08ac]/;\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  if (!$head.parent.isTextblock) { return false }\n  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n  var sel = view.root.getSelection();\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    { return dir == \"left\" || dir == \"backward\" ? atStart : atEnd }\n\n  return withFlushedState(view, state, function () {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;\n    var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox\n    sel.modify(\"move\", dir, \"character\");\n    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset);\n    // Restore the previous selection\n    sel.removeAllRanges();\n    sel.addRange(oldRange);\n    if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }\n    return result\n  })\n}\n\nvar cachedState = null, cachedDir = null, cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) { return cachedResult }\n  cachedState = state; cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Mark views only support `dom` and `contentDOM`, and don't support\n// any of the node view methods.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), an array\n//   of active decorations around the node (which are automatically\n//   drawn, and the node view may ignore if it isn't interested in\n//   them), and a [decoration source](#view.DecorationSource) that\n//   represents any decorations that apply to the content of the node\n//   (which again may be ignored). It should return true if it was\n//   able to update to that node, and false otherwise. If the node\n//   view has a `contentDOM` property (or no `dom` property), updating\n//   its child nodes will be handled by ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   or a selection change happens within the view. When the change is\n//   a selection change, the record will have a `type` property of\n//   `\"selection\"` (which doesn't occur for native mutation records).\n//   Return false if the editor should re-read the selection or\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed. (Not available for marks.)\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nvar NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nvar ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {\n  this.parent = parent;\n  this.children = children;\n  this.dom = dom;\n  // An expando property on the DOM node provides a link back to its\n  // description.\n  dom.pmViewDesc = this;\n  // This is the node that holds the child views. It may be null for\n  // descs that don't have children.\n  this.contentDOM = contentDOM;\n  this.dirty = NOT_DIRTY;\n};\n\nvar prototypeAccessors = { size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true },ignoreForCoords: { configurable: true } };\n\n// Used to check whether a given description corresponds to a\n// widget/mark/node.\nViewDesc.prototype.matchesWidget = function matchesWidget () { return false };\nViewDesc.prototype.matchesMark = function matchesMark () { return false };\nViewDesc.prototype.matchesNode = function matchesNode () { return false };\nViewDesc.prototype.matchesHack = function matchesHack (_nodeName) { return false };\n\n// : () → ?ParseRule\n// When parsing in-editor content (in domchange.js), we allow\n// descriptions to determine the parse rules that should be used to\n// parse them.\nViewDesc.prototype.parseRule = function parseRule () { return null };\n\n// : (dom.Event) → bool\n// Used by the editor's event handler to ignore events that come\n// from certain descs.\nViewDesc.prototype.stopEvent = function stopEvent () { return false };\n\n// The size of the content represented by this desc.\nprototypeAccessors.size.get = function () {\n  var size = 0;\n  for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }\n  return size\n};\n\n// For block nodes, this represents the space taken up by their\n// start/end tokens.\nprototypeAccessors.border.get = function () { return 0 };\n\nViewDesc.prototype.destroy = function destroy () {\n  this.parent = null;\n  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }\n  for (var i = 0; i < this.children.length; i++)\n    { this.children[i].destroy(); }\n};\n\nViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {\n  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n    var cur = this.children[i];\n    if (cur == child) { return pos }\n    pos += cur.size;\n  }\n};\n\nprototypeAccessors.posBefore.get = function () {\n  return this.parent.posBeforeChild(this)\n};\n\nprototypeAccessors.posAtStart.get = function () {\n  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n};\n\nprototypeAccessors.posAfter.get = function () {\n  return this.posBefore + this.size\n};\n\nprototypeAccessors.posAtEnd.get = function () {\n  return this.posAtStart + this.size - 2 * this.border\n};\n\n// : (dom.Node, number, ?number) → number\nViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n  // If the DOM position is in the content, use the child desc after\n  // it to figure out a position.\n  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n    if (bias < 0) {\n      var domBefore, desc;\n      if (dom == this.contentDOM) {\n        domBefore = dom.childNodes[offset - 1];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domBefore = dom.previousSibling;\n      }\n      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }\n      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n    } else {\n      var domAfter, desc$1;\n      if (dom == this.contentDOM) {\n        domAfter = dom.childNodes[offset];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domAfter = dom.nextSibling;\n      }\n      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }\n      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd\n    }\n  }\n  // Otherwise, use various heuristics, falling back on the bias\n  // parameter, to determine whether to return the position at the\n  // start or at the end of this view desc.\n  var atEnd;\n  if (dom == this.dom && this.contentDOM) {\n    atEnd = offset > domIndex(this.contentDOM);\n  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n  } else if (this.dom.firstChild) {\n    if (offset == 0) { for (var search = dom;; search = search.parentNode) {\n      if (search == this.dom) { atEnd = false; break }\n      if (search.parentNode.firstChild != search) { break }\n    } }\n    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {\n      if (search$1 == this.dom) { atEnd = true; break }\n      if (search$1.parentNode.lastChild != search$1) { break }\n    } }\n  }\n  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n};\n\n// Scan up the dom finding the first desc that is a descendant of\n// this one.\nViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {\n  for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n    var desc = this.getDesc(cur);\n    if (desc && (!onlyNodes || desc.node)) {\n      // If dom is outside of this desc's nodeDOM, don't count it.\n      if (first && desc.nodeDOM &&\n          !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))\n        { first = false; }\n      else\n        { return desc }\n    }\n  }\n};\n\nViewDesc.prototype.getDesc = function getDesc (dom) {\n  var desc = dom.pmViewDesc;\n  for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }\n};\n\nViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {\n  for (var scan = dom; scan; scan = scan.parentNode) {\n    var desc = this.getDesc(scan);\n    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }\n  }\n  return -1\n};\n\n// : (number) → ?NodeViewDesc\n// Find the desc for the node after the given pos, if any. (When a\n// parent node overrode rendering, there might not be one.)\nViewDesc.prototype.descAt = function descAt (pos) {\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (offset == pos && end != offset) {\n      while (!child.border && child.children.length) { child = child.children[0]; }\n      return child\n    }\n    if (pos < end) { return child.descAt(pos - offset - child.border) }\n    offset = end;\n  }\n};\n\n// : (number, number) → {node: dom.Node, offset: number}\nViewDesc.prototype.domFromPos = function domFromPos (pos, side) {\n  if (!this.contentDOM) { return {node: this.dom, offset: 0} }\n  // First find the position in the child array\n  var i = 0, offset = 0;\n  for (var curPos = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = curPos + child.size;\n    if (end > pos || child instanceof TrailingHackViewDesc) { offset = pos - curPos; break }\n    curPos = end;\n  }\n  // If this points into the middle of a child, call through\n  if (offset) { return this.children[i].domFromPos(offset - this.children[i].border, side) }\n  // Go back if there were any zero-length widgets with side >= 0 before this point\n  for (var prev = (void 0); i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {}\n  // Scan towards the first useable node\n  if (side <= 0) {\n    var prev$1, enter = true;\n    for (;; i--, enter = false) {\n      prev$1 = i ? this.children[i - 1] : null;\n      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) { break }\n    }\n    if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) { return prev$1.domFromPos(prev$1.size, side) }\n    return {node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0}\n  } else {\n    var next, enter$1 = true;\n    for (;; i++, enter$1 = false) {\n      next = i < this.children.length ? this.children[i] : null;\n      if (!next || next.dom.parentNode == this.contentDOM) { break }\n    }\n    if (next && enter$1 && !next.border && !next.domAtom) { return next.domFromPos(0, side) }\n    return {node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length}\n  }\n};\n\n// Used to find a DOM range in a single parent for a given changed\n// range.\nViewDesc.prototype.parseRange = function parseRange (from, to, base) {\n    if ( base === void 0 ) base = 0;\n\n  if (this.children.length == 0)\n    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }\n\n  var fromOffset = -1, toOffset = -1;\n  for (var offset = base, i = 0;; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (fromOffset == -1 && from <= end) {\n      var childBase = offset + child.border;\n      // FIXME maybe descend mark views to parse a narrower range?\n      if (from >= childBase && to <= end - child.border && child.node &&\n          child.contentDOM && this.contentDOM.contains(child.contentDOM))\n        { return child.parseRange(from, to, childBase) }\n\n      from = offset;\n      for (var j = i; j > 0; j--) {\n        var prev = this.children[j - 1];\n        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n          fromOffset = domIndex(prev.dom) + 1;\n          break\n        }\n        from -= prev.size;\n      }\n      if (fromOffset == -1) { fromOffset = 0; }\n    }\n    if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n      to = end;\n      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {\n        var next = this.children[j$1];\n        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n          toOffset = domIndex(next.dom);\n          break\n        }\n        to += next.size;\n      }\n      if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }\n      break\n    }\n    offset = end;\n  }\n  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}\n};\n\nViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {\n  if (this.border || !this.contentDOM || !this.children.length) { return false }\n  var child = this.children[side < 0 ? 0 : this.children.length - 1];\n  return child.size == 0 || child.emptyChildAt(side)\n};\n\n// : (number) → dom.Node\nViewDesc.prototype.domAfterPos = function domAfterPos (pos) {\n  var ref = this.domFromPos(pos, 0);\n    var node = ref.node;\n    var offset = ref.offset;\n  if (node.nodeType != 1 || offset == node.childNodes.length)\n    { throw new RangeError(\"No node after pos \" + pos) }\n  return node.childNodes[offset]\n};\n\n// : (number, number, dom.Document)\n// View descs are responsible for setting any selection that falls\n// entirely inside of them, so that custom implementations can do\n// custom things with the selection. Note that this falls apart when\n// a selection starts in such a node and ends in another, in which\n// case we just use whatever domFromPos produces as a best effort.\nViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n  // If the selection falls entirely in a child, give it to that child\n  var from = Math.min(anchor, head), to = Math.max(anchor, head);\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (from > offset && to < end)\n      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }\n    offset = end;\n  }\n\n  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n  var domSel = root.getSelection();\n\n  var brKludge = false;\n  // On Firefox, using Selection.collapse to put the cursor after a\n  // BR node for some reason doesn't always work (#1073). On Safari,\n  // the cursor sometimes inexplicable visually lags behind its\n  // reported position in such situations (#1092).\n  if ((result.gecko || result.safari) && anchor == head) {\n    var node = anchorDOM.node;\n      var offset$1 = anchorDOM.offset;\n    if (node.nodeType == 3) {\n      brKludge = offset$1 && node.nodeValue[offset$1 - 1] == \"\\n\";\n      // Issue #1128\n      if (brKludge && offset$1 == node.nodeValue.length) {\n        for (var scan = node, after = (void 0); scan; scan = scan.parentNode) {\n          if (after = scan.nextSibling) {\n            if (after.nodeName == \"BR\")\n              { anchorDOM = headDOM = {node: after.parentNode, offset: domIndex(after) + 1}; }\n            break\n          }\n          var desc = scan.pmViewDesc;\n          if (desc && desc.node && desc.node.isBlock) { break }\n        }\n      }\n    } else {\n      var prev = node.childNodes[offset$1 - 1];\n      brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n    }\n  }\n  // Firefox can act strangely when the selection is in front of an\n  // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];\n    if (after$1 && after$1.contentEditable == \"false\") { force = true; }\n  }\n\n  if (!(force || brKludge && result.safari) &&\n      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n    { return }\n\n  // Selection.extend can be used to create an 'inverted' selection\n  // (one where the focus is before the anchor), but not all\n  // browsers support it yet.\n  var domSelExtended = false;\n  if ((domSel.extend || anchor == head) && !brKludge) {\n    domSel.collapse(anchorDOM.node, anchorDOM.offset);\n    try {\n      if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }\n      domSelExtended = true;\n    } catch (err) {\n      // In some cases with Chrome the selection is empty after calling\n      // collapse, even when it should be valid. This appears to be a bug, but\n      // it is difficult to isolate. If this happens fallback to the old path\n      // without using extend.\n      if (!(err instanceof DOMException)) { throw err }\n      // declare global: DOMException\n    }\n  }\n  if (!domSelExtended) {\n    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }\n    var range = document.createRange();\n    range.setEnd(headDOM.node, headDOM.offset);\n    range.setStart(anchorDOM.node, anchorDOM.offset);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n  }\n};\n\n// : (dom.MutationRecord) → bool\nViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n  return !this.contentDOM && mutation.type != \"selection\"\n};\n\nprototypeAccessors.contentLost.get = function () {\n  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n};\n\n// Remove a subtree of the element tree that has been touched\n// by a DOM change, so that the next update will redraw it.\nViewDesc.prototype.markDirty = function markDirty (from, to) {\n  for (var offset = 0, i = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n      var startInside = offset + child.border, endInside = end - child.border;\n      if (from >= startInside && to <= endInside) {\n        this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (from == startInside && to == endInside &&\n            (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }\n        else { child.markDirty(from - startInside, to - startInside); }\n        return\n      } else {\n        child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n          ? CONTENT_DIRTY : NODE_DIRTY;\n      }\n    }\n    offset = end;\n  }\n  this.dirty = CONTENT_DIRTY;\n};\n\nViewDesc.prototype.markParentsDirty = function markParentsDirty () {\n  var level = 1;\n  for (var node = this.parent; node; node = node.parent, level++) {\n    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n    if (node.dirty < dirty) { node.dirty = dirty; }\n  }\n};\n\nprototypeAccessors.domAtom.get = function () { return false };\n\nprototypeAccessors.ignoreForCoords.get = function () { return false };\n\nObject.defineProperties( ViewDesc.prototype, prototypeAccessors );\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nvar nothing = [];\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nvar WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function WidgetViewDesc(parent, widget, view, pos) {\n    var self, dom = widget.type.toDOM;\n    if (typeof dom == \"function\") { dom = dom(view, function () {\n      if (!self) { return pos }\n      if (self.parent) { return self.parent.posBeforeChild(self) }\n    }); }\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        var wrap = document.createElement(\"span\");\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n      dom.contentEditable = false;\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n    ViewDesc.call(this, parent, nothing, dom, null);\n    this.widget = widget;\n    self = this;\n  }\n\n  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;\n  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  WidgetViewDesc.prototype.constructor = WidgetViewDesc;\n\n  var prototypeAccessors$1 = { domAtom: { configurable: true } };\n\n  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  };\n\n  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n\n  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {\n    var stop = this.widget.spec.stopEvent;\n    return stop ? stop(event) : false\n  };\n\n  WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection\n  };\n\n  WidgetViewDesc.prototype.destroy = function destroy () {\n    this.widget.type.destroy(this.dom);\n    ViewDesc.prototype.destroy.call(this);\n  };\n\n  prototypeAccessors$1.domAtom.get = function () { return true };\n\n  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );\n\n  return WidgetViewDesc;\n}(ViewDesc));\n\nvar CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function CompositionViewDesc(parent, dom, textDOM, text) {\n    ViewDesc.call(this, parent, nothing, dom, null);\n    this.textDOM = textDOM;\n    this.text = text;\n  }\n\n  if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;\n  CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  CompositionViewDesc.prototype.constructor = CompositionViewDesc;\n\n  var prototypeAccessors$2 = { size: { configurable: true } };\n\n  prototypeAccessors$2.size.get = function () { return this.text.length };\n\n  CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {\n    if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }\n    return this.posAtStart + offset\n  };\n\n  CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    return {node: this.textDOM, offset: pos}\n  };\n\n  CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {\n    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue\n   };\n\n  Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );\n\n  return CompositionViewDesc;\n}(ViewDesc));\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nvar MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function MarkViewDesc(parent, mark, dom, contentDOM) {\n    ViewDesc.call(this, parent, [], dom, contentDOM);\n    this.mark = mark;\n  }\n\n  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;\n  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  MarkViewDesc.prototype.constructor = MarkViewDesc;\n\n  MarkViewDesc.create = function create (parent, mark, inline, view) {\n    var custom = view.nodeViews[mark.type.name];\n    var spec = custom && custom(mark, view, inline);\n    if (!spec || !spec.dom)\n      { spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  };\n\n  MarkViewDesc.prototype.parseRule = function parseRule () {\n    if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView) { return null }\n    return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM}\n  };\n\n  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };\n\n  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {\n    ViewDesc.prototype.markDirty.call(this, from, to);\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      var parent = this.parent;\n      while (!parent.node) { parent = parent.parent; }\n      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }\n      this.dirty = NOT_DIRTY;\n    }\n  };\n\n  MarkViewDesc.prototype.slice = function slice (from, to, view) {\n    var copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n    var nodes = this.children, size = this.size;\n    if (to < size) { nodes = replaceNodes(nodes, to, size, view); }\n    if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }\n    for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }\n    copy.children = nodes;\n    return copy\n  };\n\n  return MarkViewDesc;\n}(ViewDesc));\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nvar NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);\n    this.nodeDOM = nodeDOM;\n    this.node = node;\n    this.outerDeco = outerDeco;\n    this.innerDeco = innerDeco;\n    if (contentDOM) { this.updateChildren(view, pos); }\n  }\n\n  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;\n  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  NodeViewDesc.prototype.constructor = NodeViewDesc;\n\n  var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {\n    var assign;\n\n    var custom = view.nodeViews[node.type.name], descObj;\n    var spec = custom && custom(node, view, function () {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) { return pos }\n      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }\n    }, outerDeco, innerDeco);\n\n    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n    if (node.isText) {\n      if (!dom) { dom = document.createTextNode(node.text); }\n      else if (dom.nodeType != 3) { throw new RangeError(\"Text must be rendered as a DOM text node\") }\n    } else if (!dom) {\n((assign = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      if (!dom.hasAttribute(\"contenteditable\")) { dom.contentEditable = false; }\n      if (node.type.spec.draggable) { dom.draggable = true; }\n    }\n\n    var nodeDOM = dom;\n    dom = applyOuterDeco(dom, outerDeco, node);\n\n    if (spec)\n      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,\n                                              spec, view, pos + 1) }\n    else if (node.isText)\n      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }\n    else\n      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }\n  };\n\n  NodeViewDesc.prototype.parseRule = function parseRule () {\n    var this$1 = this;\n\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) { return null }\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    var rule = {node: this.node.type.name, attrs: this.node.attrs};\n    if (this.node.type.whitespace == \"pre\") { rule.preserveWhitespace = \"full\"; }\n    if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }\n    else { rule.getContent = function () { return this$1.contentDOM ? Fragment.empty : this$1.node.content; }; }\n    return rule\n  };\n\n  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  };\n\n  prototypeAccessors$3.size.get = function () { return this.node.nodeSize };\n\n  prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {\n    var this$1 = this;\n\n    var inline = this.node.inlineContent, off = pos;\n    var composition = view.composing && this.localCompositionInfo(view, pos);\n    var localComposition = composition && composition.pos > -1 ? composition : null;\n    var compositionInChild = composition && composition.pos < 0;\n    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);\n    iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {\n      if (widget.spec.marks)\n        { updater.syncToMarks(widget.spec.marks, inline, view); }\n      else if (widget.type.side >= 0 && !insideNode)\n        { updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline, view); }\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, off);\n    }, function (child, outerDeco, innerDeco, i) {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view);\n      // Try several strategies for drawing this node\n      var compIndex;\n      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ; else if (compositionInChild && view.state.selection.from > off &&\n                 view.state.selection.to < off + child.nodeSize &&\n                 (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                 updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ; else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ; else {\n        // Add it as a new view\n        updater.addNode(child, outerDeco, innerDeco, view, off);\n      }\n      off += child.nodeSize;\n    });\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view);\n    if (this.node.isTextblock) { updater.addTextblockHacks(); }\n    updater.destroyRest();\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      // May have to protect focused DOM from being changed if a composition is active\n      if (localComposition) { this.protectLocalComposition(view, localComposition); }\n      renderDescs(this.contentDOM, this.children, view);\n      if (result.ios) { iosHacks(this.dom); }\n    }\n  };\n\n  NodeViewDesc.prototype.localCompositionInfo = function localCompositionInfo (view, pos) {\n    // Only do something if both the selection and a focused text node\n    // are inside of this node\n    var ref = view.state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) { return }\n    var sel = view.root.getSelection();\n    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode || !this.dom.contains(textNode.parentNode)) { return }\n\n    if (this.node.inlineContent) {\n      // Find the text in the focused node in the node, stop if it's not\n      // there (may have been modified through other means, in which\n      // case it should overwritten)\n      var text = textNode.nodeValue;\n      var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n      return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}\n    } else {\n      return {node: textNode, pos: -1}\n    }\n  };\n\n  NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {\n    var node = ref.node;\n    var pos = ref.pos;\n    var text = ref.text;\n\n    // The node is already part of a local view desc, leave it there\n    if (this.getDesc(node)) { return }\n\n    // Create a composition view for the orphaned nodes\n    var topNode = node;\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM) { break }\n      while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }\n      while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }\n      if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }\n    }\n    var desc = new CompositionViewDesc(this, topNode, node, text);\n    view.compositionNodes.push(desc);\n\n    // Patch up this.children to contain the composition view\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n  };\n\n  // : (Node, [Decoration], DecorationSource, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateInner(node, outerDeco, innerDeco, view);\n    return true\n  };\n\n  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco);\n    this.node = node;\n    this.innerDeco = innerDeco;\n    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }\n    this.dirty = NOT_DIRTY;\n  };\n\n  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }\n    var needsWrap = this.nodeDOM.nodeType != 1;\n    var oldDOM = this.dom;\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap));\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null;\n      this.dom.pmViewDesc = this;\n    }\n    this.outerDeco = outerDeco;\n  };\n\n  // Mark this node as being the selected node.\n  NodeViewDesc.prototype.selectNode = function selectNode () {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }\n  };\n\n  // Remove selected node marking from this node.\n  NodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute(\"draggable\"); }\n  };\n\n  prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };\n\n  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );\n\n  return NodeViewDesc;\n}(ViewDesc));\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc);\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nvar TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {\n  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);\n  }\n\n  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;\n  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  TextViewDesc.prototype.constructor = TextViewDesc;\n\n  var prototypeAccessors$4 = { domAtom: { configurable: true } };\n\n  TextViewDesc.prototype.parseRule = function parseRule () {\n    var skip = this.nodeDOM.parentNode;\n    while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }\n    return {skip: skip || true}\n  };\n\n  TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateOuterDeco(outerDeco);\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text;\n      if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }\n    }\n    this.node = node;\n    this.dirty = NOT_DIRTY;\n    return true\n  };\n\n  TextViewDesc.prototype.inParent = function inParent () {\n    var parentDOM = this.parent.contentDOM;\n    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }\n    return false\n  };\n\n  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    return {node: this.nodeDOM, offset: pos}\n  };\n\n  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }\n    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)\n  };\n\n  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\"\n  };\n\n  TextViewDesc.prototype.slice = function slice (from, to, view) {\n    var node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)\n  };\n\n  TextViewDesc.prototype.markDirty = function markDirty (from, to) {\n    NodeViewDesc.prototype.markDirty.call(this, from, to);\n    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n      { this.dirty = NODE_DIRTY; }\n  };\n\n  prototypeAccessors$4.domAtom.get = function () { return false };\n\n  Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );\n\n  return TextViewDesc;\n}(NodeViewDesc));\n\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nvar TrailingHackViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function TrailingHackViewDesc () {\n    ViewDesc.apply(this, arguments);\n  }\n\n  if ( ViewDesc ) TrailingHackViewDesc.__proto__ = ViewDesc;\n  TrailingHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  TrailingHackViewDesc.prototype.constructor = TrailingHackViewDesc;\n\n  var prototypeAccessors$5 = { domAtom: { configurable: true },ignoreForCoords: { configurable: true } };\n\n  TrailingHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n  TrailingHackViewDesc.prototype.matchesHack = function matchesHack (nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName };\n  prototypeAccessors$5.domAtom.get = function () { return true };\n  prototypeAccessors$5.ignoreForCoords.get = function () { return this.dom.nodeName == \"IMG\" };\n\n  Object.defineProperties( TrailingHackViewDesc.prototype, prototypeAccessors$5 );\n\n  return TrailingHackViewDesc;\n}(ViewDesc));\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nvar CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {\n  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n    this.spec = spec;\n  }\n\n  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;\n  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) { return false }\n    if (this.spec.update) {\n      var result = this.spec.update(node, outerDeco, innerDeco);\n      if (result) { this.updateInner(node, outerDeco, innerDeco, view); }\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)\n    }\n  };\n\n  CustomNodeViewDesc.prototype.selectNode = function selectNode () {\n    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);\n  };\n\n  CustomNodeViewDesc.prototype.destroy = function destroy () {\n    if (this.spec.destroy) { this.spec.destroy(); }\n    NodeViewDesc.prototype.destroy.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  };\n\n  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)\n  };\n\n  return CustomNodeViewDesc;\n}(NodeViewDesc));\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n  var dom = parentDOM.firstChild, written = false;\n  for (var i = 0; i < descs.length; i++) {\n    var desc = descs[i], childDOM = desc.dom;\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); written = true; }\n      dom = dom.nextSibling;\n    } else {\n      written = true;\n      parentDOM.insertBefore(childDOM, dom);\n    }\n    if (desc instanceof MarkViewDesc) {\n      var pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children, view);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n  while (dom) { dom = rm(dom); written = true; }\n  if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) { this.nodeName = nodeName; }\n}\nOuterDecoLevel.prototype = Object.create(null);\n\nvar noDeco = [new OuterDecoLevel];\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) { return noDeco }\n\n  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n\n  for (var i = 0; i < outerDeco.length; i++) {\n    var attrs = outerDeco[i].type.attrs;\n    if (!attrs) { continue }\n    if (attrs.nodeName)\n      { result.push(top = new OuterDecoLevel(attrs.nodeName)); }\n\n    for (var name in attrs) {\n      var val = attrs[name];\n      if (val == null) { continue }\n      if (needsWrap && result.length == 1)\n        { result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\")); }\n      if (name == \"class\") { top.class = (top.class ? top.class + \" \" : \"\") + val; }\n      else if (name == \"style\") { top.style = (top.style ? top.style + \";\" : \"\") + val; }\n      else if (name != \"nodeName\") { top[name] = val; }\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }\n\n  var curDOM = nodeDOM;\n  for (var i = 0; i < curComputed.length; i++) {\n    var deco = curComputed[i], prev = prevComputed[i];\n    if (i) {\n      var parent = (void 0);\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.pmIsDeco = true;\n        parent.appendChild(curDOM);\n        prev = noDeco[0];\n        curDOM = parent;\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (var name in prev)\n    { if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      { dom.removeAttribute(name); } }\n  for (var name$1 in cur)\n    { if (name$1 != \"class\" && name$1 != \"style\" && name$1 != \"nodeName\" && cur[name$1] != prev[name$1])\n      { dom.setAttribute(name$1, cur[name$1]); } }\n  if (prev.class != cur.class) {\n    var prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : nothing;\n    var curList = cur.class ? cur.class.split(\" \").filter(Boolean) : nothing;\n    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)\n      { dom.classList.remove(prevList[i]); } }\n    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)\n      { dom.classList.add(curList[i$1]); } }\n    if (dom.classList.length == 0)\n      { dom.removeAttribute(\"class\"); }\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      var prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n      while (m = prop.exec(prev.style))\n        { dom.style.removeProperty(m[1]); }\n    }\n    if (cur.style)\n      { dom.style.cssText += cur.style; }\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nvar ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {\n  this.top = top;\n  this.lock = lockedNode;\n  // Index into `this.top`'s child array, represents the current\n  // update position.\n  this.index = 0;\n  // When entering a mark, the current top and index are pushed\n  // onto this.\n  this.stack = [];\n  // Tracks whether anything was changed\n  this.changed = false;\n\n  this.preMatch = preMatch(top.node.content, top);\n};\n\n// Destroy and remove the children between the given indices in\n// `this.top`.\nViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {\n  if (start == end) { return }\n  for (var i = start; i < end; i++) { this.top.children[i].destroy(); }\n  this.top.children.splice(start, end - start);\n  this.changed = true;\n};\n\n// Destroy all remaining children in `this.top`.\nViewTreeUpdater.prototype.destroyRest = function destroyRest () {\n  this.destroyBetween(this.index, this.top.children.length);\n};\n\n// : ([Mark], EditorView)\n// Sync the current stack of mark descs with the given array of\n// marks, reusing existing mark descs when possible.\nViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {\n  var keep = 0, depth = this.stack.length >> 1;\n  var maxKeep = Math.min(depth, marks.length);\n  while (keep < maxKeep &&\n         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n    { keep++; }\n\n  while (keep < depth) {\n    this.destroyRest();\n    this.top.dirty = NOT_DIRTY;\n    this.index = this.stack.pop();\n    this.top = this.stack.pop();\n    depth--;\n  }\n  while (depth < marks.length) {\n    this.stack.push(this.top, this.index + 1);\n    var found = -1;\n    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n      if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }\n    }\n    if (found > -1) {\n      if (found > this.index) {\n        this.changed = true;\n        this.destroyBetween(this.index, found);\n      }\n      this.top = this.top.children[this.index];\n    } else {\n      var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n      this.top.children.splice(this.index, 0, markDesc);\n      this.top = markDesc;\n      this.changed = true;\n    }\n    this.index = 0;\n    depth++;\n  }\n};\n\n// : (Node, [Decoration], DecorationSource) → bool\n// Try to find a node desc matching the given data. Skip over it and\n// return true when successful.\nViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {\n  var found = -1, targetDesc;\n  if (index >= this.preMatch.index &&\n      (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n      targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n    found = this.top.children.indexOf(targetDesc, this.index);\n  } else {\n    for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n      var child = this.top.children[i];\n      if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n        found = i;\n        break\n      }\n    }\n  }\n  if (found < 0) { return false }\n  this.destroyBetween(this.index, found);\n  this.index++;\n  return true\n};\n\nViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt (node, outerDeco, innerDeco, index, view) {\n  var child = this.top.children[index];\n  if (!child.update(node, outerDeco, innerDeco, view)) { return false }\n  this.destroyBetween(this.index, index);\n  this.index = index + 1;\n  return true\n};\n\nViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild (domNode) {\n  for (;;) {\n    var parent = domNode.parentNode;\n    if (!parent) { return -1 }\n    if (parent == this.top.contentDOM) {\n      var desc = domNode.pmViewDesc;\n      if (desc) { for (var i = this.index; i < this.top.children.length; i++) {\n        if (this.top.children[i] == desc) { return i }\n      } }\n      return -1\n    }\n    domNode = parent;\n  }\n};\n\n// : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool\n// Try to update the next node, if any, to the given data. Checks\n// pre-matches to avoid overwriting nodes that could still be used.\nViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {\n  for (var i = this.index; i < this.top.children.length; i++) {\n    var next = this.top.children[i];\n    if (next instanceof NodeViewDesc) {\n      var preMatch = this.preMatch.matched.get(next);\n      if (preMatch != null && preMatch != index) { return false }\n      var nextDOM = next.dom;\n\n      // Can't update if nextDOM is or contains this.lock, except if\n      // it's a text node whose content already matches the new text\n      // and whose decorations match the new ones.\n      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&\n          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n      if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n        this.destroyBetween(this.index, i);\n        if (next.dom != nextDOM) { this.changed = true; }\n        this.index++;\n        return true\n      }\n      break\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSource, EditorView)\n// Insert the node as a newly created node desc.\nViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {\n  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));\n  this.changed = true;\n};\n\nViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {\n  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n  if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n    this.index++;\n  } else {\n    var desc = new WidgetViewDesc(this.top, widget, view, pos);\n    this.top.children.splice(this.index++, 0, desc);\n    this.changed = true;\n  }\n};\n\n// Make sure a textblock looks and behaves correctly in\n// contentEditable.\nViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {\n  var lastChild = this.top.children[this.index - 1];\n  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }\n\n  if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) ||\n      /\\n$/.test(lastChild.node.text)) {\n    // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n      { this.addHackNode(\"IMG\"); }\n    this.addHackNode(\"BR\");\n  }\n};\n\nViewTreeUpdater.prototype.addHackNode = function addHackNode (nodeName) {\n  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {\n    this.index++;\n  } else {\n    var dom = document.createElement(nodeName);\n    if (nodeName == \"IMG\") {\n      dom.className = \"ProseMirror-separator\";\n      dom.alt = \"\";\n    }\n    if (nodeName == \"BR\") { dom.className = \"ProseMirror-trailingBreak\"; }\n    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));\n    this.changed = true;\n  }\n};\n\n// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>, matches: ViewDesc[]}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n  var curDesc = parentDesc, descI = curDesc.children.length;\n  var fI = frag.childCount, matched = new Map, matches = [];\n  outer: while (fI > 0) {\n    var desc = (void 0);\n    for (;;) {\n      if (descI) {\n        var next = curDesc.children[descI - 1];\n        if (next instanceof MarkViewDesc) {\n          curDesc = next;\n          descI = next.children.length;\n        } else {\n          desc = next;\n          descI--;\n          break\n        }\n      } else if (curDesc == parentDesc) {\n        break outer\n      } else {\n        // FIXME\n        descI = curDesc.parent.children.indexOf(curDesc);\n        curDesc = curDesc.parent;\n      }\n    }\n    var node = desc.node;\n    if (!node) { continue }\n    if (node != frag.child(fI - 1)) { break }\n    --fI;\n    matched.set(desc, fI);\n    matches.push(desc);\n  }\n  return {index: fI, matched: matched, matches: matches.reverse()}\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  var locals = deco.locals(parent), offset = 0;\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (var i = 0; i < parent.childCount; i++) {\n      var child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n    return\n  }\n\n  var decoIndex = 0, active = [], restNode = null;\n  for (var parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      var widget = locals[decoIndex++], widgets = (void 0);\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }\n      if (widgets) {\n        widgets.sort(compareSide);\n        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }\n      } else {\n        onWidget(widget, parentIndex, !!restNode);\n      }\n    }\n\n    var child$1 = (void 0), index = (void 0);\n    if (restNode) {\n      index = -1;\n      child$1 = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex;\n      child$1 = parent.child(parentIndex++);\n    } else {\n      break\n    }\n\n    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      { active.push(locals[decoIndex++]); }\n\n    var end = offset + child$1.nodeSize;\n    if (child$1.isText) {\n      var cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }\n      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }\n      if (cutAt < end) {\n        restNode = child$1.cut(cutAt - offset);\n        child$1 = child$1.cut(0, cutAt - offset);\n        end = cutAt;\n        index = -1;\n      }\n    }\n\n    var outerDeco = !active.length ? nothing\n        : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })\n        : active.slice();\n    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);\n    offset = end;\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) { return node }\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        { return node.childNodes[offset] }\n      node = node.childNodes[offset - 1];\n      offset = nodeSize(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null\n    }\n  }\n}\n\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    var child = frag.child(i++), childStart = pos;\n    pos += child.nodeSize;\n    if (!child.isText) { continue }\n    var str = child.text;\n    while (i < frag.childCount) {\n      var next = frag.child(i++);\n      pos += next.nodeSize;\n      if (!next.isText) { break }\n      str += next.text;\n    }\n    if (pos >= from) {\n      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n      if (found >= 0 && found + text.length + childStart >= from)\n        { return childStart + found }\n      if (from == to && str.length >= (to + text.length) - childStart &&\n          str.slice(to - childStart, to - childStart + text.length) == text)\n        { return to }\n    }\n  }\n  return -1\n}\n\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  var result = [];\n  for (var i = 0, off = 0; i < nodes.length; i++) {\n    var child = nodes[i], start = off, end = off += child.size;\n    if (start >= to || end <= from) {\n      result.push(child);\n    } else {\n      if (start < from) { result.push(child.slice(0, from - start, view)); }\n      if (replacement) {\n        result.push(replacement);\n        replacement = null;\n      }\n      if (end > to) { result.push(child.slice(to - start, child.size, view)); }\n    }\n  }\n  return result\n}\n\nfunction selectionFromDOM(view, origin) {\n  var domSel = view.root.getSelection(), doc = view.state.doc;\n  if (!domSel.focusNode) { return null }\n  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n  if (head < 0) { return null }\n  var $head = doc.resolve(head), $anchor, selection;\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head;\n    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }\n    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent\n        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      var pos = nearestDesc.posBefore;\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));\n    }\n  } else {\n    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n    if (anchor < 0) { return null }\n    $anchor = doc.resolve(anchor);\n  }\n\n  if (!selection) {\n    var bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n    selection = selectionBetween(view, $anchor, $head, bias);\n  }\n  return selection\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() :\n    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)\n}\n\nfunction selectionToDOM(view, force) {\n  var sel = view.state.selection;\n  syncNodeSelection(view, sel);\n\n  if (!editorOwnsSelection(view)) { return }\n\n  // The delayed drag selection causes issues with Cell Selections\n  // in Safari. And the drag selection delay is to workarond issues\n  // which only present in Chrome.\n  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {\n    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;\n    if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset,\n                                                  curSel.anchorNode, curSel.anchorOffset)) {\n      view.mouseDown.delayedSelectionSync = true;\n      view.domObserver.setCurSelection();\n      return\n    }\n  }\n\n  view.domObserver.disconnectSelection();\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    var anchor = sel.anchor;\n    var head = sel.head;\n    var resetEditableFrom, resetEditableTo;\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        { resetEditableTo = temporarilyEditableNear(view, sel.to); }\n    }\n    view.docView.setSelection(anchor, head, view.root, force);\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) { resetEditable(resetEditableFrom); }\n      if (resetEditableTo) { resetEditable(resetEditableTo); }\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document) { removeClassOnSelectionChange(view); }\n    }\n  }\n\n  view.domObserver.setCurSelection();\n  view.domObserver.connectSelection();\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nvar brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;\n\nfunction temporarilyEditableNear(view, pos) {\n  var ref = view.docView.domFromPos(pos, 0);\n  var node = ref.node;\n  var offset = ref.offset;\n  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  var before = offset ? node.childNodes[offset - 1] : null;\n  if (result.safari && after && after.contentEditable == \"false\") { return setEditable(after) }\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) { return setEditable(after) }\n    else if (before) { return setEditable(before) }\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\";\n  if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }\n  return element\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\";\n  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  var doc = view.dom.ownerDocument;\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n  var domSel = view.root.getSelection();\n  var node = domSel.anchorNode, offset = domSel.anchorOffset;\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = function () {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n      setTimeout(function () {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          { view.dom.classList.remove(\"ProseMirror-hideselection\"); }\n      }, 20);\n    }\n  });\n}\n\nfunction selectCursorWrapper(view) {\n  var domSel = view.root.getSelection(), range = document.createRange();\n  var node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n  if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }\n  else { range.setEnd(node, 0); }\n  range.collapse(false);\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\n\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    var desc = view.docView.descAt(sel.from);\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc) { desc.selectNode(); }\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      { view.lastSelectedViewDesc.deselectNode(); }\n    view.lastSelectedViewDesc = null;\n  }\n}\n\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", function (f) { return f(view, $anchor, $head); })\n    || TextSelection.between($anchor, $head, bias)\n}\n\nfunction hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) { return false }\n  return hasSelection(view)\n}\n\nfunction hasSelection(view) {\n  var sel = view.root.getSelection();\n  if (!sel.anchorNode) { return false }\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nfunction anchorInRightPlace(view) {\n  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n  var domSel = view.root.getSelection();\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)\n}\n\nfunction moveSelectionBlock(state, dir) {\n  var ref = state.selection;\n  var $anchor = ref.$anchor;\n  var $head = ref.$head;\n  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  var sel = view.state.selection;\n  if (sel instanceof TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      var next = moveSelectionBlock(view.state, dir);\n      if (next && (next instanceof NodeSelection)) { return apply(view, next) }\n      return false\n    } else if (!(result.mac && mods.indexOf(\"m\") > -1)) {\n      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n      if (!node || node.isText) { return false }\n      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))\n      } else if (result.webkit) {\n        // Chrome and Safari will introduce extra pointless cursor\n        // positions around inline uneditable nodes, so we have to\n        // take over and move the cursor past them (#937)\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))\n      } else {\n        return false\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    var next$1 = moveSelectionBlock(view.state, dir);\n    if (next$1) { return apply(view, next$1) }\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var moveNode, moveOffset, force = false;\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break\n      } else {\n        var before = node.childNodes[offset - 1];\n        if (isIgnorable(before)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else { break }\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var prev = node.previousSibling;\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n  if (force) { setSelFocus(view, sel, node, offset); }\n  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var len = nodeLen(node);\n  var moveNode, moveOffset;\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) { break }\n      var after = node.childNodes[offset];\n      if (isIgnorable(after)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      }\n      else { break }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var next = node.nextSibling;\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\nfunction isBlockNode(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    var range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n  view.domObserver.setCurSelection();\n  var state = view.state;\n  // If no state update ends up happening, reset the selection.\n  setTimeout(function () {\n    if (view.state == state) { selectionToDOM(view); }\n  }, 50);\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n  var sel = view.state.selection;\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) { return false }\n  if (result.mac && mods.indexOf(\"m\") > -1) { return false }\n  var $from = sel.$from;\n  var $to = sel.$to;\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    var next = moveSelectionBlock(view.state, dir);\n    if (next && (next instanceof NodeSelection))\n      { return apply(view, next) }\n  }\n  if (!$from.parent.inlineContent) {\n    var side = dir < 0 ? $from : $to;\n    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);\n    return beyond ? apply(view, beyond) : false\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection)) { return true }\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  var empty = ref.empty;\n  if (!$head.sameParent($anchor)) { return true }\n  if (!empty) { return false }\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) { return true }\n  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n  if (nextNode && !nextNode.isText) {\n    var tr = view.state.tr;\n    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }\n    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }\n    view.dispatch(tr);\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\n\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n  if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }\n  var ref = view.root.getSelection();\n  var focusNode = ref.focusNode;\n  var focusOffset = ref.focusOffset;\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    var child = focusNode.firstChild;\n    switchEditable(view, child, true);\n    setTimeout(function () { return switchEditable(view, child, false); }, 20);\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  var result = \"\";\n  if (event.ctrlKey) { result += \"c\"; }\n  if (event.metaKey) { result += \"m\"; }\n  if (event.altKey) { result += \"a\"; }\n  if (event.shiftKey) { result += \"s\"; }\n  return result\n}\n\nfunction captureKeyDown(view, event) {\n  var code = event.keyCode, mods = getMods(event);\n  if (code == 8 || (result.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (result.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (mods == (result.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, from_, to_) {\n  var ref = view.docView.parseRange(from_, to_);\n  var parent = ref.node;\n  var fromOffset = ref.fromOffset;\n  var toOffset = ref.toOffset;\n  var from = ref.from;\n  var to = ref.to;\n\n  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}];\n    if (!selectionCollapsed(domSel))\n      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (result.chrome && view.lastKeyCode === 8) {\n    for (var off = toOffset; off > fromOffset; off--) {\n      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n      if (node.nodeName == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) { break }\n    }\n  }\n  var startDoc = view.state.doc;\n  var parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n  var $from = startDoc.resolve(from);\n\n  var sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode: ruleFromNode,\n    context: $from\n  });\n  if (find && find[0].pos != null) {\n    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;\n    if (head == null) { head = anchor$1; }\n    sel = {anchor: anchor$1 + from, head: head + from};\n  }\n  return {doc: doc, sel: sel, from: from, to: to}\n}\n\nfunction ruleFromNode(dom) {\n  var desc = dom.pmViewDesc;\n  if (desc) {\n    return desc.parseRule()\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    // Safari replaces the list item or table cell with a BR\n    // directly in the list node (?!) if you delete the last\n    // character in a list item or table cell (#708, #862)\n    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      var skip = document.createElement(\"div\");\n      skip.appendChild(document.createElement(\"li\"));\n      return {skip: skip}\n    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {ignore: true}\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {ignore: true}\n  }\n}\n\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;\n    var newSel = selectionFromDOM(view, origin);\n    if (newSel && !view.state.selection.eq(newSel)) {\n      var tr$1 = view.state.tr.setSelection(newSel);\n      if (origin == \"pointer\") { tr$1.setMeta(\"pointer\", true); }\n      else if (origin == \"key\") { tr$1.scrollIntoView(); }\n      view.dispatch(tr$1);\n    }\n    return\n  }\n\n  var $before = view.state.doc.resolve(from);\n  var shared = $before.sharedDepth(to);\n  from = $before.before(shared + 1);\n  to = view.state.doc.resolve(to).after(shared + 1);\n\n  var sel = view.state.selection;\n  var parse = parseBetween(view, from, to);\n\n  // Chrome sometimes leaves the cursor before the inserted text when\n  // composing after a cursor wrapper. This moves it forward.\n  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {\n    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;\n    var size = text && text.nodeValue ? text.nodeValue.length : 1;\n    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};\n  }\n\n  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n  var preferredPos, preferredSide;\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = view.state.selection.from;\n    preferredSide = \"start\";\n  }\n  view.lastKeyCode = null;\n\n  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {start: sel.from, endA: sel.to, endB: sel.to};\n    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) &&\n               addedNodes.some(function (n) { return n.nodeName == \"DIV\" || n.nodeName == \"P\"; }) &&\n               view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })) {\n      view.lastIOSEnter = 0;\n      return\n    } else {\n      if (parse.sel) {\n        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);\n        if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }\n      }\n      return\n    }\n  }\n  view.domChangeCount++;\n  // Handle the case where overwriting a selection by typing matches\n  // the start or end of the selected content, creating a change\n  // that's smaller than what was actually overwritten.\n  if (view.state.selection.from < view.state.selection.to &&\n      change.start == change.endB &&\n      view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&\n        view.state.selection.from >= parse.from) {\n      change.start = view.state.selection.from;\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&\n               view.state.selection.to <= parse.to) {\n      change.endB += (view.state.selection.to - change.endA);\n      change.endA = view.state.selection.to;\n    }\n  }\n\n  // IE11 will insert a non-breaking space _ahead_ of the space after\n  // the cursor space when adding a space before another space. When\n  // that happened, adjust the change to cover the space instead.\n  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&\n      change.endA == change.start && change.start > parse.from &&\n      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n    change.start--;\n    change.endA--;\n    change.endB--;\n  }\n\n  var $from = parse.doc.resolveNoCache(change.start - parse.from);\n  var $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;\n  var nextSel;\n  // If this looks like the effect of pressing Enter (or was recorded\n  // as being an iOS enter press), just dispatch an Enter key instead.\n  if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(function (n) { return n.nodeName == \"DIV\" || n.nodeName == \"P\"; }))) ||\n       (!inlineChange && $from.pos < parse.doc.content.size &&\n        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n        nextSel.head == $to.pos)) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })) {\n    view.lastIOSEnter = 0;\n    return\n  }\n  // Same for backspace\n  if (view.state.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); })) {\n    if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820\n    return\n  }\n\n  // Chrome Android will occasionally, during composition, delete the\n  // entire composition and then immediately insert it again. This is\n  // used to detect that situation.\n  if (result.chrome && result.android && change.toB == change.from)\n    { view.lastAndroidDelete = Date.now(); }\n\n  // This tries to detect Android virtual keyboard\n  // enter-and-pick-suggestion action. That sometimes (see issue\n  // #1059) first fires a DOM mutation, before moving the selection to\n  // the newly created block. And then, because ProseMirror cleans up\n  // the DOM selection, it gives up moving the selection entirely,\n  // leaving the cursor in the wrong place. When that happens, we drop\n  // the new paragraph from the initial change, and fire a simulated\n  // enter key afterwards.\n  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2;\n    $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    setTimeout(function () {\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n    }, 20);\n  }\n\n  var chFrom = change.start, chTo = change.endA;\n\n  var tr, storedMarks, markChange, $from1;\n  if (inlineChange) {\n    if ($from.pos == $to.pos) { // Deletion\n      // IE11 sometimes weirdly moves the DOM selection around after\n      // backspacing out the first element in a textblock\n      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates();\n        setTimeout(function () { return selectionToDOM(view); }, 20);\n      }\n      tr = view.state.tr.delete(chFrom, chTo);\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr;\n      if (markChange.type == \"add\") { tr.addMark(chFrom, chTo, markChange.mark); }\n      else { tr.removeMark(chFrom, chTo, markChange.mark); }\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      if (view.someProp(\"handleTextInput\", function (f) { return f(view, chFrom, chTo, text$1); })) { return }\n      tr = view.state.tr.insertText(text$1, chFrom, chTo);\n    }\n  }\n\n  if (!tr)\n    { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }\n  if (parse.sel) {\n    var sel$2 = resolveSelection(view, tr.doc, parse.sel);\n    // Chrome Android will sometimes, during composition, report the\n    // selection in the wrong place. If it looks like that is\n    // happening, don't update the selection.\n    // Edge just doesn't move the cursor forward when you start typing\n    // in an empty block or between br nodes.\n    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&\n                 (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) &&\n                 (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||\n                 result.ie && sel$2.empty && sel$2.head == chFrom))\n      { tr.setSelection(sel$2); }\n  }\n  if (storedMarks) { tr.ensureMarks(storedMarks); }\n  view.dispatch(tr.scrollIntoView());\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n  var added = curMarks, removed = prevMarks, type, mark, update;\n  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }\n  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n    update = function (node) { return node.mark(mark.addToSet(node.marks)); };\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };\n  } else {\n    return null\n  }\n  var updated = [];\n  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }\n  if (Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    { return false }\n\n  var $start = old.resolve(start);\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    { return false }\n  var $next = old.resolve(skipClosingAndOpening($start, true, true));\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    { return false }\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n  if (mayOpen) {\n    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  var start = a.findDiffStart(b, pos);\n  if (start == null) { return null }\n  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  var endA = ref.a;\n  var endB = ref.b;\n  if (preferredSide == \"end\") {\n    var adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n  if (endA < start && a.size < b.size) {\n    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n    start -= move$1;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return {start: start, endA: endA, endB: endB}\n}\n\nfunction serializeForClipboard(view, slice) {\n  var context = [];\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    var node = content.firstChild;\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n    content = node.content;\n  }\n\n  var serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema);\n  var doc = detachedDoc(), wrap = doc.createElement(\"div\");\n  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));\n\n  var firstChild = wrap.firstChild, needsWrap;\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (var i = needsWrap.length - 1; i >= 0; i--) {\n      var wrapper = doc.createElement(needsWrap[i]);\n      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }\n      wrap.appendChild(wrapper);\n      if (needsWrap[i] != \"tbody\") {\n        openStart++;\n        openEnd++;\n      }\n    }\n    firstChild = wrap.firstChild;\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    { firstChild.setAttribute(\"data-pm-slice\", (openStart + \" \" + openEnd + \" \" + (JSON.stringify(context)))); }\n\n  var text = view.someProp(\"clipboardTextSerializer\", function (f) { return f(slice); }) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n\n  return {dom: wrap, text: text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  var dom, inCode = $context.parent.type.spec.code, slice;\n  if (!html && !text) { return null }\n  var asText = text && (plainText || inCode || !html);\n  if (asText) {\n    view.someProp(\"transformPastedText\", function (f) { text = f(text, inCode || plainText); });\n    if (inCode) { return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : Slice.empty }\n    var parsed = view.someProp(\"clipboardTextParser\", function (f) { return f(text, $context, plainText); });\n    if (parsed) {\n      slice = parsed;\n    } else {\n      var marks = $context.marks();\n      var ref = view.state;\n      var schema = ref.schema;\n      var serializer = DOMSerializer.fromSchema(schema);\n      dom = document.createElement(\"div\");\n      text.split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n        var p = dom.appendChild(document.createElement(\"p\"));\n        if (block) { p.appendChild(serializer.serializeNode(schema.text(block, marks))); }\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", function (f) { html = f(html); });\n    dom = readHTML(html);\n    if (result.webkit) { restoreReplacedSpaces(dom); }\n  }\n\n  var contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  var sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"));\n  if (!slice) {\n    var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {\n      preserveWhitespace: !!(asText || sliceData),\n      context: $context,\n      ruleFromNode: function ruleFromNode(dom) {\n        if (dom.nodeName == \"BR\" && !dom.nextSibling &&\n            dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) { return {ignore: true} }\n      }\n    });\n  }\n  if (sliceData) {\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);\n  } else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n    if (slice.openStart || slice.openEnd) {\n      var openStart = 0, openEnd = 0;\n      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating;\n           openStart++, node = node.firstChild) {}\n      for (var node$1 = slice.content.lastChild; openEnd < slice.openEnd && !node$1.type.spec.isolating;\n           openEnd++, node$1 = node$1.lastChild) {}\n      slice = closeSlice(slice, openStart, openEnd);\n    }\n  }\n\n  view.someProp(\"transformPasted\", function (f) { slice = f(slice); });\n  return slice\n}\n\nvar inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) { return fragment }\n  var loop = function ( d ) {\n    var parent = $context.node(d);\n    var match = parent.contentMatchAt($context.index(d));\n    var lastWrap = (void 0), result = [];\n    fragment.forEach(function (node) {\n      if (!result) { return }\n      var wrap = match.findWrapping(node.type), inLast;\n      if (!wrap) { return result = null }\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }\n        var wrapped = withWrappers(node, wrap);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type, wrapped.attrs);\n        lastWrap = wrap;\n      }\n    });\n    if (result) { return { v: Fragment.from(result) } }\n  };\n\n  for (var d = $context.depth; d >= 0; d--) {\n    var returned = loop( d );\n\n    if ( returned ) return returned.v;\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from) {\n  if ( from === void 0 ) from = 0;\n\n  for (var i = wrap.length - 1; i >= from; i--)\n    { node = wrap[i].create(null, Fragment.from(node)); }\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }\n    var match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      { return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1)))) }\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) { return node }\n  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);\n  return node.copy(fragment.append(fill))\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n  if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }\n  if (depth >= from)\n    { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)); }\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    { slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }\n  if (openEnd < slice.openEnd)\n    { slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }\n  return slice\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nvar wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n};\n\nvar _detachedDoc = null;\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n}\n\nfunction readHTML(html) {\n  var metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas) { html = html.slice(metas[0].length); }\n  var elt = detachedDoc().createElement(\"div\");\n  var firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    { html = wrap.map(function (n) { return \"<\" + n + \">\"; }).join(\"\") + html + wrap.map(function (n) { return \"</\" + n + \">\"; }).reverse().join(\"\"); }\n  elt.innerHTML = html;\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { elt = elt.querySelector(wrap[i]) || elt; } }\n  return elt\n}\n\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n  var nodes = dom.querySelectorAll(result.chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (node.childNodes.length == 1 && node.textContent == \"\\u00a0\" && node.parentNode)\n      { node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node); }\n  }\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) { return slice }\n  var schema = slice.content.firstChild.type.schema, array;\n  try { array = JSON.parse(context); }\n  catch(e) { return slice }\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  for (var i = array.length - 2; i >= 0; i -= 2) {\n    var type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs()) { break }\n    content = Fragment.from(type.create(array[i + 1], content));\n    openStart++; openEnd++;\n  }\n  return new Slice(content, openStart, openEnd)\n}\n\nvar observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nvar useCharData = result.ie && result.ie_version <= 11;\n\nvar SelectionState = function SelectionState() {\n  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;\n};\n\nSelectionState.prototype.set = function set (sel) {\n  this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;\n  this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;\n};\n\nSelectionState.prototype.eq = function eq (sel) {\n  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n    sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset\n};\n\nvar DOMObserver = function DOMObserver(view, handleDOMChange) {\n  var this$1 = this;\n\n  this.view = view;\n  this.handleDOMChange = handleDOMChange;\n  this.queue = [];\n  this.flushingSoon = -1;\n  this.observer = window.MutationObserver &&\n    new window.MutationObserver(function (mutations) {\n      for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }\n      // IE11 will sometimes (on backspacing out a single character\n      // text node after a BR node) call the observer callback\n      // before actually updating the DOM, which will cause\n      // ProseMirror to miss the change (see #930)\n      if (result.ie && result.ie_version <= 11 && mutations.some(\n        function (m) { return m.type == \"childList\" && m.removedNodes.length ||\n             m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length; }))\n        { this$1.flushSoon(); }\n      else\n        { this$1.flush(); }\n    });\n  this.currentSelection = new SelectionState;\n  if (useCharData) {\n    this.onCharData = function (e) {\n      this$1.queue.push({target: e.target, type: \"characterData\", oldValue: e.prevValue});\n      this$1.flushSoon();\n    };\n  }\n  this.onSelectionChange = this.onSelectionChange.bind(this);\n  this.suppressingSelectionUpdates = false;\n};\n\nDOMObserver.prototype.flushSoon = function flushSoon () {\n    var this$1 = this;\n\n  if (this.flushingSoon < 0)\n    { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }\n};\n\nDOMObserver.prototype.forceFlush = function forceFlush () {\n  if (this.flushingSoon > -1) {\n    window.clearTimeout(this.flushingSoon);\n    this.flushingSoon = -1;\n    this.flush();\n  }\n};\n\nDOMObserver.prototype.start = function start () {\n  if (this.observer)\n    { this.observer.observe(this.view.dom, observeOptions); }\n  if (useCharData)\n    { this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n  this.connectSelection();\n};\n\nDOMObserver.prototype.stop = function stop () {\n    var this$1 = this;\n\n  if (this.observer) {\n    var take = this.observer.takeRecords();\n    if (take.length) {\n      for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }\n      window.setTimeout(function () { return this$1.flush(); }, 20);\n    }\n    this.observer.disconnect();\n  }\n  if (useCharData) { this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n  this.disconnectSelection();\n};\n\nDOMObserver.prototype.connectSelection = function connectSelection () {\n  this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n};\n\nDOMObserver.prototype.disconnectSelection = function disconnectSelection () {\n  this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n};\n\nDOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {\n    var this$1 = this;\n\n  this.suppressingSelectionUpdates = true;\n  setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);\n};\n\nDOMObserver.prototype.onSelectionChange = function onSelectionChange () {\n  if (!hasFocusAndSelection(this.view)) { return }\n  if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }\n  // Deletions on IE11 fire their events in the wrong order, giving\n  // us a selection change event before the DOM changes are\n  // reported.\n  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {\n    var sel = this.view.root.getSelection();\n    // Selection.isCollapsed isn't reliable on IE\n    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n      { return this.flushSoon() }\n  }\n  this.flush();\n};\n\nDOMObserver.prototype.setCurSelection = function setCurSelection () {\n  this.currentSelection.set(this.view.root.getSelection());\n};\n\nDOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {\n  if (sel.rangeCount == 0) { return true }\n  var container = sel.getRangeAt(0).commonAncestorContainer;\n  var desc = this.view.docView.nearestDesc(container);\n  if (desc && desc.ignoreMutation({type: \"selection\", target: container.nodeType == 3 ? container.parentNode : container})) {\n    this.setCurSelection();\n    return true\n  }\n};\n\nDOMObserver.prototype.flush = function flush () {\n  if (!this.view.docView || this.flushingSoon > -1) { return }\n  var mutations = this.observer ? this.observer.takeRecords() : [];\n  if (this.queue.length) {\n    mutations = this.queue.concat(mutations);\n    this.queue.length = 0;\n  }\n\n  var sel = this.view.root.getSelection();\n  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);\n\n  var from = -1, to = -1, typeOver = false, added = [];\n  if (this.view.editable) {\n    for (var i = 0; i < mutations.length; i++) {\n      var result$1 = this.registerMutation(mutations[i], added);\n      if (result$1) {\n        from = from < 0 ? result$1.from : Math.min(result$1.from, from);\n        to = to < 0 ? result$1.to : Math.max(result$1.to, to);\n        if (result$1.typeOver) { typeOver = true; }\n      }\n    }\n  }\n\n  if (result.gecko && added.length > 1) {\n    var brs = added.filter(function (n) { return n.nodeName == \"BR\"; });\n    if (brs.length == 2) {\n      var a = brs[0];\n        var b = brs[1];\n      if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }\n      else { a.remove(); }\n    }\n  }\n\n  if (from > -1 || newSel) {\n    if (from > -1) {\n      this.view.docView.markDirty(from, to);\n      checkCSS(this.view);\n    }\n    this.handleDOMChange(from, to, typeOver, added);\n    if (this.view.docView && this.view.docView.dirty) { this.view.updateState(this.view.state); }\n    else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }\n    this.currentSelection.set(sel);\n  }\n};\n\nDOMObserver.prototype.registerMutation = function registerMutation (mut, added) {\n  // Ignore mutations inside nodes that were already noted as inserted\n  if (added.indexOf(mut.target) > -1) { return null }\n  var desc = this.view.docView.nearestDesc(mut.target);\n  if (mut.type == \"attributes\" &&\n      (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n       // Firefox sometimes fires spurious events for null/empty styles\n       (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n    { return null }\n  if (!desc || desc.ignoreMutation(mut)) { return null }\n\n  if (mut.type == \"childList\") {\n    for (var i = 0; i < mut.addedNodes.length; i++) { added.push(mut.addedNodes[i]); }\n    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n      { return {from: desc.posBefore, to: desc.posAfter} }\n    var prev = mut.previousSibling, next = mut.nextSibling;\n    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {\n      // IE11 gives us incorrect next/prev siblings for some\n      // insertions, so if there are added nodes, recompute those\n      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {\n        var ref = mut.addedNodes[i$1];\n          var previousSibling = ref.previousSibling;\n          var nextSibling = ref.nextSibling;\n        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }\n        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }\n      }\n    }\n    var fromOffset = prev && prev.parentNode == mut.target\n        ? domIndex(prev) + 1 : 0;\n    var from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n    var toOffset = next && next.parentNode == mut.target\n        ? domIndex(next) : mut.target.childNodes.length;\n    var to = desc.localPosFromDOM(mut.target, toOffset, 1);\n    return {from: from, to: to}\n  } else if (mut.type == \"attributes\") {\n    return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}\n  } else { // \"characterData\"\n    return {\n      from: desc.posAtStart,\n      to: desc.posAtEnd,\n      // An event was generated for a text change that didn't change\n      // any text. Mark the dom change to fall back to assuming the\n      // selection was typed over with an identical value if it can't\n      // find another change.\n      typeOver: mut.target.nodeValue == mut.oldValue\n    }\n  }\n};\n\nvar cssChecked = false;\n\nfunction checkCSS(view) {\n  if (cssChecked) { return }\n  cssChecked = true;\n  if (getComputedStyle(view.dom).whiteSpace == \"normal\")\n    { console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\"); }\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nvar handlers = {}, editHandlers = {};\n\nfunction initInput(view) {\n  view.shiftKey = false;\n  view.mouseDown = null;\n  view.lastKeyCode = null;\n  view.lastKeyCodeTime = 0;\n  view.lastClick = {time: 0, x: 0, y: 0, type: \"\"};\n  view.lastSelectionOrigin = null;\n  view.lastSelectionTime = 0;\n\n  view.lastIOSEnter = 0;\n  view.lastIOSEnterFallbackTimeout = null;\n  view.lastAndroidDelete = 0;\n\n  view.composing = false;\n  view.composingTimeout = null;\n  view.compositionNodes = [];\n  view.compositionEndedAt = -2e8;\n\n  view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });\n  view.domObserver.start();\n  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM\n  view.domChangeCount = 0;\n\n  view.eventHandlers = Object.create(null);\n  var loop = function ( event ) {\n    var handler = handlers[event];\n    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        { handler(view, event); }\n    });\n  };\n\n  for (var event in handlers) loop( event );\n  // On Safari, for reasons beyond my understanding, adding an input\n  // event handler makes an issue where the composition vanishes when\n  // you press enter go away.\n  if (result.safari) { view.dom.addEventListener(\"input\", function () { return null; }); }\n\n  ensureListeners(view);\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.lastSelectionOrigin = origin;\n  view.lastSelectionTime = Date.now();\n}\n\nfunction destroyInput(view) {\n  view.domObserver.stop();\n  for (var type in view.eventHandlers)\n    { view.dom.removeEventListener(type, view.eventHandlers[type]); }\n  clearTimeout(view.composingTimeout);\n  clearTimeout(view.lastIOSEnterFallbackTimeout);\n}\n\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", function (currentHandlers) {\n    for (var type in currentHandlers) { if (!view.eventHandlers[type])\n      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }\n  });\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", function (handlers) {\n    var handler = handlers[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) { return true }\n  if (event.defaultPrevented) { return false }\n  for (var node = event.target; node != view.dom; node = node.parentNode)\n    { if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      { return false } }\n  return true\n}\n\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    { handlers[event.type](view, event); }\n}\n\neditHandlers.keydown = function (view, event) {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (inOrNearComposition(view, event)) { return }\n  view.lastKeyCode = event.keyCode;\n  view.lastKeyCodeTime = Date.now();\n  // Suppress enter key events on Chrome Android, because those tend\n  // to be part of a confused sequence of composition events fired,\n  // and handling them eagerly tends to corrupt the input.\n  if (result.android && result.chrome && event.keyCode == 13) { return }\n  if (event.keyCode != 229) { view.domObserver.forceFlush(); }\n\n  // On iOS, if we preventDefault enter key presses, the virtual\n  // keyboard gets confused. So the hack here is to set a flag that\n  // makes the DOM change code recognize that what just happens should\n  // be replaced by whatever the Enter key handlers do.\n  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    var now = Date.now();\n    view.lastIOSEnter = now;\n    view.lastIOSEnterFallbackTimeout = setTimeout(function () {\n      if (view.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n        view.lastIOSEnter = 0;\n      }\n    }, 200);\n  } else if (view.someProp(\"handleKeyDown\", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"key\");\n  }\n};\n\neditHandlers.keyup = function (view, e) {\n  if (e.keyCode == 16) { view.shiftKey = false; }\n};\n\neditHandlers.keypress = function (view, event) {\n  if (inOrNearComposition(view, event) || !event.charCode ||\n      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }\n\n  if (view.someProp(\"handleKeyPress\", function (f) { return f(view, event); })) {\n    event.preventDefault();\n    return\n  }\n\n  var sel = view.state.selection;\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    var text = String.fromCharCode(event.charCode);\n    if (!view.someProp(\"handleTextInput\", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))\n      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }\n    event.preventDefault();\n  }\n};\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nfunction isNear(event, click) {\n  var dx = click.x - event.clientX, dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside);\n  var loop = function ( i ) {\n    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))\n      { return { v: true } }\n  };\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) { view.focus(); }\n  var tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true); }\n  view.dispatch(tr);\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\");\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) { return false }\n  var sel = view.state.selection, selectedNode, selectAt;\n  if (sel instanceof NodeSelection) { selectedNode = sel.node; }\n\n  var $pos = view.state.doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        { selectAt = $pos.before(sel.$from.depth); }\n      else\n        { selectAt = $pos.before(i); }\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", function (f) { return f(view, pos, event); }) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", function (f) { return f(view, pos, event); })\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", function (f) { return f(view, pos, event); }) ||\n    defaultTripleClick(view, inside, event)\n}\n\nfunction defaultTripleClick(view, inside, event) {\n  if (event.button != 0) { return false }\n  var doc = view.state.doc;\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n      return true\n    }\n    return false\n  }\n\n  var $pos = doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    var nodePos = $pos.before(i);\n    if (node.inlineContent)\n      { updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\"); }\n    else if (NodeSelection.isSelectable(node))\n      { updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\"); }\n    else\n      { continue }\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view)\n}\n\nvar selectNodeModifier = result.mac ? \"metaKey\" : \"ctrlKey\";\n\nhandlers.mousedown = function (view, event) {\n  view.shiftKey = event.shiftKey;\n  var flushed = forceDOMFlush(view);\n  var now = Date.now(), type = \"singleClick\";\n  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {\n    if (view.lastClick.type == \"singleClick\") { type = \"doubleClick\"; }\n    else if (view.lastClick.type == \"doubleClick\") { type = \"tripleClick\"; }\n  }\n  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};\n\n  var pos = view.posAtCoords(eventCoords(event));\n  if (!pos) { return }\n\n  if (type == \"singleClick\") {\n    if (view.mouseDown) { view.mouseDown.done(); }\n    view.mouseDown = new MouseDown(view, pos, event, flushed);\n  } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"pointer\");\n  }\n};\n\nvar MouseDown = function MouseDown(view, pos, event, flushed) {\n  var this$1 = this;\n\n  this.view = view;\n  this.startDoc = view.state.doc;\n  this.pos = pos;\n  this.event = event;\n  this.flushed = flushed;\n  this.selectNode = event[selectNodeModifier];\n  this.allowDefault = event.shiftKey;\n  this.delayedSelectionSync = false;\n\n  var targetNode, targetPos;\n  if (pos.inside > -1) {\n    targetNode = view.state.doc.nodeAt(pos.inside);\n    targetPos = pos.inside;\n  } else {\n    var $pos = view.state.doc.resolve(pos.pos);\n    targetNode = $pos.parent;\n    targetPos = $pos.depth ? $pos.before() : 0;\n  }\n\n  this.mightDrag = null;\n\n  var target = flushed ? null : event.target;\n  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n  this.target = targetDesc ? targetDesc.dom : null;\n\n  var ref = view.state;\n  var selection = ref.selection;\n  if (event.button == 0 &&\n      targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n      selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n    { this.mightDrag = {node: targetNode,\n                      pos: targetPos,\n                      addAttr: this.target && !this.target.draggable,\n                      setUneditable: this.target && result.gecko && !this.target.hasAttribute(\"contentEditable\")}; }\n\n  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.draggable = true; }\n    if (this.mightDrag.setUneditable)\n      { setTimeout(function () {\n        if (this$1.view.mouseDown == this$1) { this$1.target.setAttribute(\"contentEditable\", \"false\"); }\n      }, 20); }\n    this.view.domObserver.start();\n  }\n\n  view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n  view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n  setSelectionOrigin(view, \"pointer\");\n};\n\nMouseDown.prototype.done = function done () {\n    var this$1 = this;\n\n  this.view.root.removeEventListener(\"mouseup\", this.up);\n  this.view.root.removeEventListener(\"mousemove\", this.move);\n  if (this.mightDrag && this.target) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.removeAttribute(\"draggable\"); }\n    if (this.mightDrag.setUneditable) { this.target.removeAttribute(\"contentEditable\"); }\n    this.view.domObserver.start();\n  }\n  if (this.delayedSelectionSync) { setTimeout(function () { return selectionToDOM(this$1.view); }); }\n  this.view.mouseDown = null;\n};\n\nMouseDown.prototype.up = function up (event) {\n  this.done();\n\n  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n    { return }\n\n  var pos = this.pos;\n  if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }\n\n  if (this.allowDefault || !pos) {\n    setSelectionOrigin(this.view, \"pointer\");\n  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n    event.preventDefault();\n  } else if (event.button == 0 &&\n             (this.flushed ||\n              // Safari ignores clicks on draggable elements\n              (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n              // Chrome will sometimes treat a node selection as a\n              // cursor, but still report that the node is selected\n              // when asked through getSelection. You'll then get a\n              // situation where clicking at the point where that\n              // (hidden) cursor is doesn't change the selection, and\n              // thus doesn't get a reaction from ProseMirror. This\n              // works around that.\n              (result.chrome && !(this.view.state.selection instanceof TextSelection) &&\n               Math.min(Math.abs(pos.pos - this.view.state.selection.from),\n                        Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(this.view, \"pointer\");\n  }\n};\n\nMouseDown.prototype.move = function move (event) {\n  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                             Math.abs(this.event.y - event.clientY) > 4))\n    { this.allowDefault = true; }\n  setSelectionOrigin(this.view, \"pointer\");\n  if (event.buttons == 0) { this.done(); }\n};\n\nhandlers.touchdown = function (view) {\n  forceDOMFlush(view);\n  setSelectionOrigin(view, \"pointer\");\n};\n\nhandlers.contextmenu = function (view) { return forceDOMFlush(view); };\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) { return true }\n  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n  // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n  // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n  // emitted. The keydown event triggers newline insertion, which we don't want.\n  // This method returns true if the keydown event should be ignored.\n  // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n  // This guards against the case where compositionend is triggered without the keyboard\n  // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n  // afterwards- we wouldn't want to ignore the keydown event in this case.\n  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {\n    view.compositionEndedAt = -2e8;\n    return true\n  }\n  return false\n}\n\n// Drop active composition after 5 seconds of inactivity on Android\nvar timeoutComposition = result.android ? 5000 : -1;\n\neditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n  if (!view.composing) {\n    view.domObserver.flush();\n    var state = view.state;\n    var $pos = state.selection.$from;\n    if (state.selection.empty &&\n        (state.storedMarks ||\n         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {\n      // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n      view.markCursor = view.state.storedMarks || $pos.marks();\n      endComposition(view, true);\n      view.markCursor = null;\n    } else {\n      endComposition(view);\n      // In firefox, if the cursor is after but outside a marked node,\n      // the inserted text won't inherit the marks. So this moves it\n      // inside if necessary.\n      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        var sel = view.root.getSelection();\n        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n          if (!before) { break }\n          if (before.nodeType == 3) {\n            sel.collapse(before, before.nodeValue.length);\n            break\n          } else {\n            node = before;\n            offset = -1;\n          }\n        }\n      }\n    }\n    view.composing = true;\n  }\n  scheduleComposeEnd(view, timeoutComposition);\n};\n\neditHandlers.compositionend = function (view, event) {\n  if (view.composing) {\n    view.composing = false;\n    view.compositionEndedAt = event.timeStamp;\n    scheduleComposeEnd(view, 20);\n  }\n};\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.composingTimeout);\n  if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }\n}\n\nfunction clearComposition(view) {\n  if (view.composing) {\n    view.composing = false;\n    view.compositionEndedAt = timestampFromCustomEvent();\n  }\n  while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }\n}\n\nfunction timestampFromCustomEvent() {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"event\", true, true);\n  return event.timeStamp\n}\n\nfunction endComposition(view, forceUpdate) {\n  if (result.android && view.domObserver.flushingSoon >= 0) { return }\n  view.domObserver.forceFlush();\n  clearComposition(view);\n  if (forceUpdate || view.docView && view.docView.dirty) {\n    var sel = selectionFromDOM(view);\n    if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }\n    else { view.updateState(view.state); }\n    return true\n  }\n  return false\n}\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  if (!view.dom.parentNode) { return }\n  var wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n  wrap.appendChild(dom);\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  var sel = getSelection(), range = document.createRange();\n  range.selectNodeContents(dom);\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(function () {\n    if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }\n    view.focus();\n  }, 50);\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nvar brokenClipboardAPI = (result.ie && result.ie_version < 15) ||\n      (result.ios && result.webkit_version < 604);\n\nhandlers.copy = editHandlers.cut = function (view, e) {\n  var sel = view.state.selection, cut = e.type == \"cut\";\n  if (sel.empty) { return }\n\n  // IE and Edge's clipboard interface is completely broken\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  var slice = sel.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  if (data) {\n    e.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\")); }\n};\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  if (!view.dom.parentNode) { return }\n  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText) { target.contentEditable = \"true\"; }\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(function () {\n    view.focus();\n    if (target.parentNode) { target.parentNode.removeChild(target); }\n    if (plainText) { doPaste(view, target.value, null, e); }\n    else { doPaste(view, target.textContent, target.innerHTML, e); }\n  }, 50);\n}\n\nfunction doPaste(view, text, html, e) {\n  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);\n  if (view.someProp(\"handlePaste\", function (f) { return f(view, e, slice || Slice.empty); })) { return true }\n  if (!slice) { return false }\n\n  var singleNode = sliceSingleNode(slice);\n  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true\n}\n\neditHandlers.paste = function (view, e) {\n  // Handling paste from JavaScript during composition is very poorly\n  // handled by browsers, so as a dodgy but preferable kludge, we just\n  // let the browser do its native thing there, except on Android,\n  // where the editor is almost always composing.\n  if (view.composing && !result.android) { return }\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e)) { e.preventDefault(); }\n  else { capturePaste(view, e); }\n};\n\nvar Dragging = function Dragging(slice, move) {\n  this.slice = slice;\n  this.move = move;\n};\n\nvar dragCopyModifier = result.mac ? \"altKey\" : \"ctrlKey\";\n\nhandlers.dragstart = function (view, e) {\n  var mouseDown = view.mouseDown;\n  if (mouseDown) { mouseDown.done(); }\n  if (!e.dataTransfer) { return }\n\n  var sel = view.state.selection;\n  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n  } else if (e.target && e.target.nodeType == 1) {\n    var desc = view.docView.nearestDesc(e.target, true);\n    if (desc && desc.node.type.spec.draggable && desc != view.docView)\n      { view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore))); }\n  }\n  var slice = view.state.selection.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  e.dataTransfer.clearData();\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  // See https://github.com/ProseMirror/prosemirror/issues/1156\n  e.dataTransfer.effectAllowed = \"copyMove\";\n  if (!brokenClipboardAPI) { e.dataTransfer.setData(\"text/plain\", text); }\n  view.dragging = new Dragging(slice, !e[dragCopyModifier]);\n};\n\nhandlers.dragend = function (view) {\n  var dragging = view.dragging;\n  window.setTimeout(function () {\n    if (view.dragging == dragging)  { view.dragging = null; }\n  }, 50);\n};\n\neditHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };\n\neditHandlers.drop = function (view, e) {\n  var dragging = view.dragging;\n  view.dragging = null;\n\n  if (!e.dataTransfer) { return }\n\n  var eventPos = view.posAtCoords(eventCoords(e));\n  if (!eventPos) { return }\n  var $mouse = view.state.doc.resolve(eventPos.pos);\n  if (!$mouse) { return }\n  var slice = dragging && dragging.slice;\n  if (slice) {\n    view.someProp(\"transformPasted\", function (f) { slice = f(slice); });\n  } else {\n    slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                               brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse);\n  }\n  var move = dragging && !e[dragCopyModifier];\n  if (view.someProp(\"handleDrop\", function (f) { return f(view, e, slice || Slice.empty, move); })) {\n    e.preventDefault();\n    return\n  }\n  if (!slice) { return }\n\n  e.preventDefault();\n  var insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null) { insertPos = $mouse.pos; }\n\n  var tr = view.state.tr;\n  if (move) { tr.deleteSelection(); }\n\n  var pos = tr.mapping.map(insertPos);\n  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  var beforeInsert = tr.doc;\n  if (isNode)\n    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }\n  else\n    { tr.replaceRange(pos, pos, slice); }\n  if (tr.doc.eq(beforeInsert)) { return }\n\n  var $pos = tr.doc.resolve(pos);\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos));\n  } else {\n    var end = tr.mapping.map(insertPos);\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n  }\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\n\nhandlers.focus = function (view) {\n  if (!view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.domObserver.start();\n    view.focused = true;\n    setTimeout(function () {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))\n        { selectionToDOM(view); }\n    }, 20);\n  }\n};\n\nhandlers.blur = function (view, e) {\n  if (view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.domObserver.start();\n    if (e.relatedTarget && view.dom.contains(e.relatedTarget))\n      { view.domObserver.currentSelection.set({}); }\n    view.focused = false;\n  }\n};\n\nhandlers.beforeinput = function (view, event) {\n  // We should probably do more with beforeinput events, but support\n  // is so spotty that I'm still waiting to see where they are going.\n\n  // Very specific hack to deal with backspace sometimes failing on\n  // Chrome Android when after an uneditable node.\n  if (result.chrome && result.android && event.inputType == \"deleteContentBackward\") {\n    view.domObserver.flushSoon();\n    var domChangeCount = view.domChangeCount;\n    setTimeout(function () {\n      if (view.domChangeCount != domChangeCount) { return } // Event already had some effect\n      // This bug tends to close the virtual keyboard, so we refocus\n      view.dom.blur();\n      view.focus();\n      if (view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); })) { return }\n      var ref = view.state.selection;\n      var $cursor = ref.$cursor;\n      // Crude approximation of backspace behavior when no command handled it\n      if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }\n    }, 50);\n  }\n};\n\n// Make sure all handlers get registered\nfor (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }\n\nfunction compareObjs(a, b) {\n  if (a == b) { return true }\n  for (var p in a) { if (a[p] !== b[p]) { return false } }\n  for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  return true\n}\n\nvar WidgetType = function WidgetType(toDOM, spec) {\n  this.spec = spec || noSpec;\n  this.side = this.spec.side || 0;\n  this.toDOM = toDOM;\n};\n\nWidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n    var pos = ref.pos;\n    var deleted = ref.deleted;\n  return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n};\n\nWidgetType.prototype.valid = function valid () { return true };\n\nWidgetType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof WidgetType &&\n     (this.spec.key && this.spec.key == other.spec.key ||\n      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n};\n\nWidgetType.prototype.destroy = function destroy (node) {\n  if (this.spec.destroy) { this.spec.destroy(node); }\n};\n\nvar InlineType = function InlineType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nInlineType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n  return from >= to ? null : new Decoration(from, to, this)\n};\n\nInlineType.prototype.valid = function valid (_, span) { return span.from < span.to };\n\nInlineType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\nInlineType.is = function is (span) { return span.type instanceof InlineType };\n\nvar NodeType = function NodeType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nNodeType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.mapResult(span.from + oldOffset, 1);\n  if (from.deleted) { return null }\n  var to = mapping.mapResult(span.to + oldOffset, -1);\n  if (to.deleted || to.pos <= from.pos) { return null }\n  return new Decoration(from.pos - offset, to.pos - offset, this)\n};\n\nNodeType.prototype.valid = function valid (node, span) {\n  var ref = node.content.findIndex(span.from);\n    var index = ref.index;\n    var offset = ref.offset;\n    var child;\n  return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to\n};\n\nNodeType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nvar Decoration = function Decoration(from, to, type) {\n  // :: number\n  // The start position of the decoration.\n  this.from = from;\n  // :: number\n  // The end position. Will be the same as `from` for [widget\n  // decorations](#view.Decoration^widget).\n  this.to = to;\n  this.type = type;\n};\n\nvar prototypeAccessors$1 = { spec: { configurable: true },inline: { configurable: true } };\n\nDecoration.prototype.copy = function copy (from, to) {\n  return new Decoration(from, to, this.type)\n};\n\nDecoration.prototype.eq = function eq (other, offset) {\n    if ( offset === void 0 ) offset = 0;\n\n  return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to\n};\n\nDecoration.prototype.map = function map (mapping, offset, oldOffset) {\n  return this.type.map(mapping, this, offset, oldOffset)\n};\n\n// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n// Creates a widget decoration, which is a DOM node that's shown in\n// the document at the given position. It is recommended that you\n// delay rendering the widget by passing a function that will be\n// called when the widget is actually drawn in a view, but you can\n// also directly pass a DOM node. `getPos` can be used to find the\n// widget's current document position.\n//\n// spec::- These options are supported:\n//\n//   side:: ?number\n//   Controls which side of the document position this widget is\n//   associated with. When negative, it is drawn before a cursor\n//   at its position, and content inserted at that position ends\n//   up after the widget. When zero (the default) or positive, the\n//   widget is drawn after the cursor and content inserted there\n//   ends up before the widget.\n//\n//   When there are multiple widgets at a given position, their\n//   `side` values determine the order in which they appear. Those\n//   with lower values appear first. The ordering of widgets with\n//   the same `side` value is unspecified.\n//\n//   When `marks` is null, `side` also determines the marks that\n//   the widget is wrapped in—those of the node before when\n//   negative, those of the node after when positive.\n//\n//   marks:: ?[Mark]\n//   The precise set of marks to draw around the widget.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to control which DOM events, when they bubble out\n//   of this widget, the editor view should ignore.\n//\n//   ignoreSelection:: ?bool\n//   When set (defaults to false), selection changes inside the\n//   widget are ignored, and don't cause ProseMirror to try and\n//   re-sync the selection with its selection state.\n//\n//   key:: ?string\n//   When comparing decorations of this type (in order to decide\n//   whether it needs to be redrawn), ProseMirror will by default\n//   compare the widget DOM node by identity. If you pass a key,\n//   that key will be compared instead, which can be useful when\n//   you generate decorations on the fly and don't want to store\n//   and reuse DOM nodes. Make sure that any widgets with the same\n//   key are interchangeable—if widgets differ in, for example,\n//   the behavior of some event handler, they should get\n//   different keys.\n//\n//   destroy:: ?(node: dom.Node)\n//   Called when the widget decoration is removed as a result of\n//   mapping\nDecoration.widget = function widget (pos, toDOM, spec) {\n  return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates an inline decoration, which adds the given attributes to\n// each inline node between `from` and `to`.\n//\n// spec::- These options are recognized:\n//\n//   inclusiveStart:: ?bool\n//   Determines how the left side of the decoration is\n//   [mapped](#transform.Position_Mapping) when content is\n//   inserted directly at that position. By default, the decoration\n//   won't include the new content, but you can set this to `true`\n//   to make it inclusive.\n//\n//   inclusiveEnd:: ?bool\n//   Determines how the right side of the decoration is mapped.\n//   See\n//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\nDecoration.inline = function inline (from, to, attrs, spec) {\n  return new Decoration(from, to, new InlineType(attrs, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates a node decoration. `from` and `to` should point precisely\n// before and after a node in the document. That node, and only that\n// node, will receive the given attributes.\n//\n// spec::-\n//\n// Optional information to store with the decoration. It\n// is also used when comparing decorators for equality.\nDecoration.node = function node (from, to, attrs, spec) {\n  return new Decoration(from, to, new NodeType(attrs, spec))\n};\n\n// :: Object\n// The spec provided when creating this decoration. Can be useful\n// if you've stored extra information in that object.\nprototypeAccessors$1.spec.get = function () { return this.type.spec };\n\nprototypeAccessors$1.inline.get = function () { return this.type instanceof InlineType };\n\nObject.defineProperties( Decoration.prototype, prototypeAccessors$1 );\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nvar none = [], noSpec = {};\n\n// :: class extends DecorationSource\n// A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nvar DecorationSet = function DecorationSet(local, children) {\n  this.local = local && local.length ? local : none;\n  this.children = children && children.length ? children : none;\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Create a set of decorations, using the structure of the given\n// document.\nDecorationSet.create = function create (doc, decorations) {\n  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n};\n\n// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n// Find all decorations in this set which touch the given range\n// (including decorations that start or end directly at the\n// boundaries) and match the given predicate on their spec. When\n// `start` and `end` are omitted, all decorations in the set are\n// considered. When `predicate` isn't given, all decorations are\n// assumed to match.\nDecorationSet.prototype.find = function find (start, end, predicate) {\n  var result = [];\n  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n  return result\n};\n\nDecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {\n  for (var i = 0; i < this.local.length; i++) {\n    var span = this.local[i];\n    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n      { result.push(span.copy(span.from + offset, span.to + offset)); }\n  }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {\n    if (this.children[i$1] < end && this.children[i$1 + 1] > start) {\n      var childOff = this.children[i$1] + 1;\n      this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n    }\n  }\n};\n\n// :: (Mapping, Node, ?Object) → DecorationSet\n// Map the set of decorations in response to a change in the\n// document.\n//\n// options::- An optional set of options.\n//\n//   onRemove:: ?(decorationSpec: Object)\n//   When given, this function will be called for each decoration\n//   that gets dropped as a result of the mapping, passing the\n//   spec of that decoration.\nDecorationSet.prototype.map = function map (mapping, doc, options) {\n  if (this == empty || mapping.maps.length == 0) { return this }\n  return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n};\n\nDecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {\n  var newLocal;\n  for (var i = 0; i < this.local.length; i++) {\n    var mapped = this.local[i].map(mapping, offset, oldOffset);\n    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }\n    else if (options.onRemove) { options.onRemove(this.local[i].spec); }\n  }\n\n  if (this.children.length)\n    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }\n  else\n    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Add the given array of decorations to the ones in the set,\n// producing a new set. Needs access to the current document to\n// create the appropriate tree structure.\nDecorationSet.prototype.add = function add (doc, decorations) {\n  if (!decorations.length) { return this }\n  if (this == empty) { return DecorationSet.create(doc, decorations) }\n  return this.addInner(doc, decorations, 0)\n};\n\nDecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {\n    var this$1 = this;\n\n  var children, childIndex = 0;\n  doc.forEach(function (childNode, childOffset) {\n    var baseOffset = childOffset + offset, found;\n    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }\n\n    if (!children) { children = this$1.children.slice(); }\n    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }\n    if (children[childIndex] == childOffset)\n      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }\n    else\n      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }\n    childIndex += 3;\n  });\n\n  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n  for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }\n\n  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                           children || this.children)\n};\n\n// :: ([Decoration]) → DecorationSet\n// Create a new set that contains the decorations in this set, minus\n// the ones in the given array.\nDecorationSet.prototype.remove = function remove (decorations) {\n  if (decorations.length == 0 || this == empty) { return this }\n  return this.removeInner(decorations, 0)\n};\n\nDecorationSet.prototype.removeInner = function removeInner (decorations, offset) {\n  var children = this.children, local = this.local;\n  for (var i = 0; i < children.length; i += 3) {\n    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;\n    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {\n      if (span.from > from && span.to < to) {\n        decorations[j] = null\n        ;(found || (found = [])).push(span);\n      }\n    } }\n    if (!found) { continue }\n    if (children == this.children) { children = this.children.slice(); }\n    var removed = children[i + 2].removeInner(found, from + 1);\n    if (removed != empty) {\n      children[i + 2] = removed;\n    } else {\n      children.splice(i, 3);\n      i -= 3;\n    }\n  }\n  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {\n    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {\n      if (local == this.local) { local = this.local.slice(); }\n      local.splice(j$1--, 1);\n    } }\n  } } }\n  if (children == this.children && local == this.local) { return this }\n  return local.length || children.length ? new DecorationSet(local, children) : empty\n};\n\nDecorationSet.prototype.forChild = function forChild (offset, node) {\n  if (this == empty) { return this }\n  if (node.isLeaf) { return DecorationSet.empty }\n\n  var child, local;\n  for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {\n    if (this.children[i] == offset) { child = this.children[i + 2]; }\n    break\n  } }\n  var start = offset + 1, end = start + node.content.size;\n  for (var i$1 = 0; i$1 < this.local.length; i$1++) {\n    var dec = this.local[i$1];\n    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }\n    }\n  }\n  if (local) {\n    var localSet = new DecorationSet(local.sort(byPos));\n    return child ? new DecorationGroup([localSet, child]) : localSet\n  }\n  return child || empty\n};\n\nDecorationSet.prototype.eq = function eq (other) {\n  if (this == other) { return true }\n  if (!(other instanceof DecorationSet) ||\n      this.local.length != other.local.length ||\n      this.children.length != other.children.length) { return false }\n  for (var i = 0; i < this.local.length; i++)\n    { if (!this.local[i].eq(other.local[i])) { return false } }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)\n    { if (this.children[i$1] != other.children[i$1] ||\n        this.children[i$1 + 1] != other.children[i$1 + 1] ||\n        !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }\n  return true\n};\n\nDecorationSet.prototype.locals = function locals (node) {\n  return removeOverlap(this.localsInner(node))\n};\n\nDecorationSet.prototype.localsInner = function localsInner (node) {\n  if (this == empty) { return none }\n  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }\n  var result = [];\n  for (var i = 0; i < this.local.length; i++) {\n    if (!(this.local[i].type instanceof InlineType))\n      { result.push(this.local[i]); }\n  }\n  return result\n};\n\n// DecorationSource:: interface\n// An object that can [provide](#view.EditorProps.decorations)\n// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),\n// and passed to [node views](#view.EditorProps.nodeViews).\n//\n//   map:: (Mapping, Node) → DecorationSource\n//   Map the set of decorations in response to a change in the\n//   document.\n\nvar empty = new DecorationSet();\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty;\n\nDecorationSet.removeOverlap = removeOverlap;\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nvar DecorationGroup = function DecorationGroup(members) {\n  this.members = members;\n};\n\nDecorationGroup.prototype.map = function map (mapping, doc) {\n  var mappedDecos = this.members.map(\n    function (member) { return member.map(mapping, doc, noSpec); }\n  );\n  return DecorationGroup.from(mappedDecos)\n};\n\nDecorationGroup.prototype.forChild = function forChild (offset, child) {\n  if (child.isLeaf) { return DecorationSet.empty }\n  var found = [];\n  for (var i = 0; i < this.members.length; i++) {\n    var result = this.members[i].forChild(offset, child);\n    if (result == empty) { continue }\n    if (result instanceof DecorationGroup) { found = found.concat(result.members); }\n    else { found.push(result); }\n  }\n  return DecorationGroup.from(found)\n};\n\nDecorationGroup.prototype.eq = function eq (other) {\n  if (!(other instanceof DecorationGroup) ||\n      other.members.length != this.members.length) { return false }\n  for (var i = 0; i < this.members.length; i++)\n    { if (!this.members[i].eq(other.members[i])) { return false } }\n  return true\n};\n\nDecorationGroup.prototype.locals = function locals (node) {\n  var result, sorted = true;\n  for (var i = 0; i < this.members.length; i++) {\n    var locals = this.members[i].localsInner(node);\n    if (!locals.length) { continue }\n    if (!result) {\n      result = locals;\n    } else {\n      if (sorted) {\n        result = result.slice();\n        sorted = false;\n      }\n      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }\n    }\n  }\n  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n};\n\n// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n// Create a group for the given array of decoration sets, or return\n// a single set when possible.\nDecorationGroup.from = function from (members) {\n  switch (members.length) {\n    case 0: return empty\n    case 1: return members[0]\n    default: return new DecorationGroup(members)\n  }\n};\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  var children = oldChildren.slice();\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  var shift = function (oldStart, oldEnd, newStart, newEnd) {\n    for (var i = 0; i < children.length; i += 3) {\n      var end = children[i + 1], dSize = (void 0);\n      if (end == -1 || oldStart > end + oldOffset) { continue }\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1;\n      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {\n        children[i] += dSize;\n        children[i + 1] += dSize;\n      }\n    }\n  };\n  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  var mustRebuild = false;\n  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes\n    var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true;\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;\n    var ref = node.content.findIndex(fromLocal);\n    var index = ref.index;\n    var childOffset = ref.offset;\n    var childNode = node.maybeChild(index);\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);\n      if (mapped != empty) {\n        children[i$1] = fromLocal;\n        children[i$1 + 1] = toLocal;\n        children[i$1 + 2] = mapped;\n      } else {\n        children[i$1 + 1] = -2;\n        mustRebuild = true;\n      }\n    } else {\n      mustRebuild = true;\n    }\n  } }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options);\n    var built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {\n      children.splice(i$2, 3);\n      i$2 -= 3;\n    } }\n    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {\n      var from$1 = built.children[i$3];\n      while (j < children.length && children[j] < from$1) { j += 3; }\n      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) { return spans }\n  var result = [];\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (var i = 0; i < set.local.length; i++) {\n      var mapped = set.local[i].map(mapping, offset, oldOffset);\n      if (mapped) { decorations.push(mapped); }\n      else if (options.onRemove) { options.onRemove(set.local[i].spec); }\n    }\n    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)\n      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }\n  }\n  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)\n    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) { return null }\n  var end = offset + node.nodeSize, found = null;\n  for (var i = 0, span = (void 0); i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n(found || (found = [])).push(span);\n      spans[i] = null;\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  var result = [];\n  for (var i = 0; i < array.length; i++)\n    { if (array[i] != null) { result.push(array[i]); } }\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  var children = [], hasNulls = false;\n  node.forEach(function (childNode, localStart) {\n    var found = takeSpansForNode(spans, childNode, localStart + offset);\n    if (found) {\n      hasNulls = true;\n      var subtree = buildTree(found, childNode, offset + localStart + 1, options);\n      if (subtree != empty)\n        { children.push(localStart, localStart + childNode.nodeSize, subtree); }\n    }\n  });\n  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) { options.onRemove(locals[i].spec); }\n    locals.splice(i--, 1);\n  } }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  var working = spans;\n  for (var i = 0; i < working.length - 1; i++) {\n    var span = working[i];\n    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {\n      var next = working[j];\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to);\n          insertAhead(working, j + 1, next.copy(span.to, next.to));\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from);\n          insertAhead(working, j, span.copy(next.from, span.to));\n        }\n        break\n      }\n    } }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }\n  array.splice(i, 0, deco);\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n  var found = [];\n  view.someProp(\"decorations\", function (f) {\n    var result = f(view.state);\n    if (result && result != empty) { found.push(result); }\n  });\n  if (view.cursorWrapper)\n    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }\n  return DecorationGroup.from(found)\n}\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nvar EditorView = function EditorView(place, props) {\n  this._props = props;\n  // :: EditorState\n  // The view's current [state](#state.EditorState).\n  this.state = props.state;\n\n  this.directPlugins = props.plugins || [];\n  this.directPlugins.forEach(checkStateComponent);\n\n  this.dispatch = this.dispatch.bind(this);\n\n  this._root = null;\n  this.focused = false;\n  // Kludge used to work around a Chrome bug\n  this.trackWrites = null;\n\n  // :: dom.Element\n  // An editable DOM node containing the document. (You probably\n  // should not directly interfere with its content.)\n  this.dom = (place && place.mount) || document.createElement(\"div\");\n  if (place) {\n    if (place.appendChild) { place.appendChild(this.dom); }\n    else if (place.apply) { place(this.dom); }\n    else if (place.mount) { this.mounted = true; }\n  }\n\n  // :: bool\n  // Indicates whether the editor is currently [editable](#view.EditorProps.editable).\n  this.editable = getEditable(this);\n  this.markCursor = null;\n  this.cursorWrapper = null;\n  updateCursorWrapper(this);\n  this.nodeViews = buildNodeViews(this);\n  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n\n  this.lastSelectedViewDesc = null;\n  // :: ?{slice: Slice, move: bool}\n  // When editor content is being dragged, this object contains\n  // information about the dragged slice and whether it is being\n  // copied or moved. At any other time, it is null.\n  this.dragging = null;\n\n  initInput(this);\n\n  this.prevDirectPlugins = [];\n  this.pluginViews = [];\n  this.updatePluginViews();\n};\n\nvar prototypeAccessors$2 = { props: { configurable: true },root: { configurable: true },isDestroyed: { configurable: true } };\n\n// composing:: boolean\n// Holds `true` when a\n// [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)\n// is active.\n\n// :: DirectEditorProps\n// The view's current [props](#view.EditorProps).\nprototypeAccessors$2.props.get = function () {\n  if (this._props.state != this.state) {\n    var prev = this._props;\n    this._props = {};\n    for (var name in prev) { this._props[name] = prev[name]; }\n    this._props.state = this.state;\n  }\n  return this._props\n};\n\n// :: (DirectEditorProps)\n// Update the view's props. Will immediately cause an update to\n// the DOM.\nEditorView.prototype.update = function update (props) {\n  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }\n  this._props = props;\n  if (props.plugins) {\n    props.plugins.forEach(checkStateComponent);\n    this.directPlugins = props.plugins;\n  }\n  this.updateStateInner(props.state, true);\n};\n\n// :: (DirectEditorProps)\n// Update the view by updating existing props object with the object\n// given as argument. Equivalent to `view.update(Object.assign({},\n// view.props, props))`.\nEditorView.prototype.setProps = function setProps (props) {\n  var updated = {};\n  for (var name in this._props) { updated[name] = this._props[name]; }\n  updated.state = this.state;\n  for (var name$1 in props) { updated[name$1] = props[name$1]; }\n  this.update(updated);\n};\n\n// :: (EditorState)\n// Update the editor's `state` prop, without touching any of the\n// other props.\nEditorView.prototype.updateState = function updateState (state) {\n  this.updateStateInner(state, this.state.plugins != state.plugins);\n};\n\nEditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {\n    var this$1 = this;\n\n  var prev = this.state, redraw = false, updateSel = false;\n  // When stored marks are added, stop composition, so that they can\n  // be displayed.\n  if (state.storedMarks && this.composing) {\n    clearComposition(this);\n    updateSel = true;\n  }\n  this.state = state;\n  if (reconfigured) {\n    var nodeViews = buildNodeViews(this);\n    if (changedNodeViews(nodeViews, this.nodeViews)) {\n      this.nodeViews = nodeViews;\n      redraw = true;\n    }\n    ensureListeners(this);\n  }\n\n  this.editable = getEditable(this);\n  updateCursorWrapper(this);\n  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n\n  var scroll = reconfigured ? \"reset\"\n      : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n  if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }\n  var oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n\n  if (updateSel) {\n    this.domObserver.stop();\n    // Work around an issue in Chrome, IE, and Edge where changing\n    // the DOM around an active selection puts it into a broken\n    // state where the thing the user sees differs from the\n    // selection reported by the Selection object (#710, #973,\n    // #1011, #1013, #1035).\n    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&\n        !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n    if (updateDoc) {\n      // If the node that the selection points into is written to,\n      // Chrome sometimes starts misreporting the selection, so this\n      // tracks that and forces a selection reset when our update\n      // did write to the node.\n      var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;\n      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n        this.docView.updateOuterDeco([]);\n        this.docView.destroy();\n        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n      }\n      if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }\n    }\n    // Work around for an issue where an update arriving right between\n    // a DOM selection change and the \"selectionchange\" event for it\n    // can cause a spurious DOM selection update, disrupting mouse\n    // drag selection.\n    if (forceSelUpdate ||\n        !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {\n      selectionToDOM(this, forceSelUpdate);\n    } else {\n      syncNodeSelection(this, state.selection);\n      this.domObserver.setCurSelection();\n    }\n    this.domObserver.start();\n  }\n\n  this.updatePluginViews(prev);\n\n  if (scroll == \"reset\") {\n    this.dom.scrollTop = 0;\n  } else if (scroll == \"to selection\") {\n    var startDOM = this.root.getSelection().focusNode;\n    if (this.someProp(\"handleScrollToSelection\", function (f) { return f(this$1); }))\n      ; // Handled\n    else if (state.selection instanceof NodeSelection)\n      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }\n    else\n      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }\n  } else if (oldScrollPos) {\n    resetScrollPos(oldScrollPos);\n  }\n};\n\nEditorView.prototype.destroyPluginViews = function destroyPluginViews () {\n  var view;\n  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }\n};\n\nEditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {\n  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n    this.prevDirectPlugins = this.directPlugins;\n    this.destroyPluginViews();\n    for (var i = 0; i < this.directPlugins.length; i++) {\n      var plugin = this.directPlugins[i];\n      if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }\n    }\n    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {\n      var plugin$1 = this.state.plugins[i$1];\n      if (plugin$1.spec.view) { this.pluginViews.push(plugin$1.spec.view(this)); }\n    }\n  } else {\n    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {\n      var pluginView = this.pluginViews[i$2];\n      if (pluginView.update) { pluginView.update(this, prevState); }\n    }\n  }\n};\n\n// :: (string, ?(prop: *) → *) → *\n// Goes over the values of a prop, first those provided directly,\n// then those from plugins given to the view, then from plugins in\n// the state (in order), and calls `f` every time a non-undefined\n// value is found. When `f` returns a truthy value, that is\n// immediately returned. When `f` isn't provided, it is treated as\n// the identity function (the prop value is returned directly).\nEditorView.prototype.someProp = function someProp (propName, f) {\n  var prop = this._props && this._props[propName], value;\n  if (prop != null && (value = f ? f(prop) : prop)) { return value }\n  for (var i = 0; i < this.directPlugins.length; i++) {\n    var prop$1 = this.directPlugins[i].props[propName];\n    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }\n  }\n  var plugins = this.state.plugins;\n  if (plugins) { for (var i$1 = 0; i$1 < plugins.length; i$1++) {\n    var prop$2 = plugins[i$1].props[propName];\n    if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) { return value }\n  } }\n};\n\n// :: () → bool\n// Query whether the view has focus.\nEditorView.prototype.hasFocus = function hasFocus () {\n  return this.root.activeElement == this.dom\n};\n\n// :: ()\n// Focus the editor.\nEditorView.prototype.focus = function focus () {\n  this.domObserver.stop();\n  if (this.editable) { focusPreventScroll(this.dom); }\n  selectionToDOM(this);\n  this.domObserver.start();\n};\n\n// :: union<dom.Document, dom.DocumentFragment>\n// Get the document root in which the editor exists. This will\n// usually be the top-level `document`, but might be a [shadow\n// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n// root if the editor is inside one.\nprototypeAccessors$2.root.get = function () {\n  var cached = this._root;\n  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {\n    if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n      if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }\n      return this._root = search\n    }\n  } }\n  return cached || document\n};\n\n// :: ({left: number, top: number}) → ?{pos: number, inside: number}\n// Given a pair of viewport coordinates, return the document\n// position that corresponds to them. May return null if the given\n// coordinates aren't inside of the editor. When an object is\n// returned, its `pos` property is the position nearest to the\n// coordinates, and its `inside` property holds the position of the\n// inner node that the position falls inside of, or -1 if it is at\n// the top level, not in any node.\nEditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {\n  return posAtCoords(this, coords)\n};\n\n// :: (number, number) → {left: number, right: number, top: number, bottom: number}\n// Returns the viewport rectangle at a given document position.\n// `left` and `right` will be the same number, as this returns a\n// flat cursor-ish rectangle. If the position is between two things\n// that aren't directly adjacent, `side` determines which element is\n// used. When < 0, the element before the position is used,\n// otherwise the element after.\nEditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {\n    if ( side === void 0 ) side = 1;\n\n  return coordsAtPos(this, pos, side)\n};\n\n// :: (number, number) → {node: dom.Node, offset: number}\n// Find the DOM position that corresponds to the given document\n// position. When `side` is negative, find the position as close as\n// possible to the content before the position. When positive,\n// prefer positions close to the content after the position. When\n// zero, prefer as shallow a position as possible.\n//\n// Note that you should **not** mutate the editor's internal DOM,\n// only inspect it (and even that is usually not necessary).\nEditorView.prototype.domAtPos = function domAtPos (pos, side) {\n    if ( side === void 0 ) side = 0;\n\n  return this.docView.domFromPos(pos, side)\n};\n\n// :: (number) → ?dom.Node\n// Find the DOM node that represents the document node after the\n// given position. May return `null` when the position doesn't point\n// in front of a node or if the node is inside an opaque node view.\n//\n// This is intended to be able to call things like\n// `getBoundingClientRect` on that DOM node. Do **not** mutate the\n// editor DOM directly, or add styling this way, since that will be\n// immediately overriden by the editor as it redraws the node.\nEditorView.prototype.nodeDOM = function nodeDOM (pos) {\n  var desc = this.docView.descAt(pos);\n  return desc ? desc.nodeDOM : null\n};\n\n// :: (dom.Node, number, ?number) → number\n// Find the document position that corresponds to a given DOM\n// position. (Whenever possible, it is preferable to inspect the\n// document structure directly, rather than poking around in the\n// DOM, but sometimes—for example when interpreting an event\n// target—you don't have a choice.)\n//\n// The `bias` parameter can be used to influence which side of a DOM\n// node to use when the position is inside a leaf node.\nEditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {\n    if ( bias === void 0 ) bias = -1;\n\n  var pos = this.docView.posFromDOM(node, offset, bias);\n  if (pos == null) { throw new RangeError(\"DOM position not inside the editor\") }\n  return pos\n};\n\n// :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n// Find out whether the selection is at the end of a textblock when\n// moving in a given direction. When, for example, given `\"left\"`,\n// it will return true if moving left from the current cursor\n// position would leave that position's parent textblock. Will apply\n// to the view's current state by default, but it is possible to\n// pass a different state.\nEditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {\n  return endOfTextblock(this, state || this.state, dir)\n};\n\n// :: ()\n// Removes the editor from the DOM and destroys all [node\n// views](#view.NodeView).\nEditorView.prototype.destroy = function destroy () {\n  if (!this.docView) { return }\n  destroyInput(this);\n  this.destroyPluginViews();\n  if (this.mounted) {\n    this.docView.update(this.state.doc, [], viewDecorations(this), this);\n    this.dom.textContent = \"\";\n  } else if (this.dom.parentNode) {\n    this.dom.parentNode.removeChild(this.dom);\n  }\n  this.docView.destroy();\n  this.docView = null;\n};\n\n// :: boolean\n// This is true when the view has been\n// [destroyed](#view.EditorView.destroy) (and thus should not be\n// used anymore).\nprototypeAccessors$2.isDestroyed.get = function () {\n  return this.docView == null\n};\n\n// Used for testing.\nEditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {\n  return dispatchEvent(this, event)\n};\n\n// :: (Transaction)\n// Dispatch a transaction. Will call\n// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n// when given, and otherwise defaults to applying the transaction to\n// the current state and calling\n// [`updateState`](#view.EditorView.updateState) with the result.\n// This method is bound to the view instance, so that it can be\n// easily passed around.\nEditorView.prototype.dispatch = function dispatch (tr) {\n  var dispatchTransaction = this._props.dispatchTransaction;\n  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }\n  else { this.updateState(this.state.apply(tr)); }\n};\n\nObject.defineProperties( EditorView.prototype, prototypeAccessors$2 );\n\nfunction computeDocDeco(view) {\n  var attrs = Object.create(null);\n  attrs.class = \"ProseMirror\";\n  attrs.contenteditable = String(view.editable);\n  attrs.translate = \"no\";\n\n  view.someProp(\"attributes\", function (value) {\n    if (typeof value == \"function\") { value = value(view.state); }\n    if (value) { for (var attr in value) {\n      if (attr == \"class\")\n        { attrs.class += \" \" + value[attr]; }\n      if (attr == \"style\") {\n        attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n      }\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        { attrs[attr] = String(value[attr]); }\n    } }\n  });\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    var dom = document.createElement(\"img\");\n    dom.className = \"ProseMirror-separator\";\n    dom.setAttribute(\"mark-placeholder\", \"true\");\n    dom.setAttribute(\"alt\", \"\");\n    view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};\n  } else {\n    view.cursorWrapper = null;\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", function (value) { return value(view.state) === false; })\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)\n}\n\nfunction buildNodeViews(view) {\n  var result = {};\n  view.someProp(\"nodeViews\", function (obj) {\n    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))\n      { result[prop] = obj[prop]; } }\n  });\n  return result\n}\n\nfunction changedNodeViews(a, b) {\n  var nA = 0, nB = 0;\n  for (var prop in a) {\n    if (a[prop] != b[prop]) { return true }\n    nA++;\n  }\n  for (var _ in b) { nB++; }\n  return nA != nB\n}\n\nfunction checkStateComponent(plugin) {\n  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n    { throw new RangeError(\"Plugins passed directly to the view must not have a state component\") }\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string, plain: bool) → string\n//   Transform pasted plain text. The `plain` flag will be true when\n//   the text is pasted as plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//   The `plain` flag will be true when the text is pasted as plain text.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   `innerDecorations` holds the decorations for the node's content.\n//   You can safely ignore this if your view has no content or a\n//   `contentDOM` property, since the editor will draw the decorations\n//   on the content. But if you, for example, want to create a nested\n//   editor with the content, it may make sense to provide it with the\n//   inner decorations.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used. This object will only have its\n//   [`serializeFragment`](#model.DOMSerializer.serializeFragment)\n//   method called, and you may provide an alternative object type\n//   implementing a compatible method.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSource\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   plugins:: [Plugin]\n//   A set of plugins to use in the view, applying their [plugin\n//   view](#state.PluginSpec.view) and\n//   [props](#state.PluginSpec.props). Passing plugins with a state\n//   component (a [state field](#state.PluginSpec.state) field or a\n//   [transaction](#state.PluginSpec.filterTransaction) filter or\n//   appender) will result in an error, since such plugins must be\n//   present in the state to work.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n\nexport { Decoration, DecorationSet, EditorView, endComposition as __endComposition, parseFromClipboard as __parseFromClipboard, serializeForClipboard as __serializeForClipboard };\n//# sourceMappingURL=index.es.js.map\n"],"names":["deleteSelection","state","dispatch","selection","empty","tr","scrollIntoView","joinBackward","view","$cursor","endOfTextblock","parentOffset","$cut","findCutBefore","range","blockRange","target","lift","before","nodeBefore","type","spec","isolating","deleteBarrier","parent","content","size","textblockAt","delStep","doc","after","slice","to","from","step","setSelection","resolve","mapping","map","pos","nodeSize","isAtom","depth","delete","node","side","only","firstChild","lastChild","isTextblock","childCount","selectNodeBackward","ref","$head","$pos","i","index","joinForward","findCutAfter","nodeAfter","selectNodeForward","newlineInCode","$anchor","code","sameParent","insertText","defaultBlockAt","match","edgeCount","edge","hasRequiredAttrs","exitCode","above","indexAfter","contentMatchAt","canReplaceWith","replaceWith","createAndFill","createParagraphNear","sel","$from","$to","inlineContent","insert","liftEmptyBlock","end","split","splitBlock","isBlock","atEnd","deflt","types","can","first","$first","setNodeMarkup","conn","compatibleContent","canReplace","clearIncompatible","join","joinMaybeClear","canDelAfter","findWrapping","matchType","validEnd","wrap","length","create","copy","joinAt","selAfter","at","wrap$1","push","afterText","afterDepth","end$1","i$1","selectTextblockSide","isInline","start","selectTextblockStart","selectTextblockEnd","setBlockType","nodeType","attrs","applicable","nodesBetween","hasMarkup","chainCommands","commands","len","arguments","backspace","del","pcBaseKeymap","macBaseKeymap","key","Home","End","navigator","test","platform","os","wrapInList","listType","doJoin","outerRange","startIndex","$insert","endIndex","wrappers","joinBefore","found","splitDepth","splitPos","i$2","e","child","doWrapInList","liftListItem","itemType","endOfList","liftToOuterList","list","$start","item","atStart","indexBefore","append","liftOutOfList","isPlainObject","value","Object","prototype","toString","call","getType","constructor","getPrototypeOf","mergeDeep","source","output","keys","forEach","assign","isFunction","callOrReturn","context","props","bind","getExtensionField","extension","field","undefined","config","Extension","this","name","defaultOptions","console","warn","options","addOptions","storage","static","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","text","separated","_a","textSerializer","isText","Math","max","getTextSeralizersFromSchema","schema","fromEntries","entries","nodes","filter","toText","ClipboardTextSerializer","addProseMirrorPlugins","clipboardTextSerializer","editor","ranges","min","blur$1","freeze","__proto__","blur","requestAnimationFrame","isDestroyed","dom","window","getSelection","removeAllRanges","clearContent$1","clearContent","emitUpdate","setContent","clearNodes$1","clearNodes","$mappedFrom","$mappedTo","nodeRange","targetLiftDepth","defaultType","command$1","command","fn","createParagraphNear$1","getNodeType","nameOrType","Error","deleteNode$1","deleteNode","typeOrName","deleteRange$1","deleteRange","deleteSelection$1","enter$1","enter","keyboardShortcut","exitCode$1","getMarkType","marks","isRegExp","objectIncludes","object1","object2","strict","every","findMarkInSet","attributes","find","isMarkInSet","getMarkRange","childAfter","mark","startPos","offset","endPos","isInSet","extendMarkRange$1","extendMarkRange","newSelection","first$1","items","isObject","Array","isArray","substring","isClass","isTextSelection","isiOS","includes","userAgent","document","minMax","resolveFocusPosition","position","selectionAtStart","selectionAtEnd","minPos","maxPos","focus$1","focus","delayedFocus","hasFocus","isSameSelection","eq","storedMarks","setStoredMarks","forEach$1","insertContent$1","insertContent","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","nodeFromJSON","error","parser","parseSlice","parse","insertContentAt$1","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","startsWith","check","startLen","bias","last","steps","maps","_from","_to","_newFrom","newTo","selectionToInsertionEnd","joinBackward$1","joinForward$1","isMacOS","keyboardShortcut$1","parts","alt","ctrl","shift","meta","result","mod","normalizeKeyName","event","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","reduce","sum","lift$1","liftEmptyBlock$1","liftListItem$1","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes$1","resetAttributes","markType","schemaType","addMark","scrollIntoView$1","selectAll$1","selectAll","setTextSelection","selectNodeBackward$1","selectNodeForward$1","selectParentNode$1","selectParentNode","same","sharedDepth","selectTextblockEnd$1","selectTextblockStart$1","createDocument","setContent$1","replaceSelectionWith","setMeta","getMarkAttributes","markItem","setMark$1","setMark","oldAttributes","addStoredMark","trimmedFrom","trimmedTo","setMeta$1","setNode$1","setNode","chain","updatedState","run","setNodeSelection$1","setNodeSelection","resolvedPos","setTextSelection$1","resolvedFrom","resolvedEnd","sinkListItem$1","sinkListItem","nestedBefore","inner","getSplittedAttributes","extensionAttributes","typeName","extensionAttribute","attribute","keepOnSplit","ensureMarks","splittableMarks","filteredMarks","splitBlock$1","keepMarks","newAttributes","extensionManager","defaultBlockAt$1","splitListItem$1","splitListItem","grandParent","depthBefore","d","depthAfter","newNextTypeAttributes","nextType","contentMatch","replace","n","newTypeAttributes","findParentNodeClosestToPos","predicate","findParentNode","splitExtensions","extensions","baseExtensions","nodeExtensions","markExtensions","isList","group","joinListBackwards","nodeAt","joinListForwards","toggleList$1","toggleList","listTypeOrName","itemTypeOrName","parentList","validContent","isMarkActive","markRanges","matchedRange","markRange","excludedRange","excludes","toggleMark$1","toggleMark","extendEmptyMarkRange","unsetMark","toggleNode$1","toggleNode","toggleTypeOrName","toggleType","toggleWrap$1","toggleWrap","wrapIn","undoInputRule$1","undoInputRule","plugins","plugin","undoable","isInputRules","getState","toUndo","transform","j","invert","docs","unsetAllMarks$1","unsetAllMarks","removeMark","unsetMark$1","removeStoredMark","updateAttributes$1","updateAttributes","wrapIn$1","wrapping","wrapInList$1","Commands","addCommands","Editable","editable","FocusEvents","handleDOMEvents","isFocused","transaction","createChainableState","apply","applyTransaction","reconfigure","toJSON","CommandManager","rawCommands","customState","hasCustomState","buildProps","args","callback","getMeta","createChain","createCan","startTr","shouldDispatch","callbacks","hasStartTransaction","formattedCommands","Keymap","addKeyboardShortcuts","handleBackspace","isAtStart","textContent","handleDelete","baseKeymap","Enter","Backspace","Delete","pcKeymap","macKeymap","appendTransaction","transactions","oldState","newState","some","docChanged","allFrom","allEnd","allWasSelected","isEmpty","textBetween","Tabindex","isEditable","tabindex","getNodeAttributes","reverse","nodeItem","getAttributes","isActive","getHTMLFromFragment","fragment","documentFragment","serializeFragment","container","implementation","createHTMLDocument","createElement","appendChild","innerHTML","getText","isNodeEmpty","defaultContent","JSON","stringify","InputRule","handler","run$1","rules","composing","matched","textBefore","rule","exec","inputRuleMatch","input","data","inputRuleMatcherHandler","inputRulesPlugin","init","prev","stored","selectionSet","handleTextInput","compositionend","setTimeout","handleKeyDown","PasteRule","handlers","resolvedTo","matchAll","matches","pasteRuleMatch","pasteRuleMatcherHandler","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","parentElement","contains","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","getAttributesFromExtensions","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","addGlobalAttributes","globalAttribute","addAttributes","mergeAttributes","objects","mergedAttributes","getRenderedAttributes","nodeOrMark","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","Number","fromString","getAttribute","cleanUpSchemaItem","isEmptyObject","getSchemaByResolvedExtensions","allAttributes","topNode","fields","extendNodeSchema","inline","atom","selectable","draggable","defining","parseDOM","toDOM","HTMLAttributes","renderText","extendMarkSchema","inclusive","spanning","getSchemaTypeByName","isExtensionRulesEnabled","enabled","enabledExtension","ExtensionManager","extensionStorage","onBeforeCreate","on","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","filtered","el","indexOf","Set","findDuplicates","addExtensions","flat","a","priorityA","priorityB","inputRules","pasteRules","allPlugins","bindings","shortcut","method","keyMapPlugin","addInputRules","enableInputRules","addPasteRules","enablePasteRules","proseMirrorPlugins","nodeViews","addNodeView","getPos","decorations","Editor","emit","off","removeAllListeners","super","element","injectCSS","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","tipTapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","createStyleTag","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","allExtensions","values","dispatchTransaction","createNodeViews","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","Node","Mark","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","_b","_c","dragHandle","closest","x","y","domBox","getBoundingClientRect","handleBox","offsetX","offsetY","dataTransfer","setDragImage","isDropEvent","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","isDragEvent","preventDefault","once","mutation","isLeaf","addedNodes","removedNodes","Tracker","currentStep","deleted","newPosition","mapResult","getMap","nodeInputRule","matchStart","lastIndexOf","lastChar","getMarksBetween","markInputRule","captureGroup","fullMatch","markEnd","startSpaces","search","textStart","textEnd","excluded","textblockTypeInputRule","textInputRule","cutOff","wrappingInputRule","joinPredicate","markPasteRule","textPasteRule","escapeForRegEx","string","combineTransactionSteps","oldDoc","findChildren","nodesWithPos","descendants","findChildrenInRange","getSchema","generateHTML","generateJSON","generateText","simplifyChangedRanges","changes","uniqueChanges","array","by","seen","hasOwnProperty","removeDuplicates","change","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","newStart","newEnd","oldStart","oldEnd","getDebugJSON","startOffset","increment","topNodeType","isNodeSelection","posToDOMRect","coordsAtPos","top","bottom","left","right","width","height","base","chrome","safari","vendor","gecko","mac","ie","brokenModifierNames","String","fromCharCode","modifiers","keymap","keydownHandler","normalize","baseName","keyCode","keyName","isChar","direct","charCodeAt","fromCode","withShift","OrderedMap","get","update","newKey","self","remove","splice","addToStart","concat","addToEnd","addBefore","place","without","prepend","subtract","childA","childB","sameMarkup","posA","posB","iA","iB","minSize","Fragment","prototypeAccessors","configurable","nodeStart","leafText","other","withText","cut","cutByIndex","replaceChild","current","RangeError","maybeChild","p","otherPos","findIndex","round","retIndex","curPos","toStringInner","fromJSON","fromArray","joined","defineProperties","compareDeep","p$1","ReplaceError","message","err","addToSet","set","placed","rank","removeFromSet","json","sameSet","setFrom","none","Slice","openStart","openEnd","prototypeAccessors$1","removeRange","ref$1","indexTo","offsetTo","insertInto","dist","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","replaceThreeWay","replaceTwoWay","checkJoin","main","sub","joinable","$before","$after","addNode","addRange","$end","textOffset","insertAt","removeBetween","maxOpen","openIsolating","n$1","ResolvedPos","path","prototypeAccessors$2","resolveDepth","val","dOff","posAtIndex","tmp","marksAcross","next","pred","NodeRange","str","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1","emptyAttrs","prototypeAccessors$3","defaultAttrs","includeParents","childBefore","rangeHasMark","toDebugString","wrapMarks","matchFragment","replacement","one","two","allowsMarks","canAppend","m","markFromJSON","TextNode","ContentMatch","wrapCache","prototypeAccessors$4","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","states$1","cmp","dfa","connect","compile","edges","exprs","loop","loop$1","cur","next$1","next$2","work","dead","checkForDeadEnds","frag","compatible","fillBefore","toEnd","finished","tp","computed","computeWrapping","active","via","scan","tokens","pop","prototypeAccessors$1$2","parseExprSeq","eat","parseExprSubscript","type$1","groups","resolveName","parseExprAtom","parseExprRange","parseNum","defaults","attrName","attr","hasDefault","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","markSet","prototypeAccessors$5","whitespace","isRequired","createChecked","allowsMarkType","allowedMarks","topType","prototypeAccessors$1$3","MarkType","instance","Schema","contentExprCache","prop$1","contentExpr","markExpr","gatherMarks","prop$2","excl","wrappings","ok","mark$1","text$1","this$1","tags","styles","tag","normalizeLists","r","ParseContext","addAll","finish","matchTag","namespace","namespaceURI","matchesContext","matchStyle","schemaRules","priority","rules$1","name$1","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","OPT_PRESERVE_WS","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","popFromStashMark","applyPending","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","prototypeAccessors$6","currentPos","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","v","returned","addDOM","addTextNode","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","prevItem","nextSibling","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","startIn","getContent","contentElement","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","compareDocumentPosition","textNode","option","useRoot","minDepth","part","$context","findSameMarkInSet","upto","level","stashMark","DOMSerializer","gatherToDOM","createDocumentFragment","keep","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","structure","xmlNS","space","createElementNS","space$1","setAttributeNS","innerContent","domSerializer","nodesFromSchema","marksFromSchema","classesById","Selection","SelectionRange","anchor","lastNode","lastParent","mapFrom","replaceRange","replaceRangeWith","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","AllSelection","cls","jsonID","id","selectionClass","getBookmark","between","visible","TextBookmark","dPos","NodeSelection","NodeBookmark","AllBookmark","Transaction","Transform","time","Date","now","curSelection","curSelectionFor","updated","storedMarksSet","isGeneric","scrolledIntoView","addStep","setTime","replaceSelection","inheritMarks","FieldDesc","desc","baseFields","_marks","_old","Configuration","pluginsByKey","EditorState","filterTransaction","rootTr","trs","applyInner","haveNew","newInstance","applyListeners","$config","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","createKey","PluginKey","factor16","pow","recoverIndex","MapResult","recover","StepMap","inverted","diff","recoverOffset","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","Mapping","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","mustOverride","failed","stepsByID","Step","_doc","_mapping","merge","_other","stepType","stepClass","StepResult","fail","fromReplace","ReplaceStep","contentBetween","slice$1","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","canCut","liftTarget","innerRange","around","outer","findWrappingOutside","inside","innerMatch","findWrappingInside","withAttrs","canSplit","typesAfter","innerType","index$1","rest","baseType","canJoin","dropPoint","pass","insertPos","fits","mapFragment","mapped","gapStart","gapEnd","splitting","d$1","splitting$1","canChangeType","startM","endM","newNode","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","replaceStep","fitsTrivially","Fitter","fit","removed","added","removing","adding","newSet","s","toRemove","found$1","parentType","delSteps","allowed","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","close","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","match$1","move","targetDepths","preferredTarget","unshift","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","point","insertPoint","covered","ie_edge","ie_upto10","ie_11up","ie_version","documentMode","gecko_version","chrome_version","ios","maxTouchPoints","android","webkit","documentElement","webkit_version","domIndex","assignedSlot","host","reusedRange","textRange","createRange","setEnd","setStart","isEquivalentPosition","targetNode","targetOff","scanFor","atomElements","hasBlockDesc","contentEditable","pmViewDesc","selectionCollapsed","domSel","collapsed","isCollapsed","rangeCount","getRangeAt","keyEvent","createEvent","initEvent","windowRect","clientWidth","clientHeight","getSide","clientRect","rect","scaleX","offsetWidth","scaleY","offsetHeight","scrollRectIntoView","startDOM","scrollThreshold","scrollMargin","atTop","bounding","moveX","moveY","defaultView","scrollBy","startX","scrollLeft","startY","scrollTop","dX","dY","scrollStack","stack","restoreScrollStack","dTop","preventScrollSupported","findOffsetInNode","coords","coordsClosest","dxClosest","rowBot","rowTop","childIndex","rects","getClientRects","dx","singleRect","inRect","findOffsetInText","elementFromPoint","box","startI","floor","posAtCoords","assign$1","caretPositionFromPoint","pos$1","offsetNode","caretRangeFromPoint","startContainer","elt","root","targetKludge","box$1","outside","nearestDesc","posBefore","posAfter","posFromDOM","posFromCaret","posFromElement","posAtStart","border","BIDI","domFromPos","supportEmptyRange","takeSide","flattenV","rectBefore","rectAfter","flattenH","before$1","after$1","ignoreForCoords","target$1","withFlushedState","viewState","activeElement","maybeRTL","cachedState","cachedDir","cachedResult","nearest","boxes","endOfTextblockVertical","modify","oldNode","focusNode","oldOff","focusOffset","oldBidiLevel","caretBidiLevel","domAfterPos","endOfTextblockHorizontal","ViewDesc","children","dirty","posAtEnd","contentLost","domAtom","matchesWidget","matchesMark","matchesNode","matchesHack","_nodeName","posBeforeChild","localPosFromDOM","domBefore","domAfter","desc$1","search$1","onlyNodes","getDesc","nodeDOM","descAt","TrailingHackViewDesc","WidgetViewDesc","widget","prev$1","parseRange","fromOffset","toOffset","childBase","emptyChildAt","j$1","force","anchorDOM","headDOM","brKludge","offset$1","anchorNode","anchorOffset","domSelExtended","collapse","DOMException","markDirty","startInside","endInside","markParentsDirty","nothing","raw","classList","stop","ignoreSelection","CompositionViewDesc","textDOM","mut","oldValue","MarkViewDesc","custom","reparseInView","replaceNodes","NodeViewDesc","outerDeco","innerDeco","updateChildren","descObj","hasAttribute","applyOuterDeco","CustomNodeViewDesc","TextViewDesc","sameOuterDeco","composition","localCompositionInfo","localComposition","compositionInChild","updater","ViewTreeUpdater","deco","onWidget","onNode","locals","forChild","decoIndex","restNode","parentIndex","widgets","compareSide","child$1","cutAt","i$3","iterDeco","insideNode","syncToMarks","placeWidget","compIndex","findNodeMatch","findIndexWithChild","updateNodeAt","updateNextNode","addTextblockHacks","destroyRest","changed","protectLocalComposition","renderDescs","oldCSS","cssText","getComputedStyle","listStyle","iosHacks","nearbyTextNode","textPos","childStart","findTextInFragment","removeChild","compositionNodes","updateInner","updateOuterDeco","needsWrap","oldDOM","patchOuterDeco","computeOuterDeco","selectNode","deselectNode","removeAttribute","docViewDesc","pmIsDeco","inParent","trackWrites","parentDOM","descs","written","childDOM","rm","insertBefore","OuterDecoLevel","noDeco","class","outerDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","Boolean","curList","removeProperty","lockedNode","lock","preMatch","parentDesc","curDesc","descI","fI","Map","selectionFromDOM","origin","inWidget","isOnEdge","selectionBetween","editorOwnsSelection","hasSelection","selectionToDOM","syncNodeSelection","mouseDown","allowDefault","curSel","domObserver","currentSelection","delayedSelectionSync","setCurSelection","disconnectSelection","cursorWrapper","img","disabled","selectCursorWrapper","resetEditableFrom","resetEditableTo","brokenSelectBetweenUneditable","temporarilyEditableNear","resetEditable","hideSelectionGuard","removeClassOnSelectionChange","connectSelection","destroyBetween","maxKeep","markDesc","targetDesc","has","domNode","nextDOM","addHackNode","className","wasDraggable","lastSelectedViewDesc","clearNodeSelection","moveSelectionBlock","$side","selectHorizontally","mods","nodePos","nodeLen","isIgnorable","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","setSelFocus","skipIgnoredNodesRight","selectVertically","beyond","stopNativeHorizontalDelete","nextNode","switchEditable","captureKeyDown","getMods","safariDownArrowBug","readDOMChange","typeOver","lastSelectionTime","lastSelectionOrigin","newSel","tr$1","shared","from_","to_","lastKeyCode","startDoc","editableContent","anchor$1","parseBetween","preferredPos","preferredSide","compare","lastKeyCodeTime","endA","endB","findDiff","lastIOSEnter","sel$1","resolveSelection","domChangeCount","nextSel","inlineChange","old","$newStart","$newEnd","skipClosingAndOpening","$next","looksLikeJoin","suppressSelectionUpdates","toB","lastAndroidDelete","markChange","$from1","chFrom","chTo","curMarks","prevMarks","isMarkChange","sel$2","parsedSel","fromEnd","mayOpen","serializeForClipboard","serializer","detachedDoc","wrapMap","wrapper","parseFromClipboard","plainText","inCode","asText","parsed","metas","firstTag","readHTML","querySelectorAll","restoreReplacedSpaces","contextNode","sliceData","inlineParents","addContext","closeSlice","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","normalizeSiblings","node$1","sibling","closeRange","thead","tbody","caption","colgroup","col","td","th","_detachedDoc","observeOptions","childList","characterData","characterDataOldValue","attributeOldValue","subtree","useCharData","SelectionState","DOMObserver","handleDOMChange","queue","flushingSoon","observer","MutationObserver","mutations","flushSoon","flush","onCharData","prevValue","onSelectionChange","suppressingSelectionUpdates","forceFlush","clearTimeout","observe","take","takeRecords","disconnect","ignoreSelectionChange","commonAncestorContainer","result$1","registerMutation","brs","cssChecked","whiteSpace","checkCSS","attributeName","editHandlers","setSelectionOrigin","ensureListeners","currentHandlers","eventHandlers","runCustomHandler","defaultPrevented","eventCoords","clientX","clientY","runHandlerOnContext","propName","focused","handleSingleClick","selectedNode","selectAt","selectClickedNode","selectClickedLeaf","handleDoubleClick","handleTripleClick","button","defaultTripleClick","forceDOMFlush","endComposition","keydown","inOrNearComposition","lastIOSEnterFallbackTimeout","keyup","keypress","charCode","selectNodeModifier","mousedown","flushed","lastClick","click","dy","isNear","done","MouseDown","targetPos","mightDrag","addAttr","setUneditable","up","abs","timeStamp","compositionEndedAt","buttons","touchdown","contextmenu","timeoutComposition","scheduleComposeEnd","delay","composingTimeout","clearComposition","forceUpdate","compositionstart","compositionupdate","markCursor","brokenClipboardAPI","doPaste","singleNode","sliceSingleNode","clearData","setData","selectNodeContents","captureCopy","capturePaste","Dragging","dragCopyModifier","dragstart","effectAllowed","dragging","dragend","dragover","dragenter","eventPos","$mouse","isNode","beforeInsert","relatedTarget","beforeinput","inputType","compareObjs","WidgetType","noSpec","span","oldOffset","Decoration","valid","InlineType","inclusiveStart","inclusiveEnd","is","DecorationSet","local","buildTree","findInner","childOff","mapInner","newLocal","onRemove","oldChildren","dSize","mustRebuild","fromLocal","toLocal","childOffset","childNode","gather","mapAndGatherRemainingDecorations","from$1","byPos","mapChildren","addInner","baseOffset","takeSpansForNode","moveSpans","withoutNulls","removeInner","span$1","dec","localSet","DecorationGroup","removeOverlap","localsInner","members","spans","hasNulls","localStart","working","insertAhead","viewDecorations","mappedDecos","member","sorted","EditorView","_props","directPlugins","checkStateComponent","_root","mounted","getEditable","updateCursorWrapper","buildNodeViews","computeDocDeco","eventBelongsToView","initInput","prevDirectPlugins","pluginViews","updatePluginViews","contenteditable","translate","updateStateInner","reconfigured","redraw","updateSel","nA","nB","changedNodeViews","scroll","scrollToSelection","updateDoc","sel1","sel2","refDOM","refTop","newRefTop","oldScrollPos","overflowAnchor","innerHeight","localRect","storeScrollPos","forceSelUpdate","chromeKludge","destroyPluginViews","prevState","pluginView","plugin$1","setActive","preventScroll","focusPreventScroll","domAtPos","posAtDOM","destroyInput","dispatchEvent"],"sourceRoot":""}