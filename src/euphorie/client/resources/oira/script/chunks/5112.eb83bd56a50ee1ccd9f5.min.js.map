{"version":3,"file":"chunks/5112.eb83bd56a50ee1ccd9f5.min.js","mappings":"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","sources":["webpack://oira.prototype/./node_modules/prosemirror-tables/dist/index.es.js","webpack://oira.prototype/./node_modules/@tiptap/extension-table/dist/tiptap-extension-table.esm.js"],"sourcesContent":["import { PluginKey, TextSelection, Selection, SelectionRange, NodeSelection, Plugin } from 'prosemirror-state';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { keydownHandler } from 'prosemirror-keymap';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { Transform } from 'prosemirror-transform';\n\n// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nvar readFromCache, addToCache;\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != \"undefined\") {\n  var cache = new WeakMap;\n  readFromCache = function (key) { return cache.get(key); };\n  addToCache = function (key, value) {\n    cache.set(key, value);\n    return value\n  };\n} else {\n  var cache$1 = [], cacheSize = 10, cachePos = 0;\n  readFromCache = function (key) {\n    for (var i = 0; i < cache$1.length; i += 2)\n      { if (cache$1[i] == key) { return cache$1[i + 1] } }\n  };\n  addToCache = function (key, value) {\n    if (cachePos == cacheSize) { cachePos = 0; }\n    cache$1[cachePos++] = key;\n    return cache$1[cachePos++] = value\n  };\n}\n\nvar Rect = function Rect(left, top, right, bottom) {\n  this.left = left; this.top = top; this.right = right; this.bottom = bottom;\n};\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nvar TableMap = function TableMap(width, height, map, problems) {\n  // :: number The width of the table\n  this.width = width;\n  // :: number The table's height\n  this.height = height;\n  // :: [number] A width * height array with the start position of\n  // the cell covering that part of the table in each slot\n  this.map = map;\n  // An optional array of problems (cell overlap or non-rectangular\n  // shape) for the table, used by the table normalizer.\n  this.problems = problems;\n};\n\n// :: (number) → Rect\n// Find the dimensions of the cell at the given position.\nTableMap.prototype.findCell = function findCell (pos) {\n  for (var i = 0; i < this.map.length; i++) {\n    var curPos = this.map[i];\n    if (curPos != pos) { continue }\n    var left = i % this.width, top = (i / this.width) | 0;\n    var right = left + 1, bottom = top + 1;\n    for (var j = 1; right < this.width && this.map[i + j] == curPos; j++) { right++; }\n    for (var j$1 = 1; bottom < this.height && this.map[i + (this.width * j$1)] == curPos; j$1++) { bottom++; }\n    return new Rect(left, top, right, bottom)\n  }\n  throw new RangeError(\"No cell with offset \" + pos + \" found\")\n};\n\n// :: (number) → number\n// Find the left side of the cell at the given position.\nTableMap.prototype.colCount = function colCount (pos) {\n  for (var i = 0; i < this.map.length; i++)\n    { if (this.map[i] == pos) { return i % this.width } }\n  throw new RangeError(\"No cell with offset \" + pos + \" found\")\n};\n\n// :: (number, string, number) → ?number\n// Find the next cell in the given direction, starting from the cell\n// at `pos`, if any.\nTableMap.prototype.nextCell = function nextCell (pos, axis, dir) {\n  var ref = this.findCell(pos);\n    var left = ref.left;\n    var right = ref.right;\n    var top = ref.top;\n    var bottom = ref.bottom;\n  if (axis == \"horiz\") {\n    if (dir < 0 ? left == 0 : right == this.width) { return null }\n    return this.map[top * this.width + (dir < 0 ? left - 1 : right)]\n  } else {\n    if (dir < 0 ? top == 0 : bottom == this.height) { return null }\n    return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)]\n  }\n};\n\n// :: (number, number) → Rect\n// Get the rectangle spanning the two given cells.\nTableMap.prototype.rectBetween = function rectBetween (a, b) {\n  var ref = this.findCell(a);\n    var leftA = ref.left;\n    var rightA = ref.right;\n    var topA = ref.top;\n    var bottomA = ref.bottom;\n  var ref$1 = this.findCell(b);\n    var leftB = ref$1.left;\n    var rightB = ref$1.right;\n    var topB = ref$1.top;\n    var bottomB = ref$1.bottom;\n  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB),\n                  Math.max(rightA, rightB), Math.max(bottomA, bottomB))\n};\n\n// :: (Rect) → [number]\n// Return the position of all cells that have the top left corner in\n// the given rectangle.\nTableMap.prototype.cellsInRect = function cellsInRect (rect) {\n  var result = [], seen = {};\n  for (var row = rect.top; row < rect.bottom; row++) {\n    for (var col = rect.left; col < rect.right; col++) {\n      var index = row * this.width + col, pos = this.map[index];\n      if (seen[pos]) { continue }\n      seen[pos] = true;\n      if ((col != rect.left || !col || this.map[index - 1] != pos) &&\n          (row != rect.top || !row || this.map[index - this.width] != pos))\n        { result.push(pos); }\n    }\n  }\n  return result\n};\n\n// :: (number, number, Node) → number\n// Return the position at which the cell at the given row and column\n// starts, or would start, if a cell started there.\nTableMap.prototype.positionAt = function positionAt (row, col, table) {\n  for (var i = 0, rowStart = 0;; i++) {\n    var rowEnd = rowStart + table.child(i).nodeSize;\n    if (i == row) {\n      var index = col + row * this.width, rowEndIndex = (row + 1) * this.width;\n      // Skip past cells from previous rows (via rowspan)\n      while (index < rowEndIndex && this.map[index] < rowStart) { index++; }\n      return index == rowEndIndex ? rowEnd - 1 : this.map[index]\n    }\n    rowStart = rowEnd;\n  }\n};\n\n// :: (Node) → TableMap\n// Find the table map for the given table node.\nTableMap.get = function get (table) {\n  return readFromCache(table) || addToCache(table, computeMap(table))\n};\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") { throw new RangeError(\"Not a table node: \" + table.type.name) }\n  var width = findWidth(table), height = table.childCount;\n  var map = [], mapPos = 0, problems = null, colWidths = [];\n  for (var i = 0, e = width * height; i < e; i++) { map[i] = 0; }\n\n  for (var row = 0, pos = 0; row < height; row++) {\n    var rowNode = table.child(row);\n    pos++;\n    for (var i$1 = 0;; i$1++) {\n      while (mapPos < map.length && map[mapPos] != 0) { mapPos++; }\n      if (i$1 == rowNode.childCount) { break }\n      var cellNode = rowNode.child(i$1);\n      var ref = cellNode.attrs;\n      var colspan = ref.colspan;\n      var rowspan = ref.rowspan;\n      var colwidth = ref.colwidth;\n      for (var h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({type: \"overlong_rowspan\", pos: pos, n: rowspan - h});\n          break\n        }\n        var start = mapPos + (h * width);\n        for (var w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            { map[start + w] = pos; }\n          else\n            { (problems || (problems = [])).push({type: \"collision\", row: row, pos: pos, n: colspan - w}); }\n          var colW = colwidth && colwidth[w];\n          if (colW) {\n            var widthIndex = ((start + w) % width) * 2, prev = colWidths[widthIndex];\n            if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    var expectedPos = (row + 1) * width, missing = 0;\n    while (mapPos < expectedPos) { if (map[mapPos++] == 0) { missing++; } }\n    if (missing) { (problems || (problems = [])).push({type: \"missing\", row: row, n: missing}); }\n    pos++;\n  }\n\n  var tableMap = new TableMap(width, height, map, problems), badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2)\n    { if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) { badWidths = true; } }\n  if (badWidths) { findBadColWidths(tableMap, colWidths, table); }\n\n  return tableMap\n}\n\nfunction findWidth(table) {\n  var width = -1, hasRowSpan = false;\n  for (var row = 0; row < table.childCount; row++) {\n    var rowNode = table.child(row), rowWidth = 0;\n    if (hasRowSpan) { for (var j = 0; j < row; j++) {\n      var prevRow = table.child(j);\n      for (var i = 0; i < prevRow.childCount; i++) {\n        var cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) { rowWidth += cell.attrs.colspan; }\n      }\n    } }\n    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {\n      var cell$1 = rowNode.child(i$1);\n      rowWidth += cell$1.attrs.colspan;\n      if (cell$1.attrs.rowspan > 1) { hasRowSpan = true; }\n    }\n    if (width == -1)\n      { width = rowWidth; }\n    else if (width != rowWidth)\n      { width = Math.max(width, rowWidth); }\n  }\n  return width\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) { map.problems = []; }\n  for (var i = 0, seen = {}; i < map.map.length; i++) {\n    var pos = map.map[i];\n    if (seen[pos]) { continue }\n    seen[pos] = true;\n    var node = table.nodeAt(pos), updated = null;\n    for (var j = 0; j < node.attrs.colspan; j++) {\n      var col = (i + j) % map.width, colWidth = colWidths[col * 2];\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))\n        { (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth; }\n    }\n    if (updated) { map.problems.unshift({type: \"colwidth mismatch\", pos: pos, colwidth: updated}); }\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) { return attrs.colwidth.slice() }\n  var result = [];\n  for (var i = 0; i < attrs.colspan; i++) { result.push(0); }\n  return result\n}\n\n// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  var widthAttr = dom.getAttribute(\"data-colwidth\");\n  var widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(function (s) { return Number(s); }) : null;\n  var colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  var result = {\n    colspan: colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (var prop in extraAttrs) {\n    var getter = extraAttrs[prop].getFromDOM;\n    var value = getter && getter(dom);\n    if (value != null) { result[prop] = value; }\n  }\n  return result\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  var attrs = {};\n  if (node.attrs.colspan != 1) { attrs.colspan = node.attrs.colspan; }\n  if (node.attrs.rowspan != 1) { attrs.rowspan = node.attrs.rowspan; }\n  if (node.attrs.colwidth)\n    { attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\"); }\n  for (var prop in extraAttrs) {\n    var setter = extraAttrs[prop].setDOMAttr;\n    if (setter) { setter(node.attrs[prop], attrs); }\n  }\n  return attrs\n}\n\n// :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nfunction tableNodes(options) {\n  var extraAttrs = options.cellAttributes || {};\n  var cellAttrs = {\n    colspan: {default: 1},\n    rowspan: {default: 1},\n    colwidth: {default: null}\n  };\n  for (var prop in extraAttrs)\n    { cellAttrs[prop] = {default: extraAttrs[prop].default}; }\n\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{tag: \"table\"}],\n      toDOM: function toDOM() { return [\"table\", [\"tbody\", 0]] }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{tag: \"tr\"}],\n      toDOM: function toDOM() { return [\"tr\", 0] }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{tag: \"td\", getAttrs: function (dom) { return getCellAttrs(dom, extraAttrs); }}],\n      toDOM: function toDOM(node) { return [\"td\", setCellAttrs(node, extraAttrs), 0] }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{tag: \"th\", getAttrs: function (dom) { return getCellAttrs(dom, extraAttrs); }}],\n      toDOM: function toDOM(node) { return [\"th\", setCellAttrs(node, extraAttrs), 0] }\n    }\n  }\n}\n\nfunction tableNodeTypes(schema) {\n  var result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (var name in schema.nodes) {\n      var type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) { result[role] = type; }\n    }\n  }\n  return result\n}\n\n// Various helper function for working with tables\n\nvar key = new PluginKey(\"selectingCells\");\n\nfunction cellAround($pos) {\n  for (var d = $pos.depth - 1; d > 0; d--)\n    { if ($pos.node(d).type.spec.tableRole == \"row\") { return $pos.node(0).resolve($pos.before(d + 1)) } }\n  return null\n}\n\nfunction cellWrapping($pos) {\n  for (var d = $pos.depth; d > 0; d--) { // Sometimes the cell can be in the same depth.\n    var role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === 'header_cell') { return $pos.node(d) }\n  }\n  return null\n}\n\nfunction isInTable(state) {\n  var $head = state.selection.$head;\n  for (var d = $head.depth; d > 0; d--) { if ($head.node(d).type.spec.tableRole == \"row\") { return true } }\n  return false\n}\n\nfunction selectionCell(state) {\n  var sel = state.selection;\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head)\n}\n\nfunction cellNear($pos) {\n  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    var role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") { return $pos.doc.resolve(pos) }\n  }\n  for (var before = $pos.nodeBefore, pos$1 = $pos.pos; before; before = before.lastChild, pos$1--) {\n    var role$1 = before.type.spec.tableRole;\n    if (role$1 == \"cell\" || role$1 == \"header_cell\") { return $pos.doc.resolve(pos$1 - before.nodeSize) }\n  }\n}\n\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && $pos.nodeAfter\n}\n\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize)\n}\n\nfunction inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1)\n}\n\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1))\n}\n\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1))\n}\n\nfunction nextCell($pos, axis, dir) {\n  var start = $pos.start(-1), map = TableMap.get($pos.node(-1));\n  var moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved)\n}\n\nfunction setAttr(attrs, name, value) {\n  var result = {};\n  for (var prop in attrs) { result[prop] = attrs[prop]; }\n  result[name] = value;\n  return result\n}\n\nfunction removeColSpan(attrs, pos, n) {\n  if ( n === void 0 ) n=1;\n\n  var result = setAttr(attrs, \"colspan\", attrs.colspan - n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(function (w) { return w > 0; })) { result.colwidth = null; }\n  }\n  return result\n}\n\nfunction addColSpan(attrs, pos, n) {\n  if ( n === void 0 ) n=1;\n\n  var result = setAttr(attrs, \"colspan\", attrs.colspan + n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (var i = 0; i < n; i++) { result.colwidth.splice(pos, 0, 0); }\n  }\n  return result\n}\n\nfunction columnIsHeader(map, table, col) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (var row = 0; row < map.height; row++)\n    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      { return false } }\n  return true\n}\n\n// This file defines a ProseMirror selection subclass that models\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nvar CellSelection = /*@__PURE__*/(function (Selection) {\n  function CellSelection($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1);\n    var rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    var cells = map.cellsInRect(rect).filter(function (p) { return p != $headCell.pos - start; });\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start);\n    var ranges = cells.map(function (pos) {\n      var cell = table.nodeAt(pos), from = pos + start + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size))\n    });\n    Selection.call(this, ranges[0].$from, ranges[0].$to, ranges);\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell;\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell;\n  }\n\n  if ( Selection ) CellSelection.__proto__ = Selection;\n  CellSelection.prototype = Object.create( Selection && Selection.prototype );\n  CellSelection.prototype.constructor = CellSelection;\n\n  CellSelection.prototype.map = function map (doc, mapping) {\n    var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    var $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        { return CellSelection.rowSelection($anchorCell, $headCell) }\n      else if (tableChanged && this.isColSelection())\n        { return CellSelection.colSelection($anchorCell, $headCell) }\n      else\n        { return new CellSelection($anchorCell, $headCell) }\n    }\n    return TextSelection.between($anchorCell, $headCell)\n  };\n\n  // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  CellSelection.prototype.content = function content () {\n    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);\n    var rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n    var seen = {}, rows = [];\n    for (var row = rect.top; row < rect.bottom; row++) {\n      var rowContent = [];\n      for (var index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        var pos = map.map[index];\n        if (!seen[pos]) {\n          seen[pos] = true;\n          var cellRect = map.findCell(pos), cell = table.nodeAt(pos);\n          var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;\n          if (extraLeft > 0 || extraRight > 0) {\n            var attrs = cell.attrs;\n            if (extraLeft > 0) { attrs = removeColSpan(attrs, 0, extraLeft); }\n            if (extraRight > 0) { attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight); }\n            if (cellRect.left < rect.left) { cell = cell.type.createAndFill(attrs); }\n            else { cell = cell.type.create(attrs, cell.content); }\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            var attrs$1 = setAttr(cell.attrs, \"rowspan\", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));\n            if (cellRect.top < rect.top) { cell = cell.type.createAndFill(attrs$1); }\n            else { cell = cell.type.create(attrs$1, cell.content); }\n          }\n          rowContent.push(cell);\n        }\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1)\n  };\n\n  CellSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    var mapFrom = tr.steps.length, ranges = this.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n    var sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) { tr.setSelection(sel); }\n  };\n\n  CellSelection.prototype.replaceWith = function replaceWith (tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  };\n\n  CellSelection.prototype.forEachCell = function forEachCell (f) {\n    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);\n    var cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n    for (var i = 0; i < cells.length; i++)\n      { f(table.nodeAt(cells[i]), start + cells[i]); }\n  };\n\n  // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  CellSelection.prototype.isColSelection = function isColSelection () {\n    var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) { return false }\n    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount\n  };\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  CellSelection.colSelection = function colSelection ($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        { $anchorCell = doc.resolve(start + map.map[anchorRect.left]); }\n      if (headRect.bottom < map.height)\n        { $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]); }\n    } else {\n      if (headRect.top > 0)\n        { $headCell = doc.resolve(start + map.map[headRect.left]); }\n      if (anchorRect.bottom < map.height)\n        { $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]); }\n    }\n    return new CellSelection($anchorCell, $headCell)\n  };\n\n  // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  CellSelection.prototype.isRowSelection = function isRowSelection () {\n    var map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1);\n    var anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) { return false }\n    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width\n  };\n\n  CellSelection.prototype.eq = function eq (other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n  };\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  CellSelection.rowSelection = function rowSelection ($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        { $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]); }\n      if (headRect.right < map.width)\n        { $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]); }\n    } else {\n      if (headRect.left > 0)\n        { $headCell = doc.resolve(start + map.map[headRect.top * map.width]); }\n      if (anchorRect.right < map.width)\n        { $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]); }\n    }\n    return new CellSelection($anchorCell, $headCell)\n  };\n\n  CellSelection.prototype.toJSON = function toJSON () {\n    return {type: \"cell\", anchor: this.$anchorCell.pos, head: this.$headCell.pos}\n  };\n\n  CellSelection.fromJSON = function fromJSON (doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → CellSelection\n  CellSelection.create = function create (doc, anchorCell, headCell) {\n    if ( headCell === void 0 ) headCell = anchorCell;\n\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell))\n  };\n\n  CellSelection.prototype.getBookmark = function getBookmark () { return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos) };\n\n  return CellSelection;\n}(Selection));\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID(\"cell\", CellSelection);\n\nvar CellBookmark = function CellBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nCellBookmark.prototype.map = function map (mapping) {\n  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nCellBookmark.prototype.resolve = function resolve (doc) {\n  var $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n  if ($anchorCell.parent.type.spec.tableRole == \"row\" &&\n      $headCell.parent.type.spec.tableRole == \"row\" &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell))\n    { return new CellSelection($anchorCell, $headCell) }\n  else\n    { return Selection.near($headCell, 1) }\n};\n\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) { return null }\n  var cells = [];\n  state.selection.forEachCell(function (node, pos) {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {class: \"selectedCell\"}));\n  });\n  return DecorationSet.create(state.doc, cells)\n}\n\nfunction isCellBoundarySelection(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) { return false } // Cheap elimination\n  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    { if ($from.after(depth + 1) < $from.end(depth)) { break } }\n  for (var d = $to.depth; d >= 0; d--, beforeTo--)\n    { if ($to.before(d + 1) > $to.start(d)) { break } }\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole)\n}\n\nfunction isTextSelectionAcrossCells(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  var fromCellBoundaryNode;\n  var toCellBoundaryNode;\n\n  for (var i = $from.depth; i > 0; i--) {\n    var node = $from.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (var i$1 = $to.depth; i$1 > 0; i$1--) {\n    var node$1 = $to.node(i$1);\n    if (node$1.type.spec.tableRole === 'cell' || node$1.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node$1;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0\n}\n\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  var sel = (tr || state).selection, doc = (tr || state).doc, normalize, role;\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      var $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      var map = TableMap.get(sel.node), start = sel.from + 1;\n      var lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    { (tr || (tr = state.tr)).setSelection(normalize); }\n  return tr\n}\n\n// Utilities used for copy/paste handling.\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nfunction pastedCells(slice) {\n  if (!slice.size) { return null }\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n  var first = content.firstChild, role = first.type.spec.tableRole;\n  var schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (var i = 0; i < content.childCount; i++) {\n      var cells = content.child(i).content;\n      var left = i ? 0 : Math.max(0, openStart - 1);\n      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) { cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content; }\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);\n  } else {\n    return null\n  }\n  return ensureRectangular(schema, rows)\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  var widths = [];\n  for (var i = 0; i < rows.length; i++) {\n    var row = rows[i];\n    for (var j = row.childCount - 1; j >= 0; j--) {\n      var ref = row.child(j).attrs;\n      var rowspan = ref.rowspan;\n      var colspan = ref.colspan;\n      for (var r = i; r < i + rowspan; r++)\n        { widths[r] = (widths[r] || 0) + colspan; }\n    }\n  }\n  var width = 0;\n  for (var r$1 = 0; r$1 < widths.length; r$1++) { width = Math.max(width, widths[r$1]); }\n  for (var r$2 = 0; r$2 < widths.length; r$2++) {\n    if (r$2 >= rows.length) { rows.push(Fragment.empty); }\n    if (widths[r$2] < width) {\n      var empty = tableNodeTypes(schema).cell.createAndFill(), cells = [];\n      for (var i$1 = widths[r$2]; i$1 < width; i$1++) { cells.push(empty); }\n      rows[r$2] = rows[r$2].append(Fragment.from(cells));\n    }\n  }\n  return {height: rows.length, width: width, rows: rows}\n}\n\nfunction fitSlice(nodeType, slice) {\n  var node = nodeType.createAndFill();\n  var tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nfunction clipCells(ref, newWidth, newHeight) {\n  var width = ref.width;\n  var height = ref.height;\n  var rows = ref.rows;\n\n  if (width != newWidth) {\n    var added = [], newRows = [];\n    for (var row = 0; row < rows.length; row++) {\n      var frag = rows[row], cells = [];\n      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {\n        var cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          { cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content); }\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (var j = 1; j < cell.attrs.rowspan; j++)\n          { added[row + j] = (added[row + j] || 0) + cell.attrs.colspan; }\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    var newRows$1 = [];\n    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {\n      var cells$1 = [], source = rows[i$1 % height];\n      for (var j$1 = 0; j$1 < source.childCount; j$1++) {\n        var cell$1 = source.child(j$1);\n        if (row$1 + cell$1.attrs.rowspan > newHeight)\n          { cell$1 = cell$1.type.create(setAttr(cell$1.attrs, \"rowspan\", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content); }\n        cells$1.push(cell$1);\n      }\n      newRows$1.push(Fragment.from(cells$1));\n    }\n    rows = newRows$1;\n    height = newHeight;\n  }\n\n  return {width: width, height: height, rows: rows}\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  var schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead;\n  if (width > map.width) {\n    for (var row = 0, rowEnd = 0; row < map.height; row++) {\n      var rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      var cells = [], add = (void 0);\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        { add = empty || (empty = types.cell.createAndFill()); }\n      else\n        { add = emptyHead || (emptyHead = types.header_cell.createAndFill()); }\n      for (var i = map.width; i < width; i++) { cells.push(add); }\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    var cells$1 = [];\n    for (var i$1 = 0, start$1 = (map.height - 1) * map.width; i$1 < Math.max(map.width, width); i$1++) {\n      var header = i$1 >= map.width ? false :\n          table.nodeAt(map.map[start$1 + i$1]).type == types.header_cell;\n      cells$1.push(header\n                 ? (emptyHead || (emptyHead = types.header_cell.createAndFill()))\n                 : (empty || (empty = types.cell.createAndFill())));\n    }\n\n    var emptyRow = types.row.create(null, Fragment.from(cells$1)), rows = [];\n    for (var i$2 = map.height; i$2 < height; i$2++) { rows.push(emptyRow); }\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead)\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) { return false }\n  var found = false;\n  for (var col = left; col < right; col++) {\n    var index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos);\n      var ref = map.findCell(pos);\n      var cellTop = ref.top;\n      var cellLeft = ref.left;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, \"rowspan\", top - cellTop));\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n                cell.type.createAndFill(setAttr(cell.attrs, \"rowspan\", (cellTop + cell.attrs.rowspan) - top)));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) { return false }\n  var found = false;\n  for (var row = top; row < bottom; row++) {\n    var index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos), cellLeft = map.colCount(pos);\n      var updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table);\n  var top = rect.top;\n  var left = rect.left;\n  var right = left + cells.width, bottom = top + cells.height;\n  var tr = state.tr, mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) { recomp(); }\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) { recomp(); }\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) { recomp(); }\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) { recomp(); }\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) { recomp(); }\n\n  for (var row = top; row < bottom; row++) {\n    var from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart),\n               new Slice(cells.rows[row - top], 0, 0));\n  }\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n                                    tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// This file defines a number of helpers for wiring up user input to\n\nvar handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1),\n\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n\n  \"Backspace\": deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  \"Delete\": deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) { return false }\n  if (dispatch) { dispatch(state.tr.setSelection(selection).scrollIntoView()); }\n  return true\n}\n\nfunction arrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir))\n    }\n    if (axis != \"horiz\" && !sel.empty) { return false }\n    var end = atEndOfCell(view, axis, dir);\n    if (end == null) { return false }\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir))\n    } else {\n      var $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel;\n      if ($next) { newSel = Selection.near($next, 1); }\n      else if (dir < 0) { newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1); }\n      else { newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1); }\n      return maybeSetSelection(state, dispatch, newSel)\n    }\n  }\n}\n\nfunction shiftArrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    if (!(sel instanceof CellSelection)) {\n      var end = atEndOfCell(view, axis, dir);\n      if (end == null) { return false }\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n    var $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) { return false }\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head))\n  }\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  var sel = state.selection;\n  if (!(sel instanceof CellSelection)) { return false }\n  if (dispatch) {\n    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell(function (cell, pos) {\n      if (!cell.content.eq(baseContent))\n        { tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1),\n                   new Slice(baseContent, 0, 0)); }\n    });\n    if (tr.docChanged) { dispatch(tr); }\n  }\n  return true\n}\n\nfunction handleTripleClick(view, pos) {\n  var doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) { return false }\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true\n}\n\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) { return false }\n  var cells = pastedCells(slice), sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells) { cells = {width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]}; }\n    var table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1);\n    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true\n  } else if (cells) {\n    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) { return }\n\n  var startDOMCell = domInCell(view, startEvent.target), $anchor;\n  if (startEvent.shiftKey && (view.state.selection instanceof CellSelection)) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell &&\n             ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n             cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    var $head = cellUnderMouse(view, event);\n    var starting = key.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) { $head = $anchor; }\n      else { return }\n    }\n    var selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      var tr = view.state.tr.setSelection(selection);\n      if (starting) { tr.setMeta(key, $anchor.pos); }\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (key.getState(view.state) != null) { view.dispatch(view.state.tr.setMeta(key, -1)); }\n  }\n\n  function move(event) {\n    var anchor = key.getState(view.state), $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) { return stop() }\n    }\n    if ($anchor) { setCellSelection($anchor, event); }\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) { return null }\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  for (var d = $head.depth - 1; d >= 0; d--) {\n    var parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) { return null }\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      var cellPos = $head.before(d);\n      var dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n      return view.endOfTextblock(dirStr) ? cellPos : null\n    }\n  }\n  return null\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    { if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") { return dom } }\n}\n\nfunction cellUnderMouse(view, event) {\n  var mousePos = view.posAtCoords({left: event.clientX, top: event.clientY});\n  if (!mousePos) { return null }\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null\n}\n\n// This file defines helpers for normalizing tables, making sure no\n\nvar fixTablesKey = new PluginKey(\"fix-tables\");\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  var oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (var i = 0, j = 0; i < curSize; i++) {\n    var child = cur.child(i);\n    for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      { changedDescendants(old.child(j), child, offset + 1, f); }\n    else\n      { child.nodesBetween(0, child.content.size, f, offset + 1); }\n    offset += child.nodeSize;\n  }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nfunction fixTables(state, oldState) {\n  var tr, check = function (node, pos) {\n    if (node.type.spec.tableRole == \"table\") { tr = fixTable(state, node, pos, tr); }\n  };\n  if (!oldState) { state.doc.descendants(check); }\n  else if (oldState.doc != state.doc) { changedDescendants(oldState.doc, state.doc, 0, check); }\n  return tr\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nfunction fixTable(state, table, tablePos, tr) {\n  var map = TableMap.get(table);\n  if (!map.problems) { return tr }\n  if (!tr) { tr = state.tr; }\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  var mustAdd = [];\n  for (var i = 0; i < map.height; i++) { mustAdd.push(0); }\n  for (var i$1 = 0; i$1 < map.problems.length; i$1++) {\n    var prob = map.problems[i$1];\n    if (prob.type == \"collision\") {\n      var cell = table.nodeAt(prob.pos);\n      for (var j = 0; j < cell.attrs.rowspan; j++) { mustAdd[prob.row + j] += prob.n; }\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      var cell$1 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, \"rowspan\", cell$1.attrs.rowspan - prob.n));\n    } else if (prob.type == \"colwidth mismatch\") {\n      var cell$2 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, \"colwidth\", prob.colwidth));\n    }\n  }\n  var first, last;\n  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) { if (mustAdd[i$2]) {\n    if (first == null) { first = i$2; }\n    last = i$2;\n  } }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (var i$3 = 0, pos = tablePos + 1; i$3 < map.height; i$3++) {\n    var row = table.child(i$3);\n    var end = pos + row.nodeSize;\n    var add = mustAdd[i$3];\n    if (add > 0) {\n      var tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n      var nodes = [];\n      for (var j$1 = 0; j$1 < add; j$1++)\n        { nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill()); }\n      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true })\n}\n\n// This file defines a number of table-related commands.\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nfunction selectedRect(state) {\n  var sel = state.selection, $pos = selectionCell(state);\n  var table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table);\n  var rect;\n  if (sel instanceof CellSelection)\n    { rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart); }\n  else\n    { rect = map.findCell($pos.pos - tableStart); }\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect\n}\n\n// Add a column at the given position in a table.\nfunction addColumn(tr, ref, col) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n\n  var refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn))\n    { refColumn = col == 0 || col == map.width ? null : 0; }\n\n  for (var row = 0; row < map.height; row++) {\n    var index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      var pos = map.map[index], cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null,\n                       addColSpan(cell.attrs, col - map.colCount(pos)));\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type;\n      var pos$1 = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());\n    }\n  }\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true\n}\n\nfunction removeColumn(tr, ref, col) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n\n  var mapStart = tr.mapping.maps.length;\n  for (var row = 0; row < map.height;) {\n    var index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos);\n    // If this is part of a col-spanning cell\n    if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null,\n                       removeColSpan(cell.attrs, col - map.colCount(pos)));\n    } else {\n      var start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += cell.attrs.rowspan;\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state), tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) { return false }\n    for (var i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) { break }\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true\n}\n\nfunction rowIsHeader(map, table, row) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (var col = 0; col < map.width; col++)\n    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      { return false } }\n  return true\n}\n\nfunction addRow(tr, ref, row) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n\n  var rowPos = tableStart;\n  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }\n  var cells = [], refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    { refRow = row == 0 || row == map.height ? null : 0; }\n  for (var col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      var pos = map.map[index], attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, \"rowspan\", attrs.rowspan + 1));\n      col += attrs.colspan - 1;\n    } else {\n      var type = refRow == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true\n}\n\nfunction removeRow(tr, ref, row) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n\n  var rowPos = 0;\n  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }\n  var nextRow = rowPos + table.child(row).nodeSize;\n\n  var mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (var col = 0, index = row * map.width; col < map.width; col++, index++) {\n    var pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      var attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, \"rowspan\", attrs.rowspan - 1));\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      var cell = table.nodeAt(pos);\n      var copy = cell.type.create(setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - 1), cell.content);\n      var newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) { return false }\n    for (var i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) { break }\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true\n}\n\nfunction isEmpty(cell) {\n  var c = cell.content;\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0\n}\n\nfunction cellsOverlapRectangle(ref, rect) {\n  var width = ref.width;\n  var height = ref.height;\n  var map = ref.map;\n\n  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (var i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] ||\n        rect.right < width && map[indexRight] == map[indexRight + 1]) { return true }\n    indexLeft += width; indexRight += width;\n  }\n  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] ||\n        rect.bottom < height && map[indexBottom] == map[indexBottom + width]) { return true }\n    indexTop++; indexBottom++;\n  }\n  return false\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nfunction mergeCells(state, dispatch) {\n  var sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) { return false }\n  var rect = selectedRect(state);\n  var map = rect.map;\n  if (cellsOverlapRectangle(map, rect)) { return false }\n  if (dispatch) {\n    var tr = state.tr, seen = {}, content = Fragment.empty, mergedPos, mergedCell;\n    for (var row = rect.top; row < rect.bottom; row++) {\n      for (var col = rect.left; col < rect.right; col++) {\n        var cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos]) { continue }\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) { content = content.append(cell.content); }\n          var mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null,\n                     setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, (rect.right - rect.left) - mergedCell.attrs.colspan),\n                             \"rowspan\", rect.bottom - rect.top));\n    if (content.size) {\n      var end = mergedPos + 1 + mergedCell.content.size;\n      var start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n  return true\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nfunction splitCell(state, dispatch) {\n  var nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(function (ref) {\n    var node = ref.node;\n\n    return nodeTypes[node.type.spec.tableRole]\n  })(state, dispatch)\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nfunction splitCellWithType(getCellType) {\n  return function (state, dispatch) {\n    var sel = state.selection;\n    var cellNode, cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) { return false }\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) { return false }\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {return false}\n    if (dispatch) {\n      var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) { baseAttrs = setAttr(baseAttrs, \"rowspan\", 1); }\n      if (baseAttrs.colspan > 1) { baseAttrs = setAttr(baseAttrs, \"colspan\", 1); }\n      var rect = selectedRect(state), tr = state.tr;\n      for (var i = 0; i < rect.right - rect.left; i++)\n        { attrs.push(colwidth ? setAttr(baseAttrs, \"colwidth\", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs); }\n      var lastCell;\n      for (var row = rect.top; row < rect.bottom; row++) {\n        var pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) { pos += cellNode.nodeSize; }\n        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {\n          if (col == rect.left && row == rect.top) { continue }\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row: row, col: col}).createAndFill(attrs[i$1]));\n        }\n      }\n      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left}), attrs[0]);\n      if (sel instanceof CellSelection)\n        { tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),\n                                          lastCell && tr.doc.resolve(lastCell))); }\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    var $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) { return false }\n    if (dispatch) {\n      var tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        { state.selection.forEachCell(function (node, pos) {\n          if (node.attrs[name] !== value)\n            { tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value)); }\n        }); }\n      else\n        { tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value)); }\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    if (dispatch) {\n      var types = tableNodeTypes(state.schema);\n      var rect = selectedRect(state), tr = state.tr;\n      var cells = rect.map.cellsInRect(type == \"column\" ? new Rect(rect.left, 0, rect.right, rect.map.height) :\n                                       type == \"row\" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);\n      var nodes = cells.map(function (pos) { return rect.table.nodeAt(pos); });\n      for (var i = 0; i < cells.length; i++) // Remove headers, if any\n        { if (nodes[i].type == types.header_cell)\n          { tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs); } }\n      if (tr.steps.length == 0) { for (var i$1 = 0; i$1 < cells.length; i$1++) // No headers removed, add instead\n        { tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs); } }\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  var cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1,\n  });\n\n  for (var i = 0; i < cellPositions.length; i++) {\n    var cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n\n  if (options.useDeprecatedLogic)\n    { return deprecated_toggleHeader(type) }\n\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    if (dispatch) {\n      var types = tableNodeTypes(state.schema);\n      var rect = selectedRect(state), tr = state.tr;\n\n      var isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      var isHeaderColumnEnabled = isHeaderEnabledByType(\"column\", rect, types);\n\n      var isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled :\n                            type === \"row\"    ? isHeaderColumnEnabled : false;\n\n      var selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n      var cellsRect = type == \"column\" ? new Rect(0, selectionStartsAt, 1, rect.map.height) :\n                      type == \"row\" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;\n\n      var newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell :\n                    type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n\n      rect.map.cellsInRect(cellsRect).forEach(function (relativeCellPos) {\n        var cellPos = relativeCellPos + rect.tableStart;\n        var cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nvar toggleHeaderRow = toggleHeader(\"row\", { useDeprecatedLogic: true });\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nvar toggleHeaderColumn = toggleHeader(\"column\", { useDeprecatedLogic: true });\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nvar toggleHeaderCell = toggleHeader(\"cell\", { useDeprecatedLogic: true });\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    var before = $cell.nodeBefore;\n    if (before) { return $cell.pos - before.nodeSize }\n    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      var rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) { return rowEnd - 1 - rowNode.lastChild.nodeSize }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) { return $cell.pos + $cell.nodeAfter.nodeSize }\n    var table = $cell.node(-1);\n    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {\n      var rowNode$1 = table.child(row$1);\n      if (rowNode$1.childCount) { return rowStart + 1 }\n      rowStart += rowNode$1.nodeSize;\n    }\n  }\n}\n\n// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    var cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) { return }\n    if (dispatch) {\n      var $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\nfunction deleteTable(state, dispatch) {\n  var $pos = state.selection.$anchor;\n  for (var d = $pos.depth; d > 0; d--) {\n    var node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) { dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()); }\n      return true\n    }\n  }\n  return false\n}\n\nvar TableView = function TableView(node, cellMinWidth) {\n  this.node = node;\n  this.cellMinWidth = cellMinWidth;\n  this.dom = document.createElement(\"div\");\n  this.dom.className = \"tableWrapper\";\n  this.table = this.dom.appendChild(document.createElement(\"table\"));\n  this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n  updateColumns(node, this.colgroup, this.table, cellMinWidth);\n  this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n};\n\nTableView.prototype.update = function update (node) {\n  if (node.type != this.node.type) { return false }\n  this.node = node;\n  updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n  return true\n};\n\nTableView.prototype.ignoreMutation = function ignoreMutation (record) {\n  return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target))\n};\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var totalWidth = 0, fixedWidth = true;\n  var nextDOM = colgroup.firstChild, row = node.firstChild;\n  for (var i = 0, col = 0; i < row.childCount; i++) {\n    var ref = row.child(i).attrs;\n    var colspan = ref.colspan;\n    var colwidth = ref.colwidth;\n    for (var j = 0; j < colspan; j++, col++) {\n      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      var cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) { fixedWidth = false; }\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) { nextDOM.style.width = cssWidth; }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    var after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\nvar key$1 = new PluginKey(\"tableColumnResizing\");\n\nfunction columnResizing(ref) {\n  if ( ref === void 0 ) ref = {};\n  var handleWidth = ref.handleWidth; if ( handleWidth === void 0 ) handleWidth = 5;\n  var cellMinWidth = ref.cellMinWidth; if ( cellMinWidth === void 0 ) cellMinWidth = 25;\n  var View = ref.View; if ( View === void 0 ) View = TableView;\n  var lastColumnResizable = ref.lastColumnResizable; if ( lastColumnResizable === void 0 ) lastColumnResizable = true;\n\n  var plugin = new Plugin({\n    key: key$1,\n    state: {\n      init: function init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] =\n          function (node, view) { return new View(node, cellMinWidth, view); };\n        return new ResizeState(-1, false)\n      },\n      apply: function apply(tr, prev) {\n        return prev.apply(tr)\n      }\n    },\n    props: {\n      attributes: function attributes(state) {\n        var pluginState = key$1.getState(state);\n        return pluginState.activeHandle > -1 ? {class: \"resize-cursor\"} : null\n      },\n\n      handleDOMEvents: {\n        mousemove: function mousemove(view, event) { handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable); },\n        mouseleave: function mouseleave(view) { handleMouseLeave(view); },\n        mousedown: function mousedown(view, event) { handleMouseDown$1(view, event, cellMinWidth); }\n      },\n\n      decorations: function decorations(state) {\n        var pluginState = key$1.getState(state);\n        if (pluginState.activeHandle > -1) { return handleDecorations(state, pluginState.activeHandle) }\n      },\n\n      nodeViews: {}\n    }\n  });\n  return plugin\n}\n\nvar ResizeState = function ResizeState(activeHandle, dragging) {\n  this.activeHandle = activeHandle;\n  this.dragging = dragging;\n};\n\nResizeState.prototype.apply = function apply (tr) {\n  var state = this, action = tr.getMeta(key$1);\n  if (action && action.setHandle != null)\n    { return new ResizeState(action.setHandle, null) }\n  if (action && action.setDragging !== undefined)\n    { return new ResizeState(state.activeHandle, action.setDragging) }\n  if (state.activeHandle > -1 && tr.docChanged) {\n    var handle = tr.mapping.map(state.activeHandle, -1);\n    if (!pointsAtCell(tr.doc.resolve(handle))) { handle = null; }\n    state = new ResizeState(handle, state.dragging);\n  }\n  return state\n};\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  var pluginState = key$1.getState(view.state);\n\n  if (!pluginState.dragging) {\n    var target = domCellAround(event.target), cell = -1;\n    if (target) {\n      var ref = target.getBoundingClientRect();\n      var left = ref.left;\n      var right = ref.right;\n      if (event.clientX - left <= handleWidth)\n        { cell = edgeCell(view, event, \"left\"); }\n      else if (right - event.clientX <= handleWidth)\n        { cell = edgeCell(view, event, \"right\"); }\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        var $cell = view.state.doc.resolve(cell);\n        var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n        var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  var pluginState = key$1.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) { updateHandle(view, -1); }\n}\n\nfunction handleMouseDown$1(view, event, cellMinWidth) {\n  var pluginState = key$1.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) { return false }\n\n  var cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(key$1, {setDragging: {startX: event.clientX, startWidth: width}}));\n\n  function finish(event) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    var pluginState = key$1.getState(view.state);\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(key$1, {setDragging: null}));\n    }\n  }\n  function move(event) {\n    if (!event.which) { return finish(event) }\n    var pluginState = key$1.getState(view.state);\n    var dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true\n}\n\nfunction currentColWidth(view, cellPos, ref) {\n  var colspan = ref.colspan;\n  var colwidth = ref.colwidth;\n\n  var width = colwidth && colwidth[colwidth.length - 1];\n  if (width) { return width }\n  var dom = view.domAtPos(cellPos);\n  var node = dom.node.childNodes[dom.offset];\n  var domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) { for (var i = 0; i < colspan; i++) { if (colwidth[i]) {\n    domWidth -= colwidth[i];\n    parts--;\n  } } }\n  return domWidth / parts\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    { target = target.classList.contains(\"ProseMirror\") ? null : target.parentNode; }\n  return target\n}\n\nfunction edgeCell(view, event, side) {\n  var found = view.posAtCoords({left: event.clientX, top: event.clientY});\n  if (!found) { return -1 }\n  var pos = found.pos;\n  var $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) { return -1 }\n  if (side == \"right\") { return $cell.pos }\n  var map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  var index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1]\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  var offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset)\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key$1, {setHandle: value}));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var tr = view.state.tr;\n  for (var row = 0; row < map.height; row++) {\n    var mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) { continue }\n    var pos = map.map[mapIndex];\n    var ref = table.nodeAt(pos);\n    var attrs = ref.attrs;\n    var index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) { continue }\n    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, \"colwidth\", colwidth));\n  }\n  if (tr.docChanged) { view.dispatch(tr); }\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1), start = $cell.start(-1);\n  var col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var dom = view.domAtPos($cell.start(-1)).node;\n  while (dom.nodeName != \"TABLE\") { dom = dom.parentNode; }\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  var result = [];\n  for (var i = 0; i < n; i++) { result.push(0); }\n  return result\n}\n\nfunction handleDecorations(state, cell) {\n  var decorations = [];\n  var $cell = state.doc.resolve(cell);\n  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (var row = 0; row < map.height; row++) {\n    var index = col + row * map.width - 1;\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if ((col == map.width || map.map[index] != map.map[index + 1]) &&\n        (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      var cellPos = map.map[index];\n      var pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      var dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n  return DecorationSet.create(state.doc, decorations)\n}\n\n// This file defines a plugin that handles the drawing of cell\n\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nfunction tableEditing(ref) {\n  if ( ref === void 0 ) ref = {};\n  var allowTableNodeSelection = ref.allowTableNodeSelection; if ( allowTableNodeSelection === void 0 ) allowTableNodeSelection = false;\n\n  return new Plugin({\n    key: key,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init: function init() { return null },\n      apply: function apply(tr, cur) {\n        var set = tr.getMeta(key);\n        if (set != null) { return set == -1 ? null : set }\n        if (cur == null || !tr.docChanged) { return cur }\n        var ref = tr.mapping.mapResult(cur);\n        var deleted = ref.deleted;\n        var pos = ref.pos;\n        return deleted ? null : pos\n      }\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n\n      createSelectionBetween: function createSelectionBetween(view) {\n        if (key.getState(view.state) != null) { return view.state.selection }\n      },\n\n      handleTripleClick: handleTripleClick,\n\n      handleKeyDown: handleKeyDown,\n\n      handlePaste: handlePaste\n    },\n\n    appendTransaction: function appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection)\n    }\n  })\n}\n\nexport { CellSelection, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, colCount, columnIsHeader, columnResizing, key$1 as columnResizingPluginKey, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setAttr, setCellAttr, splitCell, splitCellWithType, tableEditing, key as tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumns as updateColumnsOnResize };\n//# sourceMappingURL=index.es.js.map\n","import { findParentNodeClosestToPos, Node as Node$1, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from 'prosemirror-tables';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors$3 = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node): leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors$3.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors$3.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors$3.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors$3 );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1$2 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1$2.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1$2 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2$1 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\nprototypeAccessors$2$1.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2$1.doc.get = function () { return this.node(0) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2$1.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2$1.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2$1.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2$1 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3$1 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3$1.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3$1.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3$1.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted to separate text\n// from different block nodes. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3$1.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3$1.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3$1.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3$1.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3$1.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3$1.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3$1.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3$1.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3$1.isAtom.get = function () { return this.type.isAtom };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3$1 );\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2$1 = { next: { configurable: true } };\n\nprototypeAccessors$1$2$1.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2$1 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true },whitespace: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: union<\"pre\", \"normal\">\n// The node type's [whitespace](#view.NodeSpec.whitespace) option.\nprototypeAccessors$5.whitespace.get = function () { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") };\n\n// :: () → bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) { return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0) }\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = wsOptionsFor(type, preserveWS, top.options);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover (value) {\n  var diff = 0, index = recoverIndex(value);\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// : (number, ?number) → MapResult\nStepMap.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\n// : (number, ?number) → number\nStepMap.prototype.map = function map (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n      if (simple) { return result }\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize;\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n  var diff = 0, index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n    if (pos <= end && i == index * 3) { return true }\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\n\n// :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\nStepMap.offset = function offset (n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n};\n\nStepMap.empty = new StepMap([]);\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || [];\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0;\n  // :: number\n  // The end position in the `maps` array.\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n};\n\n// :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map);\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n};\n\n// :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\nMapping.prototype.getMirror = function getMirror (n) {\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = []; }\n  this.mirror.push(n, m);\n};\n\n// :: (Mapping)\n// Append the inverse of the given mapping to this one.\nMapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n};\n\n// :: () → Mapping\n// Create an inverted version of this mapping.\nMapping.prototype.invert = function invert () {\n  var inverse = new Mapping;\n  inverse.appendMappingInverted(this);\n  return inverse\n};\n\n// : (number, ?number) → number\n// Map a position through this mapping.\nMapping.prototype.map = function map (pos, assoc) {\n    if ( assoc === void 0 ) assoc = 1;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this.maps[i].map(pos, assoc); }\n  return pos\n};\n\n// : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i], result = map.mapResult(pos, assoc);\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue\n      }\n    }\n\n    if (result.deleted) { deleted = true; }\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc;\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = [];\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = [];\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping;\n};\n\nvar prototypeAccessors$2 = { before: { configurable: true },docChanged: { configurable: true } };\n\n// :: Node The starting document.\nprototypeAccessors$2.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object);\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc);\n  if (!result.failed) { this.addStep(step, result.doc); }\n  return result\n};\n\n// :: bool\n// True when the document has been changed (when there are any\n// steps).\nprototypeAccessors$2.docChanged.get = function () {\n  return this.steps.length > 0\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors$2 );\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null);\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\nStep.prototype.toJSON = function toJSON () { return mustOverride() };\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  if (!json || !json.stepType) { throw new RangeError(\"Invalid input for Step.fromJSON\") }\n  var type = stepsByID[json.stepType];\n  if (!type) { throw new RangeError((\"No step type \" + (json.stepType) + \" defined\")) }\n  return type.fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass\n};\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc;\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed;\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = /*@__PURE__*/(function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\") }\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\n\nStep.jsonID(\"replace\", ReplaceStep);\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = /*@__PURE__*/(function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom;\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\") }\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  var start = gapStart, end = gapEnd;\n\n  var before = Fragment.empty, openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    } }\n  var after = Fragment.empty, openEnd = 0;\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n};\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  var start = range.start, end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n};\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1$1.doc, this$1$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1$1.clearIncompatible(this$1$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      this$1$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false\n    }\n  });\n  return this\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type; }\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }\n\n  if (!type.validContent(node.content))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n};\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n};\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step)\n};\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }\n    if (child.isInline) { child = f(child, parent, i); }\n    mapped.push(child);\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = /*@__PURE__*/(function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the marked range.\n    this.from = from;\n    // :: number\n    // The end of the marked range.\n    this.to = to;\n    // :: Mark\n    // The mark to add.\n    this.mark = mark;\n  }\n\n  if ( Step ) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1$1.mark.type)) { return node }\n      return node.mark(this$1$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\") }\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = /*@__PURE__*/(function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the unmarked range.\n    this.from = from;\n    // :: number\n    // The end of the unmarked range.\n    this.to = to;\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark;\n  }\n\n  if ( Step ) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\") }\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) { return }\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            { removing.to = end; }\n          else\n            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }\n        }\n      }\n\n      if (adding && adding.to == start)\n        { adding.to = end; }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)); }\n    }\n  });\n\n  removed.forEach(function (s) { return this$1$1.step(s); });\n  added.forEach(function (s) { return this$1$1.step(s); });\n  return this\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++;\n    var toRemove = null;\n    if (mark instanceof MarkType) {\n      var set = node.marks, found;\n      while (found = mark.isInSet(set)) {\n(toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark]; }\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0);\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }\n        }\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) { return this$1$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n  return this\n};\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match) {\n  if ( match === void 0 ) match = parentType.contentMatch;\n\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [], cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))\n        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }\n  return this\n};\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice);\n  if (step) { this.step(step); }\n  return this\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n\n  this.frontier = [];\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n  for (var i$1 = $from.depth; i$1 > 0; i$1--)\n    { this.placed = Fragment.from($from.node(i$1).copy(this.placed)); }\n};\n\nvar prototypeAccessors$1$1 = { depth: { configurable: true } };\n\nprototypeAccessors$1$1.depth.get = function () { return this.frontier.length - 1 };\n\nFitter.prototype.fit = function fit () {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n    if (fit) { this.placeNodes(fit); }\n    else { this.openMore() || this.dropNode(); }\n  }\n  // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n  if (!$to) { return null }\n\n  // If closing to `$to` succeeded, create a step\n  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--; openEnd--;\n  }\n  var slice = new Slice(content, openStart, openEnd);\n  if (moveInline > -1)\n    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    { return new ReplaceStep($from.pos, $to.pos, slice) }\n};\n\n// Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\nFitter.prototype.findFittable = function findFittable () {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = (void 0), parent = (void 0);\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n      var first = fragment.firstChild;\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n          var type = ref.type;\n          var match = ref.match;\n          var wrap = (void 0), inject = (void 0);\n        // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                          : type.compatibleContent(parent.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }\n        // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }\n        // Don't continue looking further up if the parent node\n        // would fit here.\n        if (parent && match.matchType(parent.type)) { break }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (!inner.childCount || inner.firstChild.isLeaf) { return false }\n  this.unplaced = new Slice(content, openStart + 1,\n                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true\n};\n\nFitter.prototype.dropNode = function dropNode () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                              openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n};\n\n// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\nFitter.prototype.placeNodes = function placeNodes (ref) {\n    var sliceDepth = ref.sliceDepth;\n    var frontierDepth = ref.frontierDepth;\n    var parent = ref.parent;\n    var inject = ref.inject;\n    var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) { this.closeFrontierNode(); }\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }\n\n  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0, add = [];\n  var ref$1 = this.frontier[frontierDepth];\n    var match = ref$1.match;\n    var type = ref$1.type;\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }\n    match = match.matchFragment(inject);\n  }\n  // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n  // Scan over the fragment, fitting as many child nodes as\n  // possible.\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken), matches = match.matchType(next.type);\n    if (!matches) { break }\n    taken++;\n    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                              taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n  var toEnd = taken == fragment.childCount;\n  if (!toEnd) { openEndCount = -1; }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match;\n\n  // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n    { this.closeFrontierNode(); }\n\n  // Add new frontier nodes for any open nodes at the end.\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});\n    cur = node.content;\n  }\n\n  // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n    : sliceDepth == 0 ? Slice.empty\n    : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline () {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }\n  var top = this.frontier[this.depth], level;\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }\n\n  var ref = this.$to;\n    var depth = ref.depth;\n    var after = this.$to.after(depth);\n  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }\n  return after\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel ($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n      var match = ref.match;\n      var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n    if (!fit) { continue }\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n        var match$1 = ref$1.match;\n        var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n      if (!matches || matches.childCount) { continue scan }\n    }\n    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n  }\n};\n\nFitter.prototype.close = function close ($to) {\n  var close = this.findCloseLevel($to);\n  if (!close) { return null }\n\n  while (this.depth > close.depth) { this.closeFrontierNode(); }\n  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }\n  $to = close.move;\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n  return $to\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({type: type, match: type.contentMatch});\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode () {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }\n};\n\nObject.defineProperties( Fitter.prototype, prototypeAccessors$1$1 );\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) { return fragment.cutByIndex(count) }\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) { return fragment.append(content) }\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) { return node }\n  var frag = node.content;\n  if (openStart > 1)\n    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true)); }\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++)\n    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.isolating) { break }\n    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }\n    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n\n  var leftNodes = [], preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) { break }\n    content = node.content;\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    { preferredDepth -= 1; }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    { preferredDepth -= 2; }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }\n      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd)) }\n    }\n  }\n\n  var startSteps = this.steps.length;\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n    if (this.steps.length > startSteps) { break }\n    var depth = targetDepths[i$2];\n    if (depth < 0) { continue }\n    from = $from.before(depth); to = $to.after(depth);\n  }\n  return this\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n    if (point != null) { from = to = point; }\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i], last = i == covered.length - 1;\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      { return this.delete($from.start(depth), $to.end(depth)) }\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      { return this.delete($from.before(depth), $to.after(depth)) }\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      { return this.delete($from.before(d), to) }\n  }\n  return this.delete(from, to)\n};\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) { break }\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      { result.push(d); }\n  }\n  return result\n}\n\nvar classesById = Object.create(null);\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nvar Selection = function Selection($anchor, $head, ranges) {\n  // :: [SelectionRange]\n  // The ranges covered by the selection.\n  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  // :: ResolvedPos\n  // The resolved anchor of the selection (the side that stays in\n  // place when the selection is modified).\n  this.$anchor = $anchor;\n  // :: ResolvedPos\n  // The resolved head of the selection (the side that moves when\n  // the selection is modified).\n  this.$head = $head;\n};\n\nvar prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };\n\n// :: number\n// The selection's anchor, as an unresolved position.\nprototypeAccessors.anchor.get = function () { return this.$anchor.pos };\n\n// :: number\n// The selection's head.\nprototypeAccessors.head.get = function () { return this.$head.pos };\n\n// :: number\n// The lower bound of the selection's main range.\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection's main range.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\n// :: ResolvedPos\n// The resolved lowerbound of the selection's main range.\nprototypeAccessors.$from.get = function () {\n  return this.ranges[0].$from\n};\n\n// :: ResolvedPos\n// The resolved upper bound of the selection's main range.\nprototypeAccessors.$to.get = function () {\n  return this.ranges[0].$to\n};\n\n// :: bool\n// Indicates whether the selection contains any content.\nprototypeAccessors.empty.get = function () {\n  var ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++)\n    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }\n  return true\n};\n\n// eq:: (Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document to which we are mapping.\n\n// :: () → Slice\n// Get the content of this selection as a slice.\nSelection.prototype.content = function content () {\n  return this.$from.node(0).slice(this.from, this.to, true)\n};\n\n// :: (Transaction, ?Slice)\n// Replace the selection with a slice or, if no slice is given,\n// delete the selection. Will append to the given transaction.\nSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n  // Put the new selection at the position after the inserted\n  // content. When that ended in an inline node, search backwards,\n  // to get the position after that node. If not, search forward.\n  var lastNode = content.content.lastChild, lastParent = null;\n  for (var i = 0; i < content.openEnd; i++) {\n    lastParent = lastNode;\n    lastNode = lastNode.lastChild;\n  }\n\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n    var ref = ranges[i$1];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content);\n    if (i$1 == 0)\n      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }\n  }\n};\n\n// :: (Transaction, Node)\n// Replace the selection with the given node, appending the changes\n// to the given transaction.\nSelection.prototype.replaceWith = function replaceWith (tr, node) {\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++) {\n    var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    var from = mapping.map($from.pos), to = mapping.map($to.pos);\n    if (i) {\n      tr.deleteRange(from, to);\n    } else {\n      tr.replaceRangeWith(from, to, node);\n      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n    }\n  }\n};\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation. When implementing\n// this for a custom selection class, make sure to give the object a\n// `type` property whose value matches the ID under which you\n// [registered](#state.Selection^jsonID) your class.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// positive. When `textOnly` is true, only consider cursor\n// selections. Will return null when no valid selection position is\n// found.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.inlineContent ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. Will return an\n// [`AllSelection`](#state.AllSelection) if no valid position\n// exists.\nSelection.atStart = function atStart (doc) {\n  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the end of the\n// given document.\nSelection.atEnd = function atEnd (doc) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n};\n\n// :: (Node, Object) → Selection\n// Deserialize the JSON representation of a selection. Must be\n// implemented for custom classes (as a static class method).\nSelection.fromJSON = function fromJSON (doc, json) {\n  if (!json || !json.type) { throw new RangeError(\"Invalid input for Selection.fromJSON\") }\n  var cls = classesById[json.type];\n  if (!cls) { throw new RangeError((\"No selection type \" + (json.type) + \" defined\")) }\n  return cls.fromJSON(doc, json)\n};\n\n// :: (string, constructor<Selection>)\n// To be able to deserialize selections from JSON, custom selection\n// classes must register themselves with an ID string, so that they\n// can be disambiguated. Try to pick something that's unlikely to\n// clash with classes from other modules.\nSelection.jsonID = function jsonID (id, selectionClass) {\n  if (id in classesById) { throw new RangeError(\"Duplicate use of selection JSON ID \" + id) }\n  classesById[id] = selectionClass;\n  selectionClass.prototype.jsonID = id;\n  return selectionClass\n};\n\n// :: () → SelectionBookmark\n// Get a [bookmark](#state.SelectionBookmark) for this selection,\n// which is a value that can be mapped without having access to a\n// current document, and later resolved to a real selection for a\n// given document again. (This is used mostly by the history to\n// track and restore old selections.) The default implementation of\n// this method just converts the selection to a text selection and\n// returns the bookmark for that.\nSelection.prototype.getBookmark = function getBookmark () {\n  return TextSelection.between(this.$anchor, this.$head).getBookmark()\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true;\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nvar SelectionRange = function SelectionRange($from, $to) {\n  // :: ResolvedPos\n  // The lower bound of the range.\n  this.$from = $from;\n  // :: ResolvedPos\n  // The upper bound of the range.\n  this.$to = $to;\n};\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nvar TextSelection = /*@__PURE__*/(function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    Selection.call(this, $anchor, $head);\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { $cursor: { configurable: true } };\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    Selection.prototype.replace.call(this, tr, content);\n    if (content == Slice.empty) {\n      var marks = this.$from.marksAcross(this.$to);\n      if (marks) { tr.ensureMarks(marks); }\n    }\n  };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  };\n\n  TextSelection.prototype.getBookmark = function getBookmark () {\n    return new TextBookmark(this.anchor, this.head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  };\n\n  TextSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      { throw new RangeError(\"Invalid input for TextSelection.fromJSON\") }\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  TextSelection.between = function between ($anchor, $head, bias) {\n    var dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }\n    if (!$head.parent.inlineContent) {\n      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) { $head = found.$head; }\n      else { return Selection.near($head, bias) }\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }\n      }\n    }\n    return new TextSelection($anchor, $head)\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function TextBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nTextBookmark.prototype.map = function map (mapping) {\n  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nTextBookmark.prototype.resolve = function resolve (doc) {\n  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n};\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nvar NodeSelection = /*@__PURE__*/(function (Selection) {\n  function NodeSelection($pos) {\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    Selection.call(this, $pos, $end);\n    // :: Node The selected node.\n    this.node = node;\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n    var $pos = doc.resolve(pos);\n    if (deleted) { return Selection.near($pos) }\n    return new NodeSelection($pos)\n  };\n\n  NodeSelection.prototype.content = function content () {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  };\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {type: \"node\", anchor: this.anchor}\n  };\n\n  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };\n\n  NodeSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\")\n      { throw new RangeError(\"Invalid input for NodeSelection.fromJSON\") }\n    return new NodeSelection(doc.resolve(json.anchor))\n  };\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\n\nNodeSelection.prototype.visible = false;\n\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function NodeBookmark(anchor) {\n  this.anchor = anchor;\n};\nNodeBookmark.prototype.map = function map (mapping) {\n  var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n};\nNodeBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }\n  return Selection.near($pos)\n};\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nvar AllSelection = /*@__PURE__*/(function (Selection) {\n  function AllSelection(doc) {\n    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  if ( Selection ) AllSelection.__proto__ = Selection;\n  AllSelection.prototype = Object.create( Selection && Selection.prototype );\n  AllSelection.prototype.constructor = AllSelection;\n\n  AllSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      var sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }\n    } else {\n      Selection.prototype.replace.call(this, tr, content);\n    }\n  };\n\n  AllSelection.prototype.toJSON = function toJSON () { return {type: \"all\"} };\n\n  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };\n\n  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };\n\n  return AllSelection;\n}(Selection));\n\nSelection.jsonID(\"all\", AllSelection);\n\nvar AllBookmark = {\n  map: function map() { return this },\n  resolve: function resolve(doc) { return new AllSelection(doc) }\n};\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) { return }\n  var step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) { return }\n  var map = tr.mapping.maps[last], end;\n  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nvar Transaction = /*@__PURE__*/(function (Transform) {\n  function Transaction(state) {\n    Transform.call(this, state.doc);\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n  }\n\n  if ( Transform ) Transaction.__proto__ = Transform;\n  Transaction.prototype = Object.create( Transform && Transform.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    if (selection.$from.doc != this.doc)\n      { throw new RangeError(\"Selection passed to setSelection must point at the current document\") }\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return (this.updated & UPDATED_SEL) > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this\n  };\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  Transaction.prototype.ensureMarks = function ensureMarks (marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      { this.setStoredMarks(marks); }\n    return this\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return (this.updated & UPDATED_MARKS) > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform.prototype.addStep.call(this, step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time;\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    this.selection.replace(this, slice);\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var selection = this.selection;\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none))); }\n    selection.replaceWith(this, node);\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    this.selection.replace(this);\n    return this\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var marks = this.storedMarks;\n      if (!marks) {\n        var $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }\n      return this\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  prototypeAccessors.isGeneric.get = function () {\n    for (var _ in this.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL;\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return (this.updated & UPDATED_SCROLL) > 0\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(Transform));\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init(config) { return config.storedMarks || null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n];\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1$1 = this;\n\n  this.schema = schema;\n  this.fields = baseFields.concat();\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1$1.plugins.push(plugin);\n    this$1$1.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state)\n      { this$1$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }\n  }); }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nvar EditorState = function EditorState(config) {\n  this.config = config;\n};\n\nvar prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next input. Will be null when\n// no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors$1.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors$1.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → bool\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this.config.plugins[i];\n    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](#state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](#state.PluginSpec.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (rootTr) {\n  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }\n\n  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n   for (;;) {\n    var haveNew = false;\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this.config.plugins[i];\n      if (plugin.spec.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n        var tr = n < trs.length &&\n            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n        if (tr && newState.filterTransaction(tr, i)) {\n          tr.setMeta(\"appendedTransaction\", rootTr);\n          if (!seen) {\n            seen = [];\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }\n          }\n          trs.push(tr);\n          newState = newState.applyInner(tr);\n          haveNew = true;\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length}; }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields;\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors$1.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a new state.\n//\n// config::- Configuration options. Must contain `schema` or `doc` (or both).\n//\n//    schema:: ?Schema\n//    The schema to use (only relevant if no `doc` is specified).\n//\n//    doc:: ?Node\n//    The starting document.\n//\n//    selection:: ?Selection\n//    A valid selection in the document.\n//\n//    storedMarks:: ?[Mark]\n//    The initial set of [stored marks](#state.EditorState.storedMarks).\n//\n//    plugins:: ?[Plugin]\n//    The plugins that should be active in this state.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n  var instance = new EditorState($config);\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\n//\n// config::- configuration options\n//\n//   plugins:: [Plugin]\n//   New set of active plugins.\nEditorState.prototype.reconfigure = function reconfigure (config) {\n  var $config = new Configuration(this.schema, config.plugins);\n  var fields = $config.fields, instance = new EditorState($config);\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name;\n    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n  }\n  return instance\n};\n\n// :: (?union<Object<Plugin>, string, number>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects. The argument may also be\n// a string or number, in which case it is ignored, to support the\n// way `JSON.stringify` calls `toString` methods.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};\n  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }\n  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.spec.state;\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\n//\n// config::- configuration options\n//\n//   schema:: Schema\n//   The schema to use.\n//\n//   plugins:: ?[Plugin]\n//   The set of active plugins.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!json) { throw new RangeError(\"Invalid input for EditorState.fromJSON\") }\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins);\n  var instance = new EditorState($config);\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = Node.fromJSON(config.schema, json.doc);\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection);\n    } else if (field.name == \"storedMarks\") {\n      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.spec.state;\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance);\n    }\n  });\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\n//\n// FIXME this is no longer needed as of prosemirror-view 1.9.0,\n// though due to backwards-compat we should probably keep it around\n// for a while (if only as a no-op)\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f);\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f);\n  if (found > -1) { applyListeners.splice(found, 1); }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors$1 );\n\nvar applyListeners = [];\n\nfunction createCell(cellType, cellContent) {\r\n    if (cellContent) {\r\n        return cellType.createChecked(null, cellContent);\r\n    }\r\n    return cellType.createAndFill();\r\n}\n\nfunction getTableNodeTypes(schema) {\r\n    if (schema.cached.tableNodeTypes) {\r\n        return schema.cached.tableNodeTypes;\r\n    }\r\n    const roles = {};\r\n    Object.keys(schema.nodes).forEach(type => {\r\n        const nodeType = schema.nodes[type];\r\n        if (nodeType.spec.tableRole) {\r\n            roles[nodeType.spec.tableRole] = nodeType;\r\n        }\r\n    });\r\n    schema.cached.tableNodeTypes = roles;\r\n    return roles;\r\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\r\n    const types = getTableNodeTypes(schema);\r\n    const headerCells = [];\r\n    const cells = [];\r\n    for (let index = 0; index < colsCount; index += 1) {\r\n        const cell = createCell(types.cell, cellContent);\r\n        if (cell) {\r\n            cells.push(cell);\r\n        }\r\n        if (withHeaderRow) {\r\n            const headerCell = createCell(types.header_cell, cellContent);\r\n            if (headerCell) {\r\n                headerCells.push(headerCell);\r\n            }\r\n        }\r\n    }\r\n    const rows = [];\r\n    for (let index = 0; index < rowsCount; index += 1) {\r\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\r\n    }\r\n    return types.table.createChecked(null, rows);\r\n}\n\nfunction isCellSelection(value) {\r\n    return value instanceof CellSelection;\r\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\r\n    const { selection } = editor.state;\r\n    if (!isCellSelection(selection)) {\r\n        return false;\r\n    }\r\n    let cellCount = 0;\r\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\r\n        return node.type.name === 'table';\r\n    });\r\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\r\n        if (node.type.name === 'table') {\r\n            return false;\r\n        }\r\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\r\n            cellCount += 1;\r\n        }\r\n    });\r\n    const allCellsSelected = cellCount === selection.ranges.length;\r\n    if (!allCellsSelected) {\r\n        return false;\r\n    }\r\n    editor.commands.deleteTable();\r\n    return true;\r\n};\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n    let totalWidth = 0;\r\n    let fixedWidth = true;\r\n    let nextDOM = colgroup.firstChild;\r\n    const row = node.firstChild;\r\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\r\n        const { colspan, colwidth } = row.child(i).attrs;\r\n        for (let j = 0; j < colspan; j += 1, col += 1) {\r\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\r\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\r\n            totalWidth += hasWidth || cellMinWidth;\r\n            if (!hasWidth) {\r\n                fixedWidth = false;\r\n            }\r\n            if (!nextDOM) {\r\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\r\n            }\r\n            else {\r\n                if (nextDOM.style.width !== cssWidth) {\r\n                    nextDOM.style.width = cssWidth;\r\n                }\r\n                nextDOM = nextDOM.nextSibling;\r\n            }\r\n        }\r\n    }\r\n    while (nextDOM) {\r\n        const after = nextDOM.nextSibling;\r\n        nextDOM.parentNode.removeChild(nextDOM);\r\n        nextDOM = after;\r\n    }\r\n    if (fixedWidth) {\r\n        table.style.width = `${totalWidth}px`;\r\n        table.style.minWidth = '';\r\n    }\r\n    else {\r\n        table.style.width = '';\r\n        table.style.minWidth = `${totalWidth}px`;\r\n    }\r\n}\r\nclass TableView {\r\n    constructor(node, cellMinWidth) {\r\n        this.node = node;\r\n        this.cellMinWidth = cellMinWidth;\r\n        this.dom = document.createElement('div');\r\n        this.dom.className = 'tableWrapper';\r\n        this.table = this.dom.appendChild(document.createElement('table'));\r\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\r\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\r\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\r\n    }\r\n    update(node) {\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        this.node = node;\r\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));\r\n    }\r\n}\n\nconst Table = Node$1.create({\r\n    name: 'table',\r\n    // @ts-ignore\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            resizable: false,\r\n            handleWidth: 5,\r\n            cellMinWidth: 25,\r\n            // TODO: fix\r\n            View: TableView,\r\n            lastColumnResizable: true,\r\n            allowTableNodeSelection: false,\r\n        };\r\n    },\r\n    content: 'tableRow+',\r\n    tableRole: 'table',\r\n    isolating: true,\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'table' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\r\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\r\n                if (dispatch) {\r\n                    const offset = tr.selection.anchor + 1;\r\n                    tr.replaceSelectionWith(node)\r\n                        .scrollIntoView()\r\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\r\n                }\r\n                return true;\r\n            },\r\n            addColumnBefore: () => ({ state, dispatch }) => {\r\n                return addColumnBefore(state, dispatch);\r\n            },\r\n            addColumnAfter: () => ({ state, dispatch }) => {\r\n                return addColumnAfter(state, dispatch);\r\n            },\r\n            deleteColumn: () => ({ state, dispatch }) => {\r\n                return deleteColumn(state, dispatch);\r\n            },\r\n            addRowBefore: () => ({ state, dispatch }) => {\r\n                return addRowBefore(state, dispatch);\r\n            },\r\n            addRowAfter: () => ({ state, dispatch }) => {\r\n                return addRowAfter(state, dispatch);\r\n            },\r\n            deleteRow: () => ({ state, dispatch }) => {\r\n                return deleteRow(state, dispatch);\r\n            },\r\n            deleteTable: () => ({ state, dispatch }) => {\r\n                return deleteTable(state, dispatch);\r\n            },\r\n            mergeCells: () => ({ state, dispatch }) => {\r\n                return mergeCells(state, dispatch);\r\n            },\r\n            splitCell: () => ({ state, dispatch }) => {\r\n                return splitCell(state, dispatch);\r\n            },\r\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\r\n                return toggleHeader('column')(state, dispatch);\r\n            },\r\n            toggleHeaderRow: () => ({ state, dispatch }) => {\r\n                return toggleHeader('row')(state, dispatch);\r\n            },\r\n            toggleHeaderCell: () => ({ state, dispatch }) => {\r\n                return toggleHeaderCell(state, dispatch);\r\n            },\r\n            mergeOrSplit: () => ({ state, dispatch }) => {\r\n                if (mergeCells(state, dispatch)) {\r\n                    return true;\r\n                }\r\n                return splitCell(state, dispatch);\r\n            },\r\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\r\n                return setCellAttr(name, value)(state, dispatch);\r\n            },\r\n            goToNextCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(1)(state, dispatch);\r\n            },\r\n            goToPreviousCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(-1)(state, dispatch);\r\n            },\r\n            fixTables: () => ({ state, dispatch }) => {\r\n                if (dispatch) {\r\n                    fixTables(state);\r\n                }\r\n                return true;\r\n            },\r\n            setCellSelection: position => ({ tr, dispatch }) => {\r\n                if (dispatch) {\r\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\r\n                    // @ts-ignore\r\n                    tr.setSelection(selection);\r\n                }\r\n                return true;\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Tab: () => {\r\n                if (this.editor.commands.goToNextCell()) {\r\n                    return true;\r\n                }\r\n                if (!this.editor.can().addRowAfter()) {\r\n                    return false;\r\n                }\r\n                return this.editor\r\n                    .chain()\r\n                    .addRowAfter()\r\n                    .goToNextCell()\r\n                    .run();\r\n            },\r\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\r\n            Backspace: deleteTableWhenAllCellsSelected,\r\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\r\n            Delete: deleteTableWhenAllCellsSelected,\r\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        const isResizable = this.options.resizable && this.editor.isEditable;\r\n        return [\r\n            ...(isResizable ? [columnResizing({\r\n                    handleWidth: this.options.handleWidth,\r\n                    cellMinWidth: this.options.cellMinWidth,\r\n                    View: this.options.View,\r\n                    // TODO: PR for @types/prosemirror-tables\r\n                    // @ts-ignore (incorrect type)\r\n                    lastColumnResizable: this.options.lastColumnResizable,\r\n                })] : []),\r\n            tableEditing({\r\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\r\n            }),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\r\n        };\r\n    },\r\n});\n\nexport { Table, createTable, Table as default };\n//# sourceMappingURL=tiptap-extension-table.esm.js.map\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cache$1","cachePos","i","length","Rect","left","top","right","bottom","this","TableMap","width","height","map","problems","freshColWidth","attrs","colwidth","slice","result","colspan","push","tableNodeTypes","schema","cached","name","nodes","type","role","spec","tableRole","prototype","findCell","pos","curPos","j","j$1","RangeError","colCount","nextCell","axis","dir","ref","rectBetween","a","b","leftA","rightA","topA","bottomA","ref$1","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","seen","row","col","index","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","rowspan","i$1","cell$1","findWidth","mapPos","colWidths","e","cellNode","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","i$2","node","nodeAt","updated","colWidth","unshift","findBadColWidths","computeMap","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","after","nodeAfter","firstChild","doc","nodeBefore","pos$1","lastChild","role$1","cellNear","pointsAtCell","parent","inSameTable","$a","$b","end","moved","setAttr","prop","removeColSpan","splice","some","addColSpan","CellSelection","Selection","cells","filter","p","ranges","from","content","size","call","$from","$to","__proto__","Object","create","constructor","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","attrs$1","copy","fragment","replace","tr","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBot","headBot","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","head","fromJSON","json","anchorCell","headCell","getBookmark","CellBookmark","visible","drawCellSelection","class","pastedCells","openStart","openEnd","first","fitSlice","widths","r","r$1","r$2","empty","append","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","setNodeMarkup","insert","isolateVertical","updatePos","insertCells","dispatch","tableStart","recomp","maps","emptyHead","types","add","header_cell","cells$1","start$1","header","emptyRow","growTable","handleKeyDown","arrow","shiftArrow","deleteCellSelection","maybeSetSelection","scrollIntoView","view","atEndOfCell","newSel","$cell","$next","baseContent","docChanged","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","newRows$1","row$1","source","clipCells","handleMouseDown","startEvent","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","root","addEventListener","stop","move","event","starting","getState","setMeta","removeEventListener","indexAfter","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","last","mustAdd","prob","cell$2","i$3","tableNodeType","side","fixTable","descendants","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","delete","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","newPos","isEmpty","c","isTextblock","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","mapped","splitCell","getCellType","nodeTypes","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","rowNode$1","findNextCell","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumns","contentDOM","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","update","ignoreMutation","record","contains","key$1","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","apply","attributes","activeHandle","handleDOMEvents","mousemove","pluginState","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","window","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown$1","decorations","handleDecorations","indexOf","setHandle","tableEditing","allowTableNodeSelection","getMeta","mapResult","deleted","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","node$1","parentOffset","isTextSelectionAcrossCells","normalizeSelection","findDiffStart","childA","childB","isText","text","inner","findDiffEnd","posA","posB","iA","iB","same","minSize","action","undefined","handle","Fragment","prototypeAccessors$3","configurable","nodeStart","textBetween","blockSeparator","leafText","separated","isLeaf","isBlock","withText","cut","cutByIndex","replaceChild","current","addToStart","concat","addToEnd","maybeChild","otherPos","findIndex","round","retIndex","toString","toStringInner","join","Array","isArray","nodeFromJSON","fromArray","array","joined","defineProperties","compareDeep","p$1","Mark","ReplaceError","message","err","Error","addToSet","placed","excludes","rank","removeFromSet","isInSet","obj","marks","sameSet","setFrom","none","sort","Slice","prototypeAccessors$1$2","removeRange","indexTo","offsetTo","insertInto","dist","canReplace","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","replaceThreeWay","replaceTwoWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","addRange","$start","$end","startIndex","endIndex","textOffset","validContent","insertAt","removeBetween","maxOpen","openIsolating","isolating","n$1","ResolvedPos","path","prototypeAccessors$2$1","resolveDepth","val","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","inlineContent","NodeRange","sameParent","str","rem","resolveCached","resolveCache","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1$1","emptyAttrs","Node","prototypeAccessors$3$1","textContent","isAtom","startPos","hasMarkup","defaultAttrs","mark","includeParents","childAfter","childBefore","rangeHasMark","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","m","markFromJSON","ContentMatch","wrapCache","prototypeAccessors$4","defaultType","edgeCount","parse","string","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","states$1","cmp","dfa","connect","compile","edge","edges","exprs","reduce","loop","loop$1","next$1","next$2","work","dead","hasRequiredAttrs","checkForDeadEnds","compatible","fillBefore","toEnd","search","finished","tp","findWrapping","computed","computeWrapping","active","via","shift","reverse","inline","tokens","split","pop","prototypeAccessors$1$2$1","parseExprSeq","eat","parseExprSubscript","typeName","type$1","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","prototypeAccessors$5","whitespace","atom","code","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","hasOwnProperty","prototypeAccessors$1$3","MarkType","excluded","instance","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","hgroup","hr","li","noscript","ol","output","pre","section","tfoot","ul","ignoreTags","object","script","title","listTags","wsOptionsFor","preserveWhitespace","base","OPT_PRESERVE_WS","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","inlineContext","toLowerCase","ParseContext","parser","open","isOpen","topContext","topOptions","topMatch","topNodeType","find","findPositions","needsBlock","prototypeAccessors$6","currentPos","v","returned","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","normalizeLists","prevItem","normalizeList","rule","ruleFromNode","matchTag","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addAll","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","styles","matchStyle","continueAfter","this$1$1","enter","startIn","getContent","contentElement","querySelector","findAround","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","ok","topOpen","compareDocumentPosition","textNode","matchesContext","context","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","factor16","pow","recoverIndex","MapResult","recover","StepMap","inverted","diff","recoverOffset","assoc","_map","simple","oldIndex","newIndex","newSize","touches","oldStart","newStart","invert","JSON","stringify","Mapping","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","docs","prototypeAccessors$2","mustOverride","step","maybeStep","failed","addStep","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","ReplaceStep","structure","contentBetween","slice$1","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","mapFragment","lift","range","gapStart","gapEnd","splitting","d$1","splitting$1","wrappers","setBlockType","canChangeType","clearIncompatible","startM","endM","newNode","typesAfter","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","fitsTrivially","addMark","removed","removing","adding","newSet","s","removeMark","matched","toRemove","found$1","parentType","delSteps","allowed","Fitter","fit","replaceStep","unplaced","frontier","prototypeAccessors$1$1","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","close","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","matches","findCloseLevel","dropInner","match$1","replaceRange","deleteRange","targetDepths","preferredTarget","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","index$1","insertPoint","covered","classesById","SelectionRange","prototypeAccessors","lastNode","lastParent","selectionToInsertionEnd","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","selectionClass","between","prototypeAccessors$1","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","meta","selectionSet","storedMarksSet","isGeneric","scrolledIntoView","setStoredMarks","addStoredMark","removeStoredMark","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","bind","self","FieldDesc","desc","baseFields","config","_marks","_old","Configuration","plugins","fields","pluginsByKey","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","createCell","cellType","cellContent","createTable","rowsCount","colsCount","withHeaderRow","roles","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","mutation","Table","addOptions","HTMLAttributes","resizable","parseHTML","tag","renderHTML","mergeAttributes","addCommands","insertTable","cols","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","Backspace","Delete","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","storage","callOrReturn","getExtensionField"],"sourceRoot":""}