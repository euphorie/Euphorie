{"version":3,"file":"chunks/75111.d5025ccb25c09943176e.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-code-block/dist/index.js"],"sourcesContent":["import { Node, mergeAttributes, textblockTypeInputRule } from '@tiptap/core';\nimport { Selection, Plugin, PluginKey, TextSelection } from '@tiptap/pm/state';\n\n/**\n * Matches a code block with backticks.\n */\nconst backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\n * Matches a code block with tildes.\n */\nconst tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nconst CodeBlock = Node.create({\n    name: 'codeBlock',\n    addOptions() {\n        return {\n            languageClassPrefix: 'language-',\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            HTMLAttributes: {},\n        };\n    },\n    content: 'text*',\n    marks: '',\n    group: 'block',\n    code: true,\n    defining: true,\n    addAttributes() {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: element => {\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [...(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || [])];\n                    const languages = classNames\n                        .filter(className => className.startsWith(languageClassPrefix))\n                        .map(className => className.replace(languageClassPrefix, ''));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false,\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'pre',\n                preserveWhitespace: 'full',\n            },\n        ];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        return [\n            'pre',\n            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                'code',\n                {\n                    class: node.attrs.language\n                        ? this.options.languageClassPrefix + node.attrs.language\n                        : null,\n                },\n                0,\n            ],\n        ];\n    },\n    addCommands() {\n        return {\n            setCodeBlock: attributes => ({ commands }) => {\n                return commands.setNode(this.name, attributes);\n            },\n            toggleCodeBlock: attributes => ({ commands }) => {\n                return commands.toggleNode(this.name, 'paragraph', attributes);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: () => {\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor }) => {\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n');\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor\n                    .chain()\n                    .command(({ tr }) => {\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                })\n                    .exitCode()\n                    .run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor }) => {\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr }) => {\n                        tr.setSelection(Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            },\n        };\n    },\n    addInputRules() {\n        return [\n            textblockTypeInputRule({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n            textblockTypeInputRule({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new Plugin({\n                key: new PluginKey('codeBlockVSCodeHandler'),\n                props: {\n                    handlePaste: (view, event) => {\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // donâ€™t create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData('text/plain');\n                        const vscode = event.clipboardData.getData('vscode-editor-data');\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        // prepare a text node\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'));\n                        // create a code block with the text node\n                        // replace selection with the code block\n                        tr.replaceSelectionWith(this.type.create({ language }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            // put cursor inside the newly created code block\n                            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta('paste', true);\n                        view.dispatch(tr);\n                        return true;\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nexport { CodeBlock, backtickInputRegex, CodeBlock as default, tildeInputRegex };\n//# sourceMappingURL=index.js.map\n"],"names":["backtickInputRegex","tildeInputRegex","CodeBlock","Node","create","name","addOptions","languageClassPrefix","exitOnTripleEnter","exitOnArrowDown","defaultLanguage","HTMLAttributes","content","marks","group","code","defining","addAttributes","language","default","this","options","parseHTML","element","_a","firstElementChild","classList","filter","className","startsWith","map","replace","rendered","tag","preserveWhitespace","renderHTML","node","mergeAttributes","class","attrs","addCommands","setCodeBlock","attributes","commands","setNode","toggleCodeBlock","toggleNode","addKeyboardShortcuts","editor","Backspace","empty","$anchor","state","selection","isAtStart","pos","parent","type","textContent","length","clearNodes","Enter","$from","isAtEnd","parentOffset","nodeSize","endsWithDoubleNewline","endsWith","chain","command","tr","delete","exitCode","run","ArrowDown","doc","after","undefined","nodeAt","setSelection","near","resolve","addInputRules","textblockTypeInputRule","find","getAttributes","match","addProseMirrorPlugins","key","props","handlePaste","view","event","clipboardData","isActive","text","getData","vscode","vscodeData","JSON","parse","mode","schema","textNode","replaceSelectionWith","Math","max","from","setMeta","dispatch"],"sourceRoot":""}