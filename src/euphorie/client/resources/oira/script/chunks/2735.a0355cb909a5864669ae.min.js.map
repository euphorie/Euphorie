{"version":3,"file":"chunks/2735.a0355cb909a5864669ae.min.js","mappings":"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","sources":["webpack://oira.prototype/./node_modules/@patternslib/patternslib/src/pat/scroll/scroll.js"],"sourcesContent":["import \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport \"../../core/jquery-ext\";\nimport $ from \"jquery\";\nimport Base from \"../../core/base\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.scroll\");\n\nexport const parser = new Parser(\"scroll\");\nparser.addArgument(\"trigger\", \"click\", [\"click\", \"auto\", \"manual\"]);\nparser.addArgument(\"direction\", \"top\", [\"top\", \"left\"]);\nparser.addArgument(\"selector\");\nparser.addArgument(\"offset\", 0);\nparser.addArgument(\"delay\");\n\nexport default Base.extend({\n    name: \"scroll\",\n    trigger: \".pat-scroll\",\n    jquery_plugin: true,\n\n    async init($el, opts) {\n        this.options = parser.parse(this.$el, opts);\n        if (this.options.delay) {\n            this.options.delay = utils.parseTime(this.options.delay);\n        }\n        if (this.options.trigger === \"auto\") {\n            const ImagesLoaded = (await import(\"imagesloaded\")).default;\n            // Only calculate the offset when all images are loaded\n            ImagesLoaded(document.body, () => this.smoothScroll());\n        }\n        if (this.options.trigger === \"auto\" || this.options.trigger === \"click\") {\n            this.el.addEventListener(\"click\", this.onClick.bind(this));\n        }\n        this.$el.on(\"pat-update\", this.onPatternsUpdate.bind(this));\n        this.markBasedOnFragment();\n        this.on(\"hashchange\", this.clearIfHidden.bind(this));\n        $(window).scroll(utils.debounce(this.markIfVisible.bind(this), 50));\n    },\n\n    onClick() {\n        //ev.preventDefault();\n        history.pushState({}, null, this.$el.attr(\"href\"));\n        this.smoothScroll();\n        this.markBasedOnFragment();\n        // manually trigger the hashchange event on all instances of pat-scroll\n        $(\"a.pat-scroll\").trigger(\"hashchange\");\n    },\n\n    markBasedOnFragment() {\n        // Get the fragment from the URL and set the corresponding this.$el as current\n        const fragment = window.location.hash.substr(1);\n        if (fragment) {\n            const $target = $(\"#\" + fragment);\n            this.$el.addClass(\"current\"); // the element that was clicked on\n            $target.addClass(\"current\");\n        }\n    },\n\n    clearIfHidden() {\n        const active_target = \"#\" + window.location.hash.substr(1);\n        const $active_target = $(active_target);\n        const target = \"#\" + this.$el[0].href.split(\"#\").pop();\n        if ($active_target.length > 0) {\n            if (active_target != target) {\n                // if the element does not match the one listed in the url #,\n                // clear the current class from it.\n                const $target = $(\"#\" + this.$el[0].href.split(\"#\").pop());\n                $target.removeClass(\"current\");\n                this.$el.removeClass(\"current\");\n            }\n        }\n    },\n\n    markIfVisible() {\n        if (this.$el.hasClass(\"pat-scroll-animated\")) {\n            // this section is triggered when the scrolling is a result of the animate function\n            // ie. automatic scrolling as opposed to the user manually scrolling\n            this.$el.removeClass(\"pat-scroll-animated\");\n        } else if (this.$el[0].nodeName === \"A\") {\n            const href = this.$el[0].href;\n            const fragment =\n                (href.indexOf(\"#\") !== -1 && href.split(\"#\").pop()) || undefined;\n            if (fragment) {\n                const $target = $(\"#\" + fragment);\n                if ($target.length) {\n                    if (\n                        utils.isElementInViewport($target[0], true, this.options.offset)\n                    ) {\n                        // check that the anchor's target is visible\n                        // if so, mark both the anchor and the target element\n                        $target.addClass(\"current\");\n                        this.$el.addClass(\"current\");\n                    }\n                    $(this.$el).trigger(\"pat-update\", { pattern: \"scroll\" });\n                }\n            }\n        }\n    },\n\n    onPatternsUpdate(ev, data) {\n        if (data?.pattern === \"stacks\") {\n            if (data.originalEvent && data.originalEvent.type === \"click\") {\n                this.smoothScroll();\n            }\n        } else if (data?.pattern === \"scroll\") {\n            const href = this.$el[0].href;\n            const fragment =\n                (href.indexOf(\"#\") !== -1 && href.split(\"#\").pop()) || undefined;\n            if (fragment) {\n                const $target = $(\"#\" + fragment);\n                if ($target.length) {\n                    if (\n                        !utils.isElementInViewport($target[0], true, this.options.offset)\n                    ) {\n                        // if the anchor's target is invisible, remove current class from anchor and target.\n                        $target.removeClass(\"current\");\n                        $(this.$el).removeClass(\"current\");\n                    }\n                }\n            }\n        }\n    },\n\n    findScrollContainer(el) {\n        const direction = this.options.direction;\n        let scrollable = $(el)\n            .parents()\n            .filter((idx, el) => {\n                return (\n                    [\"auto\", \"scroll\"].indexOf($(el).css(\"overflow\")) > -1 ||\n                    (direction === \"top\" &&\n                        [\"auto\", \"scroll\"].indexOf($(el).css(\"overflow-y\")) > -1) ||\n                    (direction === \"left\" &&\n                        [\"auto\", \"scroll\"].indexOf($(el).css(\"overflow-x\")) > -1)\n                );\n            })\n            .first();\n        if (typeof scrollable[0] === \"undefined\") {\n            scrollable = $(\"body\");\n        }\n        return scrollable;\n    },\n\n    _get_selector_target() {\n        const selector = this.options.selector;\n        if (!selector && this.el.href?.includes(\"#\")) {\n            return document.querySelector(`#${this.el.href.split(\"#\").pop()}`);\n        } else if (!selector || selector === \"self\") {\n            return this.el;\n        }\n        return document.querySelector(selector);\n    },\n\n    async smoothScroll() {\n        if (this.options.delay) {\n            await utils.timeout(this.options.delay);\n        }\n        const scroll = this.options.direction == \"top\" ? \"scrollTop\" : \"scrollLeft\";\n        const options = {};\n        let scrollable;\n        if (this.options.selector === \"top\") {\n            // Just scroll up or left, period.\n            scrollable = this.findScrollContainer(this.$el);\n            options[scroll] = 0;\n        } else if (this.options.selector === \"bottom\") {\n            // Just scroll down or right, period.\n            scrollable = this.findScrollContainer(this.$el);\n            if (scroll === \"scrollTop\") {\n                options.scrollTop = scrollable[0].scrollHeight;\n            } else {\n                options.scrollLeft = scrollable[0].scrollWidth;\n            }\n        } else {\n            // Get the first element with overflow (the scroll container)\n            // starting from the *target*\n            // The intent is to move target into view within scrollable\n            // if the scrollable has no scrollbar, do not scroll body\n\n            const target = $(this._get_selector_target());\n\n            if (!target.length) {\n                return;\n            }\n\n            scrollable = this.findScrollContainer(target);\n\n            if (scrollable[0] === document.body) {\n                // positioning context is document\n                if (scroll === \"scrollTop\") {\n                    options[scroll] = Math.floor(target.safeOffset().top);\n                } else {\n                    options[scroll] = Math.floor(target.safeOffset().left);\n                }\n            } else if (scroll === \"scrollTop\") {\n                // difference between target top and scrollable top becomes 0\n                options[scroll] = Math.floor(\n                    scrollable.scrollTop() +\n                        target.safeOffset().top -\n                        scrollable.safeOffset().top\n                );\n            } else {\n                options[scroll] = Math.floor(\n                    scrollable.scrollLeft() +\n                        target.safeOffset().left -\n                        scrollable.safeOffset().left\n                );\n            }\n        }\n\n        options[scroll] -= this.options.offset;\n\n        // Fix scrolling on body - need to scroll on HTML, howsoever.\n        if (scrollable[0] === document.body) {\n            scrollable = $(\"html\");\n        }\n\n        // execute the scroll\n        await scrollable\n            .animate(options, {\n                duration: 500,\n                start: () => {\n                    $(\".pat-scroll\").addClass(\"pat-scroll-animated\");\n                    log.debug(\"scrolling.\");\n                },\n            })\n            .promise();\n    },\n});\n"],"names":["log","parser","addArgument","name","trigger","jquery_plugin","async","$el","opts","this","options","parse","delay","ImagesLoaded","default","document","body","smoothScroll","el","addEventListener","onClick","bind","on","onPatternsUpdate","markBasedOnFragment","clearIfHidden","window","scroll","markIfVisible","history","pushState","attr","fragment","location","hash","substr","$target","addClass","active_target","$active_target","target","href","split","pop","length","removeClass","hasClass","nodeName","indexOf","undefined","offset","pattern","ev","data","originalEvent","type","findScrollContainer","direction","scrollable","parents","filter","idx","css","first","_get_selector_target","selector","includes","querySelector","scrollTop","scrollHeight","scrollLeft","scrollWidth","Math","floor","safeOffset","top","left","animate","duration","start","debug","promise"],"sourceRoot":""}