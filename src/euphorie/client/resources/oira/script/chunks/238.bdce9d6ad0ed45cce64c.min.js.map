{"version":3,"file":"chunks/238.bdce9d6ad0ed45cce64c.min.js","mappings":"yeACA,4gGAAAA,GAAA,wBAAAA,EAAA,sBAAAA,GAAA,iBAAAA,GAAA,0oDAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,4bAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,yhBAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,qGAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,sQ,4TAIA,IAAIC,EAAY,KAET,SAAeC,EAAtB,kC,kCAAO,gHACHC,EADG,EACHA,IACAC,EAFG,EAEHA,OAFG,IAGHC,SAAAA,OAHG,MAGQ,KAHR,MAIHC,QAAAA,OAJG,MAIO,KAJP,MAKHC,YAAAA,OALG,MAKW,KALX,EAOGC,EAAYP,EACZQ,EAAYR,EAAYG,EAAOM,MAAMC,IAAIC,OAAOR,EAAOM,MAAMG,UAAUC,MAE5D,OAAbT,GAAqBI,IAAaD,IAElCH,EAAWU,EAAmB,CAC1BV,SAAUA,EACVW,aAAcV,EAAQW,QAIzBZ,EAlBF,wBAyBKC,IACAY,EAAAA,EAAAA,SAAkBZ,EAAQW,MAAQX,GAIhCa,EAAiBf,EAAOgB,QAAQC,QA9BvC,SA+BkB,IAAIC,EAAAA,EAAWH,EAAgB,CAC5C,OAAU,OACV,IAAOhB,EACP,QAAW,OACX,MAASI,EACT,gBAAiB,CAAC,QApCvB,cA+BCF,EA/BD,iBAuCOkB,EAAAA,EAAAA,mBAA0BlB,GAvCjC,QAyCOmB,GAAqBC,EAAAA,EAAAA,cACvBrB,EAAOsB,KACPtB,EAAOM,MAAMG,UAAUC,KACvBV,EAAOM,MAAMG,UAAUc,IAG3B,UAAAtB,EAASuB,aAAT,SAAgBC,SAAS,CAErBC,uBAAwB,kBAAMN,KAGlCnB,EAAS0B,OApDV,wBAsDC1B,EAAS2B,YAAY7B,GAtDtB,iCAyDIE,GAzDJ,6C,sBA4DA,SAASU,EAAT,GAAwD,IAA1BV,EAA0B,EAA1BA,SAAUW,EAAgB,EAAhBA,aAY3C,OAVIX,IACAA,EAAS4B,OACT5B,EAAS6B,UACT7B,EAAW,MAIXW,UACOE,EAAAA,EAAAA,SAAkBF,GAEtB,O,mXC9EX,4gGAAAhB,GAAA,wBAAAA,EAAA,sBAAAA,GAAA,iBAAAA,GAAA,0oDAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,4bAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,yhBAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,qGAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,sQ,4TAEO,IAAMmC,EAAU,GAEhB,SAASC,EAAcC,GAG1BA,EAAGC,aAAa,WAAY,MAC5Bf,EAAAA,EAAAA,mBACIc,EACA,QACA,iBAHJ,YAII,8EACIE,EAAAA,EAAAA,QAAc,GACdJ,EAAQK,KAAI,SAACC,GAAD,OAAQA,MAAAA,OAAR,EAAQA,EAAIC,UAAUC,IAAI,mBAF1C,4CAIA,GAEJpB,EAAAA,EAAAA,mBACIc,EACA,OACA,mBACA,WACIF,EAAQK,KAAI,SAACC,GAAD,OAAQA,MAAAA,OAAR,EAAQA,EAAIC,UAAUE,OAAO,sBAE7C","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import Registry from \"@patternslib/patternslib/src/core/registry\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (instance !== null && cur_node !== prev_node) {\n        // Close context menu, when new node is selected.\n        instance = context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n    }\n\n    if (!instance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            Registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = await new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete Registry.patterns[pattern_name];\n    }\n    return null;\n}\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["i","PREV_NODE","context_menu","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","context_menu_close","pattern_name","name","Registry","editor_element","options","element","patTooltip","events","reference_position","posToDOMRect","view","to","tippy","setProps","getReferenceClientRect","show","get_content","hide","destroy","TARGETS","focus_handler","el","setAttribute","utils","map","it","classList","add","remove"],"sourceRoot":""}