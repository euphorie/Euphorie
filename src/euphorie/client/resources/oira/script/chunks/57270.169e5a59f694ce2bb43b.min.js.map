{"version":3,"file":"chunks/57270.169e5a59f694ce2bb43b.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/rope-sequence/dist/index.js","webpack://@patternslib/patternslib/./node_modules/prosemirror-history/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-history/dist/index.js"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n","import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n","import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from '@tiptap/pm/history';\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = Extension.create({\n    name: 'history',\n    addOptions() {\n        return {\n            depth: 100,\n            newGroupDelay: 500,\n        };\n    },\n    addCommands() {\n        return {\n            undo: () => ({ state, dispatch }) => {\n                return undo(state, dispatch);\n            },\n            redo: () => ({ state, dispatch }) => {\n                return redo(state, dispatch);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            history(this.options),\n        ];\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            // Russian keyboard layouts\n            'Mod-я': () => this.editor.commands.undo(),\n            'Shift-Mod-я': () => this.editor.commands.redo(),\n        };\n    },\n});\n\nexport { History, History as default };\n//# sourceMappingURL=index.js.map\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","prototype","append","other","length","from","this","leafAppend","leafPrepend","appendInner","prepend","Append","slice","to","empty","sliceInner","Math","max","min","get","i","getInner","forEach","f","forEachInner","forEachInvertedInner","map","result","elt","push","values","Leaf","call","__proto__","Object","create","constructor","prototypeAccessors","configurable","depth","flatten","start","concat","defineProperties","left","right","leftLen","inner","Branch","items","eventCount","popEvent","state","preserveItems","remap","mapFrom","end","selection","remapping","maps","remaining","transform","tr","addAfter","addBefore","item","step","Item","maybeStep","doc","mapping","undefined","appendMap","reverse","addTransform","histOptions","newItems","oldItems","lastItem","steps","merged","invert","docs","merge","pop","overflow","DEPTH_OVERFLOW","n","cutPoint","cutOffEvents","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","newUntil","iRebased","pos","getMirror","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","last","HistoryState","done","undone","prevRanges","prevTime","prevComposition","rangesFor","_from","_to","mapRanges","ranges","cachedPreserveItems","cachedPreserveItemsPlugins","mustPreserveItems","plugins","spec","historyPreserveItems","historyKey","closeHistoryKey","config","newGroupDelay","key","init","apply","hist","history","options","historyTr","getMeta","historyState","appended","redo","composition","newGroup","time","docChanged","adjacent","isAdjacentTo","getBookmark","applyTransaction","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","dispatch","buildCommand","scroll","getState","resolve","added","newHist","setSelection","setMeta","histTransaction","scrollIntoView","History","Extension","name","addOptions","addCommands","addProseMirrorPlugins","addKeyboardShortcuts","editor","commands"],"sourceRoot":""}