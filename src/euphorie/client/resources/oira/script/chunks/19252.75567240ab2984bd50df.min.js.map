{"version":3,"file":"chunks/19252.75567240ab2984bd50df.min.js","mappings":"mNAqBA,SAASA,EAAcC,GAAkB,IAAjB,MAAEC,EAAK,KAAEC,GAAMF,EACnC,OAAQG,MAAMC,QAAQH,IAAUA,EAAMI,SAASH,EAAKI,OAAUJ,EAAKI,OAASL,CAChF,CAEO,MAAMM,EAAUA,IAMZC,EAAAA,UAAUC,OAAO,CACpBC,KAAM,eAENC,UAAAA,GACI,MAAO,CACHT,KAAM,kBACNU,SAAU,CAAC,YAAa,mBAEhC,EAEAC,qBAAAA,GACI,MAAMC,EAAS,IAAIC,EAAAA,GAAUC,KAAKN,MAC5BO,EAAgBC,OAAOC,QAAQH,KAAKI,OAAOC,OAAOC,OACnDC,KAAIC,IAAA,IAAE,CAAEC,GAAMD,EAAA,OAAKC,CAAK,IACxBC,QAAQxB,GAASc,KAAKW,QAAQf,SAASP,SAASH,EAAKQ,QAE1D,MAAO,CACH,IAAIkB,EAAAA,GAAO,CACPC,IAAKf,EACLgB,kBAAmBA,CAACC,EAAGC,EAAIC,KACvB,MAAM,IAAEC,EAAG,GAAEC,EAAE,OAAEd,GAAWY,EACtBG,EAAwBtB,EAAOuB,SAASJ,GACxCK,EAAcJ,EAAIK,QAAQC,KAC1BlC,EAAOe,EAAOC,MAAMN,KAAKW,QAAQzB,MAEvC,GAAKkC,EAIL,OAAOD,EAAGM,OACNH,EACAhC,EAAKG,OAAO,KAAM,CAACY,EAAOqB,KAAK,OAClC,EAELT,MAAO,CACHU,KAAMA,CAACZ,EAAGE,KAEElC,EAAe,CACnBG,KAFa+B,EAAME,GAAGD,IAAIU,UAG1B3C,MAAOgB,IAGf4B,MAAOA,CAACV,EAAIV,KACR,IAAKU,EAAGW,WACJ,OAAOrB,EAIX,OAAQ1B,EAAe,CACnBG,KAFaiC,EAAGD,IAAIU,UAGpB3C,MAAOgB,GACT,KAKtB,G","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/trailing-node.js"],"sourcesContent":["// TrailingNode extension from:\n// https://gist.github.com/jelleroorda/2a3085f45ef75b9fdd9f76a4444d6bd6/0a2a7b51871bd01808f5663fcab9a4eb3d593559\n// https://tiptap.dev/experiments/trailing-node\n// https://github.com/ueberdosis/tiptap/issues/143\n//\n//   The trailing node extension is necessary to pragmatically fix a problem\n//   with tables and table selections. When the last node in the document is a\n//   table and the last table cell is empty, then pressing <CTRL>-<a> to select\n//   everyting only selects the very first node in the document. As soon as one\n//   of the conditions - table not the last node or last table cell not empty -\n//   is not met, <CTRL>-<a> selects all, as expected.\n//   The Problem exists throughout browsers.\n//\n//   More information here:\n//   - https://github.com/ueberdosis/tiptap/issues/2401\n//   - https://github.com/ueberdosis/tiptap/issues/3651\n//\n\nimport { Extension } from \"@tiptap/core\";\nimport { PluginKey, Plugin } from \"prosemirror-state\";\n\nfunction nodeEqualsType({ types, node }) {\n    return (Array.isArray(types) && types.includes(node.type)) || node.type === types;\n}\n\nexport const factory = () => {\n    /**\n     * Extension based on:\n     * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n     * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n     */\n    return Extension.create({\n        name: \"trailingNode\",\n\n        addOptions() {\n            return {\n                node: \"fixed-paragraph\",\n                notAfter: [\"paragraph\", \"fixed-paragraph\"],\n          }\n        },\n\n        addProseMirrorPlugins() {\n            const plugin = new PluginKey(this.name);\n            const disabledNodes = Object.entries(this.editor.schema.nodes)\n                .map(([, value]) => value)\n                .filter((node) => this.options.notAfter.includes(node.name));\n\n            return [\n                new Plugin({\n                    key: plugin,\n                    appendTransaction: (_, __, state) => {\n                        const { doc, tr, schema } = state;\n                        const shouldInsertNodeAtEnd = plugin.getState(state);\n                        const endPosition = doc.content.size;\n                        const type = schema.nodes[this.options.node];\n\n                        if (!shouldInsertNodeAtEnd) {\n                            return;\n                        }\n\n                        return tr.insert(\n                            endPosition,\n                            type.create(null, [schema.text(\" \")])\n                        );\n                    },\n                    state: {\n                        init: (_, state) => {\n                            const lastNode = state.tr.doc.lastChild;\n                            return !nodeEqualsType({\n                                node: lastNode,\n                                types: disabledNodes,\n                            });\n                        },\n                        apply: (tr, value) => {\n                            if (!tr.docChanged) {\n                                return value;\n                            }\n\n                            const lastNode = tr.doc.lastChild;\n                            return !nodeEqualsType({\n                                node: lastNode,\n                                types: disabledNodes,\n                            });\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n"],"names":["nodeEqualsType","_ref","types","node","Array","isArray","includes","type","factory","Extension","create","name","addOptions","notAfter","addProseMirrorPlugins","plugin","PluginKey","this","disabledNodes","Object","entries","editor","schema","nodes","map","_ref2","value","filter","options","Plugin","key","appendTransaction","_","__","state","doc","tr","shouldInsertNodeAtEnd","getState","endPosition","content","size","insert","text","init","lastChild","apply","docChanged"],"sourceRoot":""}