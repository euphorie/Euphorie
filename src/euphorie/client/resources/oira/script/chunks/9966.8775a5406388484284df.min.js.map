{"version":3,"file":"chunks/9966.8775a5406388484284df.min.js","mappings":"+QASA,MAAMA,UAAkB,KAIpBC,YAAYC,GACRC,MAAMD,EAAMA,EAChB,CACAE,IAAIC,EAAKC,GACL,IAAIJ,EAAOG,EAAIE,QAAQD,EAAQF,IAAII,KAAKC,OACxC,OAAOT,EAAUU,MAAMR,GAAQ,IAAIF,EAAUE,GAAQ,KAAUS,KAAKT,EACxE,CACAU,UAAY,OAAO,KAAMC,KAAO,CAChCC,GAAGC,GACC,OAAOA,aAAiBf,GAAae,EAAMN,MAAQD,KAAKC,IAC5D,CACAO,SACI,MAAO,CAAEC,KAAM,YAAaC,IAAKV,KAAKC,KAC1C,CAIAU,gBAAgBd,EAAKe,GACjB,GAAuB,iBAAZA,EAAKF,IACZ,MAAM,IAAIG,WAAW,wCACzB,OAAO,IAAIrB,EAAUK,EAAIE,QAAQa,EAAKF,KAC1C,CAIAI,cAAgB,OAAO,IAAIC,EAAYf,KAAKgB,OAAS,CAIrDL,aAAajB,GACT,IAAIuB,EAASvB,EAAKuB,OAClB,GAAIA,EAAOC,cAmEnB,SAAsBxB,GAClB,IAAK,IAAIyB,EAAIzB,EAAK0B,MAAOD,GAAK,EAAGA,IAAK,CAClC,IAAIE,EAAQ3B,EAAK2B,MAAMF,GAAIF,EAASvB,EAAK4B,KAAKH,GAE9C,GAAa,GAATE,EAMJ,IAAK,IAAIE,EAASN,EAAOO,MAAMH,EAAQ,IAAKE,EAASA,EAAOE,UAAW,CACnE,GAA0B,GAArBF,EAAOG,aAAoBH,EAAOI,eAAkBJ,EAAOK,QAAUL,EAAOd,KAAKoB,KAAKC,UACvF,OAAO,EACX,GAAIP,EAAOI,cACP,OAAO,CACf,MAVI,GAAIV,EAAOR,KAAKoB,KAAKC,UACjB,OAAO,CAUnB,CAEA,OAAO,CACX,CAtFmCC,CAAarC,KAuFhD,SAAqBA,GACjB,IAAK,IAAIyB,EAAIzB,EAAK0B,MAAOD,GAAK,EAAGA,IAAK,CAClC,IAAIE,EAAQ3B,EAAKsC,WAAWb,GAAIF,EAASvB,EAAK4B,KAAKH,GACnD,GAAIE,GAASJ,EAAOS,WAKpB,IAAK,IAAIO,EAAQhB,EAAOO,MAAMH,IAASY,EAAQA,EAAMC,WAAY,CAC7D,GAAyB,GAApBD,EAAMP,aAAoBO,EAAMN,eAAkBM,EAAML,QAAUK,EAAMxB,KAAKoB,KAAKC,UACnF,OAAO,EACX,GAAIG,EAAMN,cACN,OAAO,CACf,MATI,GAAIV,EAAOR,KAAKoB,KAAKC,UACjB,OAAO,CASnB,CACA,OAAO,CACX,CAvG0DK,CAAYzC,GAC1D,OAAO,EACX,IAAI0C,EAAWnB,EAAOR,KAAKoB,KAAKQ,eAChC,GAAgB,MAAZD,EACA,OAAOA,EACX,IAAIE,EAAQrB,EAAOsB,eAAe7C,EAAK2B,SAASmB,YAChD,OAAOF,GAASA,EAAMpB,WAC1B,CAIAP,yBAAyBjB,EAAM+C,EAAKC,GAAW,GAC3CC,EAAQ,OAAS,CACb,IAAKD,GAAYlD,EAAUU,MAAMR,GAC7B,OAAOA,EACX,IAAIgB,EAAMhB,EAAKgB,IAAKkC,EAAO,KAE3B,IAAK,IAAIzB,EAAIzB,EAAK0B,OAAQD,IAAK,CAC3B,IAAIF,EAASvB,EAAK4B,KAAKH,GACvB,GAAIsB,EAAM,EAAI/C,EAAKsC,WAAWb,GAAKF,EAAOS,WAAahC,EAAK2B,MAAMF,GAAK,EAAG,CACtEyB,EAAO3B,EAAOO,MAAMiB,EAAM,EAAI/C,EAAKsC,WAAWb,GAAKzB,EAAK2B,MAAMF,GAAK,GACnE,KACJ,CACK,GAAS,GAALA,EACL,OAAO,KAEXT,GAAO+B,EACP,IAAII,EAAOnD,EAAKG,IAAIE,QAAQW,GAC5B,GAAIlB,EAAUU,MAAM2C,GAChB,OAAOA,CACf,CAEA,OAAS,CACL,IAAIC,EAASL,EAAM,EAAIG,EAAKV,WAAaU,EAAKnB,UAC9C,IAAKqB,EAAQ,CACT,GAAIF,EAAKhB,SAAWgB,EAAKG,SAAW,KAAcC,aAAaJ,GAAO,CAClElD,EAAOA,EAAKG,IAAIE,QAAQW,EAAMkC,EAAKK,SAAWR,GAC9CC,GAAW,EACX,SAASC,CACb,CACA,KACJ,CACAC,EAAOE,EACPpC,GAAO+B,EACP,IAAII,EAAOnD,EAAKG,IAAIE,QAAQW,GAC5B,GAAIlB,EAAUU,MAAM2C,GAChB,OAAOA,CACf,CACA,OAAO,IACX,CACJ,EAEJrD,EAAU0D,UAAUC,SAAU,EAC9B3D,EAAU4D,SAAW5D,EAAU6D,kBAC/B,KAAUC,OAAO,YAAa9D,GAC9B,MAAMuB,EACFtB,YAAYiB,GACRV,KAAKU,IAAMA,CACf,CACAd,IAAIE,GACA,OAAO,IAAIiB,EAAYjB,EAAQF,IAAII,KAAKU,KAC5C,CACAX,QAAQF,GACJ,IAAIH,EAAOG,EAAIE,QAAQC,KAAKU,KAC5B,OAAOlB,EAAUU,MAAMR,GAAQ,IAAIF,EAAUE,GAAQ,KAAUS,KAAKT,EACxE,EA8DJ,MAAM6D,GAAgB,OAAe,CACjC,UAAaC,EAAM,SAAU,GAC7B,WAAcA,EAAM,QAAS,GAC7B,QAAWA,EAAM,QAAS,GAC1B,UAAaA,EAAM,OAAQ,KAE/B,SAASA,EAAMC,EAAMhB,GACjB,MAAMiB,EAAiB,QAARD,EAAkBhB,EAAM,EAAI,OAAS,KAASA,EAAM,EAAI,QAAU,OACjF,OAAO,SAAUkB,EAAOC,EAAUC,GAC9B,IAAIC,EAAMH,EAAMI,UACZC,EAASvB,EAAM,EAAIqB,EAAIG,IAAMH,EAAII,MAAOxB,EAAWoB,EAAIzD,MAC3D,GAAIyD,aAAe,KAAe,CAC9B,IAAKD,EAAKM,eAAeT,IAA2B,GAAhBM,EAAO5C,MACvC,OAAO,EACXsB,GAAW,EACXsB,EAASL,EAAM9D,IAAIE,QAAQ0C,EAAM,EAAIuB,EAAO/B,QAAU+B,EAAOzC,SACjE,CACA,IAAI6C,EAAS5E,EAAU6D,kBAAkBW,EAAQvB,EAAKC,GACtD,QAAK0B,IAEDR,GACAA,EAASD,EAAMU,GAAGC,aAAa,IAAI9E,EAAU4E,MAC1C,EACX,CACJ,CACA,SAASG,EAAYV,EAAMnD,EAAK8D,GAC5B,IAAKX,IAASA,EAAKY,SACf,OAAO,EACX,IAAI/E,EAAOmE,EAAKF,MAAM9D,IAAIE,QAAQW,GAClC,IAAKlB,EAAUU,MAAMR,GACjB,OAAO,EACX,IAAIgF,EAAWb,EAAKc,YAAY,CAAEC,KAAMJ,EAAMK,QAASC,IAAKN,EAAMO,UAClE,QAAIL,GAAYA,EAAS5B,QAAU,GAAK,KAAcE,aAAaa,EAAKF,MAAM9D,IAAImF,OAAON,EAAS5B,YAElGe,EAAKD,SAASC,EAAKF,MAAMU,GAAGC,aAAa,IAAI9E,EAAUE,MAChD,EACX,CAKA,SAASuF,EAAYpB,EAAMW,GACvB,GAAuB,yBAAnBA,EAAMU,aAA0CrB,EAAKF,MAAMI,qBAAqBvE,GAChF,OAAO,EACX,IAAI,MAAE0E,GAAUL,EAAKF,MAAMI,UACvBoB,EAASjB,EAAMjD,OAAOsB,eAAe2B,EAAM7C,SAAS+D,aAAavB,EAAKF,MAAM0B,OAAOC,MAAMC,MAC7F,IAAKJ,EACD,OAAO,EACX,IAAIK,EAAO,KAASnF,MACpB,IAAK,IAAIoF,EAAIN,EAAOO,OAAS,EAAGD,GAAK,EAAGA,IACpCD,EAAO,KAASG,KAAKR,EAAOM,GAAGG,cAAc,KAAMJ,IACvD,IAAInB,EAAKR,EAAKF,MAAMU,GAAGwB,QAAQ3B,EAAMxD,IAAKwD,EAAMxD,IAAK,IAAI,KAAM8E,EAAM,EAAG,IAGxE,OAFAnB,EAAGC,aAAa,KAAcnE,KAAKkE,EAAGxE,IAAIE,QAAQmE,EAAMxD,IAAM,KAC9DmD,EAAKD,SAASS,IACP,CACX,CACA,SAASyB,EAAcnC,GACnB,KAAMA,EAAMI,qBAAqBvE,GAC7B,OAAO,KACX,IAAI8B,EAAOyE,SAASC,cAAc,OAElC,OADA1E,EAAK2E,UAAY,wBACV,KAAcC,OAAOvC,EAAM9D,IAAK,CAAC,IAAWsG,OAAOxC,EAAMI,UAAU9D,KAAMqB,EAAM,CAAE8E,IAAK,eACjG,CCtOA,MAAMC,EAAY,EAAAC,UAAUJ,OAAO,CAC/BK,KAAM,YACNC,wBACI,MAAO,CDyJJ,IAAI,KAAO,CACdC,MAAO,CACHC,YAAaZ,EACba,uBAAuBC,EAAOC,EAASC,GACnC,OAAOD,EAAQnG,KAAOoG,EAAMpG,KAAOlB,EAAUU,MAAM4G,GAAS,IAAItH,EAAUsH,GAAS,IACvF,EACAvC,cACAhB,gBACAwD,gBAAiB,CAAE9B,YAAaA,MC9JxC,EACA+B,iBAAiBC,GACb,IAAIC,EACJ,MAAMC,EAAU,CACZZ,KAAMU,EAAUV,KAChBa,QAASH,EAAUG,QACnBC,QAASJ,EAAUI,SAEvB,MAAO,CACHhF,eAAiG,QAAhF6E,GAAK,IAAAI,eAAa,IAAAC,mBAAkBN,EAAW,iBAAkBE,WAA8B,IAAPD,EAAgBA,EAAK,KAEtI,G","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-gapcursor/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-gapcursor/dist/index.js"],"sourcesContent":["import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n","import { Extension, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { gapCursor } from '@tiptap/pm/gapcursor';\n\nconst Gapcursor = Extension.create({\r\n    name: 'gapCursor',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            gapCursor(),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        var _a;\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            allowGapCursor: (_a = callOrReturn(getExtensionField(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\r\n        };\r\n    },\r\n});\n\nexport { Gapcursor, Gapcursor as default };\n//# sourceMappingURL=index.js.map\n"],"names":["GapCursor","constructor","$pos","super","map","doc","mapping","resolve","this","head","valid","near","content","empty","eq","other","toJSON","type","pos","static","json","RangeError","getBookmark","GapBookmark","anchor","parent","isTextblock","d","depth","index","node","before","child","lastChild","childCount","inlineContent","isAtom","spec","isolating","closedBefore","indexAfter","after","firstChild","closedAfter","override","allowGapCursor","deflt","contentMatchAt","defaultType","dir","mustMove","search","next","$cur","inside","isText","isSelectable","nodeSize","prototype","visible","findFrom","findGapCursorFrom","jsonID","handleKeyDown","arrow","axis","dirStr","state","dispatch","view","sel","selection","$start","$to","$from","endOfTextblock","$found","tr","setSelection","handleClick","event","editable","clickPos","posAtCoords","left","clientX","top","clientY","nodeAt","beforeinput","inputType","insert","findWrapping","schema","nodes","text","frag","i","length","from","createAndFill","replace","drawGapCursor","document","createElement","className","create","widget","key","Gapcursor","Extension","name","addProseMirrorPlugins","props","decorations","createSelectionBetween","_view","$anchor","$head","handleDOMEvents","extendNodeSchema","extension","_a","context","options","storage","callOrReturn","getExtensionField"],"sourceRoot":""}