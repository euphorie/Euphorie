{"version":3,"file":"chunks/9966.8775a5406388484284df.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-gapcursor/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-gapcursor/dist/index.js"],"sourcesContent":["import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n","import { Extension, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { gapCursor } from '@tiptap/pm/gapcursor';\n\nconst Gapcursor = Extension.create({\r\n    name: 'gapCursor',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            gapCursor(),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        var _a;\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            allowGapCursor: (_a = callOrReturn(getExtensionField(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\r\n        };\r\n    },\r\n});\n\nexport { Gapcursor, Gapcursor as default };\n//# sourceMappingURL=index.js.map\n"],"names":["GapCursor","constructor","$pos","super","map","doc","mapping","resolve","this","head","valid","content","eq","other","toJSON","type","pos","static","json","RangeError","getBookmark","GapBookmark","anchor","parent","isTextblock","d","depth","index","node","before","child","lastChild","childCount","inlineContent","isAtom","spec","isolating","closedBefore","indexAfter","after","firstChild","closedAfter","override","allowGapCursor","deflt","contentMatchAt","defaultType","dir","mustMove","search","next","$cur","inside","isText","nodeSize","prototype","visible","findFrom","findGapCursorFrom","handleKeyDown","arrow","axis","dirStr","state","dispatch","view","sel","selection","$start","$to","$from","empty","endOfTextblock","$found","tr","setSelection","handleClick","event","editable","clickPos","posAtCoords","left","clientX","top","clientY","nodeAt","beforeinput","inputType","insert","findWrapping","schema","nodes","text","frag","i","length","createAndFill","replace","drawGapCursor","document","createElement","className","key","Gapcursor","Extension","name","addProseMirrorPlugins","props","decorations","createSelectionBetween","_view","$anchor","$head","handleDOMEvents","extendNodeSchema","extension","_a","context","options","storage","callOrReturn","getExtensionField"],"sourceRoot":""}