{"version":3,"file":"chunks/4626.29405bc0f82642235c19.min.js","mappings":"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","sources":["webpack://oira.prototype/./node_modules/@patternslib/pat-tiptap/src/extensions/tag.js","webpack://oira.prototype/./node_modules/@tiptap/suggestion/dist/tiptap-suggestion.esm.js","webpack://oira.prototype/./node_modules/@tiptap/extension-mention/dist/tiptap-extension-mention.esm.js"],"sourcesContent":["import { mergeAttributes } from \"@tiptap/core\";\nimport { Mention as TipTapMention } from \"@tiptap/extension-mention\";\nimport { PluginKey } from \"prosemirror-state\";\n\nexport const TagPluginKey = new PluginKey(\"tag\");\n\nexport const Tag = TipTapMention.extend({\n    name: \"tag\",\n\n    addOptions() {\n        const config = {\n            ...this.parent?.(),\n            suggestion: {\n                ...this.parent?.()?.suggestion,\n                pluginKey: TagPluginKey,\n                char: \"#\",\n            },\n            url_scheme: null,\n        };\n        return config;\n    },\n\n    addAttributes() {\n        return {\n            id: {\n                default: null,\n                parseHTML: (element) => element.getAttribute(\"data-id\"),\n                renderHTML: (attributes) => {\n                    if (!attributes.id) {\n                        return {};\n                    }\n\n                    return {\n                        \"data-id\": attributes.id,\n                    };\n                },\n            },\n\n            href: {\n                default: null,\n                parseHTML: (element) => element.getAttribute(\"href\"),\n                renderHTML: (attributes) => {\n                    if (!attributes.id) {\n                        return {};\n                    }\n\n                    return {\n                        href: this.options.url_scheme.replace(\"{TAG}\", attributes.id),\n                    };\n                },\n            },\n        };\n    },\n\n    parseHTML() {\n        return [\n            {\n                tag: \"a[data-tag]\",\n            },\n        ];\n    },\n\n    renderHTML({ node, HTMLAttributes }) {\n        return [\n            \"a\",\n            mergeAttributes(\n                { \"data-tag\": \"\" },\n                this.options.HTMLAttributes,\n                HTMLAttributes\n            ),\n            this.options.renderLabel({\n                options: this.options,\n                node,\n            }),\n        ];\n    },\n});\n\nexport default Tag;\n","import { PluginKey, Plugin } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { escapeForRegEx } from '@tiptap/core';\n\nfunction findSuggestionMatch(config) {\r\n    const { char, allowSpaces, prefixSpace, startOfLine, $position, } = config;\r\n    const escapedChar = escapeForRegEx(char);\r\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\r\n    const prefix = startOfLine ? '^' : '';\r\n    const regexp = allowSpaces\r\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\r\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm');\r\n    const isTopLevelNode = $position.depth <= 0;\r\n    const textFrom = isTopLevelNode\r\n        ? 0\r\n        : $position.before();\r\n    const textTo = $position.pos;\r\n    const text = $position.doc.textBetween(textFrom, textTo, '\\0', '\\0');\r\n    const match = Array.from(text.matchAll(regexp)).pop();\r\n    if (!match || match.input === undefined || match.index === undefined) {\r\n        return null;\r\n    }\r\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\r\n    // is a space or the start of the line\r\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\r\n    const matchPrefixIsSpace = /^[\\s\\0]?$/.test(matchPrefix);\r\n    if (prefixSpace && !matchPrefixIsSpace) {\r\n        return null;\r\n    }\r\n    // The absolute position of the match in the document\r\n    const from = match.index + $position.start();\r\n    let to = from + match[0].length;\r\n    // Edge case handling; if spaces are allowed and we're directly in between\r\n    // two triggers\r\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\r\n        match[0] += ' ';\r\n        to += 1;\r\n    }\r\n    // If the $position is located within the matched substring, return that range\r\n    if (from < $position.pos && to >= $position.pos) {\r\n        return {\r\n            range: {\r\n                from,\r\n                to,\r\n            },\r\n            query: match[0].slice(char.length),\r\n            text: match[0],\r\n        };\r\n    }\r\n    return null;\r\n}\n\nconst SuggestionPluginKey = new PluginKey('suggestion');\r\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, prefixSpace = true, startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, }) {\r\n    let props;\r\n    const renderer = render === null || render === void 0 ? void 0 : render();\r\n    return new Plugin({\r\n        key: pluginKey,\r\n        view() {\r\n            return {\r\n                update: async (view, prevState) => {\r\n                    var _a, _b, _c, _d, _e;\r\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\r\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\r\n                    // See how the state changed\r\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\r\n                    const started = !prev.active && next.active;\r\n                    const stopped = prev.active && !next.active;\r\n                    const changed = !started && !stopped && prev.query !== next.query;\r\n                    const handleStart = started || moved;\r\n                    const handleChange = changed && !moved;\r\n                    const handleExit = stopped || moved;\r\n                    // Cancel when suggestion isn't active\r\n                    if (!handleStart && !handleChange && !handleExit) {\r\n                        return;\r\n                    }\r\n                    const state = handleExit && !handleStart\r\n                        ? prev\r\n                        : next;\r\n                    const decorationNode = document.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\r\n                    props = {\r\n                        editor,\r\n                        range: state.range,\r\n                        query: state.query,\r\n                        text: state.text,\r\n                        items: (handleChange || handleStart)\r\n                            ? await items({\r\n                                editor,\r\n                                query: state.query,\r\n                            })\r\n                            : [],\r\n                        command: commandProps => {\r\n                            command({\r\n                                editor,\r\n                                range: state.range,\r\n                                props: commandProps,\r\n                            });\r\n                        },\r\n                        decorationNode,\r\n                        // virtual node for popper.js or tippy.js\r\n                        // this can be used for building popups without a DOM node\r\n                        clientRect: decorationNode\r\n                            ? () => {\r\n                                var _a;\r\n                                // because of `items` can be asynchrounous weâ€™ll search for the current docoration node\r\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state);\r\n                                const currentDecorationNode = document.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\r\n                                // @ts-ignore-error\r\n                                return currentDecorationNode.getBoundingClientRect();\r\n                            }\r\n                            : null,\r\n                    };\r\n                    if (handleExit) {\r\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\r\n                    }\r\n                    if (handleChange) {\r\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\r\n                    }\r\n                    if (handleStart) {\r\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\r\n                    }\r\n                },\r\n                destroy: () => {\r\n                    var _a;\r\n                    if (!props) {\r\n                        return;\r\n                    }\r\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\r\n                },\r\n            };\r\n        },\r\n        state: {\r\n            // Initialize the plugin's internal state.\r\n            init() {\r\n                return {\r\n                    active: false,\r\n                    range: {},\r\n                    query: null,\r\n                    text: null,\r\n                    composing: false,\r\n                };\r\n            },\r\n            // Apply changes to the plugin state from a view transaction.\r\n            apply(transaction, prev, oldState, state) {\r\n                const { composing } = editor.view;\r\n                const { selection } = transaction;\r\n                const { empty, from } = selection;\r\n                const next = { ...prev };\r\n                next.composing = composing;\r\n                // We can only be suggesting if there is no selection\r\n                // or a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\r\n                if (empty || editor.view.composing) {\r\n                    // Reset active state if we just left the previous suggestion range\r\n                    if ((from < prev.range.from || from > prev.range.to)\r\n                        && !composing\r\n                        && !prev.composing) {\r\n                        next.active = false;\r\n                    }\r\n                    // Try to match against where our cursor currently is\r\n                    const match = findSuggestionMatch({\r\n                        char,\r\n                        allowSpaces,\r\n                        prefixSpace,\r\n                        startOfLine,\r\n                        $position: selection.$from,\r\n                    });\r\n                    const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`;\r\n                    // If we found a match, update the current state to show it\r\n                    if (match && allow({ editor, state, range: match.range })) {\r\n                        next.active = true;\r\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\r\n                        next.range = match.range;\r\n                        next.query = match.query;\r\n                        next.text = match.text;\r\n                    }\r\n                    else {\r\n                        next.active = false;\r\n                    }\r\n                }\r\n                else {\r\n                    next.active = false;\r\n                }\r\n                // Make sure to empty the range if suggestion is inactive\r\n                if (!next.active) {\r\n                    next.decorationId = null;\r\n                    next.range = {};\r\n                    next.query = null;\r\n                    next.text = null;\r\n                }\r\n                return next;\r\n            },\r\n        },\r\n        props: {\r\n            // Call the keydown hook if suggestion is active.\r\n            handleKeyDown(view, event) {\r\n                var _a;\r\n                const { active, range } = this.getState(view.state);\r\n                if (!active) {\r\n                    return false;\r\n                }\r\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\r\n            },\r\n            // Setup decorator on the currently active suggestion.\r\n            decorations(state) {\r\n                const { active, range, decorationId } = this.getState(state);\r\n                if (!active) {\r\n                    return null;\r\n                }\r\n                return DecorationSet.create(state.doc, [\r\n                    Decoration.inline(range.from, range.to, {\r\n                        nodeName: decorationTag,\r\n                        class: decorationClass,\r\n                        'data-decoration-id': decorationId,\r\n                    }),\r\n                ]);\r\n            },\r\n        },\r\n    });\r\n}\n\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=tiptap-suggestion.esm.js.map\n","import { Node, mergeAttributes } from '@tiptap/core';\nimport { PluginKey } from 'prosemirror-state';\nimport Suggestion from '@tiptap/suggestion';\n\nconst MentionPluginKey = new PluginKey('mention');\r\nconst Mention = Node.create({\r\n    name: 'mention',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            renderLabel({ options, node }) {\r\n                var _a;\r\n                return `${options.suggestion.char}${(_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id}`;\r\n            },\r\n            suggestion: {\r\n                char: '@',\r\n                pluginKey: MentionPluginKey,\r\n                command: ({ editor, range, props }) => {\r\n                    var _a;\r\n                    // increase range.to by one when the next node is of type \"text\"\r\n                    // and starts with a space character\r\n                    const nodeAfter = editor.view.state.selection.$to.nodeAfter;\r\n                    const overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(' ');\r\n                    if (overrideSpace) {\r\n                        range.to += 1;\r\n                    }\r\n                    editor\r\n                        .chain()\r\n                        .focus()\r\n                        .insertContentAt(range, [\r\n                        {\r\n                            type: this.name,\r\n                            attrs: props,\r\n                        },\r\n                        {\r\n                            type: 'text',\r\n                            text: ' ',\r\n                        },\r\n                    ])\r\n                        .run();\r\n                },\r\n                allow: ({ state, range }) => {\r\n                    const $from = state.doc.resolve(range.from);\r\n                    const type = state.schema.nodes[this.name];\r\n                    const allow = !!$from.parent.type.contentMatch.matchType(type);\r\n                    return allow;\r\n                },\r\n            },\r\n        };\r\n    },\r\n    group: 'inline',\r\n    inline: true,\r\n    selectable: false,\r\n    atom: true,\r\n    addAttributes() {\r\n        return {\r\n            id: {\r\n                default: null,\r\n                parseHTML: element => element.getAttribute('data-id'),\r\n                renderHTML: attributes => {\r\n                    if (!attributes.id) {\r\n                        return {};\r\n                    }\r\n                    return {\r\n                        'data-id': attributes.id,\r\n                    };\r\n                },\r\n            },\r\n            label: {\r\n                default: null,\r\n                parseHTML: element => element.getAttribute('data-label'),\r\n                renderHTML: attributes => {\r\n                    if (!attributes.label) {\r\n                        return {};\r\n                    }\r\n                    return {\r\n                        'data-label': attributes.label,\r\n                    };\r\n                },\r\n            },\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: `span[data-type=\"${this.name}\"]`,\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ node, HTMLAttributes }) {\r\n        return [\r\n            'span',\r\n            mergeAttributes({ 'data-type': this.name }, this.options.HTMLAttributes, HTMLAttributes),\r\n            this.options.renderLabel({\r\n                options: this.options,\r\n                node,\r\n            }),\r\n        ];\r\n    },\r\n    renderText({ node }) {\r\n        return this.options.renderLabel({\r\n            options: this.options,\r\n            node,\r\n        });\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Backspace: () => this.editor.commands.command(({ tr, state }) => {\r\n                let isMention = false;\r\n                const { selection } = state;\r\n                const { empty, anchor } = selection;\r\n                if (!empty) {\r\n                    return false;\r\n                }\r\n                state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\r\n                    if (node.type.name === this.name) {\r\n                        isMention = true;\r\n                        tr.insertText(this.options.suggestion.char || '', pos, pos + node.nodeSize);\r\n                        return false;\r\n                    }\r\n                });\r\n                return isMention;\r\n            }),\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            Suggestion({\r\n                editor: this.editor,\r\n                ...this.options.suggestion,\r\n            }),\r\n        ];\r\n    },\r\n});\n\nexport { Mention, MentionPluginKey, Mention as default };\n//# sourceMappingURL=tiptap-extension-mention.esm.js.map\n"],"names":["TagPluginKey","Tag","name","addOptions","this","parent","suggestion","pluginKey","char","url_scheme","addAttributes","id","default","parseHTML","element","getAttribute","renderHTML","attributes","href","options","replace","tag","node","HTMLAttributes","mergeAttributes","renderLabel","SuggestionPluginKey","Suggestion","editor","allowSpaces","prefixSpace","startOfLine","decorationTag","decorationClass","command","items","render","allow","props","renderer","key","view","update","async","prevState","_a","_b","_c","_d","_e","prev","getState","next","state","moved","active","range","from","started","stopped","handleStart","handleChange","query","handleExit","decorationNode","document","querySelector","decorationId","text","commandProps","clientRect","getBoundingClientRect","onExit","call","onUpdate","onStart","destroy","init","composing","apply","transaction","oldState","selection","empty","to","match","config","$position","escapedChar","escapeForRegEx","suffix","RegExp","prefix","regexp","textFrom","depth","before","textTo","pos","doc","textBetween","Array","matchAll","pop","undefined","input","index","matchPrefix","slice","Math","max","matchPrefixIsSpace","test","start","length","findSuggestionMatch","$from","floor","random","handleKeyDown","event","onKeyDown","decorations","nodeName","class","MentionPluginKey","Mention","Node","attrs","label","nodeAfter","$to","startsWith","chain","focus","insertContentAt","type","run","resolve","schema","nodes","contentMatch","matchType","group","inline","selectable","atom","renderText","addKeyboardShortcuts","Backspace","commands","tr","isMention","anchor","nodesBetween","insertText","nodeSize","addProseMirrorPlugins"],"sourceRoot":""}