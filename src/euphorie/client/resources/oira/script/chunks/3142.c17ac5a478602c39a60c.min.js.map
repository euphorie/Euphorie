{"version":3,"file":"chunks/3142.c17ac5a478602c39a60c.min.js","mappings":"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","sources":["webpack://oira.prototype/./node_modules/rope-sequence/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-history/dist/index.es.js","webpack://oira.prototype/./node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n","import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nvar max_empty_items = 500;\n\nvar Branch = function Branch(items, eventCount) {\n  this.items = items;\n  this.eventCount = eventCount;\n};\n\n// : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n// Pop the latest event off the branch's history and apply it\n// to a document transform.\nBranch.prototype.popEvent = function popEvent (state, preserveItems) {\n    var this$1 = this;\n\n  if (this.eventCount == 0) { return null }\n\n  var end = this.items.length;\n  for (;; end--) {\n    var next = this.items.get(end - 1);\n    if (next.selection) { --end; break }\n  }\n\n  var remap, mapFrom;\n  if (preserveItems) {\n    remap = this.remapping(end, this.items.length);\n    mapFrom = remap.maps.length;\n  }\n  var transform = state.tr;\n  var selection, remaining;\n  var addAfter = [], addBefore = [];\n\n  this.items.forEach(function (item, i) {\n    if (!item.step) {\n      if (!remap) {\n        remap = this$1.remapping(end, i + 1);\n        mapFrom = remap.maps.length;\n      }\n      mapFrom--;\n      addBefore.push(item);\n      return\n    }\n\n    if (remap) {\n      addBefore.push(new Item(item.map));\n      var step = item.step.map(remap.slice(mapFrom)), map;\n\n      if (step && transform.maybeStep(step).doc) {\n        map = transform.mapping.maps[transform.mapping.maps.length - 1];\n        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));\n      }\n      mapFrom--;\n      if (map) { remap.appendMap(map, mapFrom); }\n    } else {\n      transform.maybeStep(item.step);\n    }\n\n    if (item.selection) {\n      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);\n      return false\n    }\n  }, this.items.length, 0);\n\n  return {remaining: remaining, transform: transform, selection: selection}\n};\n\n// : (Transform, ?SelectionBookmark, Object) → Branch\n// Create a new branch with the given transform added.\nBranch.prototype.addTransform = function addTransform (transform, selection, histOptions, preserveItems) {\n  var newItems = [], eventCount = this.eventCount;\n  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n\n  for (var i = 0; i < transform.steps.length; i++) {\n    var step = transform.steps[i].invert(transform.docs[i]);\n    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0);\n    if (merged = lastItem && lastItem.merge(item)) {\n      item = merged;\n      if (i) { newItems.pop(); }\n      else { oldItems = oldItems.slice(0, oldItems.length - 1); }\n    }\n    newItems.push(item);\n    if (selection) {\n      eventCount++;\n      selection = null;\n    }\n    if (!preserveItems) { lastItem = item; }\n  }\n  var overflow = eventCount - histOptions.depth;\n  if (overflow > DEPTH_OVERFLOW) {\n    oldItems = cutOffEvents(oldItems, overflow);\n    eventCount -= overflow;\n  }\n  return new Branch(oldItems.append(newItems), eventCount)\n};\n\nBranch.prototype.remapping = function remapping (from, to) {\n  var maps = new Mapping;\n  this.items.forEach(function (item, i) {\n    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n        ? maps.maps.length - item.mirrorOffset : null;\n    maps.appendMap(item.map, mirrorPos);\n  }, from, to);\n  return maps\n};\n\nBranch.prototype.addMaps = function addMaps (array) {\n  if (this.eventCount == 0) { return this }\n  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)\n};\n\n// : (Transform, number)\n// When the collab module receives remote changes, the history has\n// to know about those, so that it can adjust the steps that were\n// rebased on top of the remote changes, and include the position\n// maps for the remote changes in its array of items.\nBranch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {\n  if (!this.eventCount) { return this }\n\n  var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n\n  var mapping = rebasedTransform.mapping;\n  var newUntil = rebasedTransform.steps.length;\n  var eventCount = this.eventCount;\n  this.items.forEach(function (item) { if (item.selection) { eventCount--; } }, start);\n\n  var iRebased = rebasedCount;\n  this.items.forEach(function (item) {\n    var pos = mapping.getMirror(--iRebased);\n    if (pos == null) { return }\n    newUntil = Math.min(newUntil, pos);\n    var map = mapping.maps[pos];\n    if (item.step) {\n      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n      if (selection) { eventCount++; }\n      rebasedItems.push(new Item(map, step, selection));\n    } else {\n      rebasedItems.push(new Item(map));\n    }\n  }, start);\n\n  var newMaps = [];\n  for (var i = rebasedCount; i < newUntil; i++)\n    { newMaps.push(new Item(mapping.maps[i])); }\n  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n  var branch = new Branch(items, eventCount);\n\n  if (branch.emptyItemCount() > max_empty_items)\n    { branch = branch.compress(this.items.length - rebasedItems.length); }\n  return branch\n};\n\nBranch.prototype.emptyItemCount = function emptyItemCount () {\n  var count = 0;\n  this.items.forEach(function (item) { if (!item.step) { count++; } });\n  return count\n};\n\n// Compressing a branch means rewriting it to push the air (map-only\n// items) out. During collaboration, these naturally accumulate\n// because each remote change adds one. The `upto` argument is used\n// to ensure that only the items below a given level are compressed,\n// because `rebased` relies on a clean, untouched set of items in\n// order to associate old items with rebased steps.\nBranch.prototype.compress = function compress (upto) {\n    if ( upto === void 0 ) upto = this.items.length;\n\n  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n  var items = [], events = 0;\n  this.items.forEach(function (item, i) {\n    if (i >= upto) {\n      items.push(item);\n      if (item.selection) { events++; }\n    } else if (item.step) {\n      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n      mapFrom--;\n      if (map) { remap.appendMap(map, mapFrom); }\n      if (step) {\n        var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n        if (selection) { events++; }\n        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n        if (merged = items.length && items[last].merge(newItem))\n          { items[last] = merged; }\n        else\n          { items.push(newItem); }\n      }\n    } else if (item.map) {\n      mapFrom--;\n    }\n  }, this.items.length, 0);\n  return new Branch(RopeSequence.from(items.reverse()), events)\n};\n\nBranch.empty = new Branch(RopeSequence.empty, 0);\n\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i;\n      return false\n    }\n  });\n  return items.slice(cutPoint)\n}\n\nvar Item = function Item(map, step, selection, mirrorOffset) {\n  // The (forward) step map for this item.\n  this.map = map;\n  // The inverted step\n  this.step = step;\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  this.selection = selection;\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  this.mirrorOffset = mirrorOffset;\n};\n\nItem.prototype.merge = function merge (other) {\n  if (this.step && other.step && !other.selection) {\n    var step = other.step.merge(this.step);\n    if (step) { return new Item(step.getMap().invert(), step, this.selection) }\n  }\n};\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nvar HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n};\n\nvar DEPTH_OVERFLOW = 20;\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey), rebased;\n  if (historyTr) { return historyTr.historyState }\n\n  if (tr.getMeta(closeHistoryKey)) { history = new HistoryState(history.done, history.undone, null, 0); }\n\n  var appended = tr.getMeta(\"appendedTransaction\");\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      { return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime) }\n    else\n      { return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime) }\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges));\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) { return false }\n  if (!transform.docChanged) { return true }\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2)\n      { if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        { adjacent = true; } }\n  });\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) { return result.push(from, to); });\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) { return null }\n  var result = [];\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) { result.push(from, to); }\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) { return }\n\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems);\n\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo: redo, historyState: newHist}).scrollIntoView());\n}\n\nvar cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (var i = 0; i < plugins.length; i++) { if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break\n    } }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\");\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nfunction history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500};\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config: config,\n\n    props: {\n      handleDOMEvents: {\n        beforeinput: function beforeinput(view, e) {\n          var handled = e.inputType == \"historyUndo\" ? undo(view.state, view.dispatch) :\n              e.inputType == \"historyRedo\" ? redo(view.state, view.dispatch) : false;\n          if (handled) { e.preventDefault(); }\n          return handled\n        }\n      }\n    }\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nfunction undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, false); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nfunction redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, true); }\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0\n}\n\nexport { HistoryState, closeHistory, history, redo, redoDepth, undo, undoDepth };\n//# sourceMappingURL=index.es.js.map\n","import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from 'prosemirror-history';\n\nconst History = Extension.create({\r\n    name: 'history',\r\n    addOptions() {\r\n        return {\r\n            depth: 100,\r\n            newGroupDelay: 500,\r\n        };\r\n    },\r\n    addCommands() {\r\n        return {\r\n            undo: () => ({ state, dispatch }) => {\r\n                return undo(state, dispatch);\r\n            },\r\n            redo: () => ({ state, dispatch }) => {\r\n                return redo(state, dispatch);\r\n            },\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            history(this.options),\r\n        ];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-z': () => this.editor.commands.undo(),\r\n            'Mod-y': () => this.editor.commands.redo(),\r\n            'Shift-Mod-z': () => this.editor.commands.redo(),\r\n            // Russian keyboard layouts\r\n            'Mod-я': () => this.editor.commands.undo(),\r\n            'Shift-Mod-я': () => this.editor.commands.redo(),\r\n        };\r\n    },\r\n});\n\nexport { History, History as default };\n//# sourceMappingURL=tiptap-extension-history.esm.js.map\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","prototype","append","other","length","from","this","leafAppend","leafPrepend","appendInner","prepend","Append","slice","to","empty","sliceInner","Math","max","min","get","i","getInner","forEach","f","forEachInner","forEachInvertedInner","map","result","elt","push","values","Leaf","call","__proto__","Object","create","constructor","prototypeAccessors","configurable","depth","flatten","start","concat","defineProperties","left","right","leftLen","inner","Branch","items","eventCount","popEvent","state","preserveItems","this$1","remap","mapFrom","end","selection","remapping","maps","remaining","transform","tr","addAfter","addBefore","item","step","Item","maybeStep","doc","mapping","appendMap","reverse","addTransform","histOptions","newItems","oldItems","lastItem","steps","merged","invert","docs","merge","pop","n","cutPoint","overflow","DEPTH_OVERFLOW","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","newUntil","iRebased","pos","getMirror","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","last","HistoryState","done","undone","prevRanges","prevTime","rangesFor","_from","_to","mapRanges","ranges","histTransaction","history","dispatch","redo","mustPreserveItems","historyKey","spec","config","resolve","added","getBookmark","newHist","setSelection","setMeta","historyState","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistoryKey","newGroupDelay","key","init","apply","hist","options","historyTr","getMeta","appended","newGroup","time","docChanged","adjacent","isAdjacentTo","applyTransaction","props","handleDOMEvents","beforeinput","view","e","handled","inputType","undo","preventDefault","getState","History","Extension","name","addOptions","addCommands","addProseMirrorPlugins","addKeyboardShortcuts","editor","commands"],"sourceRoot":""}