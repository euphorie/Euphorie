{"version":3,"file":"chunks/22711.e5a297aeac26f127d536.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-tables/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-table/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/table.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, cellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  var _a;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos))\n      continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n    let totalWidth = 0;\n    let fixedWidth = true;\n    let nextDOM = colgroup.firstChild;\n    const row = node.firstChild;\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j += 1, col += 1) {\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) {\n                fixedWidth = false;\n            }\n            if (!nextDOM) {\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n            }\n            else {\n                if (nextDOM.style.width !== cssWidth) {\n                    nextDOM.style.width = cssWidth;\n                }\n                nextDOM = nextDOM.nextSibling;\n            }\n        }\n    }\n    while (nextDOM) {\n        const after = nextDOM.nextSibling;\n        nextDOM.parentNode.removeChild(nextDOM);\n        nextDOM = after;\n    }\n    if (fixedWidth) {\n        table.style.width = `${totalWidth}px`;\n        table.style.minWidth = '';\n    }\n    else {\n        table.style.width = '';\n        table.style.minWidth = `${totalWidth}px`;\n    }\n}\nclass TableView {\n    constructor(node, cellMinWidth) {\n        this.node = node;\n        this.cellMinWidth = cellMinWidth;\n        this.dom = document.createElement('div');\n        this.dom.className = 'tableWrapper';\n        this.table = this.dom.appendChild(document.createElement('table'));\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n    }\n    update(node) {\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        this.node = node;\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n        return true;\n    }\n    ignoreMutation(mutation) {\n        return (mutation.type === 'attributes'\n            && (mutation.target === this.table || this.colgroup.contains(mutation.target)));\n    }\n}\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nfunction createColGroup(node, cellMinWidth, overrideCol, overrideValue) {\n    let totalWidth = 0;\n    let fixedWidth = true;\n    const cols = [];\n    const row = node.firstChild;\n    if (!row) {\n        return {};\n    }\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j += 1, col += 1) {\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) {\n                fixedWidth = false;\n            }\n            cols.push(['col', cssWidth ? { style: `width: ${cssWidth}` } : {}]);\n        }\n    }\n    const tableWidth = fixedWidth ? `${totalWidth}px` : '';\n    const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`;\n    const colgroup = ['colgroup', {}, ...cols];\n    return { colgroup, tableWidth, tableMinWidth };\n}\n\nfunction createCell(cellType, cellContent) {\n    if (cellContent) {\n        return cellType.createChecked(null, cellContent);\n    }\n    return cellType.createAndFill();\n}\n\nfunction getTableNodeTypes(schema) {\n    if (schema.cached.tableNodeTypes) {\n        return schema.cached.tableNodeTypes;\n    }\n    const roles = {};\n    Object.keys(schema.nodes).forEach(type => {\n        const nodeType = schema.nodes[type];\n        if (nodeType.spec.tableRole) {\n            roles[nodeType.spec.tableRole] = nodeType;\n        }\n    });\n    schema.cached.tableNodeTypes = roles;\n    return roles;\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n    const types = getTableNodeTypes(schema);\n    const headerCells = [];\n    const cells = [];\n    for (let index = 0; index < colsCount; index += 1) {\n        const cell = createCell(types.cell, cellContent);\n        if (cell) {\n            cells.push(cell);\n        }\n        if (withHeaderRow) {\n            const headerCell = createCell(types.header_cell, cellContent);\n            if (headerCell) {\n                headerCells.push(headerCell);\n            }\n        }\n    }\n    const rows = [];\n    for (let index = 0; index < rowsCount; index += 1) {\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n    }\n    return types.table.createChecked(null, rows);\n}\n\nfunction isCellSelection(value) {\n    return value instanceof CellSelection;\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\n    const { selection } = editor.state;\n    if (!isCellSelection(selection)) {\n        return false;\n    }\n    let cellCount = 0;\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n        return node.type.name === 'table';\n    });\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\n        if (node.type.name === 'table') {\n            return false;\n        }\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n            cellCount += 1;\n        }\n    });\n    const allCellsSelected = cellCount === selection.ranges.length;\n    if (!allCellsSelected) {\n        return false;\n    }\n    editor.commands.deleteTable();\n    return true;\n};\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nconst Table = Node.create({\n    name: 'table',\n    // @ts-ignore\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            resizable: false,\n            handleWidth: 5,\n            cellMinWidth: 25,\n            // TODO: fix\n            View: TableView,\n            lastColumnResizable: true,\n            allowTableNodeSelection: false,\n        };\n    },\n    content: 'tableRow+',\n    tableRole: 'table',\n    isolating: true,\n    group: 'block',\n    parseHTML() {\n        return [{ tag: 'table' }];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);\n        const table = [\n            'table',\n            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n                style: tableWidth\n                    ? `width: ${tableWidth}`\n                    : `min-width: ${tableMinWidth}`,\n            }),\n            colgroup,\n            ['tbody', 0],\n        ];\n        return table;\n    },\n    addCommands() {\n        return {\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\n                if (dispatch) {\n                    const offset = tr.selection.from + 1;\n                    tr.replaceSelectionWith(node)\n                        .scrollIntoView()\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\n                }\n                return true;\n            },\n            addColumnBefore: () => ({ state, dispatch }) => {\n                return addColumnBefore(state, dispatch);\n            },\n            addColumnAfter: () => ({ state, dispatch }) => {\n                return addColumnAfter(state, dispatch);\n            },\n            deleteColumn: () => ({ state, dispatch }) => {\n                return deleteColumn(state, dispatch);\n            },\n            addRowBefore: () => ({ state, dispatch }) => {\n                return addRowBefore(state, dispatch);\n            },\n            addRowAfter: () => ({ state, dispatch }) => {\n                return addRowAfter(state, dispatch);\n            },\n            deleteRow: () => ({ state, dispatch }) => {\n                return deleteRow(state, dispatch);\n            },\n            deleteTable: () => ({ state, dispatch }) => {\n                return deleteTable(state, dispatch);\n            },\n            mergeCells: () => ({ state, dispatch }) => {\n                return mergeCells(state, dispatch);\n            },\n            splitCell: () => ({ state, dispatch }) => {\n                return splitCell(state, dispatch);\n            },\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\n                return toggleHeader('column')(state, dispatch);\n            },\n            toggleHeaderRow: () => ({ state, dispatch }) => {\n                return toggleHeader('row')(state, dispatch);\n            },\n            toggleHeaderCell: () => ({ state, dispatch }) => {\n                return toggleHeaderCell(state, dispatch);\n            },\n            mergeOrSplit: () => ({ state, dispatch }) => {\n                if (mergeCells(state, dispatch)) {\n                    return true;\n                }\n                return splitCell(state, dispatch);\n            },\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\n                return setCellAttr(name, value)(state, dispatch);\n            },\n            goToNextCell: () => ({ state, dispatch }) => {\n                return goToNextCell(1)(state, dispatch);\n            },\n            goToPreviousCell: () => ({ state, dispatch }) => {\n                return goToNextCell(-1)(state, dispatch);\n            },\n            fixTables: () => ({ state, dispatch }) => {\n                if (dispatch) {\n                    fixTables(state);\n                }\n                return true;\n            },\n            setCellSelection: position => ({ tr, dispatch }) => {\n                if (dispatch) {\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\n                    // @ts-ignore\n                    tr.setSelection(selection);\n                }\n                return true;\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            Tab: () => {\n                if (this.editor.commands.goToNextCell()) {\n                    return true;\n                }\n                if (!this.editor.can().addRowAfter()) {\n                    return false;\n                }\n                return this.editor.chain().addRowAfter().goToNextCell().run();\n            },\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n            Backspace: deleteTableWhenAllCellsSelected,\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\n            Delete: deleteTableWhenAllCellsSelected,\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\n        };\n    },\n    addProseMirrorPlugins() {\n        const isResizable = this.options.resizable && this.editor.isEditable;\n        return [\n            ...(isResizable\n                ? [\n                    columnResizing({\n                        handleWidth: this.options.handleWidth,\n                        cellMinWidth: this.options.cellMinWidth,\n                        View: this.options.View,\n                        lastColumnResizable: this.options.lastColumnResizable,\n                    }),\n                ]\n                : []),\n            tableEditing({\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\n            }),\n        ];\n    },\n    extendNodeSchema(extension) {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n        };\n    },\n});\n\nexport { Table, createColGroup, createTable, Table as default };\n//# sourceMappingURL=index.js.map\n","import { mergeAttributes } from \"@tiptap/core\";\nimport { Table as TipTapTable } from \"@tiptap/extension-table\";\n\nexport const factory = () => {\n    return TipTapTable.extend({\n        parseHTML() {\n            return [\n                {\n                    tag: \"table\",\n                    getAttrs: (node) =>\n                        node.closest(\"div.scroll-table\") === null && null,\n                },\n                {\n                    tag: \"div\",\n                    getAttrs: (node) =>\n                        node.querySelector(\".scroll-table > table\") ? null : false,\n                },\n            ];\n        },\n        renderHTML({ HTMLAttributes }) {\n            return [\n                \"div\",\n                { class: \"scroll-table\" },\n                [\n                    \"table\",\n                    mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                    0,\n                ],\n            ];\n        },\n    });\n};\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","this","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","type","spec","tableRole","name","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","attrs","rowspan","colspan","findWidth","mapPos","colWidths","e","cellNode","colwidth","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","node","nodeAt","updated","colWidth","freshColWidth","unshift","findBadColWidths","computeMap","slice","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","cellNear","head","pointsAtCell","parent","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","splice","some","addColSpan","CellSelection","_CellSelection","cells","filter","p","ranges","from","content","size","super","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","between","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","empty","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","fromJSON","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","jsonID","_CellBookmark","near","drawCellSelection","class","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","mustAdd","prob","setNodeMarkup","first","last","add","side","insert","setMeta","fixTable","descendants","pastedCells","openStart","openEnd","fitSlice","widths","r","append","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","dispatch","Error","recomp","maps","types","emptyHead","header_cell","start2","header","emptyRow","growTable","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","view","atEndOfCell","$next","newSel","cellSel","baseContent","docChanged","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","createChecked","source","clipCells","handleMouseDown","startEvent","_a","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","indexAfter","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","_b","nodeViews","props","tableName","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","win","ownerDocument","defaultView","window","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","event2","pluginState2","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown2","decorations","widget","handleDecorations","_ResizeState","action","getMeta","setHandle","handle","indexOf","Array","fill","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","delete","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","Set","has","newPos","isEmpty","c","isTextblock","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","mapped","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","findNextCell","tableEditing","allowTableNodeSelection","deleted","mapResult","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","isTextSelectionAcrossCells","normalizeSelection","updateColumns","mutation","createCell","cellType","cellContent","createTable","rowsCount","colsCount","withHeaderRow","roles","Object","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","isolating","group","parseHTML","tag","renderHTML","tableWidth","tableMinWidth","cols","createColGroup","mergeAttributes","addCommands","insertTable","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField","factory","TipTapTable","extend","getAttrs","closest","querySelector","_ref"],"sourceRoot":""}