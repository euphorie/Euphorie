{"version":3,"file":"chunks/55531.ad9fc9a7412afdc2b665.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/image-figure.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","import { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { Node, mergeAttributes } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nlet context_menu_instance;\n\nfunction pattern_image_context_menu({ app: app }) {\n    class Pattern extends BasePattern {\n        static name = \"tiptap-image-context-menu\";\n        static trigger = \".tiptap-image-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_edit = this.el.querySelector(\".tiptap-edit-image\");\n            const btn_remove = this.el.querySelector(\".tiptap-remove-image\");\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", () => {\n                    app.toolbar.image.click();\n                });\n\n            btn_remove &&\n                btn_remove.addEventListener(\"click\", () => {\n                    app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n                    app.editor.commands.deleteSelection();\n                    app.editor.commands.focus();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction image_panel({ app }) {\n    // Not Base-pattern based due to two reasons:\n    // - We need to reinitialize the pattern on already initialized nodes on possible tab-changes within the modal.\n    // - We need to keep the _node_image and _figcaption references among re-initializations.\n    return {\n        name: \"tiptap-image-panel\",\n        trigger: app.options.image?.panel,\n\n        init(image_panel) {\n            const image_srcs = image_panel.querySelectorAll(\"[name=tiptap-src]\");\n            const image_alt = image_panel.querySelector(\"[name=tiptap-alt]\");\n            const image_title = image_panel.querySelector(\"[name=tiptap-title]\");\n            const image_caption = image_panel.querySelector(\"[name=tiptap-caption]\");\n            const image_confirm = image_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n            focus_handler(image_panel);\n\n            const node_image = this.node_image;\n\n            // Populate form fields\n            if (node_image) {\n                const current_src = node_image.attrs?.src;\n                // Filter for all inputs with the same src value but not an empty src.\n                let image_srcs_ = current_src\n                    ? [...image_srcs].filter((it) => it.value === current_src)\n                    : [];\n                if (image_srcs_.length > 0) {\n                    for (const image_src of image_srcs_) {\n                        image_src.checked = true;\n                        image_src.dispatchEvent(events.change_event());\n                    }\n                } else {\n                    let image_srcs_ = [...image_srcs].filter(\n                        (it) => it.type === \"text\" || it.type === \"url\"\n                    );\n                    if (image_srcs_.length > 0 && !image_srcs_[0].value) {\n                        image_srcs_[0].value = current_src || \"\";\n                    }\n                }\n                if (image_title && !image_title.value) {\n                    image_title.value = node_image.attrs?.title || \"\";\n                }\n                if (image_alt && !image_alt.value) {\n                    image_alt.value = node_image.attrs?.alt || \"\";\n                }\n            }\n\n            // Get / set figcaption node, if it exists\n            const node_figcaption = this.figcaption_node;\n            if (node_figcaption && image_caption && !image_caption.value) {\n                image_caption.value = node_figcaption.textContent || \"\";\n            }\n\n            const update_callback = (set_focus) => {\n                // Get the selected image on time of submitting\n                const selected_image_src = image_panel.querySelector(\n                    `[name=tiptap-src][type=radio]:checked,\n                         [name=tiptap-src][type=checkbox]:checked,\n                         [name=tiptap-src][type=option]:checked,\n                         [name=tiptap-src][type=hidden],\n                         [name=tiptap-src][type=text],\n                         [name=tiptap-src][type=url]`\n                );\n\n                app.editor.commands.insertContent({\n                    type: \"figure\",\n                    content: [\n                        {\n                            type: \"image-figure\",\n                            attrs: {\n                                src: selected_image_src.value,\n                                ...(image_alt?.value && { alt: image_alt.value }),\n                                ...(image_title?.value && {\n                                    title: image_title.value,\n                                }),\n                            },\n                        },\n                        // Conditionally add a figcaption\n                        ...(image_caption?.value\n                            ? [\n                                  {\n                                      type: \"figcaption\",\n                                      content: [\n                                          {\n                                              type: \"text\",\n                                              text: image_caption.value,\n                                          },\n                                      ],\n                                  },\n                              ]\n                            : []),\n                    ],\n                });\n                if (set_focus === true) {\n                    // set cursor after the image, otherwise image is\n                    // selected and right away deleted when starting typing.\n                    app.editor.commands.selectParentNode();\n                    app.editor.commands.focus(app.editor.state.selection.to);\n                    //app.editor.commands.blur();\n                }\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(image_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_image_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (image_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    image_confirm,\n                    \"click\",\n                    \"tiptap_image_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                for (const image_src of image_srcs) {\n                    events.add_event_listener(\n                        image_src,\n                        \"change\",\n                        \"tiptap_image_src\",\n                        update_callback\n                    );\n                }\n                events.add_event_listener(\n                    image_alt,\n                    \"change\",\n                    \"tiptap_image_alt\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_title,\n                    \"change\",\n                    \"tiptap_image_title\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_caption,\n                    \"change\",\n                    \"tiptap_image_caption\",\n                    update_callback\n                );\n            }\n        },\n\n        _node_image: null,\n        get node_image() {\n            // Get image node\n            if (this._node_image || this._node_image === undefined) {\n                return this._node_image;\n            }\n            this._node_image = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            return this._node_image;\n        },\n\n        _figcaption: null, // initialized as null. If not found this will be set to undefined.\n        get figcaption_node() {\n            // Return cached figcaption and avoid calling this method multiple times.\n            // Calling it again would select again a parent node which would lead to incorrect results.\n            if (this._figcaption || this._figcaption === undefined) {\n                return this._figcaption;\n            }\n\n            app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n            const node_figure = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            const node_figcaption = node_figure?.content.content.filter(\n                (it) => it.type.name === \"figcaption\"\n            )?.[0];\n            this._figcaption = node_figcaption; // if not found, this is undefined.\n            return node_figcaption;\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the image-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's image button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const image_panel_pattern = image_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                image_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    image_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"image-figure\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setImage()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (!app.options.image.menu) {\n            // Nothing to do, return.\n            return;\n        }\n\n        // Open the context menu with a small delay.\n        utils.debounce(async () => {\n            if (!app.editor.isActive(\"image-figure\")) {\n                // Image not active anymore. Return.\n                if (context_menu_instance) {\n                    // If open, close.\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-image-context-menu\",\n                    });\n                    context_menu_instance = null;\n                }\n                return;\n            }\n\n            // Initialize the context menu\n            context_menu_instance = await context_menu({\n                url: app.options.image.menu,\n                editor: app.editor,\n                instance: context_menu_instance,\n                pattern: pattern_image_context_menu({ app: app }),\n                extra_class: \"tiptap-image-menu\",\n            });\n        }, 50)();\n    });\n}\n\nexport const factory = () => {\n    return Node.create({\n        name: \"image-figure\",\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n            };\n        },\n\n        addAttributes() {\n            return {\n                src: {\n                    default: null,\n                },\n                alt: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            };\n        },\n\n        group: \"block\",\n        inline: false,\n\n        allowGapCursor: false,\n        atom: true,\n        draggable: false,\n        isolating: true,\n        selectable: true,\n\n        parseHTML() {\n            return [\n                {\n                    tag: \"img\",\n                    getAttrs: (node) => node.closest(\"figure\") !== null && null, // prosemirror expects null for a successful check.\n                },\n            ];\n        },\n\n        renderHTML({ HTMLAttributes }) {\n            return [\"img\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n        },\n\n        addProseMirrorPlugins() {\n            return [\n                new Plugin({\n                    props: {\n                        handleDOMEvents: {\n                            dragstart: (view, event) => {\n                                // prevent drag/drop at all.\n                                event.preventDefault();\n                                return false;\n                            },\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["PREV_NODE","async","context_menu","_ref","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","patterns","editor_element","options","element","patTooltip","events","await_pattern_init","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","add_event_listener","document","e","target","dom","get_parents","includes","popper","key","show","_ref2","hide","destroy","remove_event_listener","context_menu_instance","pattern_image_context_menu","app","Pattern","BasePattern","static","init","focus_handler","this","el","btn_edit","querySelector","btn_remove","addEventListener","toolbar","image","click","commands","selectParentNode","deleteSelection","focus","_ref3","button","get_data","toolbar_el","image_panel_pattern","trigger","panel","image_panel","image_srcs","querySelectorAll","image_alt","image_title","image_caption","image_confirm","node_image","current_src","attrs","src","image_srcs_","filter","it","value","length","image_src","checked","dispatchEvent","change_event","type","title","alt","node_figcaption","figcaption_node","textContent","update_callback","set_focus","selected_image_src","insertContent","content","text","form","querySelectorAllAndMe","preventDefault","_node_image","undefined","_figcaption","node_figure","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","setImage","menu","utils","debounce","factory","Node","create","addOptions","HTMLAttributes","addAttributes","default","group","inline","allowGapCursor","atom","draggable","isolating","selectable","parseHTML","tag","getAttrs","node","closest","renderHTML","_ref4","mergeAttributes","addProseMirrorPlugins","Plugin","props","handleDOMEvents","dragstart","event","TARGETS","setAttribute","timeout","map"],"sourceRoot":""}