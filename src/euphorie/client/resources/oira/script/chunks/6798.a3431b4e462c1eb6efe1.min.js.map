{"version":3,"file":"chunks/6798.a3431b4e462c1eb6efe1.min.js","mappings":"ohEAMA,SAASA,EAAgBC,EAAOC,GAC9B,OAAID,EAAME,UAAUC,QAChBF,GAAYA,EAASD,EAAMI,GAAGL,kBAAkBM,mBAC7C,GAWT,SAASC,EAAaN,EAAOC,EAAUM,GACrC,IACIC,EADMR,EAAME,UACEM,QAClB,IAAKA,IAAYD,GAAQA,EAAKE,eAAe,WAAYT,GACjCQ,EAAQE,aAAe,GAC3C,OAAO,EAEX,IAAIC,EAAOC,EAAcJ,GAGzB,IAAKG,EAAM,CACT,IAAIE,EAAQL,EAAQM,aAAcC,EAASF,IAAS,QAAWA,GAC/D,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GAGT,IAAIY,EAASN,EAAKO,WAElB,IAAKD,EAAOE,KAAKC,KAAKC,WAAaC,EAActB,EAAOW,EAAMV,GAC1D,OAAO,EAIX,GAAmC,GAA/BO,EAAQe,OAAOC,QAAQC,OACtBC,EAAYT,EAAQ,QAAU,kBAA2BA,IAAU,CACtE,IAAIU,GAAU,QAAY3B,EAAM4B,IAAKpB,EAAQS,SAAUT,EAAQqB,QAAS,YACxE,GAAIF,EAAQG,MAAML,KAAOE,EAAQI,GAAKJ,EAAQK,KAAM,CAClD,GAAI/B,EAAU,CACZ,IAAIG,EAAKJ,EAAMI,GAAG6B,KAAKN,GACvBvB,EAAG8B,aAAaR,EAAYT,EAAQ,OAAS,cAAmBb,EAAGwB,IAAIO,QAAQ/B,EAAGgC,QAAQC,IAAI1B,EAAK2B,KAAM,KAAM,GAC7F,YAAqBlC,EAAGwB,IAAKjB,EAAK2B,IAAMrB,EAAOsB,WACjEtC,EAASG,EAAGC,kBAEd,OAAO,GAKX,SAAIY,EAAOuB,QAAU7B,EAAK8B,OAASjC,EAAQiC,MAAQ,KAC7CxC,GAAYA,EAASD,EAAMI,GAAGsC,OAAO/B,EAAK2B,IAAMrB,EAAOsB,SAAU5B,EAAK2B,KAAKjC,mBACxE,GAMX,SAASqB,EAAYiB,EAAMC,EAAMC,GAC/B,KAAOF,EAAMA,EAAgB,SAARC,EAAkBD,EAAKG,WAAaH,EAAKI,UAAY,CACxE,GAAIJ,EAAKK,YAAe,OAAO,EAC/B,GAAIH,GAA2B,GAAnBF,EAAKM,WAAmB,OAAO,EAE7C,OAAO,EAUT,SAASC,EAAmBlD,EAAOC,EAAUM,GAC3C,IAAI4C,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MAEZzC,EAAOyC,EACX,IAFYD,EAAIhD,MAEF,OAAO,EAErB,GAAIiD,EAAM7B,OAAOyB,YAAa,CAC5B,GAAIzC,GAAQA,EAAKE,eAAe,WAAYT,GAASoD,EAAM1C,aAAe,EAAK,OAAO,EACtFC,EAAOC,EAAcwC,GAEvB,IAAIT,EAAOhC,GAAQA,EAAKO,WACxB,SAAKyB,IAAS,kBAA2BA,MACrC1C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKjB,EAAK2B,IAAMK,EAAKJ,WAAWlC,mBACvF,GAGT,SAASO,EAAcyC,GACrB,IAAKA,EAAK9B,OAAOJ,KAAKC,KAAKC,UAAa,IAAK,IAAIiC,EAAID,EAAKZ,MAAQ,EAAGa,GAAK,EAAGA,IAAK,CAChF,GAAID,EAAKE,MAAMD,GAAK,EAAK,OAAOD,EAAKzB,IAAIO,QAAQkB,EAAKpC,OAAOqC,EAAI,IACjE,GAAID,EAAKV,KAAKW,GAAGnC,KAAKC,KAAKC,UAAa,MAE1C,OAAO,KAST,SAASmC,EAAYxD,EAAOC,EAAUM,GACpC,IACIC,EADMR,EAAME,UACEM,QAClB,IAAKA,IAAYD,GAAQA,EAAKE,eAAe,UAAWT,GAChCQ,EAAQE,aAAeF,EAAQe,OAAOC,QAAQC,MAClE,OAAO,EAEX,IAAId,EAAO8C,EAAajD,GAGxB,IAAKG,EAAQ,OAAO,EAEpB,IAAIkB,EAAQlB,EAAK+C,UAEjB,GAAIpC,EAActB,EAAOW,EAAMV,GAAa,OAAO,EAInD,GAAmC,GAA/BO,EAAQe,OAAOC,QAAQC,OACtBC,EAAYG,EAAO,UAAY,kBAA2BA,IAAS,CACtE,IAAIF,GAAU,QAAY3B,EAAM4B,IAAKpB,EAAQS,SAAUT,EAAQqB,QAAS,YACxE,GAAIF,EAAQG,MAAML,KAAOE,EAAQI,GAAKJ,EAAQK,KAAM,CAClD,GAAI/B,EAAU,CACZ,IAAIG,EAAKJ,EAAMI,GAAG6B,KAAKN,GACvBvB,EAAG8B,aAAaR,EAAYG,EAAO,SAAW,cAAmBzB,EAAGwB,IAAIO,QAAQ/B,EAAGgC,QAAQC,IAAI1B,EAAK2B,MAAO,GACzF,YAAqBlC,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI1B,EAAK2B,OACnErC,EAASG,EAAGC,kBAEd,OAAO,GAKX,SAAIwB,EAAMW,QAAU7B,EAAK8B,OAASjC,EAAQiC,MAAQ,KAC5CxC,GAAYA,EAASD,EAAMI,GAAGsC,OAAO/B,EAAK2B,IAAK3B,EAAK2B,IAAMT,EAAMU,UAAUlC,mBACvE,GAaX,SAASsD,EAAkB3D,EAAOC,EAAUM,GAC1C,IAAI4C,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MAEZzC,EAAOyC,EACX,IAFYD,EAAIhD,MAEF,OAAO,EACrB,GAAIiD,EAAM7B,OAAOyB,YAAa,CAC5B,GAAIzC,GAAQA,EAAKE,eAAe,UAAWT,GAASoD,EAAM1C,aAAe0C,EAAM7B,OAAOC,QAAQC,KAC1F,OAAO,EACXd,EAAO8C,EAAaL,GAEtB,IAAIT,EAAOhC,GAAQA,EAAK+C,UACxB,SAAKf,IAAS,kBAA2BA,MACrC1C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKjB,EAAK2B,MAAMjC,mBACvE,GAGT,SAASoD,EAAaJ,GACpB,IAAKA,EAAK9B,OAAOJ,KAAKC,KAAKC,UAAa,IAAK,IAAIiC,EAAID,EAAKZ,MAAQ,EAAGa,GAAK,EAAGA,IAAK,CAChF,IAAI/B,EAAS8B,EAAKV,KAAKW,GACvB,GAAID,EAAKE,MAAMD,GAAK,EAAI/B,EAAO0B,WAAc,OAAOI,EAAKzB,IAAIO,QAAQkB,EAAKxB,MAAMyB,EAAI,IACpF,GAAI/B,EAAOJ,KAAKC,KAAKC,UAAa,MAEpC,OAAO,KA0DT,SAASuC,EAAc5D,EAAOC,GAC5B,IAAIkD,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QAClB,SAAKT,EAAM7B,OAAOJ,KAAKC,KAAK0C,OAASV,EAAMW,WAAWF,MAClD5D,GAAYA,EAASD,EAAMI,GAAG4D,WAAW,MAAM3D,mBAC5C,GAGT,SAAS4D,EAAeC,GACtB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,IAAK,CACxC,IACInC,EADM+C,EAAME,KAAKd,GACNnC,KACf,GAAIA,EAAK6B,cAAgB7B,EAAKkD,mBAAsB,OAAOlD,EAE7D,OAAO,KAOT,SAASmD,EAAStE,EAAOC,GACvB,IAAIkD,EAAMnD,EAAME,UACZkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QAClB,IAAKT,EAAM7B,OAAOJ,KAAKC,KAAK0C,OAASV,EAAMW,WAAWF,GAAY,OAAO,EACzE,IAAIU,EAAQnB,EAAMT,MAAM,GAAId,EAAQuB,EAAMoB,YAAY,GAAIrD,EAAO8C,EAAeM,EAAME,eAAe5C,IACrG,IAAK0C,EAAMG,eAAe7C,EAAOA,EAAOV,GAAS,OAAO,EACxD,GAAIlB,EAAU,CACZ,IAAIqC,EAAMc,EAAMvB,QAASzB,EAAKJ,EAAMI,GAAGuE,YAAYrC,EAAKA,EAAKnB,EAAKyD,iBAClExE,EAAG8B,aAAa,UAAe9B,EAAGwB,IAAIO,QAAQG,GAAM,IACpDrC,EAASG,EAAGC,kBAEd,OAAO,EAMT,SAASwE,EAAoB7E,EAAOC,GAClC,IAAI6E,EAAM9E,EAAME,UACZ6E,EAAQD,EAAIC,MACZC,EAAMF,EAAIE,IACd,GAAIF,aAAe,MAAgBC,EAAMxD,OAAO0D,eAAiBD,EAAIzD,OAAO0D,cAAiB,OAAO,EACpG,IAAI9D,EAAO8C,EAAee,EAAIzD,OAAOkD,eAAeO,EAAIR,eACxD,IAAKrD,IAASA,EAAK6B,YAAe,OAAO,EACzC,GAAI/C,EAAU,CACZ,IAAI2C,IAASmC,EAAMrE,cAAgBsE,EAAIzB,QAAUyB,EAAIzD,OAAO0B,WAAa8B,EAAQC,GAAK1C,IAClFlC,EAAKJ,EAAMI,GAAG8E,OAAOtC,EAAMzB,EAAKyD,iBACpCxE,EAAG8B,aAAa,YAAqB9B,EAAGwB,IAAKgB,EAAO,IACpD3C,EAASG,EAAGC,kBAEd,OAAO,EAMT,SAAS8E,EAAenF,EAAOC,GAC7B,IACIO,EADMR,EAAME,UACEM,QAClB,IAAKA,GAAWA,EAAQe,OAAOC,QAAQC,KAAQ,OAAO,EACtD,GAAIjB,EAAQiC,MAAQ,GAAKjC,EAAQqB,SAAWrB,EAAQ4E,KAAK,GAAI,CAC3D,IAAInE,EAAST,EAAQS,SACrB,IAAI,QAASjB,EAAM4B,IAAKX,GAEtB,OADIhB,GAAYA,EAASD,EAAMI,GAAGiF,MAAMpE,GAAQZ,mBACzC,EAGX,IAAIQ,EAAQL,EAAQM,aAAcC,EAASF,IAAS,QAAWA,GAC/D,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GAMT,SAASiF,EAAWtF,EAAOC,GACzB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACd,GAAIhF,EAAME,qBAAqB,MAAiBF,EAAME,UAAUyC,KAAK4C,QACnE,SAAKR,EAAMrE,gBAAiB,QAASV,EAAM4B,IAAKmD,EAAMzC,QAClDrC,GAAYA,EAASD,EAAMI,GAAGiF,MAAMN,EAAMzC,KAAKjC,mBAC5C,GAGT,IAAK0E,EAAMxD,OAAOgE,QAAW,OAAO,EAEpC,GAAItF,EAAU,CACZ,IAAIuF,EAAQR,EAAItE,cAAgBsE,EAAIzD,OAAOC,QAAQC,KAC/CrB,EAAKJ,EAAMI,IACXJ,EAAME,qBAAqB,MAAiBF,EAAME,qBAAqB,OAAgBE,EAAGL,kBAC9F,IAAI0F,EAAuB,GAAfV,EAAMtC,MAAa,KAAOwB,EAAec,EAAMpC,MAAM,GAAG8B,eAAeM,EAAMP,YAAY,KACjGkB,EAAQF,GAASC,EAAQ,CAAC,CAACtE,KAAMsE,IAAU,KAC3CE,GAAM,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GAKzD,GAJKA,GAAUC,KAAO,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGmD,GAAS,CAAC,CAACtE,KAAMsE,OACpFC,EAAQ,CAAC,CAACvE,KAAMsE,IAChBE,GAAM,GAEJA,IACFvF,EAAGiF,MAAMjF,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,IAClCF,IAAUT,EAAMrE,cAAgBqE,EAAMxD,OAAOJ,MAAQsE,GAAO,CAC/D,IAAIG,EAAQxF,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAW4E,EAASzF,EAAGwB,IAAIO,QAAQyD,GAChEb,EAAMpC,MAAM,GAAG+B,eAAemB,EAAOtC,QAASsC,EAAOtC,QAAU,EAAGkC,IAClErF,EAAG0F,cAAc1F,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAWwE,GAGzDxF,EAASG,EAAGC,kBAEd,OAAO,EAqDT,SAASiB,EAActB,EAAOW,EAAMV,GAClC,IAAsD8F,EAAM7B,EAAxDjD,EAASN,EAAKO,WAAYW,EAAQlB,EAAK+C,UAC3C,GAAIzC,EAAOE,KAAKC,KAAKC,WAAaQ,EAAMV,KAAKC,KAAKC,UAAa,OAAO,EACtE,GApBF,SAAwBrB,EAAOqD,EAAMpD,GACnC,IAAIgB,EAASoC,EAAKnC,WAAYW,EAAQwB,EAAKK,UAAWH,EAAQF,EAAKE,QACnE,UAAKtC,GAAWY,GAAUZ,EAAOE,KAAK6E,kBAAkBnE,EAAMV,UACzDF,EAAOO,QAAQC,MAAQ4B,EAAK9B,OAAO0E,WAAW1C,EAAQ,EAAGA,IACxDtD,GAAYA,EAASD,EAAMI,GAAGsC,OAAOW,EAAKf,IAAMrB,EAAOsB,SAAUc,EAAKf,KAAKjC,kBACxE,IAEJgD,EAAK9B,OAAO0E,WAAW1C,EAAOA,EAAQ,KAAQ1B,EAAMmB,eAAe,QAAQhD,EAAM4B,IAAKyB,EAAKf,OAE5FrC,GACAA,EAASD,EAAMI,GACP8F,kBAAkB7C,EAAKf,IAAKrB,EAAOE,KAAMF,EAAOwD,eAAexD,EAAOgC,aACtEkD,KAAK9C,EAAKf,KACVjC,kBACL,KAMH+F,CAAepG,EAAOW,EAAMV,GAAa,OAAO,EAEpD,IAAIoG,EAAc1F,EAAKY,OAAO0E,WAAWtF,EAAK4C,QAAS5C,EAAK4C,QAAU,GACtE,GAAI8C,IACCN,GAAQ7B,EAAQjD,EAAOwD,eAAexD,EAAOgC,aAAaqD,aAAazE,EAAMV,QAC9E+C,EAAMqC,UAAUR,EAAK,IAAMlE,EAAMV,MAAMqF,SAAU,CACnD,GAAIvG,EAAU,CAEZ,IADA,IAAImF,EAAMzE,EAAK2B,IAAMT,EAAMU,SAAUkE,EAAO,WACnCnD,EAAIyC,EAAKW,OAAS,EAAGpD,GAAK,EAAGA,IAClCmD,EAAO,UAAcV,EAAKzC,GAAGqD,OAAO,KAAMF,IAC9CA,EAAO,UAAcxF,EAAO2F,KAAKH,IACjC,IAAIrG,EAAKJ,EAAMI,GAAG6B,KAAK,IAAI,KAAkBtB,EAAK2B,IAAM,EAAG8C,EAAKzE,EAAK2B,IAAK8C,EAAK,IAAI,KAAMqB,EAAM,EAAG,GAAIV,EAAKW,QAAQ,IAC/GG,EAASzB,EAAM,EAAIW,EAAKW,QACxB,QAAQtG,EAAGwB,IAAKiF,IAAWzG,EAAG+F,KAAKU,GACvC5G,EAASG,EAAGC,kBAEd,OAAO,EAGT,IAAIyG,EAAW,cAAmBnG,EAAM,GACpCE,EAAQiG,GAAYA,EAAS/B,MAAMjE,WAAWgG,EAAS9B,KAAMjE,EAASF,IAAS,QAAWA,GAC9F,GAAc,MAAVE,GAAkBA,GAAUJ,EAAK8B,MAEnC,OADIxC,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,EAGT,GAAIgG,GAAe3E,EAAYG,EAAO,SAAS,IAASH,EAAYT,EAAQ,OAAQ,CAElF,IADA,IAAI8F,EAAK9F,EAAQ+F,EAAS,GAExBA,EAAOC,KAAKF,IACRA,EAAG/D,aACP+D,EAAKA,EAAGhE,UAGV,IADA,IAAImE,EAAYrF,EAAOsF,EAAa,GAC5BD,EAAUlE,YAAakE,EAAYA,EAAUpE,WAAcqE,IACnE,GAAIJ,EAAGd,WAAWc,EAAG9D,WAAY8D,EAAG9D,WAAYiE,EAAU1F,SAAU,CAClE,GAAIvB,EAAU,CAEZ,IADA,IAAImH,EAAQ,WACHC,EAAML,EAAON,OAAS,EAAGW,GAAO,EAAGA,IAASD,EAAQ,UAAcJ,EAAOK,GAAKT,KAAKQ,IAI5FnH,EAHWD,EAAMI,GAAG6B,KAAK,IAAI,KAAkBtB,EAAK2B,IAAM0E,EAAON,OAAQ/F,EAAK2B,IAAMT,EAAMU,SAC7C5B,EAAK2B,IAAM6E,EAAYxG,EAAK2B,IAAMT,EAAMU,SAAW4E,EACnD,IAAI,KAAMC,EAAOJ,EAAON,OAAQ,GAAI,GAAG,IACtErG,kBAEhB,OAAO,GAIX,OAAO,EAGT,SAASiH,EAAoB1E,GAC3B,OAAO,SAAS5C,EAAOC,GAGrB,IAFA,IAAI6E,EAAM9E,EAAME,UAAWmD,EAAOT,EAAO,EAAIkC,EAAIC,MAAQD,EAAIE,IACzDvC,EAAQY,EAAKZ,MACVY,EAAKV,KAAKF,GAAO8E,UAAU,CAChC,IAAK9E,EAAS,OAAO,EACrBA,IAEF,QAAKY,EAAKV,KAAKF,GAAOO,cAClB/C,GACAA,EAASD,EAAMI,GAAG8B,aAAa,YAC/BlC,EAAM4B,IAAKgB,EAAO,EAAIS,EAAKmE,MAAM/E,GAASY,EAAK+B,IAAI3C,OAChD,IAMX,IAAIgF,EAAuBH,GAAqB,GAI5CI,EAAqBJ,EAAoB,GAsB7C,SAASK,EAAaC,EAAUC,GAC9B,OAAO,SAAS7H,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ8B,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GACT+F,GAAa,EAWjB,OAVA9H,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC/C,GAAIwF,EAAc,OAAO,EACzB,GAAKnF,EAAKK,cAAeL,EAAKqF,UAAUJ,EAAUC,GAClD,GAAIlF,EAAKxB,MAAQyG,EACfE,GAAa,MACR,CACL,IAAIzE,EAAOrD,EAAM4B,IAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAChDuE,EAAazE,EAAK9B,OAAOmD,eAAenB,EAAOA,EAAQ,EAAGqE,SAGzDE,IACD7H,GAAYA,EAASD,EAAMI,GAAGuH,aAAa3F,EAAMD,EAAI6F,EAAUC,GAAOxH,mBACnE,IAmIX,SAAS4H,IAEP,IADA,IAAIC,EAAW,GAAIC,EAAMC,UAAU1B,OAC3ByB,KAAQD,EAAUC,GAAQC,UAAWD,GAE7C,OAAO,SAASnI,EAAOC,EAAUM,GAC/B,IAAK,IAAI+C,EAAI,EAAGA,EAAI4E,EAASxB,OAAQpD,IACjC,GAAI4E,EAAS5E,GAAGtD,EAAOC,EAAUM,GAAS,OAAO,EACrD,OAAO,GAIX,IAAI8H,EAAYJ,EAAclI,EAAiBO,EAAc4C,GACzDoF,EAAML,EAAclI,EAAiByD,EAAaG,GAalD4E,EAAe,CACjB,MAASN,EAAcrE,EAAeiB,EAAqBM,EAAgBG,GAC3E,YAAahB,EACb,UAAa+D,EACb,gBAAiBA,EACjB,kBAAmBA,EACnB,OAAUC,EACV,aAAcA,EACd,QA9SF,SAAmBtI,EAAOC,GAExB,OADIA,GAAYA,EAASD,EAAMI,GAAG8B,aAAa,IAAI,KAAalC,EAAM4B,QAC/D,IAoTL4G,EAAgB,CAClB,SAAUD,EAAwB,UAClC,gBAAiBA,EAAa,iBAC9B,SAAUA,EAAqB,OAC/B,qBAAsBA,EAAa,cACnC,aAAcA,EAAa,cAC3B,QAASA,EAAa,cACtB,SAAUd,EACV,SAAUC,GAEZ,IAAK,IAAIe,KAAOF,EAAgBC,EAAcC,GAAOF,EAAaE,GAElEF,EAAaG,KAAOjB,EACpBc,EAAaI,IAAMjB,EAGW,oBAAbkB,UAA2B,qBAAqBC,KAAKD,UAAUE,UACvD,oBAANC,IAAoBA,GAAGD,WCtoB1C,SAASE,EAAWC,EAAUpB,GAC5B,OAAO,SAAS7H,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAMkE,GAAS,EAAOC,EAAatI,EAChE,IAAKA,EAAS,OAAO,EAErB,GAAIA,EAAM4B,OAAS,GAAKsC,EAAMpC,KAAK9B,EAAM4B,MAAQ,GAAGtB,KAAK6E,kBAAkBiD,IAAiC,GAApBpI,EAAMuI,WAAiB,CAE7G,GAAoC,GAAhCrE,EAAMxB,MAAM1C,EAAM4B,MAAQ,GAAW,OAAO,EAChD,IAAI4G,EAAUrJ,EAAM4B,IAAIO,QAAQtB,EAAM2G,MAAQ,GAC9C2B,EAAa,IAAI,KAAUE,EAASA,EAASxI,EAAM4B,OAC/C5B,EAAMyI,SAAWzI,EAAMU,OAAO0B,aAC9BpC,EAAQ,IAAI,KAAUkE,EAAO/E,EAAM4B,IAAIO,QAAQ6C,EAAII,IAAIvE,EAAM4B,QAAS5B,EAAM4B,QAChFyG,GAAS,EAEX,IAAIzC,GAAO,QAAa0C,EAAYF,EAAUpB,EAAOhH,GACrD,QAAK4F,IACDxG,GAAYA,EAKpB,SAAsBG,EAAIS,EAAO0I,EAAUC,EAAYP,GAErD,IADA,IAAIzH,EAAU,WACL8B,EAAIiG,EAAS7C,OAAS,EAAGpD,GAAK,EAAGA,IACtC9B,EAAU,UAAc+H,EAASjG,GAAGnC,KAAKwF,OAAO4C,EAASjG,GAAGuE,MAAOrG,IAEvEpB,EAAG6B,KAAK,IAAI,KAAkBpB,EAAM2G,OAASgC,EAAa,EAAI,GAAI3I,EAAMuE,IAAKvE,EAAM2G,MAAO3G,EAAMuE,IAClE,IAAI,KAAM5D,EAAS,EAAG,GAAI+H,EAAS7C,QAAQ,IAGzE,IADA,IAAI+C,EAAQ,EACHpC,EAAM,EAAGA,EAAMkC,EAAS7C,OAAQW,IAAakC,EAASlC,GAAKlG,MAAQ8H,IAAYQ,EAAQpC,EAAM,GAItG,IAHA,IAAIqC,EAAaH,EAAS7C,OAAS+C,EAE/BE,EAAW9I,EAAM2G,MAAQ+B,EAAS7C,QAAU8C,EAAa,EAAI,GAAIjI,EAASV,EAAMU,OAC3EqI,EAAM/I,EAAMuI,WAAYS,EAAIhJ,EAAMyI,SAAU1D,GAAQ,EAAMgE,EAAMC,EAAGD,IAAOhE,GAAQ,GACpFA,IAAS,QAASxF,EAAGwB,IAAK+H,EAAUD,KACvCtJ,EAAGiF,MAAMsE,EAAUD,GACnBC,GAAY,EAAID,GAElBC,GAAYpI,EAAOuI,MAAMF,GAAKrH,SAEhC,OAAOnC,EAzBoB2J,CAAa/J,EAAMI,GAAIS,EAAO4F,EAAMyC,EAAQD,GAAU5I,mBACxE,IAgFX,SAAS2J,EAAaC,GACpB,OAAO,SAASjK,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAK,SAAUrC,GAAQ,OAAOA,EAAKM,YAAcN,EAAKG,WAAW3B,MAAQ8I,KACtG,QAAKpJ,KACAZ,IACD8E,EAAMpC,KAAK9B,EAAM4B,MAAQ,GAAGtB,MAAQ8I,EAO5C,SAAyBjK,EAAOC,EAAUgK,EAAUpJ,GAClD,IAAIT,EAAKJ,EAAMI,GAAIgF,EAAMvE,EAAMuE,IAAK8E,EAAYrJ,EAAMmE,IAAII,IAAIvE,EAAM4B,OAChE2C,EAAM8E,IAGR9J,EAAG6B,KAAK,IAAI,KAAkBmD,EAAM,EAAG8E,EAAW9E,EAAK8E,EACzB,IAAI,KAAM,UAAcD,EAAStD,OAAO,KAAM9F,EAAMU,OAAOqF,SAAU,EAAG,GAAI,GAAG,IAC7G/F,EAAQ,IAAI,KAAUT,EAAGwB,IAAIO,QAAQtB,EAAMkE,MAAMzC,KAAMlC,EAAGwB,IAAIO,QAAQ+H,GAAYrJ,EAAM4B,QAG1F,OADAxC,EAASG,EAAGY,KAAKH,GAAO,QAAWA,IAAQR,mBACpC,EAhBM8J,CAAgBnK,EAAOC,EAAUgK,EAAUpJ,GAmB1D,SAAuBb,EAAOC,EAAUY,GAGtC,IAFA,IAAIT,EAAKJ,EAAMI,GAAIgK,EAAOvJ,EAAMU,OAEvBe,EAAMzB,EAAMuE,IAAK9B,EAAIzC,EAAMyI,SAAW,EAAGO,EAAIhJ,EAAMuI,WAAY9F,EAAIuG,EAAGvG,IAC7EhB,GAAO8H,EAAKN,MAAMxG,GAAGf,SACrBnC,EAAGsC,OAAOJ,EAAM,EAAGA,EAAM,GAE3B,IAAI+H,EAASjK,EAAGwB,IAAIO,QAAQtB,EAAM2G,OAAQ8C,EAAOD,EAAO3G,UACxD,GAAItD,EAAGgC,QAAQC,IAAIxB,EAAMuE,MAAQvE,EAAM2G,MAAQ6C,EAAO3G,UAAUnB,SAAY,OAAO,EACnF,IAAIgI,EAA8B,GAApB1J,EAAMuI,WAAiB5D,EAAQ3E,EAAMyI,UAAYc,EAAKnH,WAChE1B,EAAS8I,EAAO1H,MAAM,GAAI6H,EAAcH,EAAO9G,OAAO,GAC1D,IAAKhC,EAAO0E,WAAWuE,GAAeD,EAAU,EAAI,GAAIC,EAAc,EAC/CF,EAAK9I,QAAQiJ,OAAOjF,EAAQ,WAAiB,UAAc4E,KAC9E,OAAO,EACX,IAAI5C,EAAQ6C,EAAO/H,IAAK8C,EAAMoC,EAAQ8C,EAAK/H,SAS3C,OALAnC,EAAG6B,KAAK,IAAI,KAAkBuF,GAAS+C,EAAU,EAAI,GAAInF,GAAOI,EAAQ,EAAI,GAAIgC,EAAQ,EAAGpC,EAAM,EACnE,IAAI,MAAOmF,EAAU,WAAiB,UAAcH,EAAKxD,KAAK,cACnD6D,OAAOjF,EAAQ,WAAiB,UAAc4E,EAAKxD,KAAK,cACzD2D,EAAU,EAAI,EAAG/E,EAAQ,EAAI,GAAI+E,EAAU,EAAI,IACvFtK,EAASG,EAAGC,mBACL,EAxCMqK,CAAc1K,EAAOC,EAAUY,M,0BCvK9C,SAAS8J,EAAcC,GACnB,MAAuB,WAJ3B,SAAiBA,GACb,OAAOC,OAAOC,UAAUC,SAASC,KAAKJ,GAAO9I,MAAM,GAAI,GAGnDmJ,CAAQL,KAGLA,EAAMM,cAAgBL,QAAUA,OAAOM,eAAeP,KAAWC,OAAOC,WAGnF,SAASM,EAAUrK,EAAQsK,GACvB,MAAMC,EAAS,IAAKvK,GAgBpB,OAfI4J,EAAc5J,IAAW4J,EAAcU,IACvCR,OAAOU,KAAKF,GAAQG,SAAQ/C,IACpBkC,EAAcU,EAAO5C,IACfA,KAAO1H,EAITuK,EAAO7C,GAAO2C,EAAUrK,EAAO0H,GAAM4C,EAAO5C,IAH5CoC,OAAOY,OAAOH,EAAQ,CAAE,CAAC7C,GAAM4C,EAAO5C,KAO1CoC,OAAOY,OAAOH,EAAQ,CAAE,CAAC7C,GAAM4C,EAAO5C,QAI3C6C,EAGX,SAASI,EAAWd,GAChB,MAAwB,mBAAVA,EAUlB,SAASe,EAAaf,EAAOgB,KAAwBC,GACjD,OAAIH,EAAWd,GACPgB,EACOhB,EAAMkB,KAAKF,EAAXhB,IAAuBiB,GAE3BjB,KAASiB,GAEbjB,EAGX,SAASmB,EAAkBC,EAAWC,EAAOL,GACzC,QAAgCM,IAA5BF,EAAUG,OAAOF,IAAwBD,EAAUzK,OACnD,OAAOwK,EAAkBC,EAAUzK,OAAQ0K,EAAOL,GAEtD,GAAuC,mBAA5BI,EAAUG,OAAOF,GAAuB,CAO/C,OANcD,EAAUG,OAAOF,GAAOH,KAAK,IACpCF,EACHrK,OAAQyK,EAAUzK,OACZwK,EAAkBC,EAAUzK,OAAQ0K,EAAOL,GAC3C,OAId,OAAOI,EAAUG,OAAOF,GAG5B,MAAMG,EACFlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,YACZkL,KAAKC,KAAO,YACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIC,EAAUD,GAEzBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAII,EAAUY,GAgBhC,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,SAASiB,EAAeC,EAAWrM,EAAO6L,GACtC,MAAM,KAAE1K,EAAI,GAAED,GAAOlB,GACf,eAAEsM,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GACtE,IAAIW,EAAO,GACPC,GAAY,EAyBhB,OAxBAJ,EAAUnF,aAAa/F,EAAMD,GAAI,CAACY,EAAML,EAAKf,EAAQgC,KACjD,IAAIgK,EACJ,MAAMC,EAAiBJ,MAAAA,OAAyD,EAASA,EAAgBzK,EAAKxB,KAAKmL,MAC/GkB,GACI7K,EAAK4C,UAAY+H,IACjBD,GAAQF,EACRG,GAAY,GAEhBD,GAAQG,EAAe,CACnB7K,KAAAA,EACAL,IAAAA,EACAf,OAAAA,EACAgC,MAAAA,KAGCZ,EAAK8K,QACVJ,GAAyE,QAAhEE,EAAK5K,MAAAA,OAAmC,EAASA,EAAK0K,YAAyB,IAAPE,OAAgB,EAASA,EAAGzL,MAAM4L,KAAKC,IAAI3L,EAAMM,GAAOA,EAAKP,EAAKO,GACnJgL,GAAY,GAEP3K,EAAK4C,UAAY+H,IACtBD,GAAQF,EACRG,GAAY,MAGbD,EAGX,SAASO,EAA4BC,GACjC,OAAOhD,OAAOiD,YAAYjD,OACrBkD,QAAQF,EAAOG,OACfC,QAAO,EAAE,CAAEtL,KAAUA,EAAKvB,KAAK8M,SAC/B7L,KAAI,EAAEiK,EAAM3J,KAAU,CAAC2J,EAAM3J,EAAKvB,KAAK8M,WAGhD,MAAMC,EAA0B/B,EAAUzF,OAAO,CAC7C2F,KAAM,0BACN8B,wBACI,MAAO,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,2BACnBoD,MAAO,CACHwC,wBAAyB,KACrB,MAAM,OAAEC,GAAWjC,MACb,MAAErM,EAAK,OAAE6N,GAAWS,GACpB,IAAE1M,EAAG,UAAE1B,GAAcF,GACrB,OAAEuO,GAAWrO,EACb8B,EAAO0L,KAAKc,OAAOD,EAAOlM,KAAIxB,GAASA,EAAMkE,MAAMzC,OACnDP,EAAK2L,KAAKC,OAAOY,EAAOlM,KAAIxB,GAASA,EAAMmE,IAAI1C,OAGrD,OAAO2K,EAAerL,EADR,CAAEI,KAAAA,EAAMD,GAAAA,GACY,CAC9BqL,gBAHoBQ,EAA4BC,aAyB5E,IAAIY,EAAsB5D,OAAO6D,OAAO,CACtCC,UAAW,KACXC,KAfW,IAAM,EAAGN,OAAAA,EAAQ/N,KAAAA,MAC1BsO,uBAAsB,KAClB,IAAItB,EACCe,EAAOQ,cACRvO,EAAKwO,IAAIH,OAGwE,QAAhFrB,EAAgB,OAAXyB,aAA8B,IAAXA,YAAoB,EAASA,OAAOC,sBAAmC,IAAP1B,GAAyBA,EAAG2B,uBAGtH,KAYX,IAAIC,EAA8BtE,OAAO6D,OAAO,CAC9CC,UAAW,KACXS,aANmB,CAACC,GAAa,IAAU,EAAGnH,SAAAA,KACrCA,EAASoH,WAAW,GAAID,KAuCnC,IAAIE,EAA4B1E,OAAO6D,OAAO,CAC5CC,UAAW,KACXa,WAjCiB,IAAM,EAAGxP,MAAAA,EAAOI,GAAAA,EAAIH,SAAAA,MACnC,MAAM,UAAEC,GAAcE,GAChB,OAAEmO,GAAWrO,EACnB,OAAKD,IAGLsO,EAAO/C,SAAQ,EAAGzG,MAAAA,EAAOC,IAAAA,MACrBhF,EAAM4B,IAAImG,aAAahD,EAAMzC,IAAK0C,EAAI1C,KAAK,CAACK,EAAML,KAC9C,GAAIK,EAAKxB,KAAKsM,OACV,OAEJ,MAAM,IAAE7L,EAAG,QAAEQ,GAAYhC,EACnBqP,EAAc7N,EAAIO,QAAQC,EAAQC,IAAIC,IACtCoN,EAAY9N,EAAIO,QAAQC,EAAQC,IAAIC,EAAMK,EAAKJ,WAC/CoN,EAAYF,EAAY3O,WAAW4O,GACzC,IAAKC,EACD,OAEJ,MAAMC,GAAkB,QAAWD,GACnC,GAAIhN,EAAKxB,KAAK6B,YAAa,CACvB,MAAM,YAAE6M,GAAgBJ,EAAYlO,OAAOkD,eAAegL,EAAYlM,SACtEnD,EAAG0F,cAAc6J,EAAUnI,MAAOqI,IAElCD,GAAuC,IAApBA,IACnBxP,EAAGY,KAAK2O,EAAWC,UAIxB,MAYX,IAAIE,EAAyBjF,OAAO6D,OAAO,CACzCC,UAAW,KACXoB,QANcC,GAAMnE,GACXmE,EAAGnE,KAYd,IAAIoE,EAAqCpF,OAAO6D,OAAO,CACrDC,UAAW,KACX9J,oBAN0B,IAAM,EAAG7E,MAAAA,EAAOC,SAAAA,KACjC4E,EAAsB7E,EAAOC,KAQxC,SAASiQ,EAAYC,EAAYtC,GAC7B,GAA0B,iBAAfsC,EAAyB,CAChC,IAAKtC,EAAOG,MAAMmC,GACd,MAAMC,MAAM,gCAAgCD,8CAEhD,OAAOtC,EAAOG,MAAMmC,GAExB,OAAOA,EAoBX,IAAIE,EAA4BxF,OAAO6D,OAAO,CAC5CC,UAAW,KACX2B,WAnBiBC,GAAc,EAAGnQ,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC3C,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QACrCxK,EAAOjD,EAAGF,UAAU2D,QAC1B,IAAK,IAAIpB,EAAQY,EAAKZ,MAAOA,EAAQ,EAAGA,GAAS,EAAG,CAEhD,GADaY,EAAKV,KAAKF,GACdtB,OAASA,EAAM,CACpB,GAAIlB,EAAU,CACV,MAAM+B,EAAOqB,EAAKpC,OAAOwB,GACnBV,EAAKsB,EAAKxB,MAAMY,GACtBrC,EAAGsC,OAAOV,EAAMD,GAAI1B,iBAExB,OAAO,GAGf,OAAO,KAgBX,IAAImQ,EAA6B3F,OAAO6D,OAAO,CAC7CC,UAAW,KACX8B,YAVkB5P,GAAS,EAAGT,GAAAA,EAAIH,SAAAA,MAChC,MAAM,KAAE+B,EAAI,GAAED,GAAOlB,EAIrB,OAHIZ,GACAG,EAAGsC,OAAOV,EAAMD,IAEb,KAYX,IAAI2O,EAAiC7F,OAAO6D,OAAO,CACjDC,UAAW,KACX5O,gBANsB,IAAM,EAAGC,MAAAA,EAAOC,SAAAA,KAC7BF,EAAkBC,EAAOC,KAYpC,IAAI0Q,EAAuB9F,OAAO6D,OAAO,CACvCC,UAAW,KACXiC,MANY,IAAM,EAAG1I,SAAAA,KACZA,EAAS2I,iBAAiB,WAYrC,IAAIC,GAA0BjG,OAAO6D,OAAO,CAC1CC,UAAW,KACXrK,SANe,IAAM,EAAGtE,MAAAA,EAAOC,SAAAA,KACtBqE,EAAWtE,EAAOC,KAQ7B,SAAS8Q,GAAYZ,EAAYtC,GAC7B,GAA0B,iBAAfsC,EAAyB,CAChC,IAAKtC,EAAOmD,MAAMb,GACd,MAAMC,MAAM,gCAAgCD,8CAEhD,OAAOtC,EAAOmD,MAAMb,GAExB,OAAOA,EAGX,SAASc,GAASrG,GACd,MAAiD,oBAA1CC,OAAOC,UAAUC,SAASC,KAAKJ,GAQ1C,SAASsG,GAAeC,EAASC,EAAS1E,EAAU,CAAE2E,QAAQ,IAC1D,MAAM9F,EAAOV,OAAOU,KAAK6F,GACzB,OAAK7F,EAAK7E,QAGH6E,EAAK+F,OAAM7I,GACViE,EAAQ2E,OACDD,EAAQ3I,KAAS0I,EAAQ1I,GAEhCwI,GAASG,EAAQ3I,IACV2I,EAAQ3I,GAAKI,KAAKsI,EAAQ1I,IAE9B2I,EAAQ3I,KAAS0I,EAAQ1I,KAIxC,SAAS8I,GAAcP,EAAO7P,EAAMqQ,EAAa,IAC7C,OAAOR,EAAMS,MAAKnH,GACPA,EAAKnJ,OAASA,GAAQ+P,GAAe5G,EAAKzC,MAAO2J,KAGhE,SAASE,GAAYV,EAAO7P,EAAMqQ,EAAa,IAC3C,QAASD,GAAcP,EAAO7P,EAAMqQ,GAExC,SAASG,GAAatO,EAAMlC,EAAMqQ,EAAa,IAC3C,IAAKnO,IAASlC,EACV,OAEJ,MAAMqG,EAAQnE,EAAK9B,OAAOqQ,WAAWvO,EAAK3C,cAC1C,IAAK8G,EAAM7E,KACP,OAEJ,MAAMkP,EAAON,GAAc/J,EAAM7E,KAAKqO,MAAO7P,EAAMqQ,GACnD,IAAKK,EACD,OAEJ,IAAIzI,EAAa/F,EAAKE,QAClBuO,EAAWzO,EAAKmE,QAAUA,EAAMuK,OAChCzI,EAAWF,EAAa,EACxB4I,EAASF,EAAWtK,EAAM7E,KAAKJ,SAEnC,IADAgP,GAAc/J,EAAM7E,KAAKqO,MAAO7P,EAAMqQ,GAC/BpI,EAAa,GAAKyI,EAAKI,QAAQ5O,EAAK9B,OAAOuI,MAAMV,EAAa,GAAG4H,QACpE5H,GAAc,EACd0I,GAAYzO,EAAK9B,OAAOuI,MAAMV,GAAY7G,SAE9C,KAAO+G,EAAWjG,EAAK9B,OAAO0B,YACvByO,GAAYrO,EAAK9B,OAAOuI,MAAMR,GAAU0H,MAAO7P,EAAMqQ,IACxDQ,GAAU3O,EAAK9B,OAAOuI,MAAMR,GAAU/G,SACtC+G,GAAY,EAEhB,MAAO,CACHtH,KAAM8P,EACN/P,GAAIiQ,GAkBZ,IAAIE,GAAiCrH,OAAO6D,OAAO,CACjDC,UAAW,KACXwD,gBAhBsB,CAAC5B,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MACnE,MAAMkB,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,IAAEjM,EAAG,UAAE1B,GAAcE,GACrB,MAAE2E,EAAK,KAAE/C,EAAI,GAAED,GAAO7B,EAC5B,GAAID,EAAU,CACV,MAAMY,EAAQ8Q,GAAa5M,EAAO5D,EAAMqQ,GACxC,GAAI3Q,GAASA,EAAMmB,MAAQA,GAAQnB,EAAMkB,IAAMA,EAAI,CAC/C,MAAMqQ,EAAe,YAAqBxQ,EAAKf,EAAMmB,KAAMnB,EAAMkB,IACjE3B,EAAG8B,aAAakQ,IAGxB,OAAO,KAoBX,IAAIC,GAAuBxH,OAAO6D,OAAO,CACvCC,UAAW,KACX/I,MAdYsC,GAAY2D,IACtB,MAAMyG,EAA4B,mBAAbpK,EACfA,EAAS2D,GACT3D,EACN,IAAK,IAAI5E,EAAI,EAAGA,EAAIgP,EAAM5L,OAAQpD,GAAK,EACnC,GAAIgP,EAAMhP,GAAGuI,GACT,OAAO,EAGf,OAAO,KAgBX,SAAS0G,GAAS3H,GACd,OAAQA,GACgB,iBAAVA,IACN4H,MAAMC,QAAQ7H,KAX1B,SAAiBA,GACb,IAAI2C,EACJ,MAAsG,WAApE,QAA5BA,EAAK3C,EAAMM,mBAAgC,IAAPqC,OAAgB,EAASA,EAAGxC,WAAW2H,UAAU,EAAG,IAUtFC,CAAQ/H,GAGpB,SAASgI,GAAgBhI,GACrB,OAAO2H,GAAS3H,IAAUA,aAAiB,KAG/C,SAASiI,KACL,MAAO,CACH,iBACA,mBACA,iBACA,OACA,SACA,QACFC,SAASlK,UAAUE,WAEbF,UAAUmK,UAAUD,SAAS,QAAU,eAAgBE,SAGnE,SAASC,GAAOrI,EAAQ,EAAG4D,EAAM,EAAGb,EAAM,GACtC,OAAOD,KAAKc,IAAId,KAAKC,IAAI/C,EAAO4D,GAAMb,GAG1C,SAASuF,GAAqBtR,EAAKuR,EAAW,MAC1C,IAAKA,EACD,OAAO,KAEX,GAAiB,UAAbA,IAAqC,IAAbA,EACxB,OAAO,aAAkBvR,GAE7B,GAAiB,QAAbuR,EACA,OAAO,WAAgBvR,GAE3B,GAAiB,QAAbuR,EACA,OAAO,YAAqBvR,EAAK,EAAGA,EAAIJ,QAAQC,MAGpD,MAAM2R,EAAS,aAAkBxR,GAAKI,KAChCqR,EAAS,WAAgBzR,GAAKG,GAC9BuR,EAAeL,GAAOE,EAAUC,EAAQC,GACxCE,EAAcN,GAAOE,EAAUC,EAAQC,GAC7C,OAAO,YAAqBzR,EAAK0R,EAAcC,GAiDnD,IAAIC,GAAuB3I,OAAO6D,OAAO,CACvCC,UAAW,KACX8E,MAhDY,CAACN,EAAW,KAAMzG,IAAY,EAAG4B,OAAAA,EAAQ/N,KAAAA,EAAMH,GAAAA,EAAIH,SAAAA,MAC7DyM,EAAU,CACNrM,gBAAgB,KACbqM,GAEP,MAAMgH,EAAe,KAGbb,MACAtS,EAAKwO,IAAI0E,QAIb5E,uBAAsB,KACbP,EAAOQ,cACRvO,EAAKkT,SACD/G,MAAAA,OAAyC,EAASA,EAAQrM,iBAC1DiO,EAAOpG,SAAS7H,sBAKhC,GAAKE,EAAKoT,YAA2B,OAAbR,IAAmC,IAAbA,EAC1C,OAAO,EAGX,GAAIlT,GAAyB,OAAbkT,IAAsBP,GAAgBtE,EAAOtO,MAAME,WAE/D,OADAwT,KACO,EAEX,MAAMxT,EAAYgT,GAAqB5E,EAAOtO,MAAM4B,IAAKuR,IAAa7E,EAAOtO,MAAME,UAC7E0T,EAAkBtF,EAAOtO,MAAME,UAAU2T,GAAG3T,GAYlD,OAXID,IACK2T,GACDxT,EAAG8B,aAAahC,GAIhB0T,GAAmBxT,EAAG0T,aACtB1T,EAAG2T,eAAe3T,EAAG0T,aAEzBJ,MAEG,KAYX,IAAIM,GAAyBnJ,OAAO6D,OAAO,CACzCC,UAAW,KACXnD,QANc,CAAC8G,EAAOtC,IAAOnE,GACpByG,EAAMhB,OAAM,CAAChH,EAAM/G,IAAUyM,EAAG1F,EAAM,IAAKuB,EAAOtI,MAAAA,QAY7D,IAAI0Q,GAA+BpJ,OAAO6D,OAAO,CAC/CC,UAAW,KACXuF,cANoB,CAACtJ,EAAO8B,IAAY,EAAGtM,GAAAA,EAAI8H,SAAAA,KACtCA,EAASiM,gBAAgB,CAAEnS,KAAM5B,EAAGF,UAAU8B,KAAMD,GAAI3B,EAAGF,UAAU6B,IAAM6I,EAAO8B,KAQ7F,SAAS0H,GAAkBxJ,GAEvB,MAAMyJ,EAAe,SAASzJ,WAC9B,OAAO,IAAIoE,OAAOsF,WAAYC,gBAAgBF,EAAc,aAAaG,KAG7E,SAASC,GAAsBjT,EAASqM,EAAQnB,GAM5C,GALAA,EAAU,CACN5K,OAAO,EACP4S,aAAc,MACXhI,GAEgB,iBAAZlL,GAAoC,OAAZA,EAC/B,IACI,OAAIgR,MAAMC,QAAQjR,GACP,eAAmBA,EAAQa,KAAIiI,GAAQuD,EAAO8G,aAAarK,MAE/DuD,EAAO8G,aAAanT,GAE/B,MAAOoT,GAEH,OADApI,QAAQC,KAAK,kCAAmC,gBAAiBjL,EAAS,SAAUoT,GAC7EH,GAAsB,GAAI5G,EAAQnB,GAGjD,GAAuB,iBAAZlL,EAAsB,CAC7B,MAAMqT,EAAS,gBAAqBhH,GACpC,OAAOnB,EAAQ5K,MACT+S,EAAOC,WAAWV,GAAkB5S,GAAUkL,EAAQgI,cAAclT,QACpEqT,EAAOE,MAAMX,GAAkB5S,GAAUkL,EAAQgI,cAE3D,OAAOD,GAAsB,GAAI5G,EAAQnB,GA4F7C,IAAIsI,GAAiCnK,OAAO6D,OAAO,CACjDC,UAAW,KACXwF,gBApEsB,CAAChB,EAAUvI,EAAO8B,IAAY,EAAGtM,GAAAA,EAAIH,SAAAA,EAAUqO,OAAAA,MACnE,GAAIrO,EAAU,CACVyM,EAAU,CACNgI,aAAc,GACdO,iBAAiB,KACdvI,GAEP,MAAMlL,EAAUiT,GAAsB7J,EAAO0D,EAAOT,OAAQ,CACxD6G,aAAc,CACVQ,mBAAoB,UACjBxI,EAAQgI,gBAInB,GAA2B,OAAvBlT,EAAQuJ,WACR,OAAO,EAEX,IAAI,KAAE/I,EAAI,GAAED,GAA2B,iBAAboR,EACpB,CAAEnR,KAAMmR,EAAUpR,GAAIoR,GACtBA,EACFgC,GAAoB,EACpBC,GAAqB,EAmBzB,IAlByB5T,EAxBPuJ,WAAWsK,WAAW,KAyBlC7T,EACA,CAACA,IACDgK,SAAQ7I,IAEVA,EAAK2S,QACLH,IAAoBA,IACdxS,EAAK8K,QAAgC,IAAtB9K,EAAKqO,MAAMtK,QAEhC0O,IAAqBA,GACfzS,EAAK4C,WAQXvD,IAASD,GAAMqT,EAAoB,CACnC,MAAM,OAAE7T,GAAWnB,EAAGwB,IAAIO,QAAQH,GACTT,EAAOyB,cACxBzB,EAAOJ,KAAKC,KAAK0C,OACjBvC,EAAO0B,aAEXjB,GAAQ,EACRD,GAAM,GAKVoT,EACA/U,EAAG4D,WAAW4G,EAAO5I,EAAMD,GAG3B3B,EAAGuE,YAAY3C,EAAMD,EAAIP,GAGzBkL,EAAQuI,iBAjFpB,SAAiC7U,EAAImV,EAAUC,GAC3C,MAAMC,EAAOrV,EAAGsV,MAAMhP,OAAS,EAC/B,GAAI+O,EAAOF,EACP,OAEJ,MAAMtT,EAAO7B,EAAGsV,MAAMD,GACtB,KAAMxT,aAAgB,MAAeA,aAAgB,MACjD,OAEJ,MAAMI,EAAMjC,EAAGgC,QAAQuT,KAAKF,GAC5B,IAAIrQ,EAAM,EACV/C,EAAImJ,SAAQ,CAACoK,EAAOC,EAAKC,EAAUC,KACnB,IAAR3Q,IACAA,EAAM2Q,MAGd3V,EAAG8B,aAAa,UAAe9B,EAAGwB,IAAIO,QAAQiD,GAAMoQ,IAkE5CQ,CAAwB5V,EAAIA,EAAGsV,MAAMhP,OAAS,GAAI,GAG1D,OAAO,KAYX,IAAIuP,GAA8BpL,OAAO6D,OAAO,CAC9CC,UAAW,KACXrO,aANmB,IAAM,EAAGN,MAAAA,EAAOC,SAAAA,KAC1BK,EAAeN,EAAOC,KAYjC,IAAIiW,GAA6BrL,OAAO6D,OAAO,CAC7CC,UAAW,KACXnL,YANkB,IAAM,EAAGxD,MAAAA,EAAOC,SAAAA,KACzBuD,EAAcxD,EAAOC,KAQhC,SAASkW,KACL,MAA4B,oBAAdvN,WACR,MAAMC,KAAKD,UAAUE,UAgF/B,IAAIsN,GAAkCvL,OAAO6D,OAAO,CAClDC,UAAW,KACXkC,iBA5BuBvE,GAAQ,EAAGgC,OAAAA,EAAQ/N,KAAAA,EAAMH,GAAAA,EAAIH,SAAAA,MAClD,MAAMsL,EAnDV,SAA0Be,GACtB,MAAM+J,EAAQ/J,EAAKjH,MAAM,UACzB,IAIIiR,EACAC,EACAC,EACAC,EAPAC,EAASL,EAAMA,EAAM3P,OAAS,GACnB,UAAXgQ,IACAA,EAAS,KAMb,IAAK,IAAIpT,EAAI,EAAGA,EAAI+S,EAAM3P,OAAS,EAAGpD,GAAK,EAAG,CAC1C,MAAMqT,EAAMN,EAAM/S,GAClB,GAAI,kBAAkBuF,KAAK8N,GACvBF,GAAO,OAEN,GAAI,YAAY5N,KAAK8N,GACtBL,GAAM,OAEL,GAAI,sBAAsBzN,KAAK8N,GAChCJ,GAAO,OAEN,GAAI,cAAc1N,KAAK8N,GACxBH,GAAQ,MAEP,KAAI,SAAS3N,KAAK8N,GASnB,MAAM,IAAIvG,MAAM,+BAA+BuG,KAR3C9D,MAAWsD,KACXM,GAAO,EAGPF,GAAO,GAmBnB,OAZID,IACAI,EAAS,OAAOA,KAEhBH,IACAG,EAAS,QAAQA,KAEjBD,IACAC,EAAS,QAAQA,KAEjBF,IACAE,EAAS,SAASA,KAEfA,EAGME,CAAiBtK,GAAMjH,MAAM,UACpCoD,EAAM8C,EAAKkG,MAAKnH,IAAS,CAAC,MAAO,OAAQ,OAAQ,SAASwI,SAASxI,KACnEuM,EAAQ,IAAIC,cAAc,UAAW,CACvCrO,IAAa,UAARA,EACC,IACAA,EACNsO,OAAQxL,EAAKuH,SAAS,OACtBkE,QAASzL,EAAKuH,SAAS,QACvBmE,QAAS1L,EAAKuH,SAAS,QACvBoE,SAAU3L,EAAKuH,SAAS,SACxBqE,SAAS,EACTC,YAAY,IAEVC,EAAsB/I,EAAOgJ,oBAAmB,KAClD/W,EAAKgX,SAAS,iBAAiBC,GAAKA,EAAEjX,EAAMsW,QAQhD,OANAQ,MAAAA,GAA0EA,EAAoB3B,MAAMlK,SAAQvJ,IACxG,MAAMwV,EAAUxV,EAAKI,IAAIjC,EAAGgC,SACxBqV,GAAWxX,GACXG,EAAGsX,UAAUD,OAGd,KAQX,SAASE,GAAa3X,EAAOuQ,EAAYiB,EAAa,IAClD,MAAM,KAAExP,EAAI,GAAED,EAAE,MAAE5B,GAAUH,EAAME,UAC5BiB,EAAOoP,EACPL,EAAYK,EAAYvQ,EAAM6N,QAC9B,KACA+J,EAAa,GACnB5X,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,GAAIK,EAAK8K,OACL,OAEJ,MAAMoK,EAAenK,KAAKC,IAAI3L,EAAMM,GAC9BwV,EAAapK,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKJ,UAC3CqV,EAAW3Q,KAAK,CACZtE,KAAAA,EACAX,KAAM6V,EACN9V,GAAI+V,OAGZ,MAAMC,EAAiBhW,EAAKC,EACtBgW,EAAoBJ,EACrB3J,QAAO0B,IACHxO,GAGEA,EAAKmL,OAASqD,EAAUhN,KAAKxB,KAAKmL,OAExC2B,QAAO0B,GAAauB,GAAevB,EAAUhN,KAAKkF,MAAO2J,EAAY,CAAEH,QAAQ,MACpF,GAAIlR,EACA,QAAS6X,EAAkBtR,OAI/B,OAFcsR,EACTC,QAAO,CAACC,EAAKvI,IAAcuI,EAAMvI,EAAU5N,GAAK4N,EAAU3N,MAAM,IACrD+V,EAYpB,IAAII,GAAsBtN,OAAO6D,OAAO,CACtCC,UAAW,KACX3N,KAXW,CAACuP,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,OAEnC0X,GAAa3X,EADjBkQ,EAAYK,EAAYvQ,EAAM6N,QACA2D,IF3nB/C,SAAcxR,EAAOC,GACnB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAMjE,EAASF,IAAS,QAAWA,GAChE,OAAc,MAAVE,IACAd,GAAYA,EAASD,EAAMI,GAAGY,KAAKH,EAAOE,GAAQV,mBAC/C,GEwnBEW,CAAOhB,EAAOC,KAYzB,IAAImY,GAAgCvN,OAAO6D,OAAO,CAChDC,UAAW,KACXxJ,eANqB,IAAM,EAAGnF,MAAAA,EAAOC,SAAAA,KAC5BkF,EAAiBnF,EAAOC,KAanC,IAAIoY,GAA8BxN,OAAO6D,OAAO,CAC9CC,UAAW,KACX3E,aAPmBuG,GAAc,EAAGvQ,MAAAA,EAAOC,SAAAA,KAElC+J,EADMkG,EAAYK,EAAYvQ,EAAM6N,QACpC7D,CAAqBhK,EAAOC,KAYvC,IAAIqY,GAA+BzN,OAAO6D,OAAO,CAC/CC,UAAW,KACX/K,cANoB,IAAM,EAAG5D,MAAAA,EAAOC,SAAAA,KAC3B2D,EAAgB5D,EAAOC,KAQlC,SAASsY,GAAwBjM,EAAMuB,GACnC,OAAIA,EAAOG,MAAM1B,GACN,OAEPuB,EAAOmD,MAAM1E,GACN,OAEJ,KAQX,SAASkM,GAAYC,EAAKC,GACtB,MAAM7M,EAA+B,iBAAhB6M,EACf,CAACA,GACDA,EACN,OAAO7N,OACFU,KAAKkN,GACLR,QAAO,CAACU,EAAQC,KACZ/M,EAAMiH,SAAS8F,KAChBD,EAAOC,GAAQH,EAAIG,IAEhBD,IACR,IAqCP,IAAIE,GAAiChO,OAAO6D,OAAO,CACjDC,UAAW,KACXmK,gBApCsB,CAACvI,EAAYiB,IAAe,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC9D,IAAI2H,EAAW,KACXmR,EAAW,KACf,MAAMC,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,QAAKmL,IAGc,SAAfA,IACApR,EAAWsI,EAAYK,EAAYvQ,EAAM6N,SAE1B,SAAfmL,IACAD,EAAWhI,GAAYR,EAAYvQ,EAAM6N,SAEzC5N,GACAG,EAAGF,UAAUqO,OAAO/C,SAAQ3K,IACxBb,EAAM4B,IAAImG,aAAalH,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,KAAK,CAACK,EAAML,KACtDsF,GAAYA,IAAajF,EAAKxB,MAC9Bf,EAAG0F,cAAcxD,OAAK4J,EAAWsM,GAAY7V,EAAKkF,MAAO2J,IAEzDuH,GAAYpW,EAAKqO,MAAMtK,QACvB/D,EAAKqO,MAAMxF,SAAQqG,IACXkH,IAAalH,EAAK1Q,MAClBf,EAAG6Y,QAAQ3W,EAAKA,EAAMK,EAAKJ,SAAUwW,EAASpS,OAAO6R,GAAY3G,EAAKhK,MAAO2J,eAO9F,MAeX,IAAI0H,GAAgCrO,OAAO6D,OAAO,CAChDC,UAAW,KACXtO,eATqB,IAAM,EAAGD,GAAAA,EAAIH,SAAAA,MAC5BA,GACAG,EAAGC,kBAEA,KAeX,IAAI8Y,GAA2BtO,OAAO6D,OAAO,CAC3CC,UAAW,KACXyK,UATgB,IAAM,EAAGhZ,GAAAA,EAAI8H,SAAAA,KACpBA,EAASmR,iBAAiB,CAC7BrX,KAAM,EACND,GAAI3B,EAAGwB,IAAIJ,QAAQC,SAa3B,IAAI6X,GAAoCzO,OAAO6D,OAAO,CACpDC,UAAW,KACXzL,mBANyB,IAAM,EAAGlD,MAAAA,EAAOC,SAAAA,KAChCiD,EAAqBlD,EAAOC,KAYvC,IAAIsZ,GAAmC1O,OAAO6D,OAAO,CACnDC,UAAW,KACXhL,kBANwB,IAAM,EAAG3D,MAAAA,EAAOC,SAAAA,KAC/B0D,EAAoB3D,EAAOC,KAYtC,IAAIuZ,GAAkC3O,OAAO6D,OAAO,CAClDC,UAAW,KACX8K,iBANuB,IAAM,EAAGzZ,MAAAA,EAAOC,SAAAA,KFloBzC,SAA0BD,EAAOC,GAC/B,IAGIqC,EAHAa,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZhD,EAAKoB,EAAIpB,GAET2X,EAAO3U,EAAM4U,YAAY5X,GAC7B,OAAY,GAAR2X,IACJpX,EAAMyC,EAAM9D,OAAOyY,GACfzZ,GAAYA,EAASD,EAAMI,GAAG8B,aAAa,YAAqBlC,EAAM4B,IAAKU,MACxE,GE0nBEmX,CAAmBzZ,EAAOC,KAarC,IAAI2Z,GAAoC/O,OAAO6D,OAAO,CACpDC,UAAW,KACXjH,mBANyB,IAAM,EAAG1H,MAAAA,EAAOC,SAAAA,KAChCyH,EAAqB1H,EAAOC,KAavC,IAAI4Z,GAAsChP,OAAO6D,OAAO,CACtDC,UAAW,KACXlH,qBAN2B,IAAM,EAAGzH,MAAAA,EAAOC,SAAAA,KAClCwH,EAAuBzH,EAAOC,KAQzC,SAAS6Z,GAAetY,EAASqM,EAAQ6G,EAAe,IACpD,OAAOD,GAAsBjT,EAASqM,EAAQ,CAAE/L,OAAO,EAAO4S,aAAAA,IAelE,IAAIqF,GAA4BlP,OAAO6D,OAAO,CAC5CC,UAAW,KACXW,WAdiB,CAAC9N,EAAS6N,GAAa,EAAOqF,EAAe,KAAO,EAAGtU,GAAAA,EAAIkO,OAAAA,EAAQrO,SAAAA,MAClF,MAAM,IAAE2B,GAAQxB,EACV4S,EAAW8G,GAAetY,EAAS8M,EAAOT,OAAQ6G,GAClDxU,EAAY,YAAqB0B,EAAK,EAAGA,EAAIJ,QAAQC,MAM3D,OALIxB,GACAG,EAAG8B,aAAahC,GACX8Z,qBAAqBhH,GAAU,GAC/BiH,QAAQ,iBAAkB5K,IAE5B,KAQX,SAAS6K,GAAkBla,EAAOuQ,GAC9B,MAAMpP,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,KAAE7L,EAAI,GAAED,EAAE,MAAE5B,GAAUH,EAAME,UAC5B8Q,EAAQ,GACV7Q,GACIH,EAAM8T,aACN9C,EAAM/J,QAAQjH,EAAM8T,aAExB9C,EAAM/J,QAAQjH,EAAME,UAAUkD,MAAM4N,UAGpChR,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAIY,IAC7BqO,EAAM/J,QAAQtE,EAAKqO,UAG3B,MAAMa,EAAOb,EAAMS,MAAK0I,GAAYA,EAAShZ,KAAKmL,OAASnL,EAAKmL,OAChE,OAAKuF,EAGE,IAAKA,EAAKhK,OAFN,GAgDf,IAAIuS,GAAyBvP,OAAO6D,OAAO,CACzCC,UAAW,KACX0L,QA7Cc,CAAC9J,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC3D,MAAM,UAAEC,GAAcE,GAChB,MAAED,EAAK,OAAEoO,GAAWrO,EACpBiB,EAAO4P,GAAYR,EAAYvQ,EAAM6N,QAC3C,GAAI5N,EACA,GAAIE,EAAO,CACP,MAAMma,EAAgBJ,GAAkBla,EAAOmB,GAC/Cf,EAAGma,cAAcpZ,EAAKwF,OAAO,IACtB2T,KACA9I,UAIPjD,EAAO/C,SAAQ3K,IACX,MAAMmB,EAAOnB,EAAMkE,MAAMzC,IACnBP,EAAKlB,EAAMmE,IAAI1C,IACrBtC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,MAAMkY,EAAc9M,KAAKC,IAAIrL,EAAKN,GAC5ByY,EAAY/M,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAC5BY,EAAKqO,MAAMS,MAAKI,GAAQA,EAAK1Q,OAASA,IAKtDwB,EAAKqO,MAAMxF,SAAQqG,IACX1Q,IAAS0Q,EAAK1Q,MACdf,EAAG6Y,QAAQuB,EAAaC,EAAWtZ,EAAKwF,OAAO,IACxCkL,EAAKhK,SACL2J,QAMfpR,EAAG6Y,QAAQuB,EAAaC,EAAWtZ,EAAKwF,OAAO6K,UAMnE,OAAO,KAaX,IAAIkJ,GAAyB7P,OAAO6D,OAAO,CACzCC,UAAW,KACXsL,QAPc,CAACxR,EAAKmC,IAAU,EAAGxK,GAAAA,MAC/BA,EAAG6Z,QAAQxR,EAAKmC,IACT,KA8BX,IAAI+P,GAAyB9P,OAAO6D,OAAO,CACzCC,UAAW,KACXiM,QAxBc,CAACrK,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,EAAU4a,MAAAA,MACjE,MAAM1Z,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAE3C,OAAK1M,EAAK6B,YAIH6X,IAEF9K,SAAQ,EAAG7H,SAAAA,OACQP,EAAaxG,EAAMqQ,EAAnB7J,CAA+B3H,IAI5CkI,EAASsH,eAEfO,SAAQ,EAAG/P,MAAO8a,KACZnT,EAAaxG,EAAMqQ,EAAnB7J,CAA+BmT,EAAc7a,KAEnD8a,OAfDvO,QAAQC,KAAK,yEACN,MAkCf,IAAIuO,GAAkCnQ,OAAO6D,OAAO,CAClDC,UAAW,KACXsM,iBAduB9H,GAAY,EAAG/S,GAAAA,EAAIH,SAAAA,MACxC,GAAIA,EAAU,CACV,MAAM,IAAE2B,GAAQxB,EACVgT,EAAS,aAAkBxR,GAAKI,KAChCqR,EAAS,WAAgBzR,GAAKG,GAC9BmZ,EAAcjI,GAAOE,EAAUC,EAAQC,GACvCnT,EAAY,YAAqB0B,EAAKsZ,GAC5C9a,EAAG8B,aAAahC,GAEpB,OAAO,KAwBX,IAAIib,GAAkCtQ,OAAO6D,OAAO,CAClDC,UAAW,KACX0K,iBAlBuBlG,GAAY,EAAG/S,GAAAA,EAAIH,SAAAA,MACxC,GAAIA,EAAU,CACV,MAAM,IAAE2B,GAAQxB,GACV,KAAE4B,EAAI,GAAED,GAA2B,iBAAboR,EACtB,CAAEnR,KAAMmR,EAAUpR,GAAIoR,GACtBA,EACAC,EAAS,EACTC,EAASjT,EAAGwB,IAAIJ,QAAQC,KACxB6R,EAAeL,GAAOjR,EAAMoR,EAAQC,GACpCE,EAAcN,GAAOlR,EAAIqR,EAAQC,GACjCnT,EAAY,YAAqB0B,EAAK0R,EAAcC,GAC1DnT,EAAG8B,aAAahC,GAEpB,OAAO,KAaX,IAAIkb,GAA8BvQ,OAAO6D,OAAO,CAC9CC,UAAW,KACX0M,aAPmB9K,GAAc,EAAGvQ,MAAAA,EAAOC,SAAAA,MACzC,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAC3C,OD39BkB5D,EC29BI9I,ED19BjB,SAASnB,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAK,SAAUrC,GAAQ,OAAOA,EAAKM,YAAcN,EAAKG,WAAW3B,MAAQ8I,KACtG,IAAKpJ,EAAS,OAAO,EACrB,IAAIuI,EAAavI,EAAMuI,WACvB,GAAkB,GAAdA,EAAmB,OAAO,EAC9B,IAAI7H,EAASV,EAAMU,OAAQL,EAAaK,EAAOuI,MAAMV,EAAa,GAClE,GAAIlI,EAAWC,MAAQ8I,EAAY,OAAO,EAE1C,GAAIhK,EAAU,CACZ,IAAIqb,EAAepa,EAAW6B,WAAa7B,EAAW6B,UAAU5B,MAAQI,EAAOJ,KAC3Eoa,EAAQ,UAAcD,EAAerR,EAAStD,SAAW,MACzD7E,EAAQ,IAAI,KAAM,UAAcmI,EAAStD,OAAO,KAAM,UAAcpF,EAAOJ,KAAKwF,OAAO,KAAM4U,MAC3ED,EAAe,EAAI,EAAG,GACxCra,EAASJ,EAAM2G,MAAO3F,EAAQhB,EAAMuE,IACxCnF,EAASD,EAAMI,GAAG6B,KAAK,IAAI,KAAkBhB,GAAUqa,EAAe,EAAI,GAAIzZ,EACjCZ,EAAQY,EAAOC,EAAO,GAAG,IAC5DzB,kBAEZ,OAAO,ICq8BqBL,EAAOC,GD39BvC,IAAsBgK,KCm+BtB,SAASuR,GAAsBC,EAAqBC,EAAUlK,GAC1D,OAAO3G,OAAOiD,YAAYjD,OACrBkD,QAAQyD,GACRvD,QAAO,EAAE3B,MACV,MAAMqP,EAAqBF,EAAoBhK,MAAKnH,GACzCA,EAAKnJ,OAASua,GAAYpR,EAAKgC,OAASA,IAEnD,QAAKqP,GAGEA,EAAmBC,UAAUC,gBAa5C,SAASC,GAAY9b,EAAO+b,GACxB,MAAM/K,EAAQhR,EAAM8T,aACZ9T,EAAME,UAAU8E,IAAItE,cAAgBV,EAAME,UAAU6E,MAAMiM,QAClE,GAAIA,EAAO,CACP,MAAMgL,EAAgBhL,EAAM/C,QAAO4D,GAAQkK,MAAAA,OAAyD,EAASA,EAAgBjJ,SAASjB,EAAK1Q,KAAKmL,QAChJtM,EAAMI,GAAG0b,YAAYE,IAsE7B,IAAIC,GAA4BpR,OAAO6D,OAAO,CAC5CC,UAAW,KACXrJ,WArEiB,EAAG4W,UAAAA,GAAY,GAAS,KAAO,EAAG9b,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAUqO,OAAAA,MACtE,MAAM,UAAEpO,EAAS,IAAE0B,GAAQxB,GACrB,MAAE2E,EAAK,IAAEC,GAAQ9E,EAEjBic,EAAgBX,GADMlN,EAAO8N,iBAAiB5K,WACazM,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OACtG,GAAI3H,aAAqB,MAAiBA,EAAUyC,KAAK4C,QACrD,SAAKR,EAAMrE,gBAAiB,QAASkB,EAAKmD,EAAMzC,QAG5CrC,IACIic,GACAJ,GAAY9b,EAAOsO,EAAO8N,iBAAiBL,iBAE/C3b,EAAGiF,MAAMN,EAAMzC,KAAKjC,mBAEjB,GAEX,IAAK0E,EAAMxD,OAAOgE,QACd,OAAO,EAEX,GAAItF,EAAU,CACV,MAAMuF,EAAQR,EAAItE,eAAiBsE,EAAIzD,OAAOC,QAAQC,KAClDvB,aAAqB,MACrBE,EAAGL,kBAEP,MAAM0F,EAAwB,IAAhBV,EAAMtC,WACdyJ,EA3Cd,SAA0BhI,GACtB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,GAAK,EAAG,CACzC,MAAM,KAAEnC,GAAS+C,EAAME,KAAKd,GAC5B,GAAInC,EAAK6B,cAAgB7B,EAAKkD,mBAC1B,OAAOlD,EAGf,OAAO,KAqCGkb,CAAiBtX,EAAMpC,MAAM,GAAG8B,eAAeM,EAAMP,YAAY,KACvE,IAAIkB,EAAQF,GAASC,EACf,CAAC,CACKtE,KAAMsE,EACNoC,MAAOsU,SAEbjQ,EACFvG,GAAM,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GAYzD,GAXKA,GACGC,KACD,QAASvF,EAAGwB,IAAKxB,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGmD,EAAQ,CAAC,CAAEtE,KAAMsE,SAAWyG,KAC9EvG,GAAM,EACND,EAAQD,EACF,CAAC,CACKtE,KAAMsE,EACNoC,MAAOsU,SAEbjQ,GAENvG,IACAvF,EAAGiF,MAAMjF,EAAGgC,QAAQC,IAAI0C,EAAMzC,KAAM,EAAGoD,GACnCD,IACID,IACAT,EAAMrE,cACPqE,EAAMxD,OAAOJ,OAASsE,GAAO,CAChC,MAAMG,EAAQxF,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAC7B4E,EAASzF,EAAGwB,IAAIO,QAAQyD,GAC1Bb,EAAMpC,MAAM,GAAG+B,eAAemB,EAAOtC,QAASsC,EAAOtC,QAAU,EAAGkC,IAClErF,EAAG0F,cAAc1F,EAAGgC,QAAQC,IAAI0C,EAAM9D,UAAWwE,GAIzDyW,GACAJ,GAAY9b,EAAOsO,EAAO8N,iBAAiBL,iBAE/C3b,EAAGC,iBAEP,OAAO,KA2FX,IAAIic,GAA+BzR,OAAO6D,OAAO,CAC/CC,UAAW,KACX4N,cArFoBhM,GAAc,EAAGnQ,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAUqO,OAAAA,MACxD,IAAIf,EACJ,MAAMpM,EAAO+O,EAAYK,EAAYvQ,EAAM6N,SACrC,MAAE9I,EAAK,IAAEC,GAAQhF,EAAME,UAGvByC,EAAO3C,EAAME,UAAUyC,KAC7B,GAAKA,GAAQA,EAAK4C,SAAYR,EAAMtC,MAAQ,IAAMsC,EAAMhB,WAAWiB,GAC/D,OAAO,EAEX,MAAMwX,EAAczX,EAAMpC,MAAM,GAChC,GAAI6Z,EAAYrb,OAASA,EACrB,OAAO,EAEX,MAAMsa,EAAsBnN,EAAO8N,iBAAiB5K,WACpD,GAAkC,IAA9BzM,EAAMxD,OAAOC,QAAQC,MAAcsD,EAAMpC,MAAM,GAAGM,aAAe8B,EAAMP,YAAY,GAAI,CAIvF,GAAoB,IAAhBO,EAAMtC,OACHsC,EAAMpC,MAAM,GAAGxB,OAASA,GACxB4D,EAAMxB,OAAO,KAAOwB,EAAMpC,MAAM,GAAGM,WAAa,EACnD,OAAO,EAEX,GAAIhD,EAAU,CACV,IAAIwG,EAAO,WAEX,MAAMgW,EAAc1X,EAAMxB,OAAO,GAC3B,EACAwB,EAAMxB,OAAO,GACT,EACA,EAGV,IAAK,IAAImZ,EAAI3X,EAAMtC,MAAQga,EAAaC,GAAK3X,EAAMtC,MAAQ,EAAGia,GAAK,EAC/DjW,EAAO,UAAc1B,EAAMpC,KAAK+Z,GAAG9V,KAAKH,IAG5C,MAAMkW,EAAa5X,EAAMP,YAAY,GAAKO,EAAMpC,MAAM,GAAGM,WACnD,EACA8B,EAAMP,YAAY,GAAKO,EAAMpC,MAAM,GAAGM,WAClC,EACA,EAEJ2Z,EAAwBpB,GAAsBC,EAAqB1W,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OACxGgV,GAAqD,QAAxCtP,EAAKpM,EAAK2b,aAAajN,mBAAgC,IAAPtC,OAAgB,EAASA,EAAG3I,cAAcgY,UAA2B1Q,EACxIzF,EAAOA,EAAKgE,OAAO,UAActJ,EAAKyD,cAAc,KAAMiY,SAAa3Q,IACvE,MAAM1E,EAAQzC,EAAM9D,OAAO8D,EAAMtC,OAASga,EAAc,IACxDrc,EAAG2c,QAAQvV,EAAOzC,EAAMlD,OAAO8a,GAAa,IAAI,KAAMlW,EAAM,EAAIgW,EAAa,IAC7E,IAAI3X,GAAO,EACX1E,EAAGwB,IAAImG,aAAaP,EAAOpH,EAAGwB,IAAIJ,QAAQC,MAAM,CAACub,EAAG1a,KAChD,GAAIwC,GAAO,EACP,OAAO,EAEPkY,EAAEha,aAAkC,IAAnBga,EAAExb,QAAQC,OAC3BqD,EAAMxC,EAAM,MAGhBwC,GAAO,GACP1E,EAAG8B,aAAa,UAAmB9B,EAAGwB,IAAIO,QAAQ2C,KAEtD1E,EAAGC,iBAEP,OAAO,EAEX,MAAMwc,EAAW7X,EAAI1C,MAAQyC,EAAMK,MAC7BoX,EAAY/X,eAAe,GAAGoL,YAC9B,KACAoN,EAAoBzB,GAAsBC,EAAqBe,EAAYrb,KAAKmL,KAAMkQ,EAAY3U,OAClG+U,EAAwBpB,GAAsBC,EAAqB1W,EAAMpC,OAAOxB,KAAKmL,KAAMvH,EAAMpC,OAAOkF,OAC9GzH,EAAGsC,OAAOqC,EAAMzC,IAAK0C,EAAI1C,KACzB,MAAMoD,EAAQmX,EACR,CAAC,CAAE1b,KAAAA,EAAM0G,MAAOoV,GAAqB,CAAE9b,KAAM0b,EAAUhV,MAAO+U,IAC9D,CAAC,CAAEzb,KAAAA,EAAM0G,MAAOoV,IACtB,SAAK,QAAS7c,EAAGwB,IAAKmD,EAAMzC,IAAK,KAG7BrC,GACAG,EAAGiF,MAAMN,EAAMzC,IAAK,EAAGoD,GAAOrF,kBAE3B,MAQX,SAAS6c,GAA2B7Z,EAAM8Z,GACtC,IAAK,IAAI7Z,EAAID,EAAKZ,MAAOa,EAAI,EAAGA,GAAK,EAAG,CACpC,MAAMX,EAAOU,EAAKV,KAAKW,GACvB,GAAI6Z,EAAUxa,GACV,MAAO,CACHL,IAAKgB,EAAI,EAAID,EAAKpC,OAAOqC,GAAK,EAC9BkE,MAAOnE,EAAKmE,MAAMlE,GAClBb,MAAOa,EACPX,KAAAA,IAMhB,SAASya,GAAeD,GACpB,OAAQjd,GAAcgd,GAA2Bhd,EAAU6E,MAAOoY,GAGtE,SAASE,GAAgBC,GAIrB,MAAO,CACHC,eAJmBD,EAAWrP,QAAOjC,GAAgC,cAAnBA,EAAU7K,OAK5Dqc,eAJmBF,EAAWrP,QAAOjC,GAAgC,SAAnBA,EAAU7K,OAK5Dsc,eAJmBH,EAAWrP,QAAOjC,GAAgC,SAAnBA,EAAU7K,QAQpE,SAASuc,GAAOpR,EAAMgR,GAClB,MAAM,eAAEE,GAAmBH,GAAgBC,GACrCtR,EAAYwR,EAAe/L,MAAKnH,GAAQA,EAAKgC,OAASA,IAC5D,IAAKN,EACD,OAAO,EAEX,MAKM2R,EAAQhS,EAAaI,EAAkBC,EAAW,QALxC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,WAGvB,MAAqB,iBAAV+Q,GAGJA,EAAMtY,MAAM,KAAKyN,SAAS,QAGrC,MAAM8K,GAAoB,CAACxd,EAAI6I,KAC3B,MAAMmB,EAAOgT,IAAeza,GAAQA,EAAKxB,OAAS8H,GAArCmU,CAA+Chd,EAAGF,WAC/D,IAAKkK,EACD,OAAO,EAEX,MAAMnJ,EAASb,EAAGwB,IAAIO,QAAQuL,KAAKC,IAAI,EAAGvD,EAAK9H,IAAM,IAAIrB,OAAOmJ,EAAK3H,OACrE,QAAeyJ,IAAXjL,EACA,OAAO,EAEX,MAAMC,EAAad,EAAGwB,IAAIic,OAAO5c,GAGjC,OAFyBmJ,EAAKzH,KAAKxB,QAAUD,MAAAA,OAA+C,EAASA,EAAWC,SACzG,QAAQf,EAAGwB,IAAKwI,EAAK9H,OAI5BlC,EAAG+F,KAAKiE,EAAK9H,MACN,IAELwb,GAAmB,CAAC1d,EAAI6I,KAC1B,MAAMmB,EAAOgT,IAAeza,GAAQA,EAAKxB,OAAS8H,GAArCmU,CAA+Chd,EAAGF,WAC/D,IAAKkK,EACD,OAAO,EAEX,MAAMvI,EAAQzB,EAAGwB,IAAIO,QAAQiI,EAAK5C,OAAO3F,MAAMuI,EAAK3H,OACpD,QAAcyJ,IAAVrK,EACA,OAAO,EAEX,MAAM6B,EAAYtD,EAAGwB,IAAIic,OAAOhc,GAGhC,OAFwBuI,EAAKzH,KAAKxB,QAAUuC,MAAAA,OAA6C,EAASA,EAAUvC,SACrG,QAAQf,EAAGwB,IAAKC,KAIvBzB,EAAG+F,KAAKtE,IACD,IA+CX,IAAIkc,GAA4BlT,OAAO6D,OAAO,CAC5CC,UAAW,KACXqP,WA/CiB,CAACC,EAAgBC,IAAmB,EAAG5P,OAAAA,EAAQlO,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,EAAU4a,MAAAA,EAAO3S,SAAAA,EAAUvC,IAAAA,MACpG,MAAM,WAAE2X,GAAehP,EAAO8N,iBACxBnT,EAAWiH,EAAY+N,EAAgBje,EAAM6N,QAC7C5D,EAAWiG,EAAYgO,EAAgBle,EAAM6N,SAC7C,UAAE3N,GAAcF,GAChB,MAAE+E,EAAK,IAAEC,GAAQ9E,EACjBW,EAAQkE,EAAMjE,WAAWkE,GAC/B,IAAKnE,EACD,OAAO,EAEX,MAAMsd,EAAaf,IAAeza,GAAQ+a,GAAO/a,EAAKxB,KAAKmL,KAAMgR,IAA9CF,CAA2Dld,GAC9E,GAAIW,EAAM4B,OAAS,GAAK0b,GAActd,EAAM4B,MAAQ0b,EAAW1b,OAAS,EAAG,CAEvE,GAAI0b,EAAWxb,KAAKxB,OAAS8H,EACzB,OAAOf,EAAS8B,aAAaC,GAGjC,GAAIyT,GAAOS,EAAWxb,KAAKxB,KAAKmL,KAAMgR,IAC/BrU,EAASmV,aAAaD,EAAWxb,KAAKnB,UACtCvB,EACH,OAAO4a,IACF9K,SAAQ,KACT3P,EAAG0F,cAAcqY,EAAW7b,IAAK2G,IAC1B,KAEN8G,SAAQ,IAAM6N,GAAkBxd,EAAI6I,KACpC8G,SAAQ,IAAM+N,GAAiB1d,EAAI6I,KACnC8R,MAGb,OAAOF,IAEF9K,SAAQ,MACapK,IAAMqD,WAAWC,IAIhCf,EAASsH,eAEfxG,WAAWC,GACX8G,SAAQ,IAAM6N,GAAkBxd,EAAI6I,KACpC8G,SAAQ,IAAM+N,GAAiB1d,EAAI6I,KACnC8R,SAQT,SAASsD,GAAare,EAAOuQ,EAAYiB,EAAa,IAClD,MAAM,MAAErR,EAAK,OAAEoO,GAAWvO,EAAME,UAC1BiB,EAAOoP,EACPQ,GAAYR,EAAYvQ,EAAM6N,QAC9B,KACN,GAAI1N,EACA,SAAUH,EAAM8T,aAAe9T,EAAME,UAAU6E,MAAMiM,SAChD/C,QAAO4D,IACH1Q,GAGEA,EAAKmL,OAASuF,EAAK1Q,KAAKmL,OAE9BmF,MAAKI,GAAQX,GAAeW,EAAKhK,MAAO2J,EAAY,CAAEH,QAAQ,MAEvE,IAAI0G,EAAiB,EACrB,MAAMuG,EAAa,GAmBnB,GAlBA/P,EAAO/C,SAAQ,EAAGzG,MAAAA,EAAOC,IAAAA,MACrB,MAAMhD,EAAO+C,EAAMzC,IACbP,EAAKiD,EAAI1C,IACftC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,IAAKK,EAAK8K,SAAW9K,EAAKqO,MAAMtK,OAC5B,OAEJ,MAAMmR,EAAenK,KAAKC,IAAI3L,EAAMM,GAC9BwV,EAAapK,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKJ,UAE3CwV,GADcD,EAAaD,EAE3ByG,EAAWrX,QAAQtE,EAAKqO,MAAM3O,KAAIwP,IAAQ,CACtCA,KAAAA,EACA7P,KAAM6V,EACN9V,GAAI+V,aAIO,IAAnBC,EACA,OAAO,EAGX,MAAMwG,EAAeD,EAChBrQ,QAAOuQ,IACHrd,GAGEA,EAAKmL,OAASkS,EAAU3M,KAAK1Q,KAAKmL,OAExC2B,QAAOuQ,GAAatN,GAAesN,EAAU3M,KAAKhK,MAAO2J,EAAY,CAAEH,QAAQ,MAC/E4G,QAAO,CAACC,EAAKsG,IAActG,EAAMsG,EAAUzc,GAAKyc,EAAUxc,MAAM,GAG/Dyc,EAAgBH,EACjBrQ,QAAOuQ,IACHrd,GAGEqd,EAAU3M,KAAK1Q,OAASA,GACxBqd,EAAU3M,KAAK1Q,KAAKud,SAASvd,KAEnC8W,QAAO,CAACC,EAAKsG,IAActG,EAAMsG,EAAUzc,GAAKyc,EAAUxc,MAAM,GAMrE,OAHcuc,EAAe,EACvBA,EAAeE,EACfF,IACUxG,EAapB,IAAI4G,GAA4B9T,OAAO6D,OAAO,CAC5CC,UAAW,KACXiQ,WAZiB,CAACrO,EAAYiB,EAAa,GAAI9E,EAAU,KAAO,EAAG1M,MAAAA,EAAOkI,SAAAA,MACxE,MAAM,qBAAE2W,GAAuB,GAAUnS,EACnCvL,EAAO4P,GAAYR,EAAYvQ,EAAM6N,QAE3C,OADiBwQ,GAAare,EAAOmB,EAAMqQ,GAEhCtJ,EAAS4W,UAAU3d,EAAM,CAAE0d,qBAAAA,IAE/B3W,EAASmS,QAAQlZ,EAAMqQ,MAkBlC,IAAIuN,GAA4BlU,OAAO6D,OAAO,CAC5CC,UAAW,KACXqQ,WAZiB,CAACzO,EAAY0O,EAAkBzN,EAAa,KAAO,EAAGxR,MAAAA,EAAOkI,SAAAA,MAC5E,MAAM/G,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QACrCqR,EAAahP,EAAY+O,EAAkBjf,EAAM6N,QAEvD,OADiB8J,GAAa3X,EAAOmB,EAAMqQ,GAEhCtJ,EAAS0S,QAAQsE,GAErBhX,EAAS0S,QAAQzZ,EAAMqQ,MAiBlC,IAAI2N,GAA4BtU,OAAO6D,OAAO,CAC5CC,UAAW,KACXyQ,WAXiB,CAAC7O,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOkI,SAAAA,MAC1D,MAAM/G,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAE3C,OADiB8J,GAAa3X,EAAOmB,EAAMqQ,GAEhCtJ,EAASlH,KAAKG,GAElB+G,EAASmX,OAAOle,EAAMqQ,MAoCjC,IAAI8N,GAA+BzU,OAAO6D,OAAO,CAC/CC,UAAW,KACX4Q,cA9BoB,IAAM,EAAGvf,MAAAA,EAAOC,SAAAA,MAClC,MAAMuf,EAAUxf,EAAMwf,QACtB,IAAK,IAAIlc,EAAI,EAAGA,EAAIkc,EAAQ9Y,OAAQpD,GAAK,EAAG,CACxC,MAAMmc,EAASD,EAAQlc,GACvB,IAAIoc,EAGJ,GAAID,EAAOre,KAAKue,eAAiBD,EAAWD,EAAOG,SAAS5f,IAAS,CACjE,GAAIC,EAAU,CACV,MAAMG,EAAKJ,EAAMI,GACXyf,EAASH,EAASI,UACxB,IAAK,IAAIC,EAAIF,EAAOnK,MAAMhP,OAAS,EAAGqZ,GAAK,EAAGA,GAAK,EAC/C3f,EAAG6B,KAAK4d,EAAOnK,MAAMqK,GAAGC,OAAOH,EAAOI,KAAKF,KAE/C,GAAIL,EAASrS,KAAM,CACf,MAAM2D,EAAQ5Q,EAAGwB,IAAIO,QAAQud,EAAS1d,MAAMgP,QAC5C5Q,EAAGuE,YAAY+a,EAAS1d,KAAM0d,EAAS3d,GAAI/B,EAAM6N,OAAOR,KAAKqS,EAASrS,KAAM2D,SAG5E5Q,EAAGsC,OAAOgd,EAAS1d,KAAM0d,EAAS3d,IAG1C,OAAO,GAGf,OAAO,KAsBX,IAAIme,GAA+BrV,OAAO6D,OAAO,CAC/CC,UAAW,KACXwR,cAhBoB,IAAM,EAAG/f,GAAAA,EAAIH,SAAAA,MAC/B,MAAM,UAAEC,GAAcE,GAChB,MAAED,EAAK,OAAEoO,GAAWrO,EAC1B,OAAIC,GAGAF,GACAsO,EAAO/C,SAAQ3K,IACXT,EAAGggB,WAAWvf,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,SAJtC,KA2Cf,IAAI+d,GAA2BxV,OAAO6D,OAAO,CAC3CC,UAAW,KACXmQ,UA9BgB,CAACvO,EAAY7D,EAAU,KAAO,EAAGtM,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MAC1D,IAAIsN,EACJ,MAAM,qBAAEsR,GAAuB,GAAUnS,GACnC,UAAExM,GAAcE,EAChBe,EAAO4P,GAAYR,EAAYvQ,EAAM6N,SACrC,MAAE9I,EAAK,MAAE5E,EAAK,OAAEoO,GAAWrO,EACjC,IAAKD,EACD,OAAO,EAEX,GAAIE,GAAS0e,EAAsB,CAC/B,IAAI,KAAE7c,EAAI,GAAED,GAAO7B,EACnB,MAAM2H,EAAkE,QAAzD0F,EAAKxI,EAAMiM,QAAQS,MAAKI,GAAQA,EAAK1Q,OAASA,WAA0B,IAAPoM,OAAgB,EAASA,EAAG1F,MACtGhH,EAAQ8Q,GAAa5M,EAAO5D,EAAM0G,GACpChH,IACAmB,EAAOnB,EAAMmB,KACbD,EAAKlB,EAAMkB,IAEf3B,EAAGggB,WAAWpe,EAAMD,EAAIZ,QAGxBoN,EAAO/C,SAAQ3K,IACXT,EAAGggB,WAAWvf,EAAMkE,MAAMzC,IAAKzB,EAAMmE,IAAI1C,IAAKnB,MAItD,OADAf,EAAGkgB,iBAAiBnf,IACb,KAoDX,IAAIof,GAAkC1V,OAAO6D,OAAO,CAClDC,UAAW,KACX6R,iBA9CuB,CAACjQ,EAAYiB,EAAa,KAAO,EAAGpR,GAAAA,EAAIJ,MAAAA,EAAOC,SAAAA,MACpE,IAAI2H,EAAW,KACXmR,EAAW,KACf,MAAMC,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,QAAKmL,IAGc,SAAfA,IACApR,EAAWsI,EAAYK,EAAYvQ,EAAM6N,SAE1B,SAAfmL,IACAD,EAAWhI,GAAYR,EAAYvQ,EAAM6N,SAEzC5N,GACAG,EAAGF,UAAUqO,OAAO/C,SAAQ3K,IACxB,MAAMmB,EAAOnB,EAAMkE,MAAMzC,IACnBP,EAAKlB,EAAMmE,IAAI1C,IACrBtC,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KAChCsF,GAAYA,IAAajF,EAAKxB,MAC9Bf,EAAG0F,cAAcxD,OAAK4J,EAAW,IAC1BvJ,EAAKkF,SACL2J,IAGPuH,GAAYpW,EAAKqO,MAAMtK,QACvB/D,EAAKqO,MAAMxF,SAAQqG,IACf,GAAIkH,IAAalH,EAAK1Q,KAAM,CACxB,MAAMqZ,EAAc9M,KAAKC,IAAIrL,EAAKN,GAC5ByY,EAAY/M,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAChD3B,EAAG6Y,QAAQuB,EAAaC,EAAW1B,EAASpS,OAAO,IAC5CkL,EAAKhK,SACL2J,gBAQxB,MAaX,IAAIiP,GAAwB5V,OAAO6D,OAAO,CACxCC,UAAW,KACX0Q,OAPa,CAAC9O,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,MACtD,MAAMkB,EAAO+O,EAAYK,EAAYvQ,EAAM6N,QAC3C,OFnxCYjG,EEmxCIzG,EFnxCM0G,EEmxCA2J,EFlxCjB,SAASxR,EAAOC,GACrB,IAAIkD,EAAMnD,EAAME,UACZ6E,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACVnE,EAAQkE,EAAMjE,WAAWkE,GAAM0b,EAAW7f,IAAS,QAAaA,EAAO+G,EAAUC,GACrF,QAAK6Y,IACDzgB,GAAYA,EAASD,EAAMI,GAAGqG,KAAK5F,EAAO6f,GAAUrgB,mBACjD,KE2wC2BL,EAAOC,GFnxC7C,IAAgB2H,EAAUC,KEgyC1B,IAAI8Y,GAA4B9V,OAAO6D,OAAO,CAC5CC,UAAW,KACX3F,WAPiB,CAACuH,EAAYiB,EAAa,KAAO,EAAGxR,MAAAA,EAAOC,SAAAA,KAEnD+I,EADMkH,EAAYK,EAAYvQ,EAAM6N,QACjB2D,EAAnBxI,CAA+BhJ,EAAOC,KAQjD,MAAM2gB,GAAWxU,EAAUzF,OAAO,CAC9B2F,KAAM,WACNuU,YAAW,KACA,IACApS,KACAU,KACAI,KACAO,KACAG,KACAI,KACAG,KACAE,KACAC,KACAG,MACAoB,MACAG,MACAmB,MACAQ,MACAC,MACAe,MACAiB,MACAC,MACAE,MACA+B,MACAC,MACAC,MACAC,MACAO,MACAK,MACAC,MACAG,MACAC,MACAC,MACAI,MACAC,MACAE,MACAK,MACAM,MACAC,MACAK,MACAG,MACAC,MACAa,MACAK,MACAyB,MACAY,MACAI,MACAI,MACAG,MACAY,MACAG,MACAE,MACAE,MACAE,OAKTG,GAAW1U,EAAUzF,OAAO,CAC9B2F,KAAM,WACN8B,wBACI,MAAO,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,YACnBoD,MAAO,CACHkV,SAAU,IAAM1U,KAAKiC,OAAO5B,QAAQqU,gBAOlDC,GAAc5U,EAAUzF,OAAO,CACjC2F,KAAM,cACN8B,wBACI,MAAM,OAAEE,GAAWjC,KACnB,MAAO,CACH,IAAI,KAAO,CACP5D,IAAK,IAAI,KAAU,eACnBoD,MAAO,CACHoV,gBAAiB,CACbxN,MAAO,CAAClT,EAAMsW,KACVvI,EAAO4S,WAAY,EACnB,MAAMC,EAAc7S,EAAOtO,MAAMI,GAC5B6Z,QAAQ,QAAS,CAAEpD,MAAAA,IACnBoD,QAAQ,gBAAgB,GAE7B,OADA1Z,EAAKN,SAASkhB,IACP,GAEXvS,KAAM,CAACrO,EAAMsW,KACTvI,EAAO4S,WAAY,EACnB,MAAMC,EAAc7S,EAAOtO,MAAMI,GAC5B6Z,QAAQ,OAAQ,CAAEpD,MAAAA,IAClBoD,QAAQ,gBAAgB,GAE7B,OADA1Z,EAAKN,SAASkhB,IACP,WASnC,SAASC,GAAqBjV,GAC1B,MAAM,MAAEnM,EAAK,YAAEmhB,GAAgBhV,EAC/B,IAAI,UAAEjM,GAAcihB,GAChB,IAAEvf,GAAQuf,GACV,YAAErN,GAAgBqN,EACtB,MAAO,IACAnhB,EACH6N,OAAQ7N,EAAM6N,OACd2R,QAASxf,EAAMwf,QACf6B,MAAOrhB,EAAMqhB,MAAMvV,KAAK9L,GACxBshB,iBAAkBthB,EAAMshB,iBAAiBxV,KAAK9L,GAC9CuhB,YAAavhB,EAAMuhB,YAAYzV,KAAK9L,GACpCwhB,OAAQxhB,EAAMwhB,OAAO1V,KAAK9L,GACtB8T,kBACA,OAAOA,GAEP5T,gBACA,OAAOA,GAEP0B,UACA,OAAOA,GAEPxB,SAIA,OAHAF,EAAYihB,EAAYjhB,UACxB0B,EAAMuf,EAAYvf,IAClBkS,EAAcqN,EAAYrN,YACnBqN,IAKnB,MAAMM,GACFvW,YAAYW,GACRQ,KAAKiC,OAASzC,EAAMyC,OACpBjC,KAAKqV,YAAcrV,KAAKiC,OAAO8N,iBAAiBlU,SAChDmE,KAAKsV,YAAc9V,EAAM7L,MAEzB4hB,qBACA,QAASvV,KAAKsV,YAEd3hB,YACA,OAAOqM,KAAKsV,aAAetV,KAAKiC,OAAOtO,MAEvCkI,eACA,MAAM,YAAEwZ,EAAW,OAAEpT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,GACX,GAAElO,GAAOJ,EACT6L,EAAQQ,KAAKwV,WAAWzhB,GAC9B,OAAOyK,OAAOiD,YAAYjD,OACrBkD,QAAQ2T,GACRrf,KAAI,EAAEiK,EAAMyD,KAQN,CAACzD,EAPO,IAAIwV,KACf,MAAMC,EAAWhS,KAAW+R,EAAX/R,CAAiBlE,GAIlC,OAHKzL,EAAG4hB,QAAQ,oBAAuB3V,KAAKuV,gBACxCrhB,EAAKN,SAASG,GAEX2hB,OAKflH,YACA,MAAO,IAAMxO,KAAK4V,cAElBtc,UACA,MAAO,IAAM0G,KAAK6V,YAEtBD,YAAYE,EAASC,GAAiB,GAClC,MAAM,YAAEV,EAAW,OAAEpT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,EACX+T,EAAY,GACZC,IAAwBH,EACxB/hB,EAAK+hB,GAAWniB,EAAMI,GAUtBya,EAAQ,IACPhQ,OAAOiD,YAAYjD,OAAOkD,QAAQ2T,GAAarf,KAAI,EAAEiK,EAAMyD,KAOnD,CAACzD,EANe,IAAIwV,KACvB,MAAMjW,EAAQQ,KAAKwV,WAAWzhB,EAAIgiB,GAC5BL,EAAWhS,KAAW+R,EAAX/R,CAAiBlE,GAElC,OADAwW,EAAUpb,KAAK8a,GACRlH,OAIfE,IAnBQ,KACHuH,IACEF,GACChiB,EAAG4hB,QAAQ,oBACX3V,KAAKuV,gBACTrhB,EAAKN,SAASG,GAEXiiB,EAAU/Q,OAAMyQ,IAAyB,IAAbA,MAcvC,OAAOlH,EAEXqH,UAAUC,GACN,MAAM,YAAET,EAAW,MAAE1hB,GAAUqM,KACzBpM,OAAWiM,EACX9L,EAAK+hB,GAAWniB,EAAMI,GACtByL,EAAQQ,KAAKwV,WAAWzhB,EAAIH,GAC5BsiB,EAAoB1X,OAAOiD,YAAYjD,OACxCkD,QAAQ2T,GACRrf,KAAI,EAAEiK,EAAMyD,KACN,CAACzD,EAAM,IAAIwV,IAAS/R,KAAW+R,EAAX/R,CAAiB,IAAKlE,EAAO5L,SAAAA,QAE5D,MAAO,IACAsiB,EACH1H,MAAO,IAAMxO,KAAK4V,YAAY7hB,EAAIH,IAG1C4hB,WAAWzhB,EAAIgiB,GAAiB,GAC5B,MAAM,YAAEV,EAAW,OAAEpT,EAAM,MAAEtO,GAAUqM,MACjC,KAAE9L,GAAS+N,EACbtO,EAAM8T,aACN1T,EAAG2T,eAAe/T,EAAM8T,aAE5B,MAAMjI,EAAQ,CACVzL,GAAAA,EACAkO,OAAAA,EACA/N,KAAAA,EACAP,MAAOohB,GAAqB,CACxBphB,MAAAA,EACAmhB,YAAa/gB,IAEjBH,SAAUmiB,EACJ,YACAlW,EACN2O,MAAO,IAAMxO,KAAK4V,YAAY7hB,GAC9BuF,IAAK,IAAM0G,KAAK6V,UAAU9hB,GACtB8H,eACA,OAAO2C,OAAOiD,YAAYjD,OACrBkD,QAAQ2T,GACRrf,KAAI,EAAEiK,EAAMyD,KACN,CAACzD,EAAM,IAAIwV,IAAS/R,KAAW+R,EAAX/R,CAAiBlE,SAIxD,OAAOA,GAIf,MAAM2W,GAASpW,EAAUzF,OAAO,CAC5B2F,KAAM,SACNmW,uBACI,MAAMC,EAAkB,IAAMrW,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACvE,IAAMA,EAASqX,gBAEf,IAAMrX,EAAS6H,SAAQ,EAAG3P,GAAAA,MACtB,MAAM,UAAEF,EAAS,IAAE0B,GAAQxB,GACrB,MAAED,EAAK,QAAE0D,GAAY3D,GACrB,IAAEoC,EAAG,OAAEf,GAAWsC,EAClB8e,EAAY,aAAkB/gB,GAAKI,OAASM,EAClD,UAAKnC,GACGwiB,GACAphB,EAAOJ,KAAK6B,cACbzB,EAAOqhB,YAAYlc,SAGnBwB,EAASsH,gBAEpB,IAAMtH,EAASnI,kBACf,IAAMmI,EAAS5H,eACf,IAAM4H,EAAShF,wBAEb2f,EAAe,IAAMxW,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACpE,IAAMA,EAASnI,kBACf,IAAMmI,EAAS1E,cACf,IAAM0E,EAASvE,uBAQbmf,EAAa,CACfC,MAPgB,IAAM1W,KAAKiC,OAAOpG,SAAStC,OAAM,EAAGsC,SAAAA,KAAe,CACnE,IAAMA,EAAStE,gBACf,IAAMsE,EAASrD,sBACf,IAAMqD,EAAS/C,iBACf,IAAM+C,EAAS5C,gBAIf,YAAa,IAAM+G,KAAKiC,OAAOpG,SAAS5D,WACxC0e,UAAWN,EACX,gBAAiBA,EACjB,kBAAmBA,EACnBO,OAAQJ,EACR,aAAcA,EACd,QAAS,IAAMxW,KAAKiC,OAAOpG,SAASkR,aAElC8J,EAAW,IACVJ,EACHpa,KAAM,IAAM2D,KAAKiC,OAAOpG,SAAST,uBACjCkB,IAAK,IAAM0D,KAAKiC,OAAOpG,SAASR,sBAE9Byb,EAAY,IACXL,EACH,SAAUJ,EACV,gBAAiBA,EACjB,SAAUG,EACV,qBAAsBA,EACtB,aAAcA,EACd,QAASA,EACT,SAAU,IAAMxW,KAAKiC,OAAOpG,SAAST,uBACrC,SAAU,IAAM4E,KAAKiC,OAAOpG,SAASR,sBAEzC,OAAImL,MAAWsD,KACJgN,EAEJD,GAEX9U,wBACI,MAAO,CAMH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,iBACnB2a,kBAAmB,CAACC,EAAcC,EAAUC,KAGxC,KAFmBF,EAAaG,MAAKrC,GAAeA,EAAYsC,eACxDH,EAAS1hB,IAAIiS,GAAG0P,EAAS3hB,MAE7B,OAEJ,MAAM,MAAEzB,EAAK,KAAE6B,EAAI,GAAED,GAAOuhB,EAASpjB,UAC/BwjB,EAAU,aAAkBJ,EAAS1hB,KAAKI,KAC1C2hB,EAAS,WAAgBL,EAAS1hB,KAAKG,GACvC6hB,EAAiB5hB,IAAS0hB,GAAW3hB,IAAO4hB,EAC5CE,EAAsF,IAA5EN,EAAS3hB,IAAIkiB,YAAY,EAAGP,EAAS3hB,IAAIJ,QAAQC,KAAM,IAAK,KAAKiF,OACjF,GAAIvG,IAAUyjB,IAAmBC,EAC7B,OAEJ,MAAMzjB,EAAKmjB,EAASnjB,GACdJ,EAAQohB,GAAqB,CAC/BphB,MAAOujB,EACPpC,YAAa/gB,KAEX,SAAE8H,GAAa,IAAIuZ,GAAe,CACpCnT,OAAQjC,KAAKiC,OACbtO,MAAAA,IAGJ,OADAkI,EAASsH,aACJpP,EAAGsV,MAAMhP,OAGPtG,OAHP,SAUd2jB,GAAW3X,EAAUzF,OAAO,CAC9B2F,KAAM,WACN8B,sBAAqB,IACV,CACH,IAAI,KAAO,CACP3F,IAAK,IAAI,KAAU,YACnBoD,MAAO,CACH2F,WAAY,CACRwS,SAAU,WAQlC,IAAI1G,GAA0BzS,OAAO6D,OAAO,CAC1CC,UAAW,KACXR,wBAAyBA,EACzByS,SAAUA,GACVE,SAAUA,GACVE,YAAaA,GACbwB,OAAQA,GACRuB,SAAUA,KAGZ,SAASE,GAAkBjkB,EAAOuQ,GAC9B,MAAMpP,EAAO+O,EAAYK,EAAYvQ,EAAM6N,SACrC,KAAE7L,EAAI,GAAED,GAAO/B,EAAME,UACrB8N,EAAQ,GACdhO,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAIY,IAC7BqL,EAAM/G,KAAKtE,MAEf,MAAMA,EAAOqL,EACRkW,UACAzS,MAAK0S,GAAYA,EAAShjB,KAAKmL,OAASnL,EAAKmL,OAClD,OAAK3J,EAGE,IAAKA,EAAKkF,OAFN,GAKf,SAASuc,GAAcpkB,EAAOuQ,GAC1B,MAAMyI,EAAaT,GAA8C,iBAAfhI,EAC5CA,EACAA,EAAWjE,KAAMtM,EAAM6N,QAC7B,MAAmB,SAAfmL,EACOiL,GAAkBjkB,EAAOuQ,GAEjB,SAAfyI,EACOkB,GAAkBla,EAAOuQ,GAE7B,GAGX,SAAS8T,GAASrkB,EAAOsM,EAAMkF,EAAa,IACxC,IAAKlF,EACD,OAAOqL,GAAa3X,EAAO,KAAMwR,IAAe6M,GAAare,EAAO,KAAMwR,GAE9E,MAAMwH,EAAaT,GAAwBjM,EAAMtM,EAAM6N,QACvD,MAAmB,SAAfmL,EACOrB,GAAa3X,EAAOsM,EAAMkF,GAElB,SAAfwH,GACOqF,GAAare,EAAOsM,EAAMkF,GAKzC,SAAS8S,GAAoBC,EAAU1W,GACnC,MAAM2W,EAAmB,gBACT3W,GACX4W,kBAAkBF,GAEjBG,EADoB1R,SAAS2R,eAAeC,qBACdC,cAAc,OAElD,OADAH,EAAUI,YAAYN,GACfE,EAAUK,UAGrB,SAASC,GAAQriB,EAAM+J,GAKnB,OAAOO,EAAetK,EAJR,CACVX,KAAM,EACND,GAAIY,EAAKnB,QAAQC,MAEciL,GAGvC,SAASuY,GAAYtiB,GACjB,IAAI4K,EACJ,MAAM2X,EAAsD,QAApC3X,EAAK5K,EAAKxB,KAAKyD,uBAAoC,IAAP2I,OAAgB,EAASA,EAAGiU,SAC1FhgB,EAAUmB,EAAK6e,SACrB,OAAO2D,KAAKC,UAAUF,KAAoBC,KAAKC,UAAU5jB,GAe7D,MAAM6jB,GACFna,YAAYiB,GACRE,KAAKoF,KAAOtF,EAAOsF,KACnBpF,KAAKiZ,QAAUnZ,EAAOmZ,SAwB9B,SAASC,GAAMpZ,GACX,IAAIoB,EACJ,MAAM,OAAEe,EAAM,KAAEtM,EAAI,GAAED,EAAE,KAAEsL,EAAI,MAAEmY,EAAK,OAAE/F,GAAYtT,GAC7C,KAAE5L,GAAS+N,EACjB,GAAI/N,EAAKklB,UACL,OAAO,EAEX,MAAM1gB,EAAQxE,EAAKP,MAAM4B,IAAIO,QAAQH,GACrC,GAEA+C,EAAMxD,OAAOJ,KAAKC,KAAK0C,OAEoC,QAAhDyJ,EAAMxI,EAAM7D,YAAc6D,EAAMrB,iBAA+B,IAAP6J,OAAgB,EAASA,EAAGyD,MAAMS,MAAKI,GAAQA,EAAK1Q,KAAKC,KAAK0C,QAC7H,OAAO,EAEX,IAAI4hB,GAAU,EACd,MACMC,EAAa5gB,EAAMxD,OAAOuiB,YAAYpW,KAAKC,IAAI,EAAG5I,EAAMrE,aAD7C,KACuEqE,EAAMrE,kBAAcwL,EAAW,KAAOmB,EA6C9H,OA5CAmY,EAAMha,SAAQoa,IACV,GAAIF,EACA,OAEJ,MAAMxhB,EA3CkB,EAACmJ,EAAMoE,KACnC,GAAIR,GAASQ,GACT,OAAOA,EAAKoU,KAAKxY,GAErB,MAAMyY,EAAiBrU,EAAKpE,GAC5B,IAAKyY,EACD,OAAO,KAEX,MAAMpP,EAAS,GAWf,OAVAA,EAAOzP,KAAK6e,EAAezY,MAC3BqJ,EAAOnT,MAAQuiB,EAAeviB,MAC9BmT,EAAOqP,MAAQ1Y,EACfqJ,EAAOsP,KAAOF,EAAeE,KACzBF,EAAenhB,cACVmhB,EAAezY,KAAKyF,SAASgT,EAAenhB,cAC7C6H,QAAQC,KAAK,sFAEjBiK,EAAOzP,KAAK6e,EAAenhB,cAExB+R,GAwBWuP,CAAwBN,EAAYC,EAAKnU,MACvD,IAAKvN,EACD,OAEJ,MAAM9D,EAAKG,EAAKP,MAAMI,GAChBJ,EAAQohB,GAAqB,CAC/BphB,MAAOO,EAAKP,MACZmhB,YAAa/gB,IAEXS,EAAQ,CACVmB,KAAMA,GAAQkC,EAAM,GAAGwC,OAAS2G,EAAK3G,QACrC3E,GAAAA,IAEE,SAAEmG,EAAQ,MAAE2S,EAAK,IAAElV,GAAQ,IAAI8b,GAAe,CAChDnT,OAAAA,EACAtO,MAAAA,IAWY,OATA4lB,EAAKN,QAAQ,CACzBtlB,MAAAA,EACAa,MAAAA,EACAqD,MAAAA,EACAgE,SAAAA,EACA2S,MAAAA,EACAlV,IAAAA,KAGqBvF,EAAGsV,MAAMhP,SAKlCtG,EAAG6Z,QAAQwF,EAAQ,CACfK,UAAW1f,EACX4B,KAAAA,EACAD,GAAAA,EACAsL,KAAAA,IAEJ9M,EAAKN,SAASG,GACdslB,GAAU,MAEPA,EAOX,SAASQ,GAAiBra,GACtB,MAAM,OAAEyC,EAAM,MAAEkX,GAAU3Z,EACpB4T,EAAS,IAAI,KAAO,CACtBzf,MAAO,CACHmmB,KAAI,IACO,KAEX9E,MAAMjhB,EAAIgmB,GACN,MAAMC,EAASjmB,EAAG4hB,QAAQ3V,MAC1B,OAAIga,IAGGjmB,EAAGkmB,cAAgBlmB,EAAGqjB,WACvB,KACA2C,KAGdva,MAAO,CACH0a,gBAAe,CAAChmB,EAAMyB,EAAMD,EAAIsL,IACrBkY,GAAM,CACTjX,OAAAA,EACAtM,KAAAA,EACAD,GAAAA,EACAsL,KAAAA,EACAmY,MAAAA,EACA/F,OAAAA,IAGRwB,gBAAiB,CACbuF,eAAgBjmB,IACZkmB,YAAW,KACP,MAAM,QAAEjmB,GAAYD,EAAKP,MAAME,UAC3BM,GACA+kB,GAAM,CACFjX,OAAAA,EACAtM,KAAMxB,EAAQ8B,IACdP,GAAIvB,EAAQ8B,IACZ+K,KAAM,GACNmY,MAAAA,EACA/F,OAAAA,QAIL,IAKfiH,cAAcnmB,EAAMsW,GAChB,GAAkB,UAAdA,EAAMpO,IACN,OAAO,EAEX,MAAM,QAAEjI,GAAYD,EAAKP,MAAME,UAC/B,QAAIM,GACO+kB,GAAM,CACTjX,OAAAA,EACAtM,KAAMxB,EAAQ8B,IACdP,GAAIvB,EAAQ8B,IACZ+K,KAAM,KACNmY,MAAAA,EACA/F,OAAAA,MAOhBE,cAAc,IAElB,OAAOF,EAOX,MAAMkH,GACFzb,YAAYiB,GACRE,KAAKoF,KAAOtF,EAAOsF,KACnBpF,KAAKiZ,QAAUnZ,EAAOmZ,SA0B9B,SAASvK,GAAI5O,GACT,MAAM,OAAEmC,EAAM,MAAEtO,EAAK,KAAEgC,EAAI,GAAED,EAAE,KAAE6jB,GAAUzZ,GACrC,SAAEjE,EAAQ,MAAE2S,EAAK,IAAElV,GAAQ,IAAI8b,GAAe,CAChDnT,OAAAA,EACAtO,MAAAA,IAEE4mB,EAAW,GACjB5mB,EAAM4B,IAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KACpC,IAAKK,EAAKK,aAAeL,EAAKxB,KAAKC,KAAK0C,KACpC,OAEJ,MAAMwP,EAAe5F,KAAKC,IAAI3L,EAAMM,GAC9BukB,EAAanZ,KAAKc,IAAIzM,EAAIO,EAAMK,EAAKnB,QAAQC,MAnC3B,EAAC4L,EAAMoE,KACnC,GAAIR,GAASQ,GACT,MAAO,IAAIpE,EAAKyZ,SAASrV,IAE7B,MAAMsV,EAAUtV,EAAKpE,GACrB,OAAK0Z,EAGEA,EAAQ1kB,KAAI2kB,IACf,MAAMtQ,EAAS,GAWf,OAVAA,EAAOzP,KAAK+f,EAAe3Z,MAC3BqJ,EAAOnT,MAAQyjB,EAAezjB,MAC9BmT,EAAOqP,MAAQ1Y,EACfqJ,EAAOsP,KAAOgB,EAAehB,KACzBgB,EAAeriB,cACVqiB,EAAe3Z,KAAKyF,SAASkU,EAAeriB,cAC7C6H,QAAQC,KAAK,sFAEjBiK,EAAOzP,KAAK+f,EAAeriB,cAExB+R,KAdA,IA+BSuQ,CADItkB,EAAKmhB,YAAYxQ,EAAehR,EAAKukB,EAAavkB,OAAK4J,EAAW,KACjC0Z,EAAKnU,MAClDjG,SAAQtH,IACZ,QAAoBgI,IAAhBhI,EAAMX,MACN,OAEJ,MAAMiE,EAAQ8L,EAAepP,EAAMX,MAAQ,EACrC6B,EAAMoC,EAAQtD,EAAM,GAAGwC,OACvB7F,EAAQ,CACVmB,KAAMhC,EAAMI,GAAGgC,QAAQC,IAAImF,GAC3BzF,GAAI/B,EAAMI,GAAGgC,QAAQC,IAAI+C,IAEvBkgB,EAAUM,EAAKN,QAAQ,CACzBtlB,MAAAA,EACAa,MAAAA,EACAqD,MAAAA,EACAgE,SAAAA,EACA2S,MAAAA,EACAlV,IAAAA,IAEJihB,EAAS3f,KAAKqe,SAItB,OADgBsB,EAAStV,OAAMgU,GAAuB,OAAZA,IAQ9C,SAAS4B,GAAiBrb,GACtB,MAAM,OAAEyC,EAAM,MAAEkX,GAAU3Z,EAC1B,IAAIsb,EAAoB,KACpBC,GAA0B,EAC1BC,GAA2B,EAmE/B,OAlEgB7B,EAAMnjB,KAAIujB,GACf,IAAI,KAAO,CAEdrlB,KAAKA,GACD,MAAM+mB,EAAmBzQ,IACrB,IAAItJ,EACJ4Z,GAAuD,QAAjC5Z,EAAKhN,EAAKwO,IAAIwY,qBAAkC,IAAPha,OAAgB,EAASA,EAAGia,SAAS3Q,EAAM9V,SACpGR,EAAKwO,IAAIwY,cACT,MAGV,OADAvY,OAAOyY,iBAAiB,YAAaH,GAC9B,CACHI,UACI1Y,OAAO2Y,oBAAoB,YAAaL,MAIpDzb,MAAO,CACHoV,gBAAiB,CACb2G,KAAMrnB,IACF8mB,EAA2BF,IAAsB5mB,EAAKwO,IAAIwY,eACnD,GAEXM,MAAO,CAACtnB,EAAMsW,KACV,IAAItJ,EACJ,MAAMua,EAAsC,QAA9Bva,EAAKsJ,EAAMkR,qBAAkC,IAAPxa,OAAgB,EAASA,EAAGya,QAAQ,aAExF,OADAZ,KAA6BU,MAAAA,OAAmC,EAASA,EAAKhV,SAAS,mBAChF,KAInBsQ,kBAAmB,CAACC,EAAcC,EAAUtjB,KACxC,MAAMmhB,EAAckC,EAAa,GAC3B4E,EAA6C,UAAnC9G,EAAYa,QAAQ,aAA2BoF,EACzDc,EAA4C,SAAnC/G,EAAYa,QAAQ,aAA0BqF,EAC7D,IAAKY,IAAYC,EACb,OAGJ,MAAMlmB,EAAOshB,EAAS1hB,IAAIJ,QAAQ2mB,cAAcnoB,EAAM4B,IAAIJ,SACpDO,EAAKuhB,EAAS1hB,IAAIJ,QAAQ4mB,YAAYpoB,EAAM4B,IAAIJ,SACtD,GA1HY,iBA0HEQ,IAAUD,GAAMC,IAASD,EAAGsmB,EACtC,OAIJ,MAAMjoB,EAAKJ,EAAMI,GACXkoB,EAAiBlH,GAAqB,CACxCphB,MAAAA,EACAmhB,YAAa/gB,IAUjB,OARgB2a,GAAI,CAChBzM,OAAAA,EACAtO,MAAOsoB,EACPtmB,KAAM0L,KAAKC,IAAI3L,EAAO,EAAG,GACzBD,GAAIA,EAAGsmB,EACPzC,KAAAA,KAGaxlB,EAAGsV,MAAMhP,OAGnBtG,OAHP,OAchB,SAASmoB,GAA4BjL,GACjC,MAAM7B,EAAsB,IACtB,eAAE+B,EAAc,eAAEC,GAAmBJ,GAAgBC,GACrDkL,EAAwB,IAAIhL,KAAmBC,GAC/CgL,EAAmB,CACrBC,QAAS,KACTC,UAAU,EACVC,WAAY,KACZC,UAAW,KACXhN,aAAa,GAwDjB,OAtDAyB,EAAW9R,SAAQQ,IACf,MAKM8c,EAAsB/c,EAAkBC,EAAW,sBALzC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,UAGvB,IAAKkc,EACD,OAGqBA,IACRtd,SAAQud,IACrBA,EAAgBrjB,MAAM8F,SAAQrK,IAC1B0J,OACKkD,QAAQgb,EAAgBvX,YACxBhG,SAAQ,EAAEc,EAAMsP,MACjBH,EAAoBxU,KAAK,CACrB9F,KAAAA,EACAmL,KAAAA,EACAsP,UAAW,IACJ6M,KACA7M,iBAO3B4M,EAAsBhd,SAAQQ,IAC1B,MAAMJ,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SAEjBoc,EAAgBjd,EAAkBC,EAAW,gBAAiBJ,GACpE,IAAKod,EACD,OAGJ,MAAMxX,EAAawX,IACnBne,OACKkD,QAAQyD,GACRhG,SAAQ,EAAEc,EAAMsP,MACjBH,EAAoBxU,KAAK,CACrB9F,KAAM6K,EAAUM,KAChBA,KAAAA,EACAsP,UAAW,IACJ6M,KACA7M,WAKZH,EAGX,SAASwN,MAAmBC,GACxB,OAAOA,EACFjb,QAAO3D,KAAUA,IACjB2N,QAAO,CAAC3F,EAAOhI,KAChB,MAAM6e,EAAmB,IAAK7W,GAiB9B,OAhBAzH,OAAOkD,QAAQzD,GAAMkB,SAAQ,EAAE/C,EAAKmC,MACjBue,EAAiB1gB,GAM5B0gB,EAAiB1gB,GADT,UAARA,EACwB,CAAC0gB,EAAiB1gB,GAAMmC,GAAOzE,KAAK,KAE/C,UAARsC,EACmB,CAAC0gB,EAAiB1gB,GAAMmC,GAAOzE,KAAK,MAGpCyE,EAVxBue,EAAiB1gB,GAAOmC,KAazBue,IACR,IAGP,SAASC,GAAsBC,EAAY5N,GACvC,OAAOA,EACFxN,QAAO3D,GAAQA,EAAKsR,UAAU+M,WAC9BtmB,KAAIiI,GACAA,EAAKsR,UAAUgN,WAKbte,EAAKsR,UAAUgN,WAAWS,EAAWxhB,QAAU,GAJ3C,CACH,CAACyC,EAAKgC,MAAO+c,EAAWxhB,MAAMyC,EAAKgC,SAK1C2L,QAAO,CAACzG,EAAYoK,IAAcqN,GAAgBzX,EAAYoK,IAAY,IA6BnF,SAAS0N,GAAqCC,EAAW9N,GACrD,OAAI8N,EAAUC,MACHD,EAEJ,IACAA,EACHE,SAAU9mB,IACN,MAAM2X,EAAgBiP,EAAUE,SAC1BF,EAAUE,SAAS9mB,GACnB4mB,EAAU1hB,MAChB,IAAsB,IAAlByS,EACA,OAAO,EAEX,MAAM6B,EAAgBV,EAAoBxD,QAAO,CAAC3F,EAAOhI,KACrD,MAAMM,EAAQN,EAAKsR,UAAUiN,UACvBve,EAAKsR,UAAUiN,UAAUlmB,GArC/C,SAAoBiI,GAChB,MAAqB,iBAAVA,EACAA,EAEPA,EAAM1G,MAAM,wBACLwlB,OAAO9e,GAEJ,SAAVA,GAGU,UAAVA,GAGGA,EAyBW+e,CAAWhnB,EAAKinB,aAAatf,EAAKgC,OACxC,OAAI1B,MAAAA,EACO0H,EAEJ,IACAA,EACH,CAAChI,EAAKgC,MAAO1B,KAElB,IACH,MAAO,IAAK0P,KAAkB6B,KAK1C,SAAS0N,GAAkB7D,GACvB,OAAOnb,OAAOiD,YAAYjD,OAAOkD,QAAQiY,GAAM/X,QAAO,EAAExF,EAAKmC,MAC7C,UAARnC,IA1DZ,SAAuBmC,EAAQ,IAC3B,OAAqC,IAA9BC,OAAOU,KAAKX,GAAOlE,QAAgBkE,EAAMM,cAAgBL,OAyDrCif,CAAclf,KAG9BA,MAAAA,KAGf,SAASmf,GAA8BzM,GACnC,IAAI/P,EACJ,MAAMyc,EAAgBzB,GAA4BjL,IAC5C,eAAEE,EAAc,eAAEC,GAAmBJ,GAAgBC,GACrD2M,EAA+F,QAApF1c,EAAKiQ,EAAe/L,MAAKzF,GAAaD,EAAkBC,EAAW,oBAAgC,IAAPuB,OAAgB,EAASA,EAAGjB,KACnI0B,EAAQnD,OAAOiD,YAAY0P,EAAenb,KAAI2J,IAChD,MAAMyP,EAAsBuO,EAAc/b,QAAO2N,GAAaA,EAAUza,OAAS6K,EAAUM,OACrFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SASjBiB,EAASgc,GAAkB,IAPTvM,EAAWrF,QAAO,CAACiS,EAAQrgB,KAC/C,MAAMsgB,EAAmBpe,EAAkBlC,EAAG,mBAAoB+B,GAClE,MAAO,IACAse,KACCC,EAAmBA,EAAiBne,GAAa,MAE1D,IAGCxK,QAASmK,EAAaI,EAAkBC,EAAW,UAAWJ,IAC9DoF,MAAOrF,EAAaI,EAAkBC,EAAW,QAASJ,IAC1D+R,MAAOhS,EAAaI,EAAkBC,EAAW,QAASJ,IAC1Dwe,OAAQze,EAAaI,EAAkBC,EAAW,SAAUJ,IAC5Dye,KAAM1e,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD0e,WAAY3e,EAAaI,EAAkBC,EAAW,aAAcJ,IACpE2e,UAAW5e,EAAaI,EAAkBC,EAAW,YAAaJ,IAClE9H,KAAM6H,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD4e,SAAU7e,EAAaI,EAAkBC,EAAW,WAAYJ,IAChEvK,UAAWsK,EAAaI,EAAkBC,EAAW,YAAaJ,IAClE/D,MAAOgD,OAAOiD,YAAY2N,EAAoBpZ,KAAIsZ,IAC9C,IAAIpO,EACJ,MAAO,CAACoO,EAAmBrP,KAAM,CAAEoc,QAAyH,QAA/Gnb,EAAKoO,MAAAA,OAA+D,EAASA,EAAmBC,iBAA8B,IAAPrO,OAAgB,EAASA,EAAGmb,gBAGlMG,EAAYld,EAAaI,EAAkBC,EAAW,YAAaJ,IACrEid,IACAhb,EAAO4c,SAAW5B,EACbxmB,KAAIknB,GAAaD,GAAqCC,EAAW9N,MAE1E,MAAMmN,EAAa7c,EAAkBC,EAAW,aAAcJ,GAC1Dgd,IACA/a,EAAO6c,MAAQ/nB,GAAQimB,EAAW,CAC9BjmB,KAAAA,EACAgoB,eAAgBvB,GAAsBzmB,EAAM8Y,MAGpD,MAAMmP,EAAa7e,EAAkBC,EAAW,aAAcJ,GAI9D,OAHIgf,IACA/c,EAAOK,OAAS0c,GAEb,CAAC5e,EAAUM,KAAMuB,OAEtBmD,EAAQnG,OAAOiD,YAAY2P,EAAepb,KAAI2J,IAChD,MAAMyP,EAAsBuO,EAAc/b,QAAO2N,GAAaA,EAAUza,OAAS6K,EAAUM,OACrFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,SASjBiB,EAASgc,GAAkB,IAPTvM,EAAWrF,QAAO,CAACiS,EAAQrgB,KAC/C,MAAMghB,EAAmB9e,EAAkBlC,EAAG,mBAAoB+B,GAClE,MAAO,IACAse,KACCW,EAAmBA,EAAiB7e,GAAa,MAE1D,IAGC8e,UAAWnf,EAAaI,EAAkBC,EAAW,YAAaJ,IAClE8S,SAAU/S,EAAaI,EAAkBC,EAAW,WAAYJ,IAChE+R,MAAOhS,EAAaI,EAAkBC,EAAW,QAASJ,IAC1Dmf,SAAUpf,EAAaI,EAAkBC,EAAW,WAAYJ,IAChE9H,KAAM6H,EAAaI,EAAkBC,EAAW,OAAQJ,IACxD/D,MAAOgD,OAAOiD,YAAY2N,EAAoBpZ,KAAIsZ,IAC9C,IAAIpO,EACJ,MAAO,CAACoO,EAAmBrP,KAAM,CAAEoc,QAAyH,QAA/Gnb,EAAKoO,MAAAA,OAA+D,EAASA,EAAmBC,iBAA8B,IAAPrO,OAAgB,EAASA,EAAGmb,gBAGlMG,EAAYld,EAAaI,EAAkBC,EAAW,YAAaJ,IACrEid,IACAhb,EAAO4c,SAAW5B,EACbxmB,KAAIknB,GAAaD,GAAqCC,EAAW9N,MAE1E,MAAMmN,EAAa7c,EAAkBC,EAAW,aAAcJ,GAO9D,OANIgd,IACA/a,EAAO6c,MAAQ7Y,GAAQ+W,EAAW,CAC9B/W,KAAAA,EACA8Y,eAAgBvB,GAAsBvX,EAAM4J,MAG7C,CAACzP,EAAUM,KAAMuB,OAE5B,OAAO,IAAI,KAAO,CACdoc,QAAAA,EACAjc,MAAAA,EACAgD,MAAAA,IAIR,SAASga,GAAoB1e,EAAMuB,GAC/B,OAAOA,EAAOG,MAAM1B,IAASuB,EAAOmD,MAAM1E,IAAS,KAGvD,SAAS2e,GAAwBjf,EAAWkf,GACxC,OAAI1Y,MAAMC,QAAQyY,GACPA,EAAQ1H,MAAK2H,IACyB,iBAArBA,EACdA,EACAA,EAAiB7e,QACPN,EAAUM,OAG3B4e,EAQX,MAAME,GACFlgB,YAAYoS,EAAYhP,GACpBjC,KAAK0P,gBAAkB,GACvB1P,KAAKiC,OAASA,EACdjC,KAAKiR,WAAa8N,GAAiBjpB,QAAQmb,GAC3CjR,KAAKwB,OAASkc,GAA8B1d,KAAKiR,YACjDjR,KAAKiR,WAAW9R,SAAQQ,IACpB,IAAIuB,EAEJlB,KAAKiC,OAAO+c,iBAAiBrf,EAAUM,MAAQN,EAAUY,QACzD,MAAMhB,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAQjC,KAAKiC,OACbnN,KAAM6pB,GAAoBhf,EAAUM,KAAMD,KAAKwB,SAEnD,GAAuB,SAAnB7B,EAAU7K,KAAiB,EACuE,QAA7EoM,EAAK5B,EAAaI,EAAkBC,EAAW,cAAeJ,WAA8B,IAAP2B,GAAgBA,IAEtHlB,KAAK0P,gBAAgB9U,KAAK+E,EAAUM,MAG5C,MAAMgf,EAAiBvf,EAAkBC,EAAW,iBAAkBJ,GAClE0f,GACAjf,KAAKiC,OAAOid,GAAG,eAAgBD,GAEnC,MAAME,EAAWzf,EAAkBC,EAAW,WAAYJ,GACtD4f,GACAnf,KAAKiC,OAAOid,GAAG,SAAUC,GAE7B,MAAMC,EAAW1f,EAAkBC,EAAW,WAAYJ,GACtD6f,GACApf,KAAKiC,OAAOid,GAAG,SAAUE,GAE7B,MAAMC,EAAoB3f,EAAkBC,EAAW,oBAAqBJ,GACxE8f,GACArf,KAAKiC,OAAOid,GAAG,kBAAmBG,GAEtC,MAAMC,EAAgB5f,EAAkBC,EAAW,gBAAiBJ,GAChE+f,GACAtf,KAAKiC,OAAOid,GAAG,cAAeI,GAElC,MAAMC,EAAU7f,EAAkBC,EAAW,UAAWJ,GACpDggB,GACAvf,KAAKiC,OAAOid,GAAG,QAASK,GAE5B,MAAMC,EAAS9f,EAAkBC,EAAW,SAAUJ,GAClDigB,GACAxf,KAAKiC,OAAOid,GAAG,OAAQM,GAE3B,MAAMC,EAAY/f,EAAkBC,EAAW,YAAaJ,GACxDkgB,GACAzf,KAAKiC,OAAOid,GAAG,UAAWO,MAItCjf,eAAeyQ,GACX,MAAMyO,EAAqBX,GAAiBY,KAAKZ,GAAiBa,QAAQ3O,IACpE4O,EAhEd,SAAwB5Z,GACpB,MAAM6Z,EAAW7Z,EAAMrE,QAAO,CAACme,EAAI7oB,IAAU+O,EAAM+Z,QAAQD,KAAQ7oB,IACnE,MAAO,IAAI,IAAI+oB,IAAIH,IA8DSI,CAAeR,EAAmB1pB,KAAI2J,GAAaA,EAAUM,QAIrF,OAHI4f,EAAgBxlB,QAChB8F,QAAQC,KAAK,oDAAoDyf,EAAgB7pB,KAAIiI,GAAQ,IAAIA,OAASnE,KAAK,oCAE5G4lB,EAEXlf,eAAeyQ,GACX,OAAOA,EACFjb,KAAI2J,IACL,MAKMwgB,EAAgBzgB,EAAkBC,EAAW,gBALnC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,UAGvB,OAAI4f,EACO,CACHxgB,KACGK,KAAK4f,QAAQO,MAGjBxgB,KAGNygB,KAAK,IAEd5f,YAAYyQ,GAER,OAAOA,EAAW0O,MAAK,CAACU,EAAGrE,KACvB,MAAMsE,EAAY5gB,EAAkB2gB,EAAG,aAFnB,IAGdE,EAAY7gB,EAAkBsc,EAAG,aAHnB,IAIpB,OAAIsE,EAAYC,GACJ,EAERD,EAAYC,EACL,EAEJ,KAGX1kB,eACA,OAAOmE,KAAKiR,WAAWrF,QAAO,CAAC/P,EAAU8D,KACrC,MAOM6U,EAAc9U,EAAkBC,EAAW,cAPjC,CACZM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAQjC,KAAKiC,OACbnN,KAAM6pB,GAAoBhf,EAAUM,KAAMD,KAAKwB,UAGnD,OAAKgT,EAGE,IACA3Y,KACA2Y,KAJI3Y,IAMZ,IAEHsX,cACA,MAAM,OAAElR,GAAWjC,KAMbiR,EAAa8N,GAAiBY,KAAK,IAAI3f,KAAKiR,YAAY4G,WACxD2I,EAAa,GACbC,EAAa,GACbC,EAAazP,EACdjb,KAAI2J,IACL,MAAMJ,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAAA,EACAnN,KAAM6pB,GAAoBhf,EAAUM,KAAMD,KAAKwB,SAE7C2R,EAAU,GACViD,EAAuB1W,EAAkBC,EAAW,uBAAwBJ,GAClF,GAAI6W,EAAsB,CACtB,MAAMuK,EAAWniB,OAAOiD,YAAYjD,OAC/BkD,QAAQ0U,KACRpgB,KAAI,EAAE4qB,EAAUC,KACV,CAACD,EAAU,IAAMC,EAAO,CAAE5e,OAAAA,QAE/B6e,GAAe,OAAOH,GAC5BxN,EAAQvY,KAAKkmB,GAEjB,MAAMC,EAAgBrhB,EAAkBC,EAAW,gBAAiBJ,GAChEqf,GAAwBjf,EAAWsC,EAAO5B,QAAQ2gB,mBAAqBD,GACvEP,EAAW5lB,QAAQmmB,KAEvB,MAAME,EAAgBvhB,EAAkBC,EAAW,gBAAiBJ,GAChEqf,GAAwBjf,EAAWsC,EAAO5B,QAAQ6gB,mBAAqBD,GACvER,EAAW7lB,QAAQqmB,KAEvB,MAAMlf,EAAwBrC,EAAkBC,EAAW,wBAAyBJ,GACpF,GAAIwC,EAAuB,CACvB,MAAMof,EAAqBpf,IAC3BoR,EAAQvY,QAAQumB,GAEpB,OAAOhO,KAENiN,OACL,MAAO,CACHvG,GAAiB,CACb5X,OAAAA,EACAkX,MAAOqH,OAER3F,GAAiB,CAChB5Y,OAAAA,EACAkX,MAAOsH,OAERC,GAGPvb,iBACA,OAAO+W,GAA4Blc,KAAKiR,YAExCmQ,gBACA,MAAM,OAAEnf,GAAWjC,MACb,eAAEmR,GAAmBH,GAAgBhR,KAAKiR,YAChD,OAAOzS,OAAOiD,YAAY0P,EACrBvP,QAAOjC,KAAeD,EAAkBC,EAAW,iBACnD3J,KAAI2J,IACL,MAAMyP,EAAsBpP,KAAKmF,WAAWvD,QAAO2N,GAAaA,EAAUza,OAAS6K,EAAUM,OACvFV,EAAU,CACZU,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,QACnBE,QAASZ,EAAUY,QACnB0B,OAAAA,EACAnN,KAAM+O,EAAYlE,EAAUM,KAAMD,KAAKwB,SAErC6f,EAAc3hB,EAAkBC,EAAW,cAAeJ,GAChE,IAAK8hB,EACD,MAAO,GAaX,MAAO,CAAC1hB,EAAUM,KAXD,CAAC3J,EAAMpC,EAAMotB,EAAQC,KAClC,MAAMjD,EAAiBvB,GAAsBzmB,EAAM8Y,GACnD,OAAOiS,GAAAA,CAAc,CACjBpf,OAAAA,EACA3L,KAAAA,EACAgrB,OAAAA,EACAC,YAAAA,EACAjD,eAAAA,EACA3e,UAAAA,WAuHpB,MAAM6hB,WA/GN,MACI3iB,cACImB,KAAKgW,UAAY,GAErBkJ,GAAG1U,EAAO7G,GAKN,OAJK3D,KAAKgW,UAAUxL,KAChBxK,KAAKgW,UAAUxL,GAAS,IAE5BxK,KAAKgW,UAAUxL,GAAO5P,KAAK+I,GACpB3D,KAEXyhB,KAAKjX,KAAUiL,GACX,MAAMO,EAAYhW,KAAKgW,UAAUxL,GAIjC,OAHIwL,GACAA,EAAU7W,SAAQuW,GAAYA,EAASV,MAAMhV,KAAMyV,KAEhDzV,KAEX0hB,IAAIlX,EAAO7G,GACP,MAAMqS,EAAYhW,KAAKgW,UAAUxL,GASjC,OARIwL,IACIrS,EACA3D,KAAKgW,UAAUxL,GAASwL,EAAUpU,QAAO8T,GAAYA,IAAa/R,WAG3D3D,KAAKgW,UAAUxL,IAGvBxK,KAEX2hB,qBACI3hB,KAAKgW,UAAY,KAiFrBnX,YAAYwB,EAAU,IAClBuhB,QACA5hB,KAAK6U,WAAY,EACjB7U,KAAKgf,iBAAmB,GACxBhf,KAAKK,QAAU,CACXwhB,QAASlb,SAAS6R,cAAc,OAChCrjB,QAAS,GACT2sB,WAAW,EACX7Q,WAAY,GACZ8Q,WAAW,EACXrN,UAAU,EACVsN,YAAa,GACb3Z,aAAc,GACd2Y,kBAAkB,EAClBE,kBAAkB,EAClBe,sBAAsB,EACtBhD,eAAgB,IAAM,KACtBE,SAAU,IAAM,KAChBC,SAAU,IAAM,KAChBC,kBAAmB,IAAM,KACzBC,cAAe,IAAM,KACrBC,QAAS,IAAM,KACfC,OAAQ,IAAM,KACdC,UAAW,IAAM,MAErBzf,KAAKkiB,wBAAyB,EAC9BliB,KAAKgL,oBAAsB,KAC3BhL,KAAKmiB,WAAW9hB,GAChBL,KAAKoiB,yBACLpiB,KAAKqiB,uBACLriB,KAAKsiB,eACLtiB,KAAKkf,GAAG,eAAgBlf,KAAKK,QAAQ4e,gBACrCjf,KAAKyhB,KAAK,eAAgB,CAAExf,OAAQjC,OACpCA,KAAKuiB,aACLviB,KAAK8hB,YACL9hB,KAAKkf,GAAG,SAAUlf,KAAKK,QAAQ8e,UAC/Bnf,KAAKkf,GAAG,SAAUlf,KAAKK,QAAQ+e,UAC/Bpf,KAAKkf,GAAG,kBAAmBlf,KAAKK,QAAQgf,mBACxCrf,KAAKkf,GAAG,cAAelf,KAAKK,QAAQif,eACpCtf,KAAKkf,GAAG,QAASlf,KAAKK,QAAQkf,SAC9Bvf,KAAKkf,GAAG,OAAQlf,KAAKK,QAAQmf,QAC7Bxf,KAAKkf,GAAG,UAAWlf,KAAKK,QAAQof,WAChC9c,OAAOyX,YAAW,KACVpa,KAAKyC,cAGTzC,KAAKnE,SAASuL,MAAMpH,KAAKK,QAAQ0hB,WACjC/hB,KAAKyhB,KAAK,SAAU,CAAExf,OAAQjC,UAC/B,GAKHO,cACA,OAAOP,KAAKgf,iBAKZnjB,eACA,OAAOmE,KAAKwiB,eAAe3mB,SAK/B2S,QACI,OAAOxO,KAAKwiB,eAAehU,QAK/BlV,MACI,OAAO0G,KAAKwiB,eAAelpB,MAK/BwoB,YACQ9hB,KAAKK,QAAQyhB,WAAanb,WAC1B3G,KAAKyiB,IAxgCjB,SAAwBtF,GACpB,MAAMuF,EAAiB/b,SAASgc,cAAc,4BAC9C,GAAuB,OAAnBD,EACA,OAAOA,EAEX,MAAME,EAAYjc,SAAS6R,cAAc,SAIzC,OAHAoK,EAAUC,aAAa,oBAAqB,IAC5CD,EAAUlK,UAAYyE,EACtBxW,SAASmc,qBAAqB,QAAQ,GAAGrK,YAAYmK,GAC9CA,EA+/BYG,CA5JT,08CAoKVZ,WAAW9hB,EAAU,IACjBL,KAAKK,QAAU,IACRL,KAAKK,WACLA,GAEFL,KAAK9L,MAAS8L,KAAKrM,QAASqM,KAAKyC,cAGlCzC,KAAKK,QAAQ2hB,aACbhiB,KAAK9L,KAAK8uB,SAAShjB,KAAKK,QAAQ2hB,aAEpChiB,KAAK9L,KAAK+uB,YAAYjjB,KAAKrM,QAK/BuvB,YAAYxO,GACR1U,KAAKmiB,WAAW,CAAEzN,SAAAA,IAKlByO,iBAIA,OAAOnjB,KAAKK,QAAQqU,UACb1U,KAAK9L,MACL8L,KAAK9L,KAAKwgB,SAKjB/gB,YACA,OAAOqM,KAAK9L,KAAKP,MAQrByvB,eAAehQ,EAAQiQ,GACnB,MAAMlQ,EAAU9T,EAAWgkB,GACrBA,EAAcjQ,EAAQpT,KAAKrM,MAAMwf,SACjC,IAAInT,KAAKrM,MAAMwf,QAASC,GACxBzf,EAAQqM,KAAKrM,MAAMuhB,YAAY,CAAE/B,QAAAA,IACvCnT,KAAK9L,KAAK+uB,YAAYtvB,GAO1B2vB,iBAAiBC,GACb,GAAIvjB,KAAKyC,YACL,OAEJ,MAAMxC,EAAkC,iBAApBsjB,EACd,GAAGA,KAEHA,EAAgBnnB,IAChBzI,EAAQqM,KAAKrM,MAAMuhB,YAAY,CAEjC/B,QAASnT,KAAKrM,MAAMwf,QAAQvR,QAAOwR,IAAWA,EAAOhX,IAAI4M,WAAW/I,OAExED,KAAK9L,KAAK+uB,YAAYtvB,GAK1ByuB,yBACI,MAGMoB,EAAgB,IAHCxjB,KAAKK,QAAQ4hB,qBAC9BzjB,OAAOilB,OAAOxS,IACd,MACuCjR,KAAKK,QAAQ4Q,YAAYrP,QAAOjC,GAClE,CAAC,YAAa,OAAQ,QAAQ8G,SAAS9G,MAAAA,OAA6C,EAASA,EAAU7K,QAElHkL,KAAK+P,iBAAmB,IAAIgP,GAAiByE,EAAexjB,MAKhEqiB,uBACIriB,KAAKwiB,eAAiB,IAAIpN,GAAe,CACrCnT,OAAQjC,OAMhBsiB,eACItiB,KAAKwB,OAASxB,KAAK+P,iBAAiBvO,OAKxC+gB,aACI,MAAMhtB,EAAMkY,GAAezN,KAAKK,QAAQlL,QAAS6K,KAAKwB,OAAQxB,KAAKK,QAAQgI,cACrExU,EAAYgT,GAAqBtR,EAAKyK,KAAKK,QAAQ0hB,WACzD/hB,KAAK9L,KAAO,IAAI,KAAW8L,KAAKK,QAAQwhB,QAAS,IAC1C7hB,KAAKK,QAAQ2hB,YAChB0B,oBAAqB1jB,KAAK0jB,oBAAoBjkB,KAAKO,MACnDrM,MAAO,YAAmB,CACtB4B,IAAAA,EACA1B,UAAAA,MAKR,MAAMqjB,EAAWlX,KAAKrM,MAAMuhB,YAAY,CACpC/B,QAASnT,KAAK+P,iBAAiBoD,UAEnCnT,KAAK9L,KAAK+uB,YAAY/L,GACtBlX,KAAK2jB,kBAGO3jB,KAAK9L,KAAKwO,IAClBT,OAASjC,KAKjB2jB,kBACI3jB,KAAK9L,KAAK8uB,SAAS,CACf5B,UAAWphB,KAAK+P,iBAAiBqR,YAGzCnW,mBAAmBtH,GACf3D,KAAKkiB,wBAAyB,EAC9Bve,IACA3D,KAAKkiB,wBAAyB,EAC9B,MAAMnuB,EAAKiM,KAAKgL,oBAEhB,OADAhL,KAAKgL,oBAAsB,KACpBjX,EAOX2vB,oBAAoB5O,GAChB,GAAI9U,KAAKkiB,uBACL,OAAKliB,KAAKgL,yBAIV8J,EAAYzL,MAAMlK,SAAQvJ,IAAU,IAAIsL,EAAI,OAA2C,QAAnCA,EAAKlB,KAAKgL,2BAAwC,IAAP9J,OAAgB,EAASA,EAAGtL,KAAKA,WAH5HoK,KAAKgL,oBAAsB8J,GAMnC,MAAMnhB,EAAQqM,KAAKrM,MAAMqhB,MAAMF,GACzB8O,GAAuB5jB,KAAKrM,MAAME,UAAU2T,GAAG7T,EAAME,WAC3DmM,KAAK9L,KAAK+uB,YAAYtvB,GACtBqM,KAAKyhB,KAAK,cAAe,CACrBxf,OAAQjC,KACR8U,YAAAA,IAEA8O,GACA5jB,KAAKyhB,KAAK,kBAAmB,CACzBxf,OAAQjC,KACR8U,YAAAA,IAGR,MAAM1N,EAAQ0N,EAAYa,QAAQ,SAC5BpT,EAAOuS,EAAYa,QAAQ,QAC7BvO,GACApH,KAAKyhB,KAAK,QAAS,CACfxf,OAAQjC,KACRwK,MAAOpD,EAAMoD,MACbsK,YAAAA,IAGJvS,GACAvC,KAAKyhB,KAAK,OAAQ,CACdxf,OAAQjC,KACRwK,MAAOjI,EAAKiI,MACZsK,YAAAA,IAGHA,EAAYsC,aAActC,EAAYa,QAAQ,kBAGnD3V,KAAKyhB,KAAK,SAAU,CAChBxf,OAAQjC,KACR8U,YAAAA,IAMRiD,cAAcjU,GACV,OAAOiU,GAAc/X,KAAKrM,MAAOmQ,GAErCkU,SAAS6L,EAAkBC,GACvB,MAAM7jB,EAAmC,iBAArB4jB,EACdA,EACA,KACA1e,EAAyC,iBAArB0e,EACpBC,EACAD,EACN,OAAO7L,GAAShY,KAAKrM,MAAOsM,EAAMkF,GAKtC4e,UACI,OAAO/jB,KAAKrM,MAAM4B,IAAI4f,SAK1B6O,UACI,OAAO/L,GAAoBjY,KAAKrM,MAAM4B,IAAIJ,QAAS6K,KAAKwB,QAK5DmX,QAAQtY,GACJ,MAAM,eAAES,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GACtE,OAAOsY,GAAQ3Y,KAAKrM,MAAM4B,IAAK,CAC3BuL,eAAAA,EACAC,gBAAiB,IACVA,KACAQ,EAA4BvB,KAAKwB,WAO5CgW,cACA,OAAOoB,GAAY5Y,KAAKrM,MAAM4B,KAOlC0uB,oBAEI,OADA9jB,QAAQC,KAAK,+HACNJ,KAAKrM,MAAM4B,IAAIJ,QAAQC,KAAO,EAKzCimB,UACIrb,KAAKyhB,KAAK,WACNzhB,KAAK9L,MACL8L,KAAK9L,KAAKmnB,UAEdrb,KAAK2hB,qBAKLlf,kBACA,IAAIvB,EAEJ,QAA8B,QAApBA,EAAKlB,KAAK9L,YAAyB,IAAPgN,OAAgB,EAASA,EAAGgjB,UAI1E,MAAMC,GACFtlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,OACZkL,KAAKC,KAAO,OACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIqkB,GAAKrkB,GAEpBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAIwkB,GAAKxjB,GAgB3B,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,MAAMykB,GACFvlB,YAAYiB,EAAS,IACjBE,KAAKlL,KAAO,OACZkL,KAAKC,KAAO,OACZD,KAAK9K,OAAS,KACd8K,KAAKvC,MAAQ,KACbuC,KAAKF,OAAS,CACVG,KAAMD,KAAKC,KACXC,eAAgB,IAEpBF,KAAKF,OAAS,IACPE,KAAKF,UACLA,GAEPE,KAAKC,KAAOD,KAAKF,OAAOG,KACpBH,EAAOI,gBACPC,QAAQC,KAAK,yHAAyHJ,KAAKC,UAG/ID,KAAKK,QAAUL,KAAKF,OAAOI,eACvBF,KAAKF,OAAOQ,aACZN,KAAKK,QAAUf,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,SAGnBD,KAAKO,QAAUjB,EAAaI,EAAkBM,KAAM,aAAc,CAC9DC,KAAMD,KAAKC,KACXI,QAASL,KAAKK,YACX,GAEXG,cAAcV,EAAS,IACnB,OAAO,IAAIskB,GAAKtkB,GAEpBW,UAAUJ,EAAU,IAGhB,MAAMV,EAAYK,KAAKU,SAMvB,OALAf,EAAUU,QAAUtB,EAAUiB,KAAKK,QAASA,GAC5CV,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,EAEXe,OAAOC,EAAiB,IACpB,MAAMhB,EAAY,IAAIykB,GAAKzjB,GAgB3B,OAfAhB,EAAUzK,OAAS8K,KACnBA,KAAKvC,MAAQkC,EACbA,EAAUM,KAAOU,EAAeV,KAC1BU,EAAeV,KACfN,EAAUzK,OAAO+K,KACnBU,EAAeT,gBACfC,QAAQC,KAAK,yHAAyHT,EAAUM,UAEpJN,EAAUU,QAAUf,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,QAEpBN,EAAUY,QAAUjB,EAAaI,EAAkBC,EAAW,aAAc,CACxEM,KAAMN,EAAUM,KAChBI,QAASV,EAAUU,WAEhBV,GAIf,MAAM0kB,GACFxlB,YAAYylB,EAAW9kB,EAAOa,GAC1BL,KAAKukB,YAAa,EAClBvkB,KAAKskB,UAAYA,EACjBtkB,KAAKiC,OAASzC,EAAMyC,OACpBjC,KAAKK,QAAU,CACXmkB,UAAW,KACXC,eAAgB,QACbpkB,GAEPL,KAAKL,UAAYH,EAAMG,UACvBK,KAAK1J,KAAOkJ,EAAMlJ,KAClB0J,KAAKuhB,YAAc/hB,EAAM+hB,YACzBvhB,KAAKshB,OAAS9hB,EAAM8hB,OACpBthB,KAAK0kB,QAETA,SAIIhiB,UACA,OAAO,KAEPiiB,iBACA,OAAO,KAEXC,YAAYpa,GACR,IAAItJ,EAAI2jB,EAAIC,EACZ,MAAM,KAAE5wB,GAAS8L,KAAKiC,OAChBvN,EAAS8V,EAAM9V,OAGfqwB,EAAiC,IAApBrwB,EAAO6G,SACY,QAA/B2F,EAAKxM,EAAOwmB,qBAAkC,IAAPha,OAAgB,EAASA,EAAG8jB,QAAQ,sBAC5EtwB,EAAOswB,QAAQ,sBACrB,IAAKhlB,KAAK0C,MACyB,QAA1BmiB,EAAK7kB,KAAK2kB,kBAA+B,IAAPE,OAAgB,EAASA,EAAG1J,SAASzmB,MACxEqwB,EACJ,OAEJ,IAAIE,EAAI,EACJC,EAAI,EAER,GAAIllB,KAAK0C,MAAQqiB,EAAY,CACzB,MAAMI,EAASnlB,KAAK0C,IAAI0iB,wBAClBC,EAAYN,EAAWK,wBAC7BH,EAAII,EAAUJ,EAAIE,EAAOF,EAAIza,EAAM8a,QACnCJ,EAAIG,EAAUH,EAAIC,EAAOD,EAAI1a,EAAM+a,QAET,QAA7BT,EAAKta,EAAMgb,oBAAiC,IAAPV,GAAyBA,EAAGW,aAAazlB,KAAK0C,IAAKuiB,EAAGC,GAG5F,MAAMrxB,EAAY,YAAqBK,EAAKP,MAAM4B,IAAKyK,KAAKshB,UACtDxM,EAAc5gB,EAAKP,MAAMI,GAAG8B,aAAahC,GAC/CK,EAAKN,SAASkhB,GAElB0P,UAAUha,GACN,IAAItJ,EACJ,IAAKlB,KAAK0C,IACN,OAAO,EAEX,GAAsC,mBAA3B1C,KAAKK,QAAQmkB,UACpB,OAAOxkB,KAAKK,QAAQmkB,UAAU,CAAEha,MAAAA,IAEpC,MAAM9V,EAAS8V,EAAM9V,OAGrB,KAFoBsL,KAAK0C,IAAIyY,SAASzmB,MAAwC,QAA1BwM,EAAKlB,KAAK2kB,kBAA+B,IAAPzjB,OAAgB,EAASA,EAAGia,SAASzmB,KAGvH,OAAO,EAEX,MAAMgxB,EAA6B,SAAflb,EAAM1V,KAI1B,IAHgB,CAAC,QAAS,SAAU,SAAU,YAAY2R,SAAS/R,EAAOixB,UACnEjxB,EAAOkxB,qBAEEF,EACZ,OAAO,EAEX,MAAM,WAAEvC,GAAenjB,KAAKiC,QACtB,WAAEsiB,GAAevkB,KACjB6lB,IAAgB7lB,KAAK1J,KAAKxB,KAAKC,KAAKmpB,UACpC4H,EAAe,kBAA2B9lB,KAAK1J,MAC/CyvB,EAA6B,SAAfvb,EAAM1V,KACpBkxB,EAA8B,UAAfxb,EAAM1V,KACrBmxB,EAA4B,QAAfzb,EAAM1V,KACnBoxB,EAA8B,cAAf1b,EAAM1V,KACrBqxB,EAAc3b,EAAM1V,KAAKkU,WAAW,QAO1C,IAHK6c,GAAeC,GAAgBK,GAChC3b,EAAM4b,iBAENP,GAAeM,IAAgB5B,EAE/B,OADA/Z,EAAM4b,kBACC,EAGX,GAAIP,GAAe1C,IAAeoB,GAAc2B,EAAc,CAC1D,MAAMnB,EAAarwB,EAAOswB,QAAQ,sBACRD,IAClB/kB,KAAK0C,MAAQqiB,GAAe/kB,KAAK0C,IAAIyY,SAAS4J,MAElD/kB,KAAKukB,YAAa,EAClB5d,SAASyU,iBAAiB,WAAW,KACjCpb,KAAKukB,YAAa,IACnB,CAAE8B,MAAM,IACX1f,SAASyU,iBAAiB,WAAW,KACjCpb,KAAKukB,YAAa,IACnB,CAAE8B,MAAM,KAInB,QAAI9B,GACGmB,GACAK,GACAC,GACAC,GACCC,GAAgBJ,GAK5BrB,eAAe6B,GACX,IAAKtmB,KAAK0C,MAAQ1C,KAAK2kB,WACnB,OAAO,EAEX,GAA2C,mBAAhC3kB,KAAKK,QAAQokB,eACpB,OAAOzkB,KAAKK,QAAQokB,eAAe,CAAE6B,SAAAA,IAIzC,GAAItmB,KAAK1J,KAAKiwB,QAAUvmB,KAAK1J,KAAKH,OAC9B,OAAO,EAGX,GAAsB,cAAlBmwB,EAASxxB,KACT,OAAO,EAMX,GAAIkL,KAAK0C,IAAIyY,SAASmL,EAAS5xB,SACN,cAAlB4xB,EAASxxB,MACT0R,MACAxG,KAAKiC,OAAO4S,UAAW,CAO1B,GANqB,IACd1O,MAAMxQ,KAAK2wB,EAASE,eACpBrgB,MAAMxQ,KAAK2wB,EAASG,eAIVxhB,OAAM3O,GAAQA,EAAKsvB,oBAChC,OAAO,EAKf,OAAI5lB,KAAK2kB,aAAe2B,EAAS5xB,QAA4B,eAAlB4xB,EAASxxB,OAIhDkL,KAAK2kB,WAAWxJ,SAASmL,EAAS5xB,QAK1Cyf,iBAAiBhP,GACbnF,KAAKiC,OAAOpG,SAAS6H,SAAQ,EAAG3P,GAAAA,MAC5B,MAAMkC,EAAM+J,KAAKshB,SAKjB,OAJAvtB,EAAG0F,cAAcxD,OAAK4J,EAAW,IAC1BG,KAAK1J,KAAKkF,SACV2J,KAEA,KAGflB,aACI,MAAMtO,EAAOqK,KAAKshB,SACZ5rB,EAAKC,EAAOqK,KAAK1J,KAAKJ,SAC5B8J,KAAKiC,OAAOpG,SAASuI,YAAY,CAAEzO,KAAAA,EAAMD,GAAAA,KAIjD,MAAMgxB,GACF7nB,YAAYiW,GACR9U,KAAK8U,YAAcA,EACnB9U,KAAK2mB,YAAc3mB,KAAK8U,YAAYzL,MAAMhP,OAE9CrE,IAAI8Q,GACA,IAAI8f,GAAU,EAYd,MAAO,CACH9f,SAZmB9G,KAAK8U,YAAYzL,MACnC5T,MAAMuK,KAAK2mB,aACX/a,QAAO,CAACib,EAAajxB,KACtB,MAAMkxB,EAAYlxB,EACbmxB,SACAD,UAAUD,GAIf,OAHIC,EAAUF,UACVA,GAAU,GAEPE,EAAU7wB,MAClB6Q,GAGC8f,QAAAA,IASZ,SAASI,GAAclnB,GACnB,OAAO,IAAIkZ,GAAU,CACjB5T,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOiY,mBAAelY,EAAWhI,IAAU,IACrE,GAAE9D,GAAOJ,EACTwH,EAAQ3G,EAAMmB,KACpB,IAAIoD,EAAMvE,EAAMkB,GAChB,GAAImC,EAAM,GAAI,CAEV,IAAIovB,EAAa9rB,EADFtD,EAAM,GAAGqvB,YAAYrvB,EAAM,IAEtCovB,EAAaluB,EACbkuB,EAAaluB,EAGbA,EAAMkuB,EAAapvB,EAAM,GAAGwC,OAGhC,MAAM8sB,EAAWtvB,EAAM,GAAGA,EAAM,GAAGwC,OAAS,GAC5CtG,EAAG4D,WAAWwvB,EAAUhsB,EAAQtD,EAAM,GAAGwC,OAAS,GAElDtG,EAAGuE,YAAY2uB,EAAYluB,EAAK+G,EAAOhL,KAAKwF,OAAO6K,SAE9CtN,EAAM,IACX9D,EAAGuE,YAAY6C,EAAOpC,EAAK+G,EAAOhL,KAAKwF,OAAO6K,OAM9D,SAASiiB,GAAgBzxB,EAAMD,EAAIH,GAC/B,MAAMoP,EAAQ,GA2Bd,OAzBIhP,IAASD,EACTH,EACKO,QAAQH,GACRgP,QACAxF,SAAQqG,IACT,MACMhR,EAAQ8Q,GADD/P,EAAIO,QAAQH,EAAO,GACC6P,EAAK1Q,MACjCN,GAGLmQ,EAAM/J,KAAK,CACP4K,KAAAA,KACGhR,OAKXe,EAAImG,aAAa/F,EAAMD,GAAI,CAACY,EAAML,KAC9B0O,EAAM/J,QAAQtE,EAAKqO,MAAM3O,KAAIwP,IAAQ,CACjC7P,KAAMM,EACNP,GAAIO,EAAMK,EAAKJ,SACfsP,KAAAA,UAILb,EAOX,SAAS0iB,GAAcvnB,GACnB,OAAO,IAAIkZ,GAAU,CACjB5T,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOiY,mBAAelY,EAAWhI,GACjE,IAAmB,IAAfsN,GAAuC,OAAfA,EACxB,OAAO,KAEX,MAAM,GAAEpR,GAAOJ,EACT2zB,EAAezvB,EAAMA,EAAMwC,OAAS,GACpCktB,EAAY1vB,EAAM,GACxB,IAAI2vB,EAAUhzB,EAAMkB,GACpB,GAAI4xB,EAAc,CACd,MAAMG,EAAcF,EAAUG,OAAO,MAC/BC,EAAYnzB,EAAMmB,KAAO4xB,EAAUvH,QAAQsH,GAC3CM,EAAUD,EAAYL,EAAajtB,OAQzC,GAPsB+sB,GAAgB5yB,EAAMmB,KAAMnB,EAAMkB,GAAI/B,EAAM4B,KAC7DqM,QAAO3D,GAESA,EAAKuH,KAAK1Q,KAAK+yB,SAChBziB,MAAKtQ,GAAQA,IAASgL,EAAOhL,MAAQA,IAASmJ,EAAKuH,KAAK1Q,SAEvE8M,QAAO3D,GAAQA,EAAKvI,GAAKiyB,IACZttB,OACd,OAAO,KAEPutB,EAAUpzB,EAAMkB,IAChB3B,EAAGsC,OAAOuxB,EAASpzB,EAAMkB,IAEzBiyB,EAAYnzB,EAAMmB,MAClB5B,EAAGsC,OAAO7B,EAAMmB,KAAO8xB,EAAaE,GAExCH,EAAUhzB,EAAMmB,KAAO8xB,EAAcH,EAAajtB,OAClDtG,EAAG6Y,QAAQpY,EAAMmB,KAAO8xB,EAAaD,EAAS1nB,EAAOhL,KAAKwF,OAAO6K,GAAc,KAC/EpR,EAAGkgB,iBAAiBnU,EAAOhL,UAY3C,SAASgzB,GAAuBhoB,GAC5B,OAAO,IAAIkZ,GAAU,CACjB5T,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMmG,EAASrK,EAAM4B,IAAIO,QAAQtB,EAAMmB,MACjCwP,EAAa7F,EAAaQ,EAAOiY,mBAAelY,EAAWhI,IAAU,GAC3E,IAAKmG,EAAO1H,MAAM,GAAG+B,eAAe2F,EAAO9G,OAAO,GAAI8G,EAAO7F,YAAY,GAAI2H,EAAOhL,MAChF,OAAO,KAEXnB,EAAMI,GACDsC,OAAO7B,EAAMmB,KAAMnB,EAAMkB,IACzB4F,aAAa9G,EAAMmB,KAAMnB,EAAMmB,KAAMmK,EAAOhL,KAAMqQ,MASnE,SAAS4iB,GAAcjoB,GACnB,OAAO,IAAIkZ,GAAU,CACjB5T,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,IAAIgB,EAASiH,EAAO4Q,QAChBvV,EAAQ3G,EAAMmB,KAClB,MAAMoD,EAAMvE,EAAMkB,GAClB,GAAImC,EAAM,GAAI,CACV,MAAM6N,EAAS7N,EAAM,GAAGqvB,YAAYrvB,EAAM,IAC1CgB,GAAUhB,EAAM,GAAGpC,MAAMiQ,EAAS7N,EAAM,GAAGwC,QAC3Cc,GAASuK,EACT,MAAMsiB,EAAS7sB,EAAQpC,EACnBivB,EAAS,IACTnvB,EAAShB,EAAM,GAAGpC,MAAMiQ,EAASsiB,EAAQtiB,GAAU7M,EACnDsC,EAAQpC,GAGhBpF,EAAMI,GAAG4D,WAAWkB,EAAQsC,EAAOpC,MAmB/C,SAASkvB,GAAkBnoB,GACvB,OAAO,IAAIkZ,GAAU,CACjB5T,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOiY,mBAAelY,EAAWhI,IAAU,GACrE9D,EAAKJ,EAAMI,GAAGsC,OAAO7B,EAAMmB,KAAMnB,EAAMkB,IAEvCjB,EADSV,EAAGwB,IAAIO,QAAQtB,EAAMmB,MACVlB,aACpB4f,EAAW5f,IAAc,QAAaA,EAAYqL,EAAOhL,KAAMqQ,GACrE,IAAKkP,EACD,OAAO,KAEXtgB,EAAGqG,KAAK3F,EAAY4f,GACpB,MAAMzf,EAASb,EAAGwB,IAAIO,QAAQtB,EAAMmB,KAAO,GAAGd,WAC1CD,GACGA,EAAOE,OAASgL,EAAOhL,OACvB,QAAQf,EAAGwB,IAAKf,EAAMmB,KAAO,MAC3BmK,EAAOooB,eAAiBpoB,EAAOooB,cAAcrwB,EAAOjD,KACzDb,EAAG+F,KAAKtF,EAAMmB,KAAO,MAUrC,SAASwyB,GAAcroB,GACnB,OAAO,IAAIwa,GAAU,CACjBlV,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,MAAMsN,EAAa7F,EAAaQ,EAAOiY,mBAAelY,EAAWhI,GACjE,IAAmB,IAAfsN,GAAuC,OAAfA,EACxB,OAAO,KAEX,MAAM,GAAEpR,GAAOJ,EACT2zB,EAAezvB,EAAMA,EAAMwC,OAAS,GACpCktB,EAAY1vB,EAAM,GACxB,IAAI2vB,EAAUhzB,EAAMkB,GACpB,GAAI4xB,EAAc,CACd,MAAMG,EAAcF,EAAUG,OAAO,MAC/BC,EAAYnzB,EAAMmB,KAAO4xB,EAAUvH,QAAQsH,GAC3CM,EAAUD,EAAYL,EAAajtB,OAQzC,GAPsB+sB,GAAgB5yB,EAAMmB,KAAMnB,EAAMkB,GAAI/B,EAAM4B,KAC7DqM,QAAO3D,GAESA,EAAKuH,KAAK1Q,KAAK+yB,SAChBziB,MAAKtQ,GAAQA,IAASgL,EAAOhL,MAAQA,IAASmJ,EAAKuH,KAAK1Q,SAEvE8M,QAAO3D,GAAQA,EAAKvI,GAAKiyB,IACZttB,OACd,OAAO,KAEPutB,EAAUpzB,EAAMkB,IAChB3B,EAAGsC,OAAOuxB,EAASpzB,EAAMkB,IAEzBiyB,EAAYnzB,EAAMmB,MAClB5B,EAAGsC,OAAO7B,EAAMmB,KAAO8xB,EAAaE,GAExCH,EAAUhzB,EAAMmB,KAAO8xB,EAAcH,EAAajtB,OAClDtG,EAAG6Y,QAAQpY,EAAMmB,KAAO8xB,EAAaD,EAAS1nB,EAAOhL,KAAKwF,OAAO6K,GAAc,KAC/EpR,EAAGkgB,iBAAiBnU,EAAOhL,UAU3C,SAASszB,GAActoB,GACnB,OAAO,IAAIwa,GAAU,CACjBlV,KAAMtF,EAAOsF,KACb6T,QAAS,EAAGtlB,MAAAA,EAAOa,MAAAA,EAAOqD,MAAAA,MACtB,IAAIgB,EAASiH,EAAO4Q,QAChBvV,EAAQ3G,EAAMmB,KAClB,MAAMoD,EAAMvE,EAAMkB,GAClB,GAAImC,EAAM,GAAI,CACV,MAAM6N,EAAS7N,EAAM,GAAGqvB,YAAYrvB,EAAM,IAC1CgB,GAAUhB,EAAM,GAAGpC,MAAMiQ,EAAS7N,EAAM,GAAGwC,QAC3Cc,GAASuK,EACT,MAAMsiB,EAAS7sB,EAAQpC,EACnBivB,EAAS,IACTnvB,EAAShB,EAAM,GAAGpC,MAAMiQ,EAASsiB,EAAQtiB,GAAU7M,EACnDsC,EAAQpC,GAGhBpF,EAAMI,GAAG4D,WAAWkB,EAAQsC,EAAOpC,MAM/C,SAASsvB,GAAeC,GACpB,OAAOA,EAAO5X,QAAQ,wBAAyB,QAMnD,SAAS6X,GAAwBC,EAAQxR,GACrC,MAAMvD,EAAY,IAAI,KAAU+U,GAMhC,OALAxR,EAAa7X,SAAQ2V,IACjBA,EAAYzL,MAAMlK,SAAQvJ,IACtB6d,EAAU7d,KAAKA,SAGhB6d,EAGX,SAAS,GAAe5b,GACpB,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,GAAK,EAAG,CACzC,MAAM,KAAEnC,GAAS+C,EAAME,KAAKd,GAC5B,GAAInC,EAAK6B,cAAgB7B,EAAKkD,mBAC1B,OAAOlD,EAGf,OAAO,KAGX,SAAS2zB,GAAanyB,EAAMwa,GACxB,MAAM4X,EAAe,GASrB,OARApyB,EAAKqyB,aAAY,CAAClrB,EAAOxH,KACjB6a,EAAUrT,IACVirB,EAAa9tB,KAAK,CACdtE,KAAMmH,EACNxH,IAAAA,OAILyyB,EAMX,SAASE,GAAoBtyB,EAAM9B,EAAOsc,GACtC,MAAM4X,EAAe,GAkBrB,OARApyB,EAAKoF,aAAalH,EAAMmB,KAAMnB,EAAMkB,IAAI,CAAC+H,EAAOxH,KACxC6a,EAAUrT,IACVirB,EAAa9tB,KAAK,CACdtE,KAAMmH,EACNxH,IAAAA,OAILyyB,EAGX,SAASG,GAAU5X,GAEf,OAAOyM,GADoBqB,GAAiBjpB,QAAQmb,IAIxD,SAAS6X,GAAavzB,EAAK0b,GACvB,MAAMzP,EAASqnB,GAAU5X,GAEzB,OAAOgH,GADa,cAAgBzW,EAAQjM,GACLJ,QAASqM,GAGpD,SAASunB,GAAatN,EAAMxK,GACxB,MAAMzP,EAASqnB,GAAU5X,GACnBvO,EAAMqF,GAAkB0T,GAC9B,OAAO,gBAAqBja,GACvBkH,MAAMhG,GACNyS,SAGT,SAAS6T,GAAazzB,EAAK0b,EAAY5Q,GACnC,MAAM,eAAES,EAAiB,OAAM,gBAAEC,EAAkB,IAAQV,GAAW,GAChEmB,EAASqnB,GAAU5X,GAEzB,OAAO0H,GADa,cAAgBnX,EAAQjM,GAChB,CACxBuL,eAAAA,EACAC,gBAAiB,IACVA,KACAQ,EAA4BC,MAuB3C,SAASynB,GAAsBC,GAC3B,MAAMC,EAfV,SAA0BC,EAAOC,EAAKvQ,KAAKC,WACvC,MAAMuQ,EAAO,GACb,OAAOF,EAAMxnB,QAAO3D,IAChB,MAAM7B,EAAMitB,EAAGprB,GACf,OAAOO,OAAOC,UAAU8qB,eAAe5qB,KAAK2qB,EAAMltB,KAE3CktB,EAAKltB,IAAO,MASDotB,CAAiBN,GACvC,OAAgC,IAAzBC,EAAc9uB,OACf8uB,EACAA,EAAcvnB,QAAO,CAAC6nB,EAAQvyB,KACfiyB,EAAcvnB,QAAO,CAAC8nB,EAAGzyB,IAAMA,IAAMC,IACrCigB,MAAKwS,GACPF,EAAOG,SAASj0B,MAAQg0B,EAAYC,SAASj0B,MAC7C8zB,EAAOG,SAASl0B,IAAMi0B,EAAYC,SAASl0B,IAC3C+zB,EAAOI,SAASl0B,MAAQg0B,EAAYE,SAASl0B,MAC7C8zB,EAAOI,SAASn0B,IAAMi0B,EAAYE,SAASn0B,OAQlE,SAASo0B,GAAiBrW,GACtB,MAAM,QAAE1d,EAAO,MAAEsT,GAAUoK,EACrByV,EAAU,GAmChB,OAlCAnzB,EAAQuT,KAAKnK,SAAQ,CAAC4qB,EAAS7yB,KAC3B,MAAMgL,EAAS,GAIf,GAAK6nB,EAAQ7nB,OAAO7H,OAQhB0vB,EAAQ5qB,SAAQ,CAACxJ,EAAMD,KACnBwM,EAAOtH,KAAK,CAAEjF,KAAAA,EAAMD,GAAAA,WATA,CACxB,MAAM,KAAEC,EAAI,GAAED,GAAO2T,EAAMnS,GAC3B,QAAa2I,IAATlK,QAA6BkK,IAAPnK,EACtB,OAEJwM,EAAOtH,KAAK,CAAEjF,KAAAA,EAAMD,GAAAA,IAOxBwM,EAAO/C,SAAQ,EAAGxJ,KAAAA,EAAMD,GAAAA,MACpB,MAAMs0B,EAAWj0B,EAAQN,MAAMyB,GAAOlB,IAAIL,GAAO,GAC3Cs0B,EAASl0B,EAAQN,MAAMyB,GAAOlB,IAAIN,GAClCw0B,EAAWn0B,EAAQ4d,SAAS3d,IAAIg0B,GAAW,GAC3CG,EAASp0B,EAAQ4d,SAAS3d,IAAIi0B,GACpCf,EAAQtuB,KAAK,CACTgvB,SAAU,CACNj0B,KAAMu0B,EACNx0B,GAAIy0B,GAERN,SAAU,CACNl0B,KAAMq0B,EACNt0B,GAAIu0B,WAKbhB,GAAsBC,GAGjC,SAASkB,GAAa9zB,EAAM+zB,EAAc,GACtC,MACMC,EADYh0B,EAAKxB,OAASwB,EAAKxB,KAAK0M,OAAO+oB,YACnB,EAAI,EAC5B50B,EAAO00B,EACP30B,EAAKC,EAAOW,EAAKJ,SACjByO,EAAQrO,EAAKqO,MAAM3O,KAAIwP,IACzB,MAAMvG,EAAS,CACXnK,KAAM0Q,EAAK1Q,KAAKmL,MAKpB,OAHIzB,OAAOU,KAAKsG,EAAKhK,OAAOnB,SACxB4E,EAAOzD,MAAQ,IAAKgK,EAAKhK,QAEtByD,KAELzD,EAAQ,IAAKlF,EAAKkF,OAClByD,EAAS,CACXnK,KAAMwB,EAAKxB,KAAKmL,KAChBtK,KAAAA,EACAD,GAAAA,GAkBJ,OAhBI8I,OAAOU,KAAK1D,GAAOnB,SACnB4E,EAAOzD,MAAQA,GAEfmJ,EAAMtK,SACN4E,EAAO0F,MAAQA,GAEfrO,EAAKnB,QAAQyB,aACbqI,EAAO9J,QAAU,GACjBmB,EAAK6I,SAAQ,CAAC1B,EAAOiI,KACjB,IAAIxE,EACsB,QAAzBA,EAAKjC,EAAO9J,eAA4B,IAAP+L,GAAyBA,EAAGtG,KAAKwvB,GAAa3sB,EAAO4sB,EAAc3kB,EAAS4kB,QAGlHh0B,EAAK0K,OACL/B,EAAO+B,KAAO1K,EAAK0K,MAEhB/B,EAGX,SAASurB,GAAgBjsB,GACrB,OAAO2H,GAAS3H,IAAUA,aAAiB,KAG/C,SAASksB,GAAav2B,EAAMyB,EAAMD,GAC9B,MACMsR,EAAS9S,EAAKP,MAAM4B,IAAIJ,QAAQC,KAChC6R,EAAeL,GAAOjR,EAFb,EAE2BqR,GACpCE,EAAcN,GAAOlR,EAHZ,EAGwBsR,GACjC7L,EAAQjH,EAAKw2B,YAAYzjB,GACzBlO,EAAM7E,EAAKw2B,YAAYxjB,GAAc,GACrCyjB,EAAMtpB,KAAKc,IAAIhH,EAAMwvB,IAAK5xB,EAAI4xB,KAC9BC,EAASvpB,KAAKC,IAAInG,EAAMyvB,OAAQ7xB,EAAI6xB,QACpCC,EAAOxpB,KAAKc,IAAIhH,EAAM0vB,KAAM9xB,EAAI8xB,MAChCC,EAAQzpB,KAAKC,IAAInG,EAAM2vB,MAAO/xB,EAAI+xB,OAKlCnR,EAAO,CACTgR,IAAAA,EACAC,OAAAA,EACAC,KAAAA,EACAC,MAAAA,EACAC,MATUD,EAAQD,EAUlBG,OATWJ,EAASD,EAUpB1F,EATM4F,EAUN3F,EATMyF,GAWV,MAAO,IACAhR,EACHxE,OAAQ,IAAMwE,K,6EC3tItB,IA5FO,IAAIsR,EAAO,CAChB,EAAG,YACH,EAAG,MACH,GAAI,QACJ,GAAI,UACJ,GAAI,QACJ,GAAI,QACJ,GAAI,UACJ,GAAI,MACJ,GAAI,WACJ,GAAI,SACJ,GAAI,IACJ,GAAI,SACJ,GAAI,WACJ,GAAI,MACJ,GAAI,OACJ,GAAI,YACJ,GAAI,UACJ,GAAI,aACJ,GAAI,YACJ,GAAI,cACJ,GAAI,SACJ,GAAI,SACJ,GAAI,IACJ,GAAI,IACJ,GAAI,OACJ,GAAI,OACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,UACL,IAAK,aACL,IAAK,QACL,IAAK,QACL,IAAK,UACL,IAAK,UACL,IAAK,MACL,IAAK,MACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,IACL,IAAK,IACL,IAAK,KAGI9gB,EAAQ,CACjB,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,GAAI,IACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,KAGH+gB,EAA6B,oBAAb3uB,WAA4B,gBAAgBid,KAAKjd,UAAUmK,WAC3EykB,EAA6B,oBAAb5uB,WAA4B,iBAAiBC,KAAKD,UAAU6uB,QAC5EC,EAA4B,oBAAb9uB,WAA4B,aAAaC,KAAKD,UAAUmK,WACvE4kB,EAA0B,oBAAb/uB,WAA4B,MAAMC,KAAKD,UAAUE,UAC9D8uB,EAAyB,oBAAbhvB,WAA4B,gDAAgDid,KAAKjd,UAAUmK,WACvG8kB,EAAsBN,IAAWI,IAAQJ,EAAO,GAAK,KAAOG,GAASC,EAGhEr0B,EAAI,EAAGA,EAAI,GAAIA,IAAKg0B,EAAK,GAAKh0B,GAAKg0B,EAAK,GAAKh0B,GAAKw0B,OAAOx0B,GAGlE,IAASA,EAAI,EAAGA,GAAK,GAAIA,IAAKg0B,EAAKh0B,EAAI,KAAO,IAAMA,EAGpD,IAASA,EAAI,GAAIA,GAAK,GAAIA,IACxBg0B,EAAKh0B,GAAKw0B,OAAOC,aAAaz0B,EAAI,IAClCkT,EAAMlT,GAAKw0B,OAAOC,aAAaz0B,GAIjC,IAAK,IAAIQ,KAAQwzB,EAAW9gB,EAAMof,eAAe9xB,KAAO0S,EAAM1S,GAAQwzB,EAAKxzB,I,eCnGvE,EAA0B,oBAAb8E,WAA2B,qBAAqBC,KAAKD,UAAUE,UAEhF,SAAS8N,EAAiBtK,GACxB,IAEIgK,EAAKC,EAAMC,EAAOC,EAFlBJ,EAAQ/J,EAAKjH,MAAM,UAAWqR,EAASL,EAAMA,EAAM3P,OAAS,GAClD,SAAVgQ,IAAqBA,EAAS,KAElC,IAAK,IAAIpT,EAAI,EAAGA,EAAI+S,EAAM3P,OAAS,EAAGpD,IAAK,CACzC,IAAIqT,EAAMN,EAAM/S,GAChB,GAAI,kBAAkBuF,KAAK8N,GAAQF,GAAO,OACrC,GAAI,YAAY5N,KAAK8N,GAAQL,GAAM,OACnC,GAAI,sBAAsBzN,KAAK8N,GAAQJ,GAAO,OAC9C,GAAI,cAAc1N,KAAK8N,GAAQH,GAAQ,MACvC,KAAI,SAAS3N,KAAK8N,GAChB,MAAM,IAAIvG,MAAM,+BAAiCuG,GADrB,EAAOF,GAAO,EAAeF,GAAO,GAOzE,OAJID,IAAOI,EAAS,OAASA,GACzBH,IAAQG,EAAS,QAAUA,GAC3BD,IAAQC,EAAS,QAAUA,GAC3BF,IAASE,EAAS,SAAWA,GAC1BA,EAST,SAASshB,EAAU1rB,EAAMuK,EAAOL,GAK9B,OAJIK,EAAME,SAAUzK,EAAO,OAASA,GAChCuK,EAAMG,UAAW1K,EAAO,QAAUA,GAClCuK,EAAMI,UAAW3K,EAAO,QAAUA,IACxB,IAAVkK,GAAmBK,EAAMK,WAAY5K,EAAO,SAAWA,GACpDA,EAiCT,SAAS2rB,EAAOjL,GACd,OAAO,IAAI,KAAO,CAACnhB,MAAO,CAAC6a,cAAewR,EAAelL,MAO3D,SAASkL,EAAelL,GACtB,IAAI3qB,EArDN,SAAmBA,GACjB,IAAIuE,EAAOiE,OAAOlE,OAAO,MACzB,IAAK,IAAIiS,KAAQvW,EAAOuE,EAAKgQ,EAAiBgC,IAASvW,EAAIuW,GAC3D,OAAOhS,EAkDGuxB,CAAUnL,GACpB,OAAO,SAASzsB,EAAMsW,GACpB,IAAqEuhB,EAAjE9rB,EDwBD,SAAiBuK,GAGtB,IAEIvK,IAFYurB,IAAwBhhB,EAAMG,SAAWH,EAAME,QAAUF,EAAMI,WAC5EugB,GAAUI,IAAO/gB,EAAMK,UAAYL,EAAMpO,KAA2B,GAApBoO,EAAMpO,IAAI/B,SACnCmQ,EAAMpO,MAC7BoO,EAAMK,SAAWV,EAAQ8gB,GAAMzgB,EAAMwhB,UACtCxhB,EAAMpO,KAAO,eASf,MAPY,OAAR6D,IAAeA,EAAO,UACd,OAARA,IAAeA,EAAO,UAEd,QAARA,IAAgBA,EAAO,aACf,MAARA,IAAcA,EAAO,WACb,SAARA,IAAiBA,EAAO,cAChB,QAARA,IAAgBA,EAAO,aACpBA,ECxCMgsB,CAAQzhB,GAAQ0hB,EAAwB,GAAfjsB,EAAK5F,QAAuB,KAAR4F,EACpDksB,EAASn2B,EAAI21B,EAAU1rB,EAAMuK,GAAQ0hB,IACzC,GAAIC,GAAUA,EAAOj4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,EAChE,GAAIg4B,IAAW1hB,EAAMK,UAAYL,EAAME,QAAUF,EAAMI,SAAW3K,EAAKmsB,WAAW,GAAK,OAClFL,EAAWd,EAAKzgB,EAAMwhB,WAAaD,GAAY9rB,EAAM,CAKxD,IAAIosB,EAAWr2B,EAAI21B,EAAUI,EAAUvhB,GAAO,IAC9C,GAAI6hB,GAAYA,EAASn4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,OAC/D,GAAIg4B,GAAU1hB,EAAMK,SAAU,CAGnC,IAAIyhB,EAAYt2B,EAAI21B,EAAU1rB,EAAMuK,GAAO,IAC3C,GAAI8hB,GAAaA,EAAUp4B,EAAKP,MAAOO,EAAKN,SAAUM,GAAS,OAAO,EAExE,OAAO,K,sBCjGX,SAASq4B,EAAWp3B,GAClB6K,KAAK7K,QAAUA,E,6PAGjBo3B,EAAW9tB,UAAY,CACrBI,YAAa0tB,EAEbnnB,KAAM,SAAShJ,GACb,IAAK,IAAInF,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,GAAK,EAC5C,GAAI+I,KAAK7K,QAAQ8B,KAAOmF,EAAK,OAAOnF,EACtC,OAAQ,GAMVu1B,IAAK,SAASpwB,GACZ,IAAIgB,EAAQ4C,KAAKoF,KAAKhJ,GACtB,OAAiB,GAAVgB,OAAcyC,EAAYG,KAAK7K,QAAQiI,EAAQ,IAOxDqvB,OAAQ,SAASrwB,EAAKmC,EAAOmuB,GAC3B,IAAIC,EAAOD,GAAUA,GAAUtwB,EAAM4D,KAAK4sB,OAAOF,GAAU1sB,KACvD5C,EAAQuvB,EAAKvnB,KAAKhJ,GAAMjH,EAAUw3B,EAAKx3B,QAAQM,QAOnD,OANc,GAAV2H,EACFjI,EAAQyF,KAAK8xB,GAAUtwB,EAAKmC,IAE5BpJ,EAAQiI,EAAQ,GAAKmB,EACjBmuB,IAAQv3B,EAAQiI,GAASsvB,IAExB,IAAIH,EAAWp3B,IAKxBy3B,OAAQ,SAASxwB,GACf,IAAIgB,EAAQ4C,KAAKoF,KAAKhJ,GACtB,IAAc,GAAVgB,EAAa,OAAO4C,KACxB,IAAI7K,EAAU6K,KAAK7K,QAAQM,QAE3B,OADAN,EAAQ03B,OAAOzvB,EAAO,GACf,IAAImvB,EAAWp3B,IAKxB23B,WAAY,SAAS1wB,EAAKmC,GACxB,OAAO,IAAIguB,EAAW,CAACnwB,EAAKmC,GAAOwuB,OAAO/sB,KAAK4sB,OAAOxwB,GAAKjH,WAK7D63B,SAAU,SAAS5wB,EAAKmC,GACtB,IAAIpJ,EAAU6K,KAAK4sB,OAAOxwB,GAAKjH,QAAQM,QAEvC,OADAN,EAAQyF,KAAKwB,EAAKmC,GACX,IAAIguB,EAAWp3B,IAMxB83B,UAAW,SAASC,EAAO9wB,EAAKmC,GAC9B,IAAI4uB,EAAUntB,KAAK4sB,OAAOxwB,GAAMjH,EAAUg4B,EAAQh4B,QAAQM,QACtD2H,EAAQ+vB,EAAQ/nB,KAAK8nB,GAEzB,OADA/3B,EAAQ03B,QAAiB,GAAVzvB,EAAcjI,EAAQkF,OAAS+C,EAAO,EAAGhB,EAAKmC,GACtD,IAAIguB,EAAWp3B,IAMxBgK,QAAS,SAASgM,GAChB,IAAK,IAAIlU,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,GAAK,EAC5CkU,EAAEnL,KAAK7K,QAAQ8B,GAAI+I,KAAK7K,QAAQ8B,EAAI,KAMxCm2B,QAAS,SAASp3B,GAEhB,OADAA,EAAMu2B,EAAW52B,KAAKK,IACbZ,KACF,IAAIm3B,EAAWv2B,EAAIb,QAAQ43B,OAAO/sB,KAAKqtB,SAASr3B,GAAKb,UADtC6K,MAOxB5B,OAAQ,SAASpI,GAEf,OADAA,EAAMu2B,EAAW52B,KAAKK,IACbZ,KACF,IAAIm3B,EAAWvsB,KAAKqtB,SAASr3B,GAAKb,QAAQ43B,OAAO/2B,EAAIb,UADtC6K,MAOxBqtB,SAAU,SAASr3B,GACjB,IAAIqU,EAASrK,KACbhK,EAAMu2B,EAAW52B,KAAKK,GACtB,IAAK,IAAIiB,EAAI,EAAGA,EAAIjB,EAAIb,QAAQkF,OAAQpD,GAAK,EAC3CoT,EAASA,EAAOuiB,OAAO52B,EAAIb,QAAQ8B,IACrC,OAAOoT,GAKLjV,WACF,OAAO4K,KAAK7K,QAAQkF,QAAU,IAQlCkyB,EAAW52B,KAAO,SAAS4I,GACzB,GAAIA,aAAiBguB,EAAY,OAAOhuB,EACxC,IAAIpJ,EAAU,GACd,GAAIoJ,EAAO,IAAK,IAAIgO,KAAQhO,EAAOpJ,EAAQyF,KAAK2R,EAAMhO,EAAMgO,IAC5D,OAAO,IAAIggB,EAAWp3B,IAGxB,IAEA,EAFiBo3B,EC9HjB,SAASzQ,EAAcuE,EAAGrE,EAAG/lB,GAC3B,IAAK,IAAIgB,EAAI,GAAIA,IAAK,CACpB,GAAIA,GAAKopB,EAAEzpB,YAAcK,GAAK+kB,EAAEplB,WAC5B,OAAOypB,EAAEzpB,YAAcolB,EAAEplB,WAAa,KAAOX,EAEjD,IAAIq3B,EAASjN,EAAE5iB,MAAMxG,GAAIs2B,EAASvR,EAAEve,MAAMxG,GAC1C,GAAIq2B,GAAUC,EAAd,CAEA,IAAKD,EAAOE,WAAWD,GAAW,OAAOt3B,EAEzC,GAAIq3B,EAAOlsB,QAAUksB,EAAOtsB,MAAQusB,EAAOvsB,KAAM,CAC/C,IAAK,IAAI0S,EAAI,EAAG4Z,EAAOtsB,KAAK0S,IAAM6Z,EAAOvsB,KAAK0S,GAAIA,IAC9Czd,IACJ,OAAOA,EAET,GAAIq3B,EAAOn4B,QAAQC,MAAQm4B,EAAOp4B,QAAQC,KAAM,CAC9C,IAAI8Z,EAAQ4M,EAAcwR,EAAOn4B,QAASo4B,EAAOp4B,QAASc,EAAM,GAChE,GAAa,MAATiZ,EAAiB,OAAOA,EAE9BjZ,GAAOq3B,EAAOp3B,cAbUD,GAAOq3B,EAAOp3B,UAiB1C,SAAS6lB,EAAYsE,EAAGrE,EAAGyR,EAAMC,GAC/B,IAAK,IAAIC,EAAKtN,EAAEzpB,WAAYg3B,EAAK5R,EAAEplB,aAAc,CAC/C,GAAU,GAAN+2B,GAAiB,GAANC,EACX,OAAOD,GAAMC,EAAK,KAAO,CAACvN,EAAGoN,EAAMzR,EAAG0R,GAE1C,IAAIJ,EAASjN,EAAE5iB,QAAQkwB,GAAKJ,EAASvR,EAAEve,QAAQmwB,GAAKx4B,EAAOk4B,EAAOp3B,SAClE,GAAIo3B,GAAUC,EAAd,CAKA,IAAKD,EAAOE,WAAWD,GAAW,MAAO,CAAClN,EAAGoN,EAAMzR,EAAG0R,GAEtD,GAAIJ,EAAOlsB,QAAUksB,EAAOtsB,MAAQusB,EAAOvsB,KAAM,CAE/C,IADA,IAAIqM,EAAO,EAAGwgB,EAAUxsB,KAAKc,IAAImrB,EAAOtsB,KAAK3G,OAAQkzB,EAAOvsB,KAAK3G,QAC1DgT,EAAOwgB,GAAWP,EAAOtsB,KAAKssB,EAAOtsB,KAAK3G,OAASgT,EAAO,IAAMkgB,EAAOvsB,KAAKusB,EAAOvsB,KAAK3G,OAASgT,EAAO,IAC7GA,IAAQogB,IAAQC,IAElB,MAAO,CAACrN,EAAGoN,EAAMzR,EAAG0R,GAEtB,GAAIJ,EAAOn4B,QAAQC,MAAQm4B,EAAOp4B,QAAQC,KAAM,CAC9C,IAAI8Z,EAAQ6M,EAAYuR,EAAOn4B,QAASo4B,EAAOp4B,QAASs4B,EAAO,EAAGC,EAAO,GACzE,GAAIxe,EAAS,OAAOA,EAEtBue,GAAQr4B,EAAMs4B,GAAQt4B,OAjBpBq4B,GAAQr4B,EAAMs4B,GAAQt4B,GA0B5B,IAAI04B,EAAW,SAAkB34B,EAASC,GAMxC,GALA4K,KAAK7K,QAAUA,EAIf6K,KAAK5K,KAAOA,GAAQ,EACR,MAARA,EAAgB,IAAK,IAAI6B,EAAI,EAAGA,EAAI9B,EAAQkF,OAAQpD,IACpD+I,KAAK5K,MAAQD,EAAQ8B,GAAGf,UAG1B63B,EAAqB,CAAEt3B,WAAY,CAAEu3B,cAAc,GAAOt3B,UAAW,CAAEs3B,cAAc,GAAOp3B,WAAY,CAAEo3B,cAAc,IAM5HF,EAASrvB,UAAU/C,aAAe,SAAuB/F,EAAMD,EAAIyV,EAAG8iB,EAAW/4B,QAC1D,IAAd+4B,IAAuBA,EAAY,GAE1C,IAAK,IAAIh3B,EAAI,EAAGhB,EAAM,EAAGA,EAAMP,EAAIuB,IAAK,CACtC,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GAAI8B,EAAM9C,EAAMwH,EAAMvH,SAC/C,GAAI6C,EAAMpD,IAAiD,IAAzCwV,EAAE1N,EAAOwwB,EAAYh4B,EAAKf,EAAQ+B,IAAgBwG,EAAMtI,QAAQC,KAAM,CACtF,IAAI+F,EAAQlF,EAAM,EAClBwH,EAAM/B,aAAa2F,KAAKC,IAAI,EAAG3L,EAAOwF,GACnBkG,KAAKc,IAAI1E,EAAMtI,QAAQC,KAAMM,EAAKyF,GAClCgQ,EAAG8iB,EAAY9yB,GAEpClF,EAAM8C,IAOV+0B,EAASrvB,UAAUkqB,YAAc,SAAsBxd,GACrDnL,KAAKtE,aAAa,EAAGsE,KAAK5K,KAAM+V,IAMlC2iB,EAASrvB,UAAUgZ,YAAc,SAAsB9hB,EAAMD,EAAIoL,EAAgBotB,GAC/E,IAAIltB,EAAO,GAAIC,GAAY,EAa3B,OAZAjB,KAAKtE,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GACtCK,EAAK8K,QACPJ,GAAQ1K,EAAK0K,KAAKvL,MAAM4L,KAAKC,IAAI3L,EAAMM,GAAOA,EAAKP,EAAKO,GACxDgL,GAAaH,GACJxK,EAAKiwB,QAAU2H,GACxBltB,GAA4B,mBAAbktB,EAA0BA,EAAS53B,GAAO43B,EACzDjtB,GAAaH,IACHG,GAAa3K,EAAK4C,UAC5B8H,GAAQF,EACRG,GAAY,KAEb,GACID,GAMT8sB,EAASrvB,UAAUL,OAAS,SAAiB+vB,GAC3C,IAAKA,EAAM/4B,KAAQ,OAAO4K,KAC1B,IAAKA,KAAK5K,KAAQ,OAAO+4B,EACzB,IAAI/kB,EAAOpJ,KAAKtJ,UAAW6C,EAAQ40B,EAAM13B,WAAYtB,EAAU6K,KAAK7K,QAAQM,QAASwB,EAAI,EAKzF,IAJImS,EAAKhI,QAAUgI,EAAKokB,WAAWj0B,KACjCpE,EAAQA,EAAQkF,OAAS,GAAK+O,EAAKglB,SAAShlB,EAAKpI,KAAOzH,EAAMyH,MAC9D/J,EAAI,GAECA,EAAIk3B,EAAMh5B,QAAQkF,OAAQpD,IAAO9B,EAAQyF,KAAKuzB,EAAMh5B,QAAQ8B,IACnE,OAAO,IAAI62B,EAAS34B,EAAS6K,KAAK5K,KAAO+4B,EAAM/4B,OAKjD04B,EAASrvB,UAAU4vB,IAAM,SAAc14B,EAAMD,GAE3C,GADU,MAANA,IAAcA,EAAKsK,KAAK5K,MAChB,GAARO,GAAaD,GAAMsK,KAAK5K,KAAQ,OAAO4K,KAC3C,IAAIqK,EAAS,GAAIjV,EAAO,EACxB,GAAIM,EAAKC,EAAQ,IAAK,IAAIsB,EAAI,EAAGhB,EAAM,EAAGA,EAAMP,EAAIuB,IAAK,CACvD,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GAAI8B,EAAM9C,EAAMwH,EAAMvH,SAC3C6C,EAAMpD,KACJM,EAAMN,GAAQoD,EAAMrD,KAElB+H,EADAA,EAAM2D,OACE3D,EAAM4wB,IAAIhtB,KAAKC,IAAI,EAAG3L,EAAOM,GAAMoL,KAAKc,IAAI1E,EAAMuD,KAAK3G,OAAQ3E,EAAKO,IAEpEwH,EAAM4wB,IAAIhtB,KAAKC,IAAI,EAAG3L,EAAOM,EAAM,GAAIoL,KAAKc,IAAI1E,EAAMtI,QAAQC,KAAMM,EAAKO,EAAM,KAE7FoU,EAAOzP,KAAK6C,GACZrI,GAAQqI,EAAMvH,UAEhBD,EAAM8C,EAER,OAAO,IAAI+0B,EAASzjB,EAAQjV,IAG9B04B,EAASrvB,UAAU6vB,WAAa,SAAqB34B,EAAMD,GACzD,OAAIC,GAAQD,EAAao4B,EAASh6B,MACtB,GAAR6B,GAAaD,GAAMsK,KAAK7K,QAAQkF,OAAiB2F,KAC9C,IAAI8tB,EAAS9tB,KAAK7K,QAAQM,MAAME,EAAMD,KAM/Co4B,EAASrvB,UAAU8vB,aAAe,SAAuBr3B,EAAOZ,GAC9D,IAAIk4B,EAAUxuB,KAAK7K,QAAQ+B,GAC3B,GAAIs3B,GAAWl4B,EAAQ,OAAO0J,KAC9B,IAAIzF,EAAOyF,KAAK7K,QAAQM,QACpBL,EAAO4K,KAAK5K,KAAOkB,EAAKJ,SAAWs4B,EAAQt4B,SAE/C,OADAqE,EAAKrD,GAASZ,EACP,IAAIw3B,EAASvzB,EAAMnF,IAM5B04B,EAASrvB,UAAUquB,WAAa,SAAqBx2B,GACnD,OAAO,IAAIw3B,EAAS,CAACx3B,GAAMy2B,OAAO/sB,KAAK7K,SAAU6K,KAAK5K,KAAOkB,EAAKJ,WAMpE43B,EAASrvB,UAAUuuB,SAAW,SAAmB12B,GAC/C,OAAO,IAAIw3B,EAAS9tB,KAAK7K,QAAQ43B,OAAOz2B,GAAO0J,KAAK5K,KAAOkB,EAAKJ,WAKlE43B,EAASrvB,UAAU+I,GAAK,SAAa2mB,GACnC,GAAInuB,KAAK7K,QAAQkF,QAAU8zB,EAAMh5B,QAAQkF,OAAU,OAAO,EAC1D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAK7K,QAAQkF,OAAQpD,IACrC,IAAK+I,KAAK7K,QAAQ8B,GAAGuQ,GAAG2mB,EAAMh5B,QAAQ8B,IAAO,OAAO,EACxD,OAAO,GAKT82B,EAAmBt3B,WAAW+1B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQ,GAAK,MAIjG44B,EAAmBr3B,UAAU81B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAAK,MAItH0zB,EAAmBn3B,WAAW41B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQkF,QAKtEyzB,EAASrvB,UAAUhB,MAAQ,SAAgBvG,GACzC,IAAIkG,EAAQ4C,KAAK7K,QAAQ+B,GACzB,IAAKkG,EAAS,MAAM,IAAIqxB,WAAW,SAAWv3B,EAAQ,qBAAuB8I,MAC7E,OAAO5C,GAKT0wB,EAASrvB,UAAUiwB,WAAa,SAAqBx3B,GACnD,OAAO8I,KAAK7K,QAAQ+B,IAMtB42B,EAASrvB,UAAUU,QAAU,SAAkBgM,GAC7C,IAAK,IAAIlU,EAAI,EAAG03B,EAAI,EAAG13B,EAAI+I,KAAK7K,QAAQkF,OAAQpD,IAAK,CACnD,IAAIwG,EAAQuC,KAAK7K,QAAQ8B,GACzBkU,EAAE1N,EAAOkxB,EAAG13B,GACZ03B,GAAKlxB,EAAMvH,WAOf43B,EAASrvB,UAAUqd,cAAgB,SAA0BqS,EAAOl4B,GAGlE,YAFe,IAARA,IAAiBA,EAAM,GAEvB6lB,EAAc9b,KAAMmuB,EAAOl4B,IAQpC63B,EAASrvB,UAAUsd,YAAc,SAAwBoS,EAAOl4B,EAAK24B,GAInE,YAHe,IAAR34B,IAAiBA,EAAM+J,KAAK5K,WACf,IAAbw5B,IAAsBA,EAAWT,EAAM/4B,MAEvC2mB,EAAY/b,KAAMmuB,EAAOl4B,EAAK24B,IAOvCd,EAASrvB,UAAUowB,UAAY,SAAoB54B,EAAK64B,GAGtD,QAFiB,IAAVA,IAAmBA,GAAS,GAExB,GAAP74B,EAAY,OAAO84B,EAAS,EAAG94B,GACnC,GAAIA,GAAO+J,KAAK5K,KAAQ,OAAO25B,EAAS/uB,KAAK7K,QAAQkF,OAAQpE,GAC7D,GAAIA,EAAM+J,KAAK5K,MAAQa,EAAM,EAAK,MAAM,IAAIw4B,WAAY,YAAcx4B,EAAM,yBAA2B,KAAS,KAChH,IAAK,IAAIgB,EAAI,EAAG+3B,EAAS,GAAI/3B,IAAK,CAChC,IAAyB8B,EAAMi2B,EAArBhvB,KAAKvC,MAAMxG,GAAuBf,SAC5C,GAAI6C,GAAO9C,EACT,OAAI8C,GAAO9C,GAAO64B,EAAQ,EAAYC,EAAS93B,EAAI,EAAG8B,GAC/Cg2B,EAAS93B,EAAG+3B,GAErBA,EAASj2B,IAMb+0B,EAASrvB,UAAUC,SAAW,WAAuB,MAAO,IAAMsB,KAAKivB,gBAAkB,KAEzFnB,EAASrvB,UAAUwwB,cAAgB,WAA4B,OAAOjvB,KAAK7K,QAAQ2E,KAAK,OAIxFg0B,EAASrvB,UAAU0W,OAAS,WAC1B,OAAOnV,KAAK7K,QAAQkF,OAAS2F,KAAK7K,QAAQa,KAAI,SAAU2a,GAAK,OAAOA,EAAEwE,YAAe,MAKvF2Y,EAASoB,SAAW,SAAmB1tB,EAAQjD,GAC7C,IAAKA,EAAS,OAAOuvB,EAASh6B,MAC9B,IAAKqS,MAAMC,QAAQ7H,GAAU,MAAM,IAAIkwB,WAAW,uCAClD,OAAO,IAAIX,EAASvvB,EAAMvI,IAAIwL,EAAO8G,gBAMvCwlB,EAASqB,UAAY,SAAoB/F,GACvC,IAAKA,EAAM/uB,OAAU,OAAOyzB,EAASh6B,MAErC,IADA,IAAIs7B,EAAQh6B,EAAO,EACV6B,EAAI,EAAGA,EAAImyB,EAAM/uB,OAAQpD,IAAK,CACrC,IAAIX,EAAO8yB,EAAMnyB,GACjB7B,GAAQkB,EAAKJ,SACTe,GAAKX,EAAK8K,QAAUgoB,EAAMnyB,EAAI,GAAGu2B,WAAWl3B,IACzC84B,IAAUA,EAAShG,EAAM3zB,MAAM,EAAGwB,IACvCm4B,EAAOA,EAAO/0B,OAAS,GAAK/D,EAAK83B,SAASgB,EAAOA,EAAO/0B,OAAS,GAAG2G,KAAO1K,EAAK0K,OACvEouB,GACTA,EAAOx0B,KAAKtE,GAGhB,OAAO,IAAIw3B,EAASsB,GAAUhG,EAAOh0B,IAQvC04B,EAASn4B,KAAO,SAAegM,GAC7B,IAAKA,EAAS,OAAOmsB,EAASh6B,MAC9B,GAAI6N,aAAiBmsB,EAAY,OAAOnsB,EACxC,GAAIwE,MAAMC,QAAQzE,GAAU,OAAO3B,KAAKmvB,UAAUxtB,GAClD,GAAIA,EAAMnG,MAAS,OAAO,IAAIsyB,EAAS,CAACnsB,GAAQA,EAAMzL,UACtD,MAAM,IAAIu4B,WAAW,mBAAqB9sB,EAAQ,kBAC5BA,EAAMjG,aAAe,mEAAqE,MAGlH8C,OAAO6wB,iBAAkBvB,EAASrvB,UAAWsvB,GAE7C,IAAI3wB,EAAQ,CAAClG,MAAO,EAAGwO,OAAQ,GAC/B,SAASqpB,EAAS73B,EAAOwO,GAGvB,OAFAtI,EAAMlG,MAAQA,EACdkG,EAAMsI,OAASA,EACRtI,EAST,SAASkyB,EAAYjP,EAAGrE,GACtB,GAAIqE,IAAMrE,EAAK,OAAO,EACtB,IAAMqE,GAAiB,iBAALA,IACZrE,GAAiB,iBAALA,EAAkB,OAAO,EAC3C,IAAIoN,EAAQjjB,MAAMC,QAAQia,GAC1B,GAAIla,MAAMC,QAAQ4V,IAAMoN,EAAS,OAAO,EACxC,GAAIA,EAAO,CACT,GAAI/I,EAAEhmB,QAAU2hB,EAAE3hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIopB,EAAEhmB,OAAQpD,IAAO,IAAKq4B,EAAYjP,EAAEppB,GAAI+kB,EAAE/kB,IAAO,OAAO,MACvE,CACL,IAAK,IAAI03B,KAAKtO,EAAK,KAAMsO,KAAK3S,KAAOsT,EAAYjP,EAAEsO,GAAI3S,EAAE2S,IAAO,OAAO,EACvE,IAAK,IAAIY,KAAOvT,EAAK,KAAMuT,KAAOlP,GAAM,OAAO,EAEjD,OAAO,EAfTyN,EAASh6B,MAAQ,IAAIg6B,EAAS,GAAI,GAwBlC,IAAI1J,EAAO,SAActvB,EAAM0G,GAG7BwE,KAAKlL,KAAOA,EAGZkL,KAAKxE,MAAQA,GAyGf,SAASg0B,EAAaC,GACpB,IAAIC,EAAM3rB,MAAMpF,KAAKqB,KAAMyvB,GAE3B,OADAC,EAAIptB,UAAYktB,EAAa/wB,UACtBixB,EAnGTtL,EAAK3lB,UAAUkxB,SAAW,SAAmBC,GAE3C,IADA,IAAIr1B,EAAMs1B,GAAS,EACV54B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAAK,CACnC,IAAIk3B,EAAQyB,EAAI34B,GAChB,GAAI+I,KAAKwH,GAAG2mB,GAAU,OAAOyB,EAC7B,GAAI5vB,KAAKlL,KAAKud,SAAS8b,EAAMr5B,MACtByF,IAAQA,EAAOq1B,EAAIn6B,MAAM,EAAGwB,QAC5B,IAAIk3B,EAAMr5B,KAAKud,SAASrS,KAAKlL,MAClC,OAAO86B,GAEFC,GAAU1B,EAAMr5B,KAAKg7B,KAAO9vB,KAAKlL,KAAKg7B,OACpCv1B,IAAQA,EAAOq1B,EAAIn6B,MAAM,EAAGwB,IACjCsD,EAAKK,KAAKoF,MACV6vB,GAAS,GAEPt1B,GAAQA,EAAKK,KAAKuzB,IAK1B,OAFK5zB,IAAQA,EAAOq1B,EAAIn6B,SACnBo6B,GAAUt1B,EAAKK,KAAKoF,MAClBzF,GAMT6pB,EAAK3lB,UAAUsxB,cAAgB,SAAwBH,GACrD,IAAK,IAAI34B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAC5B,GAAI+I,KAAKwH,GAAGooB,EAAI34B,IACd,OAAO24B,EAAIn6B,MAAM,EAAGwB,GAAG81B,OAAO6C,EAAIn6B,MAAMwB,EAAI,IAClD,OAAO24B,GAKTxL,EAAK3lB,UAAUmH,QAAU,SAAkBgqB,GACzC,IAAK,IAAI34B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAC5B,GAAI+I,KAAKwH,GAAGooB,EAAI34B,IAAO,OAAO,EAClC,OAAO,GAMTmtB,EAAK3lB,UAAU+I,GAAK,SAAa2mB,GAC/B,OAAOnuB,MAAQmuB,GACZnuB,KAAKlL,MAAQq5B,EAAMr5B,MAAQw6B,EAAYtvB,KAAKxE,MAAO2yB,EAAM3yB,QAK9D4oB,EAAK3lB,UAAU0W,OAAS,WACtB,IAAI/I,EAAM,CAACtX,KAAMkL,KAAKlL,KAAKmL,MAC3B,IAAK,IAAIypB,KAAK1pB,KAAKxE,MAAO,CACxB4Q,EAAI5Q,MAAQwE,KAAKxE,MACjB,MAEF,OAAO4Q,GAITgY,EAAK8K,SAAW,SAAmB1tB,EAAQwuB,GACzC,IAAKA,EAAQ,MAAM,IAAIvB,WAAW,mCAClC,IAAI35B,EAAO0M,EAAOmD,MAAMqrB,EAAKl7B,MAC7B,IAAKA,EAAQ,MAAM,IAAI25B,WAAY,yBAA4BuB,EAAS,KAAI,mBAC5E,OAAOl7B,EAAKwF,OAAO01B,EAAKx0B,QAK1B4oB,EAAK6L,QAAU,SAAkB5P,EAAGrE,GAClC,GAAIqE,GAAKrE,EAAK,OAAO,EACrB,GAAIqE,EAAEhmB,QAAU2hB,EAAE3hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIopB,EAAEhmB,OAAQpD,IAC1B,IAAKopB,EAAEppB,GAAGuQ,GAAGwU,EAAE/kB,IAAO,OAAO,EACjC,OAAO,GAMTmtB,EAAK8L,QAAU,SAAkBvrB,GAC/B,IAAKA,GAAyB,GAAhBA,EAAMtK,OAAe,OAAO+pB,EAAK+L,KAC/C,GAAIxrB,aAAiByf,EAAQ,MAAO,CAACzf,GACrC,IAAIpK,EAAOoK,EAAMlP,QAEjB,OADA8E,EAAKolB,MAAK,SAAUU,EAAGrE,GAAK,OAAOqE,EAAEvrB,KAAKg7B,KAAO9T,EAAElnB,KAAKg7B,QACjDv1B,GAIT6pB,EAAK+L,KAAO,GAYZX,EAAa/wB,UAAYD,OAAOlE,OAAOyJ,MAAMtF,WAC7C+wB,EAAa/wB,UAAUI,YAAc2wB,EACrCA,EAAa/wB,UAAUwB,KAAO,eAK9B,IAAImwB,EAAQ,SAAej7B,EAASk7B,EAAWC,GAE7CtwB,KAAK7K,QAAUA,EAEf6K,KAAKqwB,UAAYA,EAEjBrwB,KAAKswB,QAAUA,GAGbC,EAAuB,CAAEn7B,KAAM,CAAE44B,cAAc,IA6DnD,SAASwC,EAAYr7B,EAASQ,EAAMD,GAClC,IAAIoB,EAAM3B,EAAQ05B,UAAUl5B,GACxBuB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACbjI,EAAQtI,EAAQu5B,WAAWx3B,GAC3Bu5B,EAAQt7B,EAAQ05B,UAAUn5B,GAC1Bg7B,EAAUD,EAAMv5B,MAChBy5B,EAAWF,EAAM/qB,OACrB,GAAIA,GAAU/P,GAAQ8H,EAAM2D,OAAQ,CAClC,GAAIuvB,GAAYj7B,IAAOP,EAAQsI,MAAMizB,GAAStvB,OAAU,MAAM,IAAIqtB,WAAW,2BAC7E,OAAOt5B,EAAQk5B,IAAI,EAAG14B,GAAMyI,OAAOjJ,EAAQk5B,IAAI34B,IAEjD,GAAIwB,GAASw5B,EAAW,MAAM,IAAIjC,WAAW,2BAC7C,OAAOt5B,EAAQo5B,aAAar3B,EAAOuG,EAAMlD,KAAKi2B,EAAY/yB,EAAMtI,QAASQ,EAAO+P,EAAS,EAAGhQ,EAAKgQ,EAAS,KAG5G,SAASkrB,EAAWz7B,EAAS07B,EAAMh4B,EAAQ3D,GACzC,IAAI4B,EAAM3B,EAAQ05B,UAAUgC,GACxB35B,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACbjI,EAAQtI,EAAQu5B,WAAWx3B,GAC/B,GAAIwO,GAAUmrB,GAAQpzB,EAAM2D,OAC1B,OAAIlM,IAAWA,EAAO0E,WAAW1C,EAAOA,EAAO2B,GAAkB,KAC1D1D,EAAQk5B,IAAI,EAAGwC,GAAMzyB,OAAOvF,GAAQuF,OAAOjJ,EAAQk5B,IAAIwC,IAEhE,IAAI3hB,EAAQ0hB,EAAWnzB,EAAMtI,QAAS07B,EAAOnrB,EAAS,EAAG7M,GACzD,OAAOqW,GAAS/Z,EAAQo5B,aAAar3B,EAAOuG,EAAMlD,KAAK2U,IAOzD,SAASwB,EAAQhY,EAAOC,EAAKlD,GAC3B,GAAIA,EAAM46B,UAAY33B,EAAMtC,MACxB,MAAM,IAAIo5B,EAAa,mDAC3B,GAAI92B,EAAMtC,MAAQX,EAAM46B,WAAa13B,EAAIvC,MAAQX,EAAM66B,QACnD,MAAM,IAAId,EAAa,4BAC3B,OAAOsB,EAAap4B,EAAOC,EAAKlD,EAAO,GAGzC,SAASq7B,EAAap4B,EAAOC,EAAKlD,EAAOW,GACvC,IAAIc,EAAQwB,EAAMxB,MAAMd,GAAQE,EAAOoC,EAAMpC,KAAKF,GAClD,GAAIc,GAASyB,EAAIzB,MAAMd,IAAUA,EAAQsC,EAAMtC,MAAQX,EAAM46B,UAAW,CACtE,IAAInhB,EAAQ4hB,EAAap4B,EAAOC,EAAKlD,EAAOW,EAAQ,GACpD,OAAOE,EAAKiE,KAAKjE,EAAKnB,QAAQo5B,aAAar3B,EAAOgY,IAC7C,GAAKzZ,EAAMN,QAAQC,KAEnB,IAAKK,EAAM46B,WAAc56B,EAAM66B,SAAW53B,EAAMtC,OAASA,GAASuC,EAAIvC,OAASA,EAG/E,CACL,IAAIU,EAgFR,SAAgCrB,EAAOs7B,GAGrC,IAFA,IAAIC,EAAQD,EAAO36B,MAAQX,EAAM46B,UAC7B/5B,EADiDy6B,EAAOz6B,KAAK06B,GAC/Cz2B,KAAK9E,EAAMN,SACpB8B,EAAI+5B,EAAQ,EAAG/5B,GAAK,EAAGA,IAC5BX,EAAOy6B,EAAOz6B,KAAKW,GAAGsD,KAAKuzB,EAASn4B,KAAKW,IAC7C,MAAO,CAAC6E,MAAO7E,EAAK26B,eAAex7B,EAAM46B,UAAYW,GAC7Cj4B,IAAKzC,EAAK26B,eAAe36B,EAAKnB,QAAQC,KAAOK,EAAM66B,QAAUU,IAtFzDE,CAAuBz7B,EAAOiD,GAGxC,OAAO,EAAMpC,EAAM66B,EAAgBz4B,EAFvB5B,EAAIqE,MACNrE,EAAIiC,IACwCJ,EAAKvC,IAN3D,IAAIlB,EAASwD,EAAMxD,OAAQC,EAAUD,EAAOC,QAC5C,OAAO,EAAMD,EAAQC,EAAQk5B,IAAI,EAAG31B,EAAMrE,cAAc+J,OAAO3I,EAAMN,SAASiJ,OAAOjJ,EAAQk5B,IAAI11B,EAAItE,gBAHrG,OAAO,EAAMiC,EAAM86B,EAAc14B,EAAOC,EAAKvC,IAYjD,SAASi7B,EAAUC,EAAMC,GACvB,IAAKA,EAAIz8B,KAAK6E,kBAAkB23B,EAAKx8B,MACjC,MAAM,IAAI06B,EAAa,eAAiB+B,EAAIz8B,KAAKmL,KAAO,SAAWqxB,EAAKx8B,KAAKmL,MAGnF,SAASuxB,EAASC,EAASC,EAAQt7B,GACjC,IAAIE,EAAOm7B,EAAQn7B,KAAKF,GAExB,OADAi7B,EAAU/6B,EAAMo7B,EAAOp7B,KAAKF,IACrBE,EAGT,SAASq7B,EAAQl0B,EAAO/I,GACtB,IAAI0U,EAAO1U,EAAO2F,OAAS,EACvB+O,GAAQ,GAAK3L,EAAM2D,QAAU3D,EAAM+vB,WAAW94B,EAAO0U,IACrD1U,EAAO0U,GAAQ3L,EAAM2wB,SAAS15B,EAAO0U,GAAMpI,KAAOvD,EAAMuD,MAExDtM,EAAOkG,KAAK6C,GAGlB,SAASm0B,EAAS5zB,EAAQ6zB,EAAMz7B,EAAO1B,GACrC,IAAI4B,GAAQu7B,GAAQ7zB,GAAQ1H,KAAKF,GAC7B2G,EAAa,EAAGE,EAAW40B,EAAOA,EAAK36B,MAAMd,GAASE,EAAKM,WAC3DoH,IACFjB,EAAaiB,EAAO9G,MAAMd,GACtB4H,EAAO5H,MAAQA,EACjB2G,IACSiB,EAAO8zB,aAChBH,EAAQ3zB,EAAO3G,UAAW3C,GAC1BqI,MAGJ,IAAK,IAAI9F,EAAI8F,EAAY9F,EAAIgG,EAAUhG,IAAO06B,EAAQr7B,EAAKmH,MAAMxG,GAAIvC,GACjEm9B,GAAQA,EAAKz7B,OAASA,GAASy7B,EAAKC,YACpCH,EAAQE,EAAKh9B,WAAYH,GAG/B,SAAS,EAAM4B,EAAMnB,GACnB,IAAKmB,EAAKxB,KAAKid,aAAa5c,GACxB,MAAM,IAAIq6B,EAAa,4BAA8Bl5B,EAAKxB,KAAKmL,MACnE,OAAO3J,EAAKiE,KAAKpF,GAGnB,SAASg8B,EAAgBz4B,EAAOsF,EAAQ6zB,EAAMl5B,EAAKvC,GACjD,IAAIi6B,EAAY33B,EAAMtC,MAAQA,GAASo7B,EAAS94B,EAAOsF,EAAQ5H,EAAQ,GACnEk6B,EAAU33B,EAAIvC,MAAQA,GAASo7B,EAASK,EAAMl5B,EAAKvC,EAAQ,GAE3DjB,EAAU,GAad,OAZAy8B,EAAS,KAAMl5B,EAAOtC,EAAOjB,GACzBk7B,GAAaC,GAAWtyB,EAAO9G,MAAMd,IAAUy7B,EAAK36B,MAAMd,IAC5Di7B,EAAUhB,EAAWC,GACrBqB,EAAQ,EAAMtB,EAAWc,EAAgBz4B,EAAOsF,EAAQ6zB,EAAMl5B,EAAKvC,EAAQ,IAAKjB,KAE5Ek7B,GACAsB,EAAQ,EAAMtB,EAAWe,EAAc14B,EAAOsF,EAAQ5H,EAAQ,IAAKjB,GACvEy8B,EAAS5zB,EAAQ6zB,EAAMz7B,EAAOjB,GAC1Bm7B,GACAqB,EAAQ,EAAMrB,EAASc,EAAcS,EAAMl5B,EAAKvC,EAAQ,IAAKjB,IAEnEy8B,EAASj5B,EAAK,KAAMvC,EAAOjB,GACpB,IAAI24B,EAAS34B,GAGtB,SAASi8B,EAAc14B,EAAOC,EAAKvC,GACjC,IAAIjB,EAAU,IACdy8B,EAAS,KAAMl5B,EAAOtC,EAAOjB,GACzBuD,EAAMtC,MAAQA,IAEhBu7B,EAAQ,EADGH,EAAS94B,EAAOC,EAAKvC,EAAQ,GACpBg7B,EAAc14B,EAAOC,EAAKvC,EAAQ,IAAKjB,GAG7D,OADAy8B,EAASj5B,EAAK,KAAMvC,EAAOjB,GACpB,IAAI24B,EAAS34B,GA1LtBo7B,EAAqBn7B,KAAKo3B,IAAM,WAC9B,OAAOxsB,KAAK7K,QAAQC,KAAO4K,KAAKqwB,UAAYrwB,KAAKswB,SAGnDF,EAAM3xB,UAAUszB,SAAW,SAAmB97B,EAAKiiB,GACjD,IAAI/iB,EAAUy7B,EAAW5wB,KAAK7K,QAASc,EAAM+J,KAAKqwB,UAAWnY,EAAU,MACvE,OAAO/iB,GAAW,IAAIi7B,EAAMj7B,EAAS6K,KAAKqwB,UAAWrwB,KAAKswB,UAG5DF,EAAM3xB,UAAUuzB,cAAgB,SAAwBr8B,EAAMD,GAC5D,OAAO,IAAI06B,EAAMI,EAAYxwB,KAAK7K,QAASQ,EAAOqK,KAAKqwB,UAAW36B,EAAKsK,KAAKqwB,WAAYrwB,KAAKqwB,UAAWrwB,KAAKswB,UAK/GF,EAAM3xB,UAAU+I,GAAK,SAAa2mB,GAChC,OAAOnuB,KAAK7K,QAAQqS,GAAG2mB,EAAMh5B,UAAY6K,KAAKqwB,WAAalC,EAAMkC,WAAarwB,KAAKswB,SAAWnC,EAAMmC,SAGtGF,EAAM3xB,UAAUC,SAAW,WACzB,OAAOsB,KAAK7K,QAAU,IAAM6K,KAAKqwB,UAAY,IAAMrwB,KAAKswB,QAAU,KAKpEF,EAAM3xB,UAAU0W,OAAS,WACvB,IAAKnV,KAAK7K,QAAQC,KAAQ,OAAO,KACjC,IAAI46B,EAAO,CAAC76B,QAAS6K,KAAK7K,QAAQggB,UAGlC,OAFInV,KAAKqwB,UAAY,IAAKL,EAAKK,UAAYrwB,KAAKqwB,WAC5CrwB,KAAKswB,QAAU,IAAKN,EAAKM,QAAUtwB,KAAKswB,SACrCN,GAKTI,EAAMlB,SAAW,SAAmB1tB,EAAQwuB,GAC1C,IAAKA,EAAQ,OAAOI,EAAMt8B,MAC1B,IAAIu8B,EAAYL,EAAKK,WAAa,EAAGC,EAAUN,EAAKM,SAAW,EAC/D,GAAwB,iBAAbD,GAA2C,iBAAXC,EACvC,MAAM,IAAI7B,WAAW,oCACzB,OAAO,IAAI2B,EAAMtC,EAASoB,SAAS1tB,EAAQwuB,EAAK76B,SAAUk7B,EAAWC,IAMvEF,EAAM6B,QAAU,SAAkB/Z,EAAUga,QACjB,IAAlBA,IAA2BA,GAAc,GAGhD,IADA,IAAI7B,EAAY,EAAGC,EAAU,EACpB3f,EAAIuH,EAASzhB,WAAYka,IAAMA,EAAE4V,SAAW2L,IAAkBvhB,EAAE7b,KAAKC,KAAKC,WAAY2b,EAAIA,EAAEla,WAAc45B,IACnH,IAAK,IAAI8B,EAAMja,EAASxhB,UAAWy7B,IAAQA,EAAI5L,SAAW2L,IAAkBC,EAAIr9B,KAAKC,KAAKC,WAAYm9B,EAAMA,EAAIz7B,UAAa45B,IAC7H,OAAO,IAAIF,EAAMlY,EAAUmY,EAAWC,IAGxC9xB,OAAO6wB,iBAAkBe,EAAM3xB,UAAW8xB,GAiC1CH,EAAMt8B,MAAQ,IAAIs8B,EAAMtC,EAASh6B,MAAO,EAAG,GAsH3C,IAAIs+B,EAAc,SAAqBn8B,EAAKo8B,EAAMh+B,GAEhD2L,KAAK/J,IAAMA,EACX+J,KAAKqyB,KAAOA,EAKZryB,KAAK5J,MAAQi8B,EAAKh4B,OAAS,EAAI,EAE/B2F,KAAK3L,aAAeA,GAGlBi+B,EAAuB,CAAEp9B,OAAQ,CAAE84B,cAAc,GAAOz4B,IAAK,CAAEy4B,cAAc,GAAO8D,WAAY,CAAE9D,cAAc,GAAO32B,UAAW,CAAE22B,cAAc,GAAOn5B,WAAY,CAAEm5B,cAAc,IAEzLoE,EAAY3zB,UAAU8zB,aAAe,SAAuBC,GAC1D,OAAW,MAAPA,EAAsBxyB,KAAK5J,MAC3Bo8B,EAAM,EAAYxyB,KAAK5J,MAAQo8B,EAC5BA,GAOTF,EAAqBp9B,OAAOs3B,IAAM,WAAc,OAAOxsB,KAAK1J,KAAK0J,KAAK5J,QAItEk8B,EAAqB/8B,IAAIi3B,IAAM,WAAc,OAAOxsB,KAAK1J,KAAK,IAK9D87B,EAAY3zB,UAAUnI,KAAO,SAAeF,GAAS,OAAO4J,KAAKqyB,KAAgC,EAA3BryB,KAAKuyB,aAAan8B,KAMxFg8B,EAAY3zB,UAAUvH,MAAQ,SAAgBd,GAAS,OAAO4J,KAAKqyB,KAAgC,EAA3BryB,KAAKuyB,aAAan8B,GAAa,IAKvGg8B,EAAY3zB,UAAUtG,WAAa,SAAqB/B,GAEtD,OADAA,EAAQ4J,KAAKuyB,aAAan8B,GACnB4J,KAAK9I,MAAMd,IAAUA,GAAS4J,KAAK5J,OAAU4J,KAAK8xB,WAAiB,EAAJ,IAMxEM,EAAY3zB,UAAUtD,MAAQ,SAAgB/E,GAE5C,OAAgB,IADhBA,EAAQ4J,KAAKuyB,aAAan8B,IACN,EAAI4J,KAAKqyB,KAAa,EAARj8B,EAAY,GAAK,GAMrDg8B,EAAY3zB,UAAU1F,IAAM,SAAc3C,GAExC,OADAA,EAAQ4J,KAAKuyB,aAAan8B,GACnB4J,KAAK7E,MAAM/E,GAAS4J,KAAK1J,KAAKF,GAAOjB,QAAQC,MAOtDg9B,EAAY3zB,UAAU7J,OAAS,SAAiBwB,GAE9C,KADAA,EAAQ4J,KAAKuyB,aAAan8B,IACZ,MAAM,IAAIq4B,WAAW,kDACnC,OAAOr4B,GAAS4J,KAAK5J,MAAQ,EAAI4J,KAAK/J,IAAM+J,KAAKqyB,KAAa,EAARj8B,EAAY,IAMpEg8B,EAAY3zB,UAAUjJ,MAAQ,SAAgBY,GAE5C,KADAA,EAAQ4J,KAAKuyB,aAAan8B,IACZ,MAAM,IAAIq4B,WAAW,iDACnC,OAAOr4B,GAAS4J,KAAK5J,MAAQ,EAAI4J,KAAK/J,IAAM+J,KAAKqyB,KAAa,EAARj8B,EAAY,GAAK4J,KAAKqyB,KAAa,EAARj8B,GAAWF,UAO9Fo8B,EAAqBR,WAAWtF,IAAM,WAAc,OAAOxsB,KAAK/J,IAAM+J,KAAKqyB,KAAKryB,KAAKqyB,KAAKh4B,OAAS,IAMnGi4B,EAAqBj7B,UAAUm1B,IAAM,WACnC,IAAIt3B,EAAS8K,KAAK9K,OAAQgC,EAAQ8I,KAAK9I,MAAM8I,KAAK5J,OAClD,GAAIc,GAAShC,EAAO0B,WAAc,OAAO,KACzC,IAAI67B,EAAOzyB,KAAK/J,IAAM+J,KAAKqyB,KAAKryB,KAAKqyB,KAAKh4B,OAAS,GAAIoD,EAAQvI,EAAOuI,MAAMvG,GAC5E,OAAOu7B,EAAOv9B,EAAOuI,MAAMvG,GAAOm3B,IAAIoE,GAAQh1B,GAOhD60B,EAAqBz9B,WAAW23B,IAAM,WACpC,IAAIt1B,EAAQ8I,KAAK9I,MAAM8I,KAAK5J,OACxBq8B,EAAOzyB,KAAK/J,IAAM+J,KAAKqyB,KAAKryB,KAAKqyB,KAAKh4B,OAAS,GACnD,OAAIo4B,EAAezyB,KAAK9K,OAAOuI,MAAMvG,GAAOm3B,IAAI,EAAGoE,GACnC,GAATv7B,EAAa,KAAO8I,KAAK9K,OAAOuI,MAAMvG,EAAQ,IAMvDk7B,EAAY3zB,UAAUi0B,WAAa,SAAqBx7B,EAAOd,GAC7DA,EAAQ4J,KAAKuyB,aAAan8B,GAE1B,IADA,IAAIE,EAAO0J,KAAKqyB,KAAa,EAARj8B,GAAYH,EAAe,GAATG,EAAa,EAAI4J,KAAKqyB,KAAa,EAARj8B,EAAY,GAAK,EAC1Ea,EAAI,EAAGA,EAAIC,EAAOD,IAAOhB,GAAOK,EAAKmH,MAAMxG,GAAGf,SACvD,OAAOD,GAQTm8B,EAAY3zB,UAAUkG,MAAQ,WAC5B,IAAIzP,EAAS8K,KAAK9K,OAAQgC,EAAQ8I,KAAK9I,QAGvC,GAA2B,GAAvBhC,EAAOC,QAAQC,KAAa,OAAOgvB,EAAK+L,KAG5C,GAAInwB,KAAK8xB,WAAc,OAAO58B,EAAOuI,MAAMvG,GAAOyN,MAElD,IAAI2sB,EAAOp8B,EAAOw5B,WAAWx3B,EAAQ,GAAIi3B,EAAQj5B,EAAOw5B,WAAWx3B,GAGnE,IAAKo6B,EAAM,CAAE,IAAIqB,EAAMrB,EAAMA,EAAOnD,EAAOA,EAAQwE,EAKnD,IADA,IAAIhuB,EAAQ2sB,EAAK3sB,MACR1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,KACO,IAAjC0N,EAAM1N,GAAGnC,KAAKC,KAAK0pB,WAAyB0P,GAAUxpB,EAAM1N,GAAG2O,QAAQuoB,EAAMxpB,SAC/EA,EAAQA,EAAM1N,KAAK84B,cAAcprB,IAEvC,OAAOA,GAUTytB,EAAY3zB,UAAUm0B,YAAc,SAAsBf,GACxD,IAAIr8B,EAAQwK,KAAK9K,OAAOw5B,WAAW1uB,KAAK9I,SACxC,IAAK1B,IAAUA,EAAM0F,SAAY,OAAO,KAGxC,IADA,IAAIyJ,EAAQnP,EAAMmP,MAAOkuB,EAAOhB,EAAK38B,OAAOw5B,WAAWmD,EAAK36B,SACnDD,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,KACO,IAAjC0N,EAAM1N,GAAGnC,KAAKC,KAAK0pB,WAAyBoU,GAASluB,EAAM1N,GAAG2O,QAAQitB,EAAKluB,SAC7EA,EAAQA,EAAM1N,KAAK84B,cAAcprB,IACvC,OAAOA,GAMTytB,EAAY3zB,UAAU6O,YAAc,SAAsBrX,GACxD,IAAK,IAAIG,EAAQ4J,KAAK5J,MAAOA,EAAQ,EAAGA,IACpC,GAAI4J,KAAK7E,MAAM/E,IAAUH,GAAO+J,KAAKjH,IAAI3C,IAAUH,EAAO,OAAOG,EACrE,OAAO,GAWTg8B,EAAY3zB,UAAUhK,WAAa,SAAqB05B,EAAO2E,GAG7D,QAFiB,IAAV3E,IAAmBA,EAAQnuB,MAE9BmuB,EAAMl4B,IAAM+J,KAAK/J,IAAO,OAAOk4B,EAAM15B,WAAWuL,MACpD,IAAK,IAAIqQ,EAAIrQ,KAAK5J,OAAS4J,KAAK9K,OAAO0D,eAAiBoH,KAAK/J,KAAOk4B,EAAMl4B,IAAM,EAAI,GAAIoa,GAAK,EAAGA,IAC5F,GAAI8d,EAAMl4B,KAAO+J,KAAKjH,IAAIsX,MAAQyiB,GAAQA,EAAK9yB,KAAK1J,KAAK+Z,KACvD,OAAO,IAAI0iB,EAAU/yB,KAAMmuB,EAAO9d,IAK1C+hB,EAAY3zB,UAAU/G,WAAa,SAAqBy2B,GACtD,OAAOnuB,KAAK/J,IAAM+J,KAAK3L,cAAgB85B,EAAMl4B,IAAMk4B,EAAM95B,cAK3D+9B,EAAY3zB,UAAU6C,IAAM,SAAc6sB,GACxC,OAAOA,EAAMl4B,IAAM+J,KAAK/J,IAAMk4B,EAAQnuB,MAKxCoyB,EAAY3zB,UAAU0D,IAAM,SAAcgsB,GACxC,OAAOA,EAAMl4B,IAAM+J,KAAK/J,IAAMk4B,EAAQnuB,MAGxCoyB,EAAY3zB,UAAUC,SAAW,WAE/B,IADA,IAAIs0B,EAAM,GACD/7B,EAAI,EAAGA,GAAK+I,KAAK5J,MAAOa,IAC7B+7B,IAAQA,EAAM,IAAM,IAAMhzB,KAAK1J,KAAKW,GAAGnC,KAAKmL,KAAO,IAAMD,KAAK9I,MAAMD,EAAI,GAC5E,OAAO+7B,EAAM,IAAMhzB,KAAK3L,cAG1B+9B,EAAYt8B,QAAU,SAAkBP,EAAKU,GAC3C,KAAMA,GAAO,GAAKA,GAAOV,EAAIJ,QAAQC,MAAS,MAAM,IAAIq5B,WAAW,YAAcx4B,EAAM,iBAGvF,IAFA,IAAIo8B,EAAO,GACPl3B,EAAQ,EAAG9G,EAAe4B,EACrBK,EAAOf,IAAO,CACrB,IAAIuB,EAAMR,EAAKnB,QAAQ05B,UAAUx6B,GAC3B6C,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACfutB,EAAM5+B,EAAeqR,EAEzB,GADA2sB,EAAKz3B,KAAKtE,EAAMY,EAAOiE,EAAQuK,IAC1ButB,EAAO,MAEZ,IADA38B,EAAOA,EAAKmH,MAAMvG,IACTkK,OAAU,MACnB/M,EAAe4+B,EAAM,EACrB93B,GAASuK,EAAS,EAEpB,OAAO,IAAI0sB,EAAYn8B,EAAKo8B,EAAMh+B,IAGpC+9B,EAAYc,cAAgB,SAAwB39B,EAAKU,GACvD,IAAK,IAAIgB,EAAI,EAAGA,EAAIk8B,EAAa94B,OAAQpD,IAAK,CAC5C,IAAIm8B,EAASD,EAAal8B,GAC1B,GAAIm8B,EAAOn9B,KAAOA,GAAOm9B,EAAO79B,KAAOA,EAAO,OAAO69B,EAEvD,IAAI/oB,EAAS8oB,EAAaE,GAAmBjB,EAAYt8B,QAAQP,EAAKU,GAEtE,OADAo9B,GAAmBA,EAAkB,GAAKC,EACnCjpB,GAGT7L,OAAO6wB,iBAAkB+C,EAAY3zB,UAAW6zB,GAEhD,IAAIa,EAAe,GAAIE,EAAkB,EAAGC,EAAmB,GAI3DP,EAAY,SAAmBr6B,EAAOC,EAAKvC,GAM7C4J,KAAKtH,MAAQA,EAGbsH,KAAKrH,IAAMA,EAEXqH,KAAK5J,MAAQA,GAGXm9B,EAAyB,CAAEp4B,MAAO,CAAE6yB,cAAc,GAAOj1B,IAAK,CAAEi1B,cAAc,GAAO94B,OAAQ,CAAE84B,cAAc,GAAOjxB,WAAY,CAAEixB,cAAc,GAAO/wB,SAAU,CAAE+wB,cAAc,IAGrLuF,EAAuBp4B,MAAMqxB,IAAM,WAAc,OAAOxsB,KAAKtH,MAAM9D,OAAOoL,KAAK5J,MAAQ,IAEvFm9B,EAAuBx6B,IAAIyzB,IAAM,WAAc,OAAOxsB,KAAKrH,IAAInD,MAAMwK,KAAK5J,MAAQ,IAGlFm9B,EAAuBr+B,OAAOs3B,IAAM,WAAc,OAAOxsB,KAAKtH,MAAMpC,KAAK0J,KAAK5J,QAE9Em9B,EAAuBx2B,WAAWyvB,IAAM,WAAc,OAAOxsB,KAAKtH,MAAMxB,MAAM8I,KAAK5J,QAEnFm9B,EAAuBt2B,SAASuvB,IAAM,WAAc,OAAOxsB,KAAKrH,IAAIR,WAAW6H,KAAK5J,QAEpFoI,OAAO6wB,iBAAkB0D,EAAUt0B,UAAW80B,GAE9C,IAAIC,EAAah1B,OAAOlE,OAAO,MAc3B6pB,EAAO,SAAcrvB,EAAM0G,EAAOrG,EAASwP,GAG7C3E,KAAKlL,KAAOA,EAMZkL,KAAKxE,MAAQA,EAIbwE,KAAK7K,QAAUA,GAAW24B,EAASh6B,MAKnCkM,KAAK2E,MAAQA,GAASyf,EAAK+L,MAGzBsD,EAAuB,CAAEv9B,SAAU,CAAE83B,cAAc,GAAOp3B,WAAY,CAAEo3B,cAAc,GAAOzX,YAAa,CAAEyX,cAAc,GAAOv3B,WAAY,CAAEu3B,cAAc,GAAOt3B,UAAW,CAAEs3B,cAAc,GAAO90B,QAAS,CAAE80B,cAAc,GAAOr3B,YAAa,CAAEq3B,cAAc,GAAOp1B,cAAe,CAAEo1B,cAAc,GAAO9yB,SAAU,CAAE8yB,cAAc,GAAO5sB,OAAQ,CAAE4sB,cAAc,GAAOzH,OAAQ,CAAEyH,cAAc,GAAO73B,OAAQ,CAAE63B,cAAc,IAW3ayF,EAAqBv9B,SAASs2B,IAAM,WAAc,OAAOxsB,KAAKumB,OAAS,EAAI,EAAIvmB,KAAK7K,QAAQC,MAI5Fq+B,EAAqB78B,WAAW41B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQyB,YAKxEutB,EAAK1lB,UAAUhB,MAAQ,SAAgBvG,GAAS,OAAO8I,KAAK7K,QAAQsI,MAAMvG,IAI1EitB,EAAK1lB,UAAUiwB,WAAa,SAAqBx3B,GAAS,OAAO8I,KAAK7K,QAAQu5B,WAAWx3B,IAKzFitB,EAAK1lB,UAAUU,QAAU,SAAkBgM,GAAKnL,KAAK7K,QAAQgK,QAAQgM,IAUrEgZ,EAAK1lB,UAAU/C,aAAe,SAAuB/F,EAAMD,EAAIyV,EAAG1F,QAC5C,IAAbA,IAAsBA,EAAW,GAExCzF,KAAK7K,QAAQuG,aAAa/F,EAAMD,EAAIyV,EAAG1F,EAAUzF,OAMnDmkB,EAAK1lB,UAAUkqB,YAAc,SAAsBxd,GACjDnL,KAAKtE,aAAa,EAAGsE,KAAK7K,QAAQC,KAAM+V,IAM1CsoB,EAAqBld,YAAYiW,IAAM,WAAc,OAAOxsB,KAAKyX,YAAY,EAAGzX,KAAK7K,QAAQC,KAAM,KAOnG+uB,EAAK1lB,UAAUgZ,YAAc,SAAsB9hB,EAAMD,EAAIoL,EAAgBotB,GAC3E,OAAOluB,KAAK7K,QAAQsiB,YAAY9hB,EAAMD,EAAIoL,EAAgBotB,IAM5DuF,EAAqBh9B,WAAW+1B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQsB,YAKxEg9B,EAAqB/8B,UAAU81B,IAAM,WAAc,OAAOxsB,KAAK7K,QAAQuB,WAIvEytB,EAAK1lB,UAAU+I,GAAK,SAAa2mB,GAC/B,OAAOnuB,MAAQmuB,GAAUnuB,KAAKwtB,WAAWW,IAAUnuB,KAAK7K,QAAQqS,GAAG2mB,EAAMh5B,UAM3EgvB,EAAK1lB,UAAU+uB,WAAa,SAAqBW,GAC/C,OAAOnuB,KAAKrE,UAAUwyB,EAAMr5B,KAAMq5B,EAAM3yB,MAAO2yB,EAAMxpB,QAMvDwf,EAAK1lB,UAAU9C,UAAY,SAAoB7G,EAAM0G,EAAOmJ,GAC1D,OAAO3E,KAAKlL,MAAQA,GAClBw6B,EAAYtvB,KAAKxE,MAAOA,GAAS1G,EAAK4+B,cAAgBF,IACtDpP,EAAK6L,QAAQjwB,KAAK2E,MAAOA,GAASyf,EAAK+L,OAM3ChM,EAAK1lB,UAAUlE,KAAO,SAAepF,GAGnC,YAFmB,IAAZA,IAAqBA,EAAU,MAElCA,GAAW6K,KAAK7K,QAAkB6K,KAC/B,IAAIA,KAAKnB,YAAYmB,KAAKlL,KAAMkL,KAAKxE,MAAOrG,EAAS6K,KAAK2E,QAMnEwf,EAAK1lB,UAAU+G,KAAO,SAAeb,GACnC,OAAOA,GAAS3E,KAAK2E,MAAQ3E,KAAO,IAAIA,KAAKnB,YAAYmB,KAAKlL,KAAMkL,KAAKxE,MAAOwE,KAAK7K,QAASwP,IAOhGwf,EAAK1lB,UAAU4vB,IAAM,SAAc14B,EAAMD,GACvC,OAAY,GAARC,GAAaD,GAAMsK,KAAK7K,QAAQC,KAAe4K,KAC5CA,KAAKzF,KAAKyF,KAAK7K,QAAQk5B,IAAI14B,EAAMD,KAM1CyuB,EAAK1lB,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIi+B,GAI/C,QAHc,IAAPj+B,IAAgBA,EAAKsK,KAAK7K,QAAQC,WACf,IAAnBu+B,IAA4BA,GAAiB,GAEhDh+B,GAAQD,EAAM,OAAO06B,EAAMt8B,MAE/B,IAAI4E,EAAQsH,KAAKlK,QAAQH,GAAOgD,EAAMqH,KAAKlK,QAAQJ,GAC/CU,EAAQu9B,EAAiB,EAAIj7B,EAAM4U,YAAY5X,GAC/CyF,EAAQzC,EAAMyC,MAAM/E,GACpBjB,EADmCuD,EAAMpC,KAAKF,GAC/BjB,QAAQk5B,IAAI31B,EAAMzC,IAAMkF,EAAOxC,EAAI1C,IAAMkF,GAC5D,OAAO,IAAIi1B,EAAMj7B,EAASuD,EAAMtC,MAAQA,EAAOuC,EAAIvC,MAAQA,IAU7D+tB,EAAK1lB,UAAUiS,QAAU,SAAoB/a,EAAMD,EAAID,GACrD,OAAOib,EAAQ1Q,KAAKlK,QAAQH,GAAOqK,KAAKlK,QAAQJ,GAAKD,IAKvD0uB,EAAK1lB,UAAU+S,OAAS,SAAiBvb,GACvC,IAAK,IAAIK,EAAO0J,OAAQ,CACtB,IAAIlJ,EAAMR,EAAKnB,QAAQ05B,UAAU54B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OAEnB,KADApP,EAAOA,EAAKo4B,WAAWx3B,IACV,OAAO,KACpB,GAAIwO,GAAUzP,GAAOK,EAAK8K,OAAU,OAAO9K,EAC3CL,GAAOyP,EAAS,IAQpBye,EAAK1lB,UAAU8G,WAAa,SAAqBtP,GAC/C,IAAIa,EAAMkJ,KAAK7K,QAAQ05B,UAAU54B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACnB,MAAO,CAACpP,KAAM0J,KAAK7K,QAAQu5B,WAAWx3B,GAAQA,MAAOA,EAAOwO,OAAQA,IAOtEye,EAAK1lB,UAAUm1B,YAAc,SAAsB39B,GACjD,GAAW,GAAPA,EAAY,MAAO,CAACK,KAAM,KAAMY,MAAO,EAAGwO,OAAQ,GACtD,IAAI5O,EAAMkJ,KAAK7K,QAAQ05B,UAAU54B,GAC3BiB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OACnB,GAAIA,EAASzP,EAAO,MAAO,CAACK,KAAM0J,KAAK7K,QAAQsI,MAAMvG,GAAQA,MAAOA,EAAOwO,OAAQA,GACnF,IAAIpP,EAAO0J,KAAK7K,QAAQsI,MAAMvG,EAAQ,GACtC,MAAO,CAACZ,KAAMA,EAAMY,MAAOA,EAAQ,EAAGwO,OAAQA,EAASpP,EAAKJ,WAM9DiuB,EAAK1lB,UAAU3I,QAAU,SAAkBG,GAAO,OAAOm8B,EAAYc,cAAclzB,KAAM/J,IAEzFkuB,EAAK1lB,UAAUwyB,eAAiB,SAAyBh7B,GAAO,OAAOm8B,EAAYt8B,QAAQkK,KAAM/J,IAKjGkuB,EAAK1lB,UAAUo1B,aAAe,SAAuBl+B,EAAMD,EAAIZ,GAC7D,IAAIsI,GAAQ,EAKZ,OAJI1H,EAAKC,GAAQqK,KAAKtE,aAAa/F,EAAMD,GAAI,SAAUY,GAErD,OADIxB,EAAK8Q,QAAQtP,EAAKqO,SAAUvH,GAAQ,IAChCA,KAEHA,GAKTq2B,EAAqBv6B,QAAQszB,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKoE,SAKlEu6B,EAAqB98B,YAAY61B,IAAM,WAAc,OAAOxsB,KAAKlL,KAAK6B,aAItE88B,EAAqB76B,cAAc4zB,IAAM,WAAc,OAAOxsB,KAAKlL,KAAK8D,eAKxE66B,EAAqBv4B,SAASsxB,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKoG,UAInEu4B,EAAqBryB,OAAOorB,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKsM,QAIjEqyB,EAAqBlN,OAAOiG,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKyxB,QAQjEkN,EAAqBt9B,OAAOq2B,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKqB,QAKjEguB,EAAK1lB,UAAUC,SAAW,WACxB,GAAIsB,KAAKlL,KAAKC,KAAK++B,cAAiB,OAAO9zB,KAAKlL,KAAKC,KAAK++B,cAAc9zB,MACxE,IAAIC,EAAOD,KAAKlL,KAAKmL,KAGrB,OAFID,KAAK7K,QAAQC,OACb6K,GAAQ,IAAMD,KAAK7K,QAAQ85B,gBAAkB,KAC1C8E,EAAU/zB,KAAK2E,MAAO1E,IAK/BkkB,EAAK1lB,UAAUrG,eAAiB,SAAyBlB,GACvD,IAAIW,EAAQmI,KAAKlL,KAAK2b,aAAaujB,cAAch0B,KAAK7K,QAAS,EAAG+B,GAClE,IAAKW,EAAS,MAAM,IAAIkM,MAAM,wDAC9B,OAAOlM,GASTssB,EAAK1lB,UAAU7E,WAAa,SAAqBjE,EAAMD,EAAIu+B,EAAa94B,EAAOpC,QACtD,IAAhBk7B,IAAyBA,EAAcnG,EAASh6B,YACtC,IAAVqH,IAAmBA,EAAQ,QACnB,IAARpC,IAAiBA,EAAMk7B,EAAYr9B,YAE1C,IAAIs9B,EAAMl0B,KAAK5H,eAAezC,GAAMq+B,cAAcC,EAAa94B,EAAOpC,GAClEo7B,EAAMD,GAAOA,EAAIF,cAAch0B,KAAK7K,QAASO,GACjD,IAAKy+B,IAAQA,EAAIh6B,SAAY,OAAO,EACpC,IAAK,IAAIlD,EAAIkE,EAAOlE,EAAI8B,EAAK9B,IAAO,IAAK+I,KAAKlL,KAAKs/B,YAAYH,EAAYx2B,MAAMxG,GAAG0N,OAAU,OAAO,EACrG,OAAO,GAMTwf,EAAK1lB,UAAUpG,eAAiB,SAAyB1C,EAAMD,EAAIZ,EAAM6P,GACvE,GAAIA,IAAU3E,KAAKlL,KAAKs/B,YAAYzvB,GAAU,OAAO,EACrD,IAAIxJ,EAAQ6E,KAAK5H,eAAezC,GAAMuE,UAAUpF,GAC5CiE,EAAMoC,GAASA,EAAM64B,cAAch0B,KAAK7K,QAASO,GACrD,QAAOqD,GAAMA,EAAIoB,UAQnBgqB,EAAK1lB,UAAU41B,UAAY,SAAoBlG,GAC7C,OAAIA,EAAMh5B,QAAQC,KAAe4K,KAAKpG,WAAWoG,KAAKpJ,WAAYoJ,KAAKpJ,WAAYu3B,EAAMh5B,SAC3E6K,KAAKlL,KAAK6E,kBAAkBw0B,EAAMr5B,OAMlDqvB,EAAK1lB,UAAUwK,MAAQ,WACrB,IAAKjJ,KAAKlL,KAAKid,aAAa/R,KAAK7K,SAC7B,MAAM,IAAIs5B,WAAY,4BAA+BzuB,KAAKlL,KAAS,KAAI,KAAQkL,KAAK7K,QAAQuJ,WAAWjJ,MAAM,EAAG,KAEpH,IADA,IAAI8E,EAAO6pB,EAAK+L,KACPl5B,EAAI,EAAGA,EAAI+I,KAAK2E,MAAMtK,OAAQpD,IAAOsD,EAAOyF,KAAK2E,MAAM1N,GAAG04B,SAASp1B,GAC5E,IAAK6pB,EAAK6L,QAAQ11B,EAAMyF,KAAK2E,OACzB,MAAM,IAAI8pB,WAAY,wCAA2CzuB,KAAKlL,KAAS,KAAI,KAAQkL,KAAK2E,MAAM3O,KAAI,SAAUs+B,GAAK,OAAOA,EAAEx/B,KAAKmL,SAC3ID,KAAK7K,QAAQgK,SAAQ,SAAU7I,GAAQ,OAAOA,EAAK2S,YAKrDkb,EAAK1lB,UAAU0W,OAAS,WACtB,IAAI/I,EAAM,CAACtX,KAAMkL,KAAKlL,KAAKmL,MAC3B,IAAK,IAAIypB,KAAK1pB,KAAKxE,MAAO,CACxB4Q,EAAI5Q,MAAQwE,KAAKxE,MACjB,MAMF,OAJIwE,KAAK7K,QAAQC,OACbgX,EAAIjX,QAAU6K,KAAK7K,QAAQggB,UAC3BnV,KAAK2E,MAAMtK,SACX+R,EAAIzH,MAAQ3E,KAAK2E,MAAM3O,KAAI,SAAU2a,GAAK,OAAOA,EAAEwE,aAChD/I,GAKT+X,EAAK+K,SAAW,SAAmB1tB,EAAQwuB,GACzC,IAAKA,EAAQ,MAAM,IAAIvB,WAAW,mCAClC,IAAI9pB,EAAQ,KACZ,GAAIqrB,EAAKrrB,MAAO,CACd,IAAKwB,MAAMC,QAAQ4pB,EAAKrrB,OAAU,MAAM,IAAI8pB,WAAW,uCACvD9pB,EAAQqrB,EAAKrrB,MAAM3O,IAAIwL,EAAO+yB,cAEhC,GAAiB,QAAbvE,EAAKl7B,KAAgB,CACvB,GAAwB,iBAAbk7B,EAAKhvB,KAAoB,MAAM,IAAIytB,WAAW,6BACzD,OAAOjtB,EAAOR,KAAKgvB,EAAKhvB,KAAM2D,GAEhC,IAAIxP,EAAU24B,EAASoB,SAAS1tB,EAAQwuB,EAAK76B,SAC7C,OAAOqM,EAAOjG,SAASy0B,EAAKl7B,MAAMwF,OAAO01B,EAAKx0B,MAAOrG,EAASwP,IAGhEnG,OAAO6wB,iBAAkBlL,EAAK1lB,UAAWg1B,GAEzC,IAAIe,EAAyB,SAAUrQ,GACrC,SAASqQ,EAAS1/B,EAAM0G,EAAOrG,EAASwP,GAGtC,GAFAwf,EAAKxlB,KAAKqB,KAAMlL,EAAM0G,EAAO,KAAMmJ,IAE9BxP,EAAW,MAAM,IAAIs5B,WAAW,oCAErCzuB,KAAKgB,KAAO7L,EAGTgvB,IAAOqQ,EAASlyB,UAAY6hB,GACjCqQ,EAAS/1B,UAAYD,OAAOlE,OAAQ6pB,GAAQA,EAAK1lB,WACjD+1B,EAAS/1B,UAAUI,YAAc21B,EAEjC,IAAIjE,EAAuB,CAAEha,YAAa,CAAEyX,cAAc,GAAO93B,SAAU,CAAE83B,cAAc,IA0C3F,OAxCAwG,EAAS/1B,UAAUC,SAAW,WAC5B,OAAIsB,KAAKlL,KAAKC,KAAK++B,cAAwB9zB,KAAKlL,KAAKC,KAAK++B,cAAc9zB,MACjE+zB,EAAU/zB,KAAK2E,MAAOmU,KAAKC,UAAU/Y,KAAKgB,QAGnDuvB,EAAqBha,YAAYiW,IAAM,WAAc,OAAOxsB,KAAKgB,MAEjEwzB,EAAS/1B,UAAUgZ,YAAc,SAAsB9hB,EAAMD,GAAM,OAAOsK,KAAKgB,KAAKvL,MAAME,EAAMD,IAEhG66B,EAAqBr6B,SAASs2B,IAAM,WAAc,OAAOxsB,KAAKgB,KAAK3G,QAEnEm6B,EAAS/1B,UAAU+G,KAAO,SAAeb,GACvC,OAAOA,GAAS3E,KAAK2E,MAAQ3E,KAAO,IAAIw0B,EAASx0B,KAAKlL,KAAMkL,KAAKxE,MAAOwE,KAAKgB,KAAM2D,IAGrF6vB,EAAS/1B,UAAU2vB,SAAW,SAAmBptB,GAC/C,OAAIA,GAAQhB,KAAKgB,KAAehB,KACzB,IAAIw0B,EAASx0B,KAAKlL,KAAMkL,KAAKxE,MAAOwF,EAAMhB,KAAK2E,QAGxD6vB,EAAS/1B,UAAU4vB,IAAM,SAAc14B,EAAMD,GAI3C,YAHc,IAATC,IAAkBA,EAAO,QAClB,IAAPD,IAAgBA,EAAKsK,KAAKgB,KAAK3G,QAExB,GAAR1E,GAAaD,GAAMsK,KAAKgB,KAAK3G,OAAiB2F,KAC3CA,KAAKouB,SAASpuB,KAAKgB,KAAKvL,MAAME,EAAMD,KAG7C8+B,EAAS/1B,UAAU+I,GAAK,SAAa2mB,GACnC,OAAOnuB,KAAKwtB,WAAWW,IAAUnuB,KAAKgB,MAAQmtB,EAAMntB,MAGtDwzB,EAAS/1B,UAAU0W,OAAS,WAC1B,IAAI8V,EAAO9G,EAAK1lB,UAAU0W,OAAOxW,KAAKqB,MAEtC,OADAirB,EAAKjqB,KAAOhB,KAAKgB,KACViqB,GAGTzsB,OAAO6wB,iBAAkBmF,EAAS/1B,UAAW8xB,GAEtCiE,EAvDmB,CAwD1BrQ,GAEF,SAAS4P,EAAUpvB,EAAOquB,GACxB,IAAK,IAAI/7B,EAAI0N,EAAMtK,OAAS,EAAGpD,GAAK,EAAGA,IACnC+7B,EAAMruB,EAAM1N,GAAGnC,KAAKmL,KAAO,IAAM+yB,EAAM,IAC3C,OAAOA,EAOT,IAAIyB,EAAe,SAAsBt6B,GAGvC6F,KAAK7F,SAAWA,EAChB6F,KAAK6yB,KAAO,GACZ7yB,KAAK00B,UAAY,IAGfC,EAAuB,CAAE/7B,cAAe,CAAEo1B,cAAc,GAAOxqB,YAAa,CAAEwqB,cAAc,GAAOl2B,UAAW,CAAEk2B,cAAc,IAElIyG,EAAa/rB,MAAQ,SAAgB4f,EAAQsM,GAC3C,IAAIC,EAAS,IAAIC,EAAYxM,EAAQsM,GACrC,GAAmB,MAAfC,EAAOhC,KAAgB,OAAO4B,EAAa3gC,MAC/C,IAAIihC,EAAOC,EAAUH,GACjBA,EAAOhC,MAAQgC,EAAOnF,IAAI,4BAC9B,IAAI73B,EAuVN,SAAao9B,GACX,IAAIC,EAAU12B,OAAOlE,OAAO,MAC5B,OAAO66B,EAAQC,EAASH,EAAK,IAE7B,SAASE,EAAQE,GACf,IAAIC,EAAM,GACVD,EAAOl2B,SAAQ,SAAU7I,GACvB2+B,EAAI3+B,GAAM6I,SAAQ,SAAUrI,GAC1B,IAAIy+B,EAAOz+B,EAAIy+B,KACX7/B,EAAKoB,EAAIpB,GAEb,GAAK6/B,EAAL,CACA,IAAIC,EAAQF,EAAItV,QAAQuV,GAAO3F,EAAM4F,GAAS,GAAKF,EAAIE,EAAQ,GAC/DJ,EAASH,EAAKv/B,GAAIyJ,SAAQ,SAAU7I,GAC7Bs5B,GAAO0F,EAAI16B,KAAK26B,EAAM3F,EAAM,KACP,GAAtBA,EAAI5P,QAAQ1pB,IAAes5B,EAAIh1B,KAAKtE,aAK9C,IADA,IAAI3C,EAAQuhC,EAAQG,EAAOv7B,KAAK,MAAQ,IAAI26B,EAAaY,EAAOrV,QAAQiV,EAAI56B,OAAS,IAAM,GAClFpD,EAAI,EAAGA,EAAIq+B,EAAIj7B,OAAQpD,GAAK,EAAG,CACtC,IAAIw+B,EAAWH,EAAIr+B,EAAI,GAAG0oB,KAAK+V,GAC/B/hC,EAAMk/B,KAAKj4B,KAAK06B,EAAIr+B,GAAIi+B,EAAQO,EAAS37B,KAAK,OAASq7B,EAAQM,IAEjE,OAAO9hC,GA/WGgiC,CAkQd,SAAaZ,GACX,IAAIE,EAAM,CAAC,IAEX,OADAW,EAAQC,EAAQd,EAAM,GAAIz+B,KACnB2+B,EAEP,SAAS3+B,IAAS,OAAO2+B,EAAIr6B,KAAK,IAAM,EACxC,SAAS7C,EAAKpC,EAAMD,EAAI6/B,GACtB,IAAIx9B,EAAO,CAACw9B,KAAMA,EAAM7/B,GAAIA,GAE5B,OADAu/B,EAAIt/B,GAAMiF,KAAK7C,GACRA,EAET,SAAS69B,EAAQE,EAAOpgC,GAAMogC,EAAM32B,SAAQ,SAAUpH,GAAQ,OAAOA,EAAKrC,GAAKA,KAE/E,SAASmgC,EAAQd,EAAMp/B,GACrB,GAAiB,UAAbo/B,EAAKjgC,KACP,OAAOigC,EAAKgB,MAAMnqB,QAAO,SAAU0pB,EAAKP,GAAQ,OAAOO,EAAIvI,OAAO8I,EAAQd,EAAMp/B,MAAW,IACtF,GAAiB,OAAbo/B,EAAKjgC,KACd,IAAK,IAAImC,EAAI,GAAIA,IAAK,CACpB,IAAI47B,EAAOgD,EAAQd,EAAKgB,MAAM9+B,GAAItB,GAClC,GAAIsB,GAAK89B,EAAKgB,MAAM17B,OAAS,EAAK,OAAOw4B,EACzC+C,EAAQ/C,EAAMl9B,EAAOW,SAElB,IAAiB,QAAby+B,EAAKjgC,KAAgB,CAC9B,IAAIkhC,EAAO1/B,IAGX,OAFAyB,EAAKpC,EAAMqgC,GACXJ,EAAQC,EAAQd,EAAKA,KAAMiB,GAAOA,GAC3B,CAACj+B,EAAKi+B,IACR,GAAiB,QAAbjB,EAAKjgC,KAAgB,CAC9B,IAAImhC,EAAS3/B,IAGb,OAFAs/B,EAAQC,EAAQd,EAAKA,KAAMp/B,GAAOsgC,GAClCL,EAAQC,EAAQd,EAAKA,KAAMkB,GAASA,GAC7B,CAACl+B,EAAKk+B,IACR,GAAiB,OAAblB,EAAKjgC,KACd,MAAO,CAACiD,EAAKpC,IAAOo3B,OAAO8I,EAAQd,EAAKA,KAAMp/B,IACzC,GAAiB,SAAbo/B,EAAKjgC,KAAiB,CAE/B,IADA,IAAIohC,EAAMvgC,EACDqF,EAAM,EAAGA,EAAM+5B,EAAK5yB,IAAKnH,IAAO,CACvC,IAAIm7B,EAAS7/B,IACbs/B,EAAQC,EAAQd,EAAKA,KAAMmB,GAAMC,GACjCD,EAAMC,EAER,IAAiB,GAAbpB,EAAKzzB,IACPs0B,EAAQC,EAAQd,EAAKA,KAAMmB,GAAMA,QAEjC,IAAK,IAAI34B,EAAMw3B,EAAK5yB,IAAK5E,EAAMw3B,EAAKzzB,IAAK/D,IAAO,CAC9C,IAAI64B,EAAS9/B,IACbyB,EAAKm+B,EAAKE,GACVR,EAAQC,EAAQd,EAAKA,KAAMmB,GAAME,GACjCF,EAAME,EAGV,MAAO,CAACr+B,EAAKm+B,IACR,GAAiB,QAAbnB,EAAKjgC,KACd,MAAO,CAACiD,EAAKpC,EAAM,KAAMo/B,EAAKx2B,UAvTlB02B,CAAIF,IAEpB,OAiXF,SAA0Bl9B,EAAOg9B,GAC/B,IAAK,IAAI59B,EAAI,EAAGo/B,EAAO,CAACx+B,GAAQZ,EAAIo/B,EAAKh8B,OAAQpD,IAAK,CAEpD,IADA,IAAItD,EAAQ0iC,EAAKp/B,GAAIq/B,GAAQ3iC,EAAMwG,SAAUwH,EAAQ,GAC5C+R,EAAI,EAAGA,EAAI/f,EAAMk/B,KAAKx4B,OAAQqZ,GAAK,EAAG,CAC7C,IAAIpd,EAAO3C,EAAMk/B,KAAKnf,GAAImf,EAAOl/B,EAAMk/B,KAAKnf,EAAI,GAChD/R,EAAM/G,KAAKtE,EAAK2J,OACZq2B,GAAUhgC,EAAK8K,QAAU9K,EAAK0B,qBAAuBs+B,GAAO,IACrC,GAAvBD,EAAKrW,QAAQ6S,IAAewD,EAAKz7B,KAAKi4B,GAExCyD,GAAQzB,EAAOnF,IAAI,+BAAiC/tB,EAAM7H,KAAK,MAAQ,mFA3X7Ey8B,CAAiB1+B,EAAOg9B,GACjBh9B,GAMT48B,EAAah2B,UAAUvE,UAAY,SAAoBpF,GACrD,IAAK,IAAImC,EAAI,EAAGA,EAAI+I,KAAK6yB,KAAKx4B,OAAQpD,GAAK,EACvC,GAAI+I,KAAK6yB,KAAK57B,IAAMnC,EAAQ,OAAOkL,KAAK6yB,KAAK57B,EAAI,GACrD,OAAO,MAMTw9B,EAAah2B,UAAUu1B,cAAgB,SAAwBwC,EAAMr7B,EAAOpC,QACzD,IAAVoC,IAAmBA,EAAQ,QACnB,IAARpC,IAAiBA,EAAMy9B,EAAK5/B,YAGnC,IADA,IAAIs/B,EAAMl2B,KACD/I,EAAIkE,EAAO+6B,GAAOj/B,EAAI8B,EAAK9B,IAChCi/B,EAAMA,EAAIh8B,UAAUs8B,EAAK/4B,MAAMxG,GAAGnC,MACtC,OAAOohC,GAGTvB,EAAqB/7B,cAAc4zB,IAAM,WACvC,IAAIjzB,EAAQyG,KAAK6yB,KAAK,GACtB,QAAOt5B,GAAQA,EAAM2B,UAMvBy5B,EAAqBnxB,YAAYgpB,IAAM,WACrC,IAAK,IAAIv1B,EAAI,EAAGA,EAAI+I,KAAK6yB,KAAKx4B,OAAQpD,GAAK,EAAG,CAC5C,IAAInC,EAAOkL,KAAK6yB,KAAK57B,GACrB,IAAMnC,EAAKsM,SAAUtM,EAAKkD,mBAAuB,OAAOlD,IAI5D2/B,EAAah2B,UAAUg4B,WAAa,SAAqBtI,GACvD,IAAK,IAAIl3B,EAAI,EAAGA,EAAI+I,KAAK6yB,KAAKx4B,OAAQpD,GAAK,EACvC,IAAK,IAAIyc,EAAI,EAAGA,EAAIya,EAAM0E,KAAKx4B,OAAQqZ,GAAK,EAC1C,GAAI1T,KAAK6yB,KAAK57B,IAAMk3B,EAAM0E,KAAKnf,GAAM,OAAO,EAClD,OAAO,GAUT+gB,EAAah2B,UAAUi4B,WAAa,SAAqBlhC,EAAOmhC,EAAO55B,QACpD,IAAV45B,IAAmBA,GAAQ,QACZ,IAAf55B,IAAwBA,EAAa,GAE5C,IAAIusB,EAAO,CAACtpB,MAgBZ,OAfA,SAAS0nB,EAAO7vB,EAAOwB,GACrB,IAAIu9B,EAAW/+B,EAAMm8B,cAAcx+B,EAAOuH,GAC1C,GAAI65B,KAAcD,GAASC,EAASz8B,UAChC,OAAO2zB,EAASn4B,KAAK0D,EAAMrD,KAAI,SAAU6gC,GAAM,OAAOA,EAAGt+B,oBAE7D,IAAK,IAAItB,EAAI,EAAGA,EAAIY,EAAMg7B,KAAKx4B,OAAQpD,GAAK,EAAG,CAC7C,IAAInC,EAAO+C,EAAMg7B,KAAK57B,GAAI47B,EAAOh7B,EAAMg7B,KAAK57B,EAAI,GAChD,IAAMnC,EAAKsM,SAAUtM,EAAKkD,qBAA8C,GAAvBsxB,EAAKtJ,QAAQ6S,GAAa,CACzEvJ,EAAK1uB,KAAKi4B,GACV,IAAIz1B,EAAQsqB,EAAOmL,EAAMx5B,EAAM0zB,OAAOj4B,IACtC,GAAIsI,EAAS,OAAOA,IAKnBsqB,CAAO1nB,KAAM,KAQtBy0B,EAAah2B,UAAUxE,aAAe,SAAuBvF,GAC3D,IAAK,IAAIuC,EAAI,EAAGA,EAAI+I,KAAK00B,UAAUr6B,OAAQpD,GAAK,EAC5C,GAAI+I,KAAK00B,UAAUz9B,IAAMvC,EAAU,OAAOsL,KAAK00B,UAAUz9B,EAAI,GACjE,IAAI6/B,EAAW92B,KAAK+2B,gBAAgBriC,GAEpC,OADAsL,KAAK00B,UAAU95B,KAAKlG,EAAQoiC,GACrBA,GAGTrC,EAAah2B,UAAUs4B,gBAAkB,SAA0BriC,GAEjE,IADA,IAAI40B,EAAO9qB,OAAOlE,OAAO,MAAO08B,EAAS,CAAC,CAACn/B,MAAOmI,KAAMlL,KAAM,KAAMmiC,IAAK,OAClED,EAAO38B,QAAQ,CACpB,IAAIm0B,EAAUwI,EAAO7sB,QAAStS,EAAQ22B,EAAQ32B,MAC9C,GAAIA,EAAMqC,UAAUxF,GAAS,CAE3B,IADA,IAAI2V,EAAS,GACJ+B,EAAMoiB,EAASpiB,EAAItX,KAAMsX,EAAMA,EAAI6qB,IACxC5sB,EAAOzP,KAAKwR,EAAItX,MACpB,OAAOuV,EAAOwN,UAEhB,IAAK,IAAI5gB,EAAI,EAAGA,EAAIY,EAAMg7B,KAAKx4B,OAAQpD,GAAK,EAAG,CAC7C,IAAInC,EAAO+C,EAAMg7B,KAAK57B,GACjBnC,EAAKyxB,QAAWzxB,EAAKkD,oBAAwBlD,EAAKmL,QAAQqpB,GAAWkF,EAAQ15B,OAAQ+C,EAAMg7B,KAAK57B,EAAI,GAAGkD,WAC1G68B,EAAOp8B,KAAK,CAAC/C,MAAO/C,EAAK2b,aAAc3b,KAAMA,EAAMmiC,IAAKzI,IACxDlF,EAAKx0B,EAAKmL,OAAQ,MAS1B00B,EAAqB78B,UAAU00B,IAAM,WACnC,OAAOxsB,KAAK6yB,KAAKx4B,QAAU,GAM7Bo6B,EAAah2B,UAAU1G,KAAO,SAAe4Y,GAC3C,IAAI1Z,EAAI0Z,GAAK,EACb,GAAI1Z,GAAK+I,KAAK6yB,KAAKx4B,OAAU,MAAM,IAAIo0B,WAAY,cAAgB9d,EAAI,iCACvE,MAAO,CAAC7b,KAAMkL,KAAK6yB,KAAK57B,GAAI47B,KAAM7yB,KAAK6yB,KAAK57B,EAAI,KAGlDw9B,EAAah2B,UAAUC,SAAW,WAChC,IAAI4qB,EAAO,GAOX,OANA,SAAS4N,EAAK5C,GACZhL,EAAK1uB,KAAK05B,GACV,IAAK,IAAIr9B,EAAI,EAAGA,EAAIq9B,EAAEzB,KAAKx4B,OAAQpD,GAAK,GACJ,GAA5BqyB,EAAKtJ,QAAQsU,EAAEzB,KAAK57B,KAAaigC,EAAK5C,EAAEzB,KAAK57B,IAEvDigC,CAAKl3B,MACEspB,EAAKtzB,KAAI,SAAUs+B,EAAGr9B,GAE3B,IADA,IAAIq+B,EAAMr+B,GAAKq9B,EAAEn6B,SAAW,IAAM,KAAO,IAChCa,EAAM,EAAGA,EAAMs5B,EAAEzB,KAAKx4B,OAAQW,GAAO,EAC1Cs6B,IAAQt6B,EAAM,KAAO,IAAMs5B,EAAEzB,KAAK73B,GAAKiF,KAAO,KAAOqpB,EAAKtJ,QAAQsU,EAAEzB,KAAK73B,EAAM,IACnF,OAAOs6B,KACNx7B,KAAK,OAGV0E,OAAO6wB,iBAAkBoF,EAAah2B,UAAWk2B,GAEjDF,EAAa3gC,MAAQ,IAAI2gC,GAAa,GAEtC,IAAIK,EAAc,SAAqBxM,EAAQsM,GAC7C50B,KAAKsoB,OAASA,EACdtoB,KAAK40B,UAAYA,EACjB50B,KAAK+d,OAAS,KACd/d,KAAK/J,IAAM,EACX+J,KAAKm3B,OAAS7O,EAAOtvB,MAAM,kBACgB,IAAvCgH,KAAKm3B,OAAOn3B,KAAKm3B,OAAO98B,OAAS,IAAY2F,KAAKm3B,OAAOC,MACvC,IAAlBp3B,KAAKm3B,OAAO,IAAYn3B,KAAKm3B,OAAOhtB,SAGtCktB,EAAyB,CAAExE,KAAM,CAAE7E,cAAc,IAUrD,SAASgH,EAAUH,GACjB,IAAIkB,EAAQ,GACZ,GAAKA,EAAMn7B,KAAK08B,EAAazC,UACtBA,EAAO0C,IAAI,MAClB,OAAuB,GAAhBxB,EAAM17B,OAAc07B,EAAM,GAAK,CAACjhC,KAAM,SAAUihC,MAAOA,GAGhE,SAASuB,EAAazC,GACpB,IAAIkB,EAAQ,GACZ,GAAKA,EAAMn7B,KAAK48B,EAAmB3C,UAC5BA,EAAOhC,MAAuB,KAAfgC,EAAOhC,MAA8B,KAAfgC,EAAOhC,MACnD,OAAuB,GAAhBkD,EAAM17B,OAAc07B,EAAM,GAAK,CAACjhC,KAAM,MAAOihC,MAAOA,GAG7D,SAASyB,EAAmB3C,GAE1B,IADA,IAAIE,EA4CN,SAAuBF,GACrB,GAAIA,EAAO0C,IAAI,KAAM,CACnB,IAAIxC,EAAOC,EAAUH,GAErB,OADKA,EAAO0C,IAAI,MAAQ1C,EAAOnF,IAAI,yBAC5BqF,EACF,IAAK,KAAKv4B,KAAKq4B,EAAOhC,MAAO,CAClC,IAAIkD,EAlBR,SAAqBlB,EAAQ50B,GAC3B,IAAI5G,EAAQw7B,EAAOD,UAAW9/B,EAAOuE,EAAM4G,GAC3C,GAAInL,EAAQ,MAAO,CAACA,GACpB,IAAIuV,EAAS,GACb,IAAK,IAAIgF,KAAYhW,EAAO,CAC1B,IAAIo+B,EAASp+B,EAAMgW,GACfooB,EAAOC,OAAO1X,QAAQ/f,IAAS,GAAKoK,EAAOzP,KAAK68B,GAEjC,GAAjBptB,EAAOhQ,QAAew6B,EAAOnF,IAAI,0BAA4BzvB,EAAO,WACxE,OAAOoK,EASOstB,CAAY9C,EAAQA,EAAOhC,MAAM78B,KAAI,SAAUlB,GAGzD,OAFqB,MAAjB+/B,EAAO9W,OAAkB8W,EAAO9W,OAASjpB,EAAKoG,SACzC25B,EAAO9W,QAAUjpB,EAAKoG,UAAY25B,EAAOnF,IAAI,mCAC/C,CAAC56B,KAAM,OAAQyJ,MAAOzJ,MAG/B,OADA+/B,EAAO5+B,MACgB,GAAhB8/B,EAAM17B,OAAc07B,EAAM,GAAK,CAACjhC,KAAM,SAAUihC,MAAOA,GAE9DlB,EAAOnF,IAAI,qBAAuBmF,EAAOhC,KAAO,KA1DvC+E,CAAc/C,KAEvB,GAAIA,EAAO0C,IAAI,KACXxC,EAAO,CAACjgC,KAAM,OAAQigC,KAAMA,QAC3B,GAAIF,EAAO0C,IAAI,KAChBxC,EAAO,CAACjgC,KAAM,OAAQigC,KAAMA,QAC3B,GAAIF,EAAO0C,IAAI,KAChBxC,EAAO,CAACjgC,KAAM,MAAOigC,KAAMA,OAC1B,KAAIF,EAAO0C,IAAI,KAEb,MADHxC,EAAO8C,EAAehD,EAAQE,GAGpC,OAAOA,EAGT,SAAS+C,EAASjD,GACZ,KAAKr4B,KAAKq4B,EAAOhC,OAASgC,EAAOnF,IAAI,yBAA2BmF,EAAOhC,KAAO,KAClF,IAAIxoB,EAASgT,OAAOwX,EAAOhC,MAE3B,OADAgC,EAAO5+B,MACAoU,EAGT,SAASwtB,EAAehD,EAAQE,GAC9B,IAAI5yB,EAAM21B,EAASjD,GAASvzB,EAAMa,EAMlC,OALI0yB,EAAO0C,IAAI,OACaj2B,EAAP,KAAfuzB,EAAOhC,KAAqBiF,EAASjD,IAC3B,GAEXA,EAAO0C,IAAI,MAAQ1C,EAAOnF,IAAI,yBAC5B,CAAC56B,KAAM,QAASqN,IAAKA,EAAKb,IAAKA,EAAKyzB,KAAMA,GAwGnD,SAASW,EAAIrV,EAAGrE,GAAK,OAAOA,EAAIqE,EAKhC,SAAS+U,EAASH,EAAK3+B,GACrB,IAAI+T,EAAS,GAEb,OAEA,SAAS6sB,EAAK5gC,GACZ,IAAIw/B,EAAQb,EAAI3+B,GAChB,GAAoB,GAAhBw/B,EAAMz7B,SAAgBy7B,EAAM,GAAGP,KAAQ,OAAO2B,EAAKpB,EAAM,GAAGpgC,IAChE2U,EAAOzP,KAAKtE,GACZ,IAAK,IAAIW,EAAI,EAAGA,EAAI6+B,EAAMz7B,OAAQpD,IAAK,CACrC,IAAIH,EAAMg/B,EAAM7+B,GACZs+B,EAAOz+B,EAAIy+B,KACX7/B,EAAKoB,EAAIpB,GACR6/B,IAA+B,GAAvBlrB,EAAO2V,QAAQtqB,IAAawhC,EAAKxhC,IAXlDwhC,CAAK5gC,GACE+T,EAAOsV,KAAK+V,GAgErB,SAAShC,EAAal4B,GACpB,IAAIu8B,EAAWv5B,OAAOlE,OAAO,MAC7B,IAAK,IAAI09B,KAAYx8B,EAAO,CAC1B,IAAIy8B,EAAOz8B,EAAMw8B,GACjB,IAAKC,EAAKC,WAAc,OAAO,KAC/BH,EAASC,GAAYC,EAAK5b,QAE5B,OAAO0b,EAGT,SAASI,EAAa38B,EAAO+C,GAC3B,IAAI65B,EAAQ55B,OAAOlE,OAAO,MAC1B,IAAK,IAAI2F,KAAQzE,EAAO,CACtB,IAAI68B,EAAQ95B,GAASA,EAAM0B,GAC3B,QAAcJ,IAAVw4B,EAAqB,CACvB,IAAIJ,EAAOz8B,EAAMyE,GACjB,IAAIg4B,EAAKC,WACF,MAAM,IAAIzJ,WAAW,mCAAqCxuB,GAD1Co4B,EAAQJ,EAAK5b,QAGtC+b,EAAMn4B,GAAQo4B,EAEhB,OAAOD,EAGT,SAASE,EAAU98B,GACjB,IAAI6O,EAAS7L,OAAOlE,OAAO,MAC3B,GAAIkB,EAAS,IAAK,IAAIyE,KAAQzE,EAAS6O,EAAOpK,GAAQ,IAAIs4B,GAAU/8B,EAAMyE,IAC1E,OAAOoK,EA/PTgtB,EAAuBxE,KAAKrG,IAAM,WAAc,OAAOxsB,KAAKm3B,OAAOn3B,KAAK/J,MAExE6+B,EAAYr2B,UAAU84B,IAAM,SAAciB,GAAO,OAAOx4B,KAAK6yB,MAAQ2F,IAAQx4B,KAAK/J,QAAS,IAE3F6+B,EAAYr2B,UAAUixB,IAAM,SAAcsD,GAAO,MAAM,IAAIyF,YAAYzF,EAAM,4BAA8BhzB,KAAKsoB,OAAS,OAEzH9pB,OAAO6wB,iBAAkByF,EAAYr2B,UAAW44B,GAgQhD,IAAIqB,EAAW,SAAkBz4B,EAAMuB,EAAQzM,GAG7CiL,KAAKC,KAAOA,EAIZD,KAAKwB,OAASA,EAIdxB,KAAKjL,KAAOA,EAEZiL,KAAK03B,OAAS3iC,EAAKuc,MAAQvc,EAAKuc,MAAMtY,MAAM,KAAO,GACnDgH,KAAKxE,MAAQ88B,EAAUvjC,EAAKyG,OAE5BwE,KAAK0zB,aAAeA,EAAa1zB,KAAKxE,OAItCwE,KAAKyQ,aAAe,KAKpBzQ,KAAK24B,QAAU,KAIf34B,KAAKpH,cAAgB,KAIrBoH,KAAK9G,UAAYnE,EAAKgpB,QAAkB,QAAR9d,GAIhCD,KAAKoB,OAAiB,QAARnB,GAGZ24B,GAAuB,CAAE19B,SAAU,CAAE8yB,cAAc,GAAOr3B,YAAa,CAAEq3B,cAAc,GAAOzH,OAAQ,CAAEyH,cAAc,GAAO73B,OAAQ,CAAE63B,cAAc,GAAO6K,WAAY,CAAE7K,cAAc,IAI5L4K,GAAqB19B,SAASsxB,IAAM,WAAc,OAAQxsB,KAAK9G,SAK/D0/B,GAAqBjiC,YAAY61B,IAAM,WAAc,OAAOxsB,KAAK9G,SAAW8G,KAAKpH,eAIjFggC,GAAqBrS,OAAOiG,IAAM,WAAc,OAAOxsB,KAAKyQ,cAAgBgkB,EAAa3gC,OAKzF8kC,GAAqBziC,OAAOq2B,IAAM,WAAc,OAAOxsB,KAAKumB,QAAUvmB,KAAKjL,KAAKipB,MAIhF4a,GAAqBC,WAAWrM,IAAM,WAAc,OAAOxsB,KAAKjL,KAAK8jC,aAAe74B,KAAKjL,KAAK0C,KAAO,MAAQ,WAI7GihC,EAASj6B,UAAUzG,iBAAmB,WACpC,IAAK,IAAI2Y,KAAK3Q,KAAKxE,MAAS,GAAIwE,KAAKxE,MAAMmV,GAAGmoB,WAAc,OAAO,EACnE,OAAO,GAGTJ,EAASj6B,UAAU9E,kBAAoB,SAA4Bw0B,GACjE,OAAOnuB,MAAQmuB,GAASnuB,KAAKyQ,aAAagmB,WAAWtI,EAAM1d,eAG7DioB,EAASj6B,UAAU05B,aAAe,SAAyB38B,GACzD,OAAKA,GAASwE,KAAK0zB,aAAuB1zB,KAAK0zB,aACjCyE,EAAan4B,KAAKxE,MAAOA,IAUzCk9B,EAASj6B,UAAUnE,OAAS,SAAiBkB,EAAOrG,EAASwP,GAC3D,GAAI3E,KAAKoB,OAAU,MAAM,IAAI2C,MAAM,8CACnC,OAAO,IAAIogB,EAAKnkB,KAAMA,KAAKm4B,aAAa38B,GAAQsyB,EAASn4B,KAAKR,GAAUivB,EAAK8L,QAAQvrB,KAOvF+zB,EAASj6B,UAAUs6B,cAAgB,SAAwBv9B,EAAOrG,EAASwP,GAEzE,GADAxP,EAAU24B,EAASn4B,KAAKR,IACnB6K,KAAK+R,aAAa5c,GACnB,MAAM,IAAIs5B,WAAW,4BAA8BzuB,KAAKC,MAC5D,OAAO,IAAIkkB,EAAKnkB,KAAMA,KAAKm4B,aAAa38B,GAAQrG,EAASivB,EAAK8L,QAAQvrB,KAUxE+zB,EAASj6B,UAAUlG,cAAgB,SAAwBiD,EAAOrG,EAASwP,GAGzE,GAFAnJ,EAAQwE,KAAKm4B,aAAa38B,IAC1BrG,EAAU24B,EAASn4B,KAAKR,IACZC,KAAM,CAChB,IAAIR,EAASoL,KAAKyQ,aAAaimB,WAAWvhC,GAC1C,IAAKP,EAAU,OAAO,KACtBO,EAAUP,EAAOwJ,OAAOjJ,GAE1B,IAAIK,EAAQwK,KAAKyQ,aAAaujB,cAAc7+B,GAASuhC,WAAW5I,EAASh6B,OAAO,GAChF,OAAK0B,EACE,IAAI2uB,EAAKnkB,KAAMxE,EAAOrG,EAAQiJ,OAAO5I,GAAQ4uB,EAAK8L,QAAQvrB,IAD5C,MAOvB+zB,EAASj6B,UAAUsT,aAAe,SAAuB5c,GACvD,IAAIkV,EAASrK,KAAKyQ,aAAaujB,cAAc7+B,GAC7C,IAAKkV,IAAWA,EAAOlQ,SAAY,OAAO,EAC1C,IAAK,IAAIlD,EAAI,EAAGA,EAAI9B,EAAQyB,WAAYK,IACpC,IAAK+I,KAAKo0B,YAAYj/B,EAAQsI,MAAMxG,GAAG0N,OAAU,OAAO,EAC5D,OAAO,GAKT+zB,EAASj6B,UAAUu6B,eAAiB,SAAyBtsB,GAC3D,OAAuB,MAAhB1M,KAAK24B,SAAmB34B,KAAK24B,QAAQ3Y,QAAQtT,IAAa,GAKnEgsB,EAASj6B,UAAU21B,YAAc,SAAsBzvB,GACrD,GAAoB,MAAhB3E,KAAK24B,QAAmB,OAAO,EACnC,IAAK,IAAI1hC,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAO,IAAK+I,KAAKg5B,eAAer0B,EAAM1N,GAAGnC,MAAS,OAAO,EAC3F,OAAO,GAKT4jC,EAASj6B,UAAUw6B,aAAe,SAAuBt0B,GACvD,GAAoB,MAAhB3E,KAAK24B,QAAmB,OAAOh0B,EAEnC,IADA,IAAIpK,EACKtD,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAC3B+I,KAAKg5B,eAAer0B,EAAM1N,GAAGnC,MAEvByF,GACTA,EAAKK,KAAK+J,EAAM1N,IAFXsD,IAAQA,EAAOoK,EAAMlP,MAAM,EAAGwB,IAKvC,OAAQsD,EAAeA,EAAKF,OAASE,EAAO6pB,EAAKtwB,MAAlC6Q,GAGjB+zB,EAAS7C,QAAU,SAAkBl0B,EAAOH,GAC1C,IAAI6I,EAAS7L,OAAOlE,OAAO,MAC3BqH,EAAMxC,SAAQ,SAAUc,EAAMlL,GAAQ,OAAOsV,EAAOpK,GAAQ,IAAIy4B,EAASz4B,EAAMuB,EAAQzM,MAEvF,IAAImkC,EAAU13B,EAAOzM,KAAK6oB,SAAW,MACrC,IAAKvT,EAAO6uB,GAAY,MAAM,IAAIzK,WAAW,yCAA2CyK,EAAU,MAClG,IAAK7uB,EAAOrJ,KAAQ,MAAM,IAAIytB,WAAW,oCACzC,IAAK,IAAI/E,KAAKrf,EAAOrJ,KAAKxF,MAAS,MAAM,IAAIizB,WAAW,iDAExD,OAAOpkB,GAGT7L,OAAO6wB,iBAAkBqJ,EAASj6B,UAAWm6B,IAI7C,IAAIL,GAAY,SAAmBl4B,GACjCL,KAAKk4B,WAAa15B,OAAOC,UAAU8qB,eAAe5qB,KAAK0B,EAAS,WAChEL,KAAKqc,QAAUhc,EAAQgc,SAGrB8c,GAAyB,CAAEL,WAAY,CAAE9K,cAAc,IAE3DmL,GAAuBL,WAAWtM,IAAM,WACtC,OAAQxsB,KAAKk4B,YAGf15B,OAAO6wB,iBAAkBkJ,GAAU95B,UAAW06B,IAQ9C,IAAIC,GAAW,SAAkBn5B,EAAM6vB,EAAMtuB,EAAQzM,GAGnDiL,KAAKC,KAAOA,EAIZD,KAAKwB,OAASA,EAIdxB,KAAKjL,KAAOA,EAEZiL,KAAKxE,MAAQ88B,EAAUvjC,EAAKyG,OAE5BwE,KAAK8vB,KAAOA,EACZ9vB,KAAK6nB,SAAW,KAChB,IAAIkQ,EAAWrE,EAAa1zB,KAAKxE,OACjCwE,KAAKq5B,SAAWtB,GAAY,IAAI3T,EAAKpkB,KAAM+3B,IAO7CqB,GAAS36B,UAAUnE,OAAS,SAAiBkB,GAC3C,OAAKA,GAASwE,KAAKq5B,SAAmBr5B,KAAKq5B,SACpC,IAAIjV,EAAKpkB,KAAMm4B,EAAan4B,KAAKxE,MAAOA,KAGjD49B,GAASvD,QAAU,SAAkBlxB,EAAOnD,GAC1C,IAAI6I,EAAS7L,OAAOlE,OAAO,MAAOw1B,EAAO,EAEzC,OADAnrB,EAAMxF,SAAQ,SAAUc,EAAMlL,GAAQ,OAAOsV,EAAOpK,GAAQ,IAAIm5B,GAASn5B,EAAM6vB,IAAQtuB,EAAQzM,MACxFsV,GAMT+uB,GAAS36B,UAAUsxB,cAAgB,SAAwBH,GACzD,IAAK,IAAI34B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAAW24B,EAAI34B,GAAGnC,MAAQkL,OACxD4vB,EAAMA,EAAIn6B,MAAM,EAAGwB,GAAG81B,OAAO6C,EAAIn6B,MAAMwB,EAAI,IAC3CA,KAEF,OAAO24B,GAKTwJ,GAAS36B,UAAUmH,QAAU,SAAkBgqB,GAC7C,IAAK,IAAI34B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAC5B,GAAI24B,EAAI34B,GAAGnC,MAAQkL,KAAQ,OAAO4vB,EAAI34B,IAM5CmiC,GAAS36B,UAAU4T,SAAW,SAAmB8b,GAC/C,OAAOnuB,KAAK6nB,SAAS7H,QAAQmO,IAAU,GAmLzC,IAAImL,GAAS,SAAgBvkC,GAQ3B,IAAK,IAAIwX,KADTvM,KAAKjL,KAAO,GACKA,EAAQiL,KAAKjL,KAAKwX,GAAQxX,EAAKwX,GAChDvM,KAAKjL,KAAK4M,MAAQ,OAAgB5M,EAAK4M,OACvC3B,KAAKjL,KAAK4P,MAAQ,OAAgB5P,EAAK4P,OAIvC3E,KAAK2B,MAAQ+2B,EAAS7C,QAAQ71B,KAAKjL,KAAK4M,MAAO3B,MAI/CA,KAAK2E,MAAQy0B,GAASvD,QAAQ71B,KAAKjL,KAAK4P,MAAO3E,MAE/C,IAAIu5B,EAAmB/6B,OAAOlE,OAAO,MACrC,IAAK,IAAIk/B,KAAUx5B,KAAK2B,MAAO,CAC7B,GAAI63B,KAAUx5B,KAAK2E,MACf,MAAM,IAAI8pB,WAAW+K,EAAS,sCAClC,IAAI1kC,EAAOkL,KAAK2B,MAAM63B,GAASC,EAAc3kC,EAAKC,KAAKI,SAAW,GAAIukC,EAAW5kC,EAAKC,KAAK4P,MAC3F7P,EAAK2b,aAAe8oB,EAAiBE,KAClCF,EAAiBE,GAAehF,EAAa/rB,MAAM+wB,EAAaz5B,KAAK2B,QACxE7M,EAAK8D,cAAgB9D,EAAK2b,aAAa7X,cACvC9D,EAAK6jC,QAAsB,KAAZe,EAAkB,KAC/BA,EAAWC,GAAY35B,KAAM05B,EAAS1gC,MAAM,MAChC,IAAZ0gC,GAAmB5kC,EAAK8D,cAAqB,KAAL,GAE5C,IAAK,IAAIghC,KAAU55B,KAAK2E,MAAO,CAC7B,IAAI8yB,EAASz3B,KAAK2E,MAAMi1B,GAASC,EAAOpC,EAAO1iC,KAAKsd,SACpDolB,EAAO5P,SAAmB,MAARgS,EAAe,CAACpC,GAAkB,IAARoC,EAAa,GAAKF,GAAY35B,KAAM65B,EAAK7gC,MAAM,MAG7FgH,KAAKsI,aAAetI,KAAKsI,aAAa7I,KAAKO,MAC3CA,KAAKu0B,aAAev0B,KAAKu0B,aAAa90B,KAAKO,MAK3CA,KAAKuqB,YAAcvqB,KAAK2B,MAAM3B,KAAKjL,KAAK6oB,SAAW,OAMnD5d,KAAKozB,OAAS50B,OAAOlE,OAAO,MAC5B0F,KAAKozB,OAAO0G,UAAYt7B,OAAOlE,OAAO,OAsDxC,SAASq/B,GAAYn4B,EAAQmD,GAE3B,IADA,IAAIvH,EAAQ,GACHnG,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAK,CACrC,IAAIgJ,EAAO0E,EAAM1N,GAAIuO,EAAOhE,EAAOmD,MAAM1E,GAAO85B,EAAKv0B,EACrD,GAAIA,EACFpI,EAAMxC,KAAK4K,QAEX,IAAK,IAAI+G,KAAQ/K,EAAOmD,MAAO,CAC7B,IAAIq1B,EAASx4B,EAAOmD,MAAM4H,IACd,KAARtM,GAAgB+5B,EAAOjlC,KAAKuc,OAAS0oB,EAAOjlC,KAAKuc,MAAMtY,MAAM,KAAKgnB,QAAQ/f,IAAS,IACnF7C,EAAMxC,KAAKm/B,EAAKC,GAGxB,IAAKD,EAAM,MAAM,IAAItB,YAAY,uBAAyB9zB,EAAM1N,GAAK,KAEvE,OAAOmG,EA7DTk8B,GAAO76B,UAAUnI,KAAO,SAAexB,EAAM0G,EAAOrG,EAASwP,GAC3D,GAAmB,iBAAR7P,EACPA,EAAOkL,KAAKzE,SAASzG,OACpB,MAAMA,aAAgB4jC,GACvB,MAAM,IAAIjK,WAAW,sBAAwB35B,GAC5C,GAAIA,EAAK0M,QAAUxB,KACpB,MAAM,IAAIyuB,WAAW,yCAA2C35B,EAAKmL,KAAO,KAEhF,OAAOnL,EAAKikC,cAAcv9B,EAAOrG,EAASwP,IAM5C20B,GAAO76B,UAAUuC,KAAO,SAAei5B,EAAQt1B,GAC7C,IAAI7P,EAAOkL,KAAK2B,MAAMX,KACtB,OAAO,IAAIwzB,EAAS1/B,EAAMA,EAAK4+B,aAAcuG,EAAQ7V,EAAK8L,QAAQvrB,KAKpE20B,GAAO76B,UAAU+G,KAAO,SAAe1Q,EAAM0G,GAE3C,MADmB,iBAAR1G,IAAoBA,EAAOkL,KAAK2E,MAAM7P,IAC1CA,EAAKwF,OAAOkB,IAMrB89B,GAAO76B,UAAU6J,aAAe,SAAuB0nB,GACrD,OAAO7L,EAAK+K,SAASlvB,KAAMgwB,IAM7BsJ,GAAO76B,UAAU81B,aAAe,SAAuBvE,GACrD,OAAO5L,EAAK8K,SAASlvB,KAAMgwB,IAG7BsJ,GAAO76B,UAAUlD,SAAW,SAAmB0E,GAC7C,IAAI7C,EAAQ4C,KAAK2B,MAAM1B,GACvB,IAAK7C,EAAS,MAAM,IAAIqxB,WAAW,sBAAwBxuB,GAC3D,OAAO7C,GAuKT,IAAI6K,GAAY,SAAmBzG,EAAQ2X,GACzC,IAAI+gB,EAASl6B,KAIbA,KAAKwB,OAASA,EAIdxB,KAAKmZ,MAAQA,EACbnZ,KAAKm6B,KAAO,GACZn6B,KAAKo6B,OAAS,GAEdjhB,EAAMha,SAAQ,SAAUoa,GAClBA,EAAK8gB,IAAOH,EAAOC,KAAKv/B,KAAK2e,GACxBA,EAAK4D,OAAS+c,EAAOE,OAAOx/B,KAAK2e,MAI5CvZ,KAAKs6B,gBAAkBt6B,KAAKm6B,KAAKhjB,MAAK,SAAUojB,GAC9C,IAAK,aAAa/9B,KAAK+9B,EAAEF,OAASE,EAAEjkC,KAAQ,OAAO,EACnD,IAAIA,EAAOkL,EAAOG,MAAM44B,EAAEjkC,MAC1B,OAAOA,EAAKma,aAAavW,UAAU5D,OAMvC2R,GAAUxJ,UAAUiK,MAAQ,SAAgBhG,EAAKrC,QAC5B,IAAZA,IAAqBA,EAAU,IAEtC,IAAId,EAAU,IAAIi7B,GAAax6B,KAAMK,GAAS,GAE9C,OADAd,EAAQk7B,OAAO/3B,EAAK,KAAMrC,EAAQ1K,KAAM0K,EAAQ3K,IACzC6J,EAAQm7B,UAUjBzyB,GAAUxJ,UAAUgK,WAAa,SAAqB/F,EAAKrC,QACtC,IAAZA,IAAqBA,EAAU,IAEtC,IAAId,EAAU,IAAIi7B,GAAax6B,KAAMK,GAAS,GAE9C,OADAd,EAAQk7B,OAAO/3B,EAAK,KAAMrC,EAAQ1K,KAAM0K,EAAQ3K,IACzC06B,EAAM6B,QAAQ1yB,EAAQm7B,WAG/BzyB,GAAUxJ,UAAUk8B,SAAW,SAAmBj4B,EAAKnD,EAAS/J,GAC9D,IAAK,IAAIyB,EAAIzB,EAAQwK,KAAKm6B,KAAKna,QAAQxqB,GAAS,EAAI,EAAGyB,EAAI+I,KAAKm6B,KAAK9/B,OAAQpD,IAAK,CAChF,IAAIsiB,EAAOvZ,KAAKm6B,KAAKljC,GACrB,GAAIyjB,GAAQhY,EAAK6W,EAAK8gB,YACEx6B,IAAnB0Z,EAAKqhB,WAA2Bl4B,EAAIm4B,cAAgBthB,EAAKqhB,cACxDrhB,EAAKha,SAAWA,EAAQu7B,eAAevhB,EAAKha,UAAW,CAC3D,GAAIga,EAAK6D,SAAU,CACjB,IAAI/S,EAASkP,EAAK6D,SAAS1a,GAC3B,IAAe,IAAX2H,EAAoB,SACxBkP,EAAK/d,MAAQ6O,EAEf,OAAOkP,KAKbtR,GAAUxJ,UAAUs8B,WAAa,SAAqBxuB,EAAMhO,EAAOgB,EAAS/J,GAC1E,IAAK,IAAIyB,EAAIzB,EAAQwK,KAAKo6B,OAAOpa,QAAQxqB,GAAS,EAAI,EAAGyB,EAAI+I,KAAKo6B,OAAO//B,OAAQpD,IAAK,CACpF,IAAIsiB,EAAOvZ,KAAKo6B,OAAOnjC,GACvB,KAAgC,GAA5BsiB,EAAK4D,MAAM6C,QAAQzT,IACnBgN,EAAKha,UAAYA,EAAQu7B,eAAevhB,EAAKha,UAI7Cga,EAAK4D,MAAM9iB,OAASkS,EAAKlS,SACc,IAAtCkf,EAAK4D,MAAMiP,WAAW7f,EAAKlS,SAAiBkf,EAAK4D,MAAM1nB,MAAM8W,EAAKlS,OAAS,IAAMkE,IANtF,CAQA,GAAIgb,EAAK6D,SAAU,CACjB,IAAI/S,EAASkP,EAAK6D,SAAS7e,GAC3B,IAAe,IAAX8L,EAAoB,SACxBkP,EAAK/d,MAAQ6O,EAEf,OAAOkP,KAKXtR,GAAU+yB,YAAc,SAAsBx5B,GAC5C,IAAI6I,EAAS,GACb,SAASxR,EAAO0gB,GAEd,IADA,IAAI0hB,EAA4B,MAAjB1hB,EAAK0hB,SAAmB,GAAK1hB,EAAK0hB,SAAUhkC,EAAI,EACxDA,EAAIoT,EAAOhQ,OAAQpD,IAAK,CAC7B,IAAI47B,EAAOxoB,EAAOpT,GAClB,IADsD,MAAjB47B,EAAKoI,SAAmB,GAAKpI,EAAKoI,UACpDA,EAAY,MAEjC5wB,EAAOwiB,OAAO51B,EAAG,EAAGsiB,GAGtB,IAAIyc,EAAO,SAAW/1B,GACpB,IAAIkZ,EAAQ3X,EAAOmD,MAAM1E,GAAMlL,KAAKqpB,SAChCjF,GAASA,EAAMha,SAAQ,SAAUoa,GACnC1gB,EAAO0gB,EAAOhf,GAAKgf,IACnBA,EAAK/T,KAAOvF,MAId,IAAK,IAAIA,KAAQuB,EAAOmD,MAAOqxB,EAAM/1B,GACvC,IACMi7B,EAOJ,IAAK,IAAIC,KAAU35B,EAAOG,MAPtBu5B,OAAAA,GAAAA,EAAU15B,EAAOG,MAAMw5B,GAAQpmC,KAAKqpB,WACzB8c,EAAQ/7B,SAAQ,SAAUoa,GACvC1gB,EAAO0gB,EAAOhf,GAAKgf,IACnBA,EAAKjjB,KAAO6kC,KAKhB,OAAO9wB,GAOTpC,GAAUmzB,WAAa,SAAqB55B,GAC1C,OAAOA,EAAO4xB,OAAOiI,YAClB75B,EAAO4xB,OAAOiI,UAAY,IAAIpzB,GAAUzG,EAAQyG,GAAU+yB,YAAYx5B,MAI3E,IAAI85B,GAAY,CACdC,SAAS,EAAMC,SAAS,EAAMC,OAAO,EAAMC,YAAY,EAAMC,QAAQ,EACrEC,IAAI,EAAMC,KAAK,EAAMC,IAAI,EAAMC,UAAU,EAAMC,YAAY,EAAMC,QAAQ,EACzEC,QAAQ,EAAMC,MAAM,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EACtEC,IAAI,EAAMC,QAAQ,EAAMC,QAAQ,EAAMC,IAAI,EAAMC,IAAI,EAAMC,UAAU,EAAMC,IAAI,EAC9E99B,QAAQ,EAAM0vB,GAAG,EAAMqO,KAAK,EAAMC,SAAS,EAAMC,OAAO,EAAMC,OAAO,EAAMC,IAAI,GAI7EC,GAAa,CACfC,MAAM,EAAMR,UAAU,EAAMS,QAAQ,EAAMC,QAAQ,EAAMrgB,OAAO,EAAMsgB,OAAO,GAI1EC,GAAW,CAACX,IAAI,EAAMK,IAAI,GAK9B,SAASO,GAAa7oC,EAAM+T,EAAoBoiB,GAC9C,OAA0B,MAAtBpiB,GAAsCA,EAHtB,EAG6D,IACvD,SAAvBA,EAJ2C,EAIY,GACnD/T,GAA2B,OAAnBA,EAAK+jC,WAAsB+E,GAAgD,EAAP3S,EAGrF,IAAI4S,GAAc,SAAqB/oC,EAAM0G,EAAOmJ,EAAOm5B,EAAcC,EAAOlmC,EAAOwI,GACrFL,KAAKlL,KAAOA,EACZkL,KAAKxE,MAAQA,EACbwE,KAAK+9B,MAAQA,EACb/9B,KAAKnI,MAAQA,IAZoD,EAY1CwI,EAA0B,KAAOvL,EAAK2b,cAC7DzQ,KAAKK,QAAUA,EACfL,KAAK7K,QAAU,GAEf6K,KAAK2E,MAAQA,EAEb3E,KAAKg+B,YAAc5Z,EAAK+L,KAExBnwB,KAAK89B,aAAeA,EAEpB99B,KAAKi+B,WAAa,IAGpBJ,GAAYp/B,UAAUxE,aAAe,SAAuB3D,GAC1D,IAAK0J,KAAKnI,MAAO,CACf,IAAKmI,KAAKlL,KAAQ,MAAO,GACzB,IAAIopC,EAAOl+B,KAAKlL,KAAK2b,aAAaimB,WAAW5I,EAASn4B,KAAKW,IAC3D,IAAI4nC,EAEG,CACL,IAAoC9jC,EAAhCe,EAAQ6E,KAAKlL,KAAK2b,aACtB,OAAIrW,EAAOe,EAAMlB,aAAa3D,EAAKxB,QACjCkL,KAAKnI,MAAQsD,EACNf,GAEA,KAPT4F,KAAKnI,MAAQmI,KAAKlL,KAAK2b,aAAaujB,cAAckK,GAWtD,OAAOl+B,KAAKnI,MAAMoC,aAAa3D,EAAKxB,OAGtC+oC,GAAYp/B,UAAUi8B,OAAS,SAAiBpK,GAC9C,KA7CoB,EA6CdtwB,KAAKK,SAA4B,CACrC,IAAkDi0B,EAA9ClrB,EAAOpJ,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAC1C+O,GAAQA,EAAKhI,SAAWkzB,EAAI,oBAAoB9a,KAAKpQ,EAAKpI,SACxDoI,EAAKpI,KAAK3G,QAAUi6B,EAAE,GAAGj6B,OAAU2F,KAAK7K,QAAQiiC,MAC7Cp3B,KAAK7K,QAAQ6K,KAAK7K,QAAQkF,OAAS,GAAK+O,EAAKglB,SAAShlB,EAAKpI,KAAKvL,MAAM,EAAG2T,EAAKpI,KAAK3G,OAASi6B,EAAE,GAAGj6B,UAG5G,IAAIlF,EAAU24B,EAASn4B,KAAKqK,KAAK7K,SAGjC,OAFKm7B,GAAWtwB,KAAKnI,QACjB1C,EAAUA,EAAQiJ,OAAO4B,KAAKnI,MAAM6+B,WAAW5I,EAASh6B,OAAO,KAC5DkM,KAAKlL,KAAOkL,KAAKlL,KAAKwF,OAAO0F,KAAKxE,MAAOrG,EAAS6K,KAAK2E,OAASxP,GAGzE0oC,GAAYp/B,UAAU0/B,iBAAmB,SAA2B34B,GAClE,IAAK,IAAIvO,EAAI+I,KAAKi+B,WAAW5jC,OAAS,EAAGpD,GAAK,EAAGA,IAC7C,GAAIuO,EAAKgC,GAAGxH,KAAKi+B,WAAWhnC,IAAO,OAAO+I,KAAKi+B,WAAWpR,OAAO51B,EAAG,GAAG,IAG7E4mC,GAAYp/B,UAAU2/B,aAAe,SAAuB5tB,GAC1D,IAAK,IAAIvZ,EAAI,EAAGonC,EAAUr+B,KAAK89B,aAAc7mC,EAAIonC,EAAQhkC,OAAQpD,IAAK,CACpE,IAAIuO,EAAO64B,EAAQpnC,IACd+I,KAAKlL,KAAOkL,KAAKlL,KAAKkkC,eAAexzB,EAAK1Q,MAAQwpC,GAAa94B,EAAK1Q,KAAM0b,MAC1EhL,EAAKI,QAAQ5F,KAAKg+B,eACrBh+B,KAAKg+B,YAAcx4B,EAAKmqB,SAAS3vB,KAAKg+B,aACtCh+B,KAAK89B,aAAet4B,EAAKuqB,cAAc/vB,KAAK89B,iBAKlDD,GAAYp/B,UAAU8/B,cAAgB,SAAwBjoC,GAC5D,OAAI0J,KAAKlL,KAAekL,KAAKlL,KAAK8D,cAC9BoH,KAAK7K,QAAQkF,OAAiB2F,KAAK7K,QAAQ,GAAG+F,SAC3C5E,EAAKkoC,aAAelD,GAAU/R,eAAejzB,EAAKkoC,WAAWC,SAASC,gBAG/E,IAAIlE,GAAe,SAAsBhyB,EAAQnI,EAASs+B,GAExD3+B,KAAKwI,OAASA,EAEdxI,KAAKK,QAAUA,EACfL,KAAK4+B,OAASD,EACd,IAA+BE,EAA3BjhB,EAAUvd,EAAQud,QAClBkhB,EAAanB,GAAa,KAAMt9B,EAAQwI,mBAAoB,IAAM81B,EAvFL,EAuF4B,GAEzFE,EADAjhB,EACa,IAAIigB,GAAYjgB,EAAQ9oB,KAAM8oB,EAAQpiB,MAAO4oB,EAAK+L,KAAM/L,EAAK+L,MAAM,EACrD9vB,EAAQ0+B,UAAYnhB,EAAQ9oB,KAAK2b,aAAcquB,GAE7D,IAAIjB,GADZc,EACwB,KAEAn2B,EAAOhH,OAAO+oB,YAFR,KAAMnG,EAAK+L,KAAM/L,EAAK+L,MAAM,EAAM,KAAM2O,GAG/E9+B,KAAK2B,MAAQ,CAACk9B,GAEd7+B,KAAK2+B,KAAO,EACZ3+B,KAAKoF,KAAO/E,EAAQ2+B,cACpBh/B,KAAKi/B,YAAa,GAGhBC,GAAuB,CAAEvU,IAAK,CAAEqD,cAAc,GAAOmR,WAAY,CAAEnR,cAAc,IAwYrF,SAAStT,GAAQhY,EAAK08B,GACpB,OAAQ18B,EAAIgY,SAAWhY,EAAI28B,mBAAqB38B,EAAI48B,uBAAyB58B,EAAI68B,oBAAoB5gC,KAAK+D,EAAK08B,GAWjH,SAAS7kC,GAAK6R,GACZ,IAAI7R,EAAO,GACX,IAAK,IAAIgS,KAAQH,EAAO7R,EAAKgS,GAAQH,EAAIG,GACzC,OAAOhS,EAMT,SAAS+jC,GAAa5xB,EAAUnR,GAC9B,IAAIoG,EAAQpG,EAASiG,OAAOG,MACxBq0B,EAAO,SAAW/1B,GACpB,IAAI/K,EAASyM,EAAM1B,GACnB,GAAK/K,EAAO8jC,eAAetsB,GAA3B,CACA,IAAI4c,EAAO,GAAI4N,EAAO,SAAUr/B,GAC9ByxB,EAAK1uB,KAAK/C,GACV,IAAK,IAAIZ,EAAI,EAAGA,EAAIY,EAAMC,UAAWb,IAAK,CACxC,IAAIH,EAAMe,EAAME,KAAKd,GACjBnC,EAAOgC,EAAIhC,KACX+9B,EAAO/7B,EAAI+7B,KACf,GAAI/9B,GAAQyG,EAAY,OAAO,EAC/B,GAAI+tB,EAAKtJ,QAAQ6S,GAAQ,GAAKqE,EAAKrE,GAAS,OAAO,IAGvD,OAAIqE,EAAKhiC,EAAOub,cAAwB,CAAE+uB,GAAG,QAA7C,IAGF,IAAK,IAAIv/B,KAAQ0B,EAAO,CACtB,IAAI89B,EAAWzJ,EAAM/1B,GAErB,GAAKw/B,EAAW,OAAOA,EAASD,GAhbpCN,GAAqBvU,IAAI6B,IAAM,WAC7B,OAAOxsB,KAAK2B,MAAM3B,KAAK2+B,OAOzBnE,GAAa/7B,UAAUihC,OAAS,SAAiBh9B,GAC/C,GAAoB,GAAhBA,EAAInH,SACNyE,KAAK2/B,YAAYj9B,QACZ,GAAoB,GAAhBA,EAAInH,SAAe,CAC5B,IAAI4hB,EAAQza,EAAI6a,aAAa,SACzB5Y,EAAQwY,EAAQnd,KAAK4/B,WA+X7B,SAAqBziB,GACnB,IAAuCmX,EAAnCuL,EAAK,6BAAiCx1B,EAAS,GACnD,KAAOiqB,EAAIuL,EAAGrmB,KAAK2D,IAAU9S,EAAOzP,KAAK05B,EAAE,GAAIA,EAAE,GAAGwL,QACpD,OAAOz1B,EAlY+B01B,CAAY5iB,IAAU,KAAMwN,EAAM3qB,KAAK2qB,IAC3E,GAAa,MAAThmB,EAAiB,IAAK,IAAI1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAAO+I,KAAKggC,eAAer7B,EAAM1N,IAExF,GADA+I,KAAKigC,WAAWv9B,GACH,MAATiC,EAAiB,IAAK,IAAI3J,EAAM,EAAGA,EAAM2J,EAAMtK,OAAQW,IAASgF,KAAKkgC,kBAAkBv7B,EAAM3J,GAAM2vB,KAI3G6P,GAAa/7B,UAAUkhC,YAAc,SAAsBj9B,GACzD,IAAInE,EAAQmE,EAAIy9B,UACZxV,EAAM3qB,KAAK2qB,IACf,GA/H8C,EA+H1CA,EAAItqB,SACJsqB,EAAI4T,cAAc77B,IAClB,mBAAmBlG,KAAK+B,GAAQ,CAClC,GAlIkB,EAkIZosB,EAAItqB,QAgBR9B,EAlJ0C,EA+I/BosB,EAAItqB,QAGP9B,EAAMmS,QAAQ,SAAU,MAFxBnS,EAAMmS,QAAQ,YAAa,UATnC,GAJAnS,EAAQA,EAAMmS,QAAQ,oBAAqB,KAIvC,mBAAmBlU,KAAK+B,IAAUyB,KAAK2+B,MAAQ3+B,KAAK2B,MAAMtH,OAAS,EAAG,CACxE,IAAIxF,EAAa81B,EAAIx1B,QAAQw1B,EAAIx1B,QAAQkF,OAAS,GAC9C+lC,EAAgB19B,EAAI29B,kBACnBxrC,GACAurC,GAA2C,MAA1BA,EAAc3B,UAC/B5pC,EAAWuM,QAAU,mBAAmB5E,KAAK3H,EAAWmM,SACzDzC,EAAQA,EAAM9I,MAAM,IAOxB8I,GAASyB,KAAKsgC,WAAWtgC,KAAKwI,OAAOhH,OAAOR,KAAKzC,IACrDyB,KAAKugC,WAAW79B,QAEhB1C,KAAKwgC,WAAW99B,IAOpB83B,GAAa/7B,UAAUwhC,WAAa,SAAqBv9B,EAAK+9B,GAC5D,IAAuCC,EAAnCzgC,EAAOyC,EAAI+7B,SAASC,cACpBhB,GAASnU,eAAetpB,IAASD,KAAKwI,OAAO8xB,gBA+TnD,SAAuB53B,GACrB,IAAK,IAAIjF,EAAQiF,EAAIjM,WAAYkqC,EAAW,KAAMljC,EAAOA,EAAQA,EAAMmjC,YAAa,CAClF,IAAI3gC,EAAyB,GAAlBxC,EAAMlC,SAAgBkC,EAAMghC,SAASC,cAAgB,KAC5Dz+B,GAAQy9B,GAASnU,eAAetpB,IAAS0gC,GAC3CA,EAASloB,YAAYhb,GACrBA,EAAQkjC,GACS,MAAR1gC,EACT0gC,EAAWljC,EACFwC,IACT0gC,EAAW,OAxUoDE,CAAcn+B,GACjF,IAAI6W,EAAQvZ,KAAKK,QAAQygC,cAAgB9gC,KAAKK,QAAQygC,aAAap+B,KAC9Dg+B,EAAS1gC,KAAKwI,OAAOmyB,SAASj4B,EAAK1C,KAAMygC,IAC9C,GAAIlnB,EAAOA,EAAKwnB,OAAS1D,GAAW9T,eAAetpB,GACjDD,KAAKwgC,WAAW99B,GAChB1C,KAAKghC,eAAet+B,QACf,IAAK6W,GAAQA,EAAK0nB,MAAQ1nB,EAAK2nB,YAAa,CAC7C3nB,GAAQA,EAAK2nB,YAAelhC,KAAK2+B,KAAOt9B,KAAKC,IAAI,EAAGtB,KAAK2+B,KAAO,GAC3DplB,GAAQA,EAAK0nB,KAAK1lC,WAAYmH,EAAM6W,EAAK0nB,MAClD,IAAIE,EAAMxW,EAAM3qB,KAAK2qB,IAAKyW,EAAgBphC,KAAKi/B,WAC/C,GAAI3D,GAAU/R,eAAetpB,GAC3BkhC,GAAO,EACFxW,EAAI71B,OAAQkL,KAAKi/B,YAAa,QAC9B,IAAKv8B,EAAIjM,WAEd,YADAuJ,KAAKqhC,aAAa3+B,GAGpB1C,KAAKy6B,OAAO/3B,GACRy+B,GAAQnhC,KAAKmhC,KAAKxW,GACtB3qB,KAAKi/B,WAAamC,OAElBphC,KAAKshC,iBAAiB5+B,EAAK6W,GAAyB,IAAnBA,EAAKgoB,UAAsBb,EAAS,OAKzElG,GAAa/7B,UAAU4iC,aAAe,SAAuB3+B,GACvC,MAAhBA,EAAI+7B,UAAoBz+B,KAAK2qB,IAAI71B,MAAQkL,KAAK2qB,IAAI71B,KAAK8D,eACvDoH,KAAK2/B,YAAYj9B,EAAI8+B,cAAcC,eAAe,QAIxDjH,GAAa/7B,UAAUuiC,eAAiB,SAAyBt+B,GAE3C,MAAhBA,EAAI+7B,UAAsBz+B,KAAK2qB,IAAI71B,MAASkL,KAAK2qB,IAAI71B,KAAK8D,eAC1DoH,KAAK0hC,UAAU1hC,KAAKwI,OAAOhH,OAAOR,KAAK,OAM7Cw5B,GAAa/7B,UAAUmhC,WAAa,SAAqBxF,GACvD,IAAIz1B,EAAQyf,EAAK+L,KACjBhT,EAAO,IAAK,IAAIlmB,EAAI,EAAGA,EAAImjC,EAAO//B,OAAQpD,GAAK,EAC7C,IAAK,IAAIzB,EAAQ,OAAQ,CACvB,IAAI+jB,EAAOvZ,KAAKwI,OAAOuyB,WAAWX,EAAOnjC,GAAImjC,EAAOnjC,EAAI,GAAI+I,KAAMxK,GAClE,IAAK+jB,EAAQ,SAAS4D,EACtB,GAAI5D,EAAKwnB,OAAU,OAAO,KAE1B,GADAp8B,EAAQ3E,KAAKwI,OAAOhH,OAAOmD,MAAM4U,EAAK/T,MAAMlL,OAAOif,EAAK/d,OAAOm0B,SAAShrB,IACjD,IAAnB4U,EAAKgoB,UACF,MADyB/rC,EAAQ+jB,EAI5C,OAAO5U,GAOT61B,GAAa/7B,UAAU6iC,iBAAmB,SAA2B5+B,EAAK6W,EAAMooB,GAC5E,IAEER,EAAM5lC,EAAoBiK,EAFxB00B,EAASl6B,KAGXuZ,EAAKjjB,MACPiF,EAAWyE,KAAKwI,OAAOhH,OAAOG,MAAM4X,EAAKjjB,OAC3BiwB,OAEFvmB,KAAKsgC,WAAW/kC,EAASjB,OAAOif,EAAK/d,SAC/CwE,KAAKqhC,aAAa3+B,GAFlBy+B,EAAOnhC,KAAKuE,MAAMhJ,EAAUge,EAAK/d,MAAO+d,EAAK1Q,qBAM/CrD,EADWxF,KAAKwI,OAAOhH,OAAOmD,MAAM4U,EAAK/T,MACzBlL,OAAOif,EAAK/d,OAC5BwE,KAAKggC,eAAex6B,IAEtB,IAAIo8B,EAAU5hC,KAAK2qB,IAEnB,GAAIpvB,GAAYA,EAASgrB,OACvBvmB,KAAKwgC,WAAW99B,QACX,GAAIi/B,EACT3hC,KAAKigC,WAAWv9B,EAAKi/B,QAChB,GAAIpoB,EAAKsoB,WACd7hC,KAAKwgC,WAAW99B,GAChB6W,EAAKsoB,WAAWn/B,EAAK1C,KAAKwI,OAAOhH,QAAQrC,SAAQ,SAAU7I,GAAQ,OAAO4jC,EAAOoG,WAAWhqC,UACvF,CACL,IAAIquB,EAAapL,EAAKuoB,eACG,iBAAdnd,EAA0BA,EAAajiB,EAAIigB,cAAcgC,GACtC,mBAAdA,IAA4BA,EAAaA,EAAWjiB,IAC/DiiB,IAAcA,EAAajiB,GAChC1C,KAAK+hC,WAAWr/B,EAAKiiB,GAAY,GACjC3kB,KAAKy6B,OAAO9V,EAAYwc,GAEtBA,IAAQnhC,KAAKmhC,KAAKS,GAAU5hC,KAAK2+B,QACjCn5B,GAAQxF,KAAKkgC,kBAAkB16B,EAAMo8B,IAO3CpH,GAAa/7B,UAAUg8B,OAAS,SAAiBvlC,EAAQisC,EAAMpkC,EAAYE,GAEzE,IADA,IAAI/F,EAAQ6F,GAAc,EACjB2F,EAAM3F,EAAa7H,EAAO8sC,WAAWjlC,GAAc7H,EAAOuB,WAC1DsC,EAAkB,MAAZkE,EAAmB,KAAO/H,EAAO8sC,WAAW/kC,GACtDyF,GAAO3J,EAAK2J,EAAMA,EAAIk+B,cAAe1pC,EACxC8I,KAAKiiC,YAAY/sC,EAAQgC,GACzB8I,KAAK0/B,OAAOh9B,GACRy+B,GAAQ7F,GAAU/R,eAAe7mB,EAAI+7B,SAASC,gBAC9C1+B,KAAKmhC,KAAKA,GAEhBnhC,KAAKiiC,YAAY/sC,EAAQgC,IAM3BsjC,GAAa/7B,UAAUijC,UAAY,SAAoBprC,GAErD,IADA,IAAI4rC,EAAOf,EACF/qC,EAAQ4J,KAAK2+B,KAAMvoC,GAAS,EAAGA,IAAS,CAC/C,IAAI+rC,EAAKniC,KAAK2B,MAAMvL,GAChBgH,EAAQ+kC,EAAGloC,aAAa3D,GAC5B,GAAI8G,KAAW8kC,GAASA,EAAM7nC,OAAS+C,EAAM/C,UAC3C6nC,EAAQ9kC,EACR+jC,EAAOgB,GACF/kC,EAAM/C,QAAU,MAEvB,GAAI8nC,EAAGpE,MAAS,MAElB,IAAKmE,EAAS,OAAO,EACrBliC,KAAKmhC,KAAKA,GACV,IAAK,IAAIlqC,EAAI,EAAGA,EAAIirC,EAAM7nC,OAAQpD,IAC9B+I,KAAKoiC,WAAWF,EAAMjrC,GAAI,MAAM,GACpC,OAAO,GAKTujC,GAAa/7B,UAAU6hC,WAAa,SAAqBhqC,GACvD,GAAIA,EAAK4E,UAAY8E,KAAKi/B,aAAej/B,KAAK2qB,IAAI71B,KAAM,CACtD,IAAIutC,EAAQriC,KAAKsiC,uBACbD,GAASriC,KAAKoiC,WAAWC,GAE/B,GAAIriC,KAAK0hC,UAAUprC,GAAO,CACxB0J,KAAKuiC,aACL,IAAI5X,EAAM3qB,KAAK2qB,IACfA,EAAIyT,aAAa9nC,EAAKxB,MAClB61B,EAAI9yB,QAAS8yB,EAAI9yB,MAAQ8yB,EAAI9yB,MAAMqC,UAAU5D,EAAKxB,OAEtD,IADA,IAAI6P,EAAQgmB,EAAIqT,YACP/mC,EAAI,EAAGA,EAAIX,EAAKqO,MAAMtK,OAAQpD,IAC9B0zB,EAAI71B,OAAQ61B,EAAI71B,KAAKkkC,eAAe1iC,EAAKqO,MAAM1N,GAAGnC,QACrD6P,EAAQrO,EAAKqO,MAAM1N,GAAG04B,SAAShrB,IAErC,OADAgmB,EAAIx1B,QAAQyF,KAAKtE,EAAKkP,KAAKb,KACpB,EAET,OAAO,GAMT61B,GAAa/7B,UAAU8F,MAAQ,SAAgBzP,EAAM0G,EAAOgnC,GAC1D,IAAIzI,EAAK/5B,KAAK0hC,UAAU5sC,EAAKwF,OAAOkB,IAEpC,OADIu+B,GAAM/5B,KAAKoiC,WAAWttC,EAAM0G,GAAO,EAAMgnC,GACtCzI,GAITS,GAAa/7B,UAAU2jC,WAAa,SAAqBttC,EAAM0G,EAAOuiC,EAAOyE,GAC3ExiC,KAAKuiC,aACL,IAAI5X,EAAM3qB,KAAK2qB,IACfA,EAAIyT,aAAatpC,GACjB61B,EAAI9yB,MAAQ8yB,EAAI9yB,OAAS8yB,EAAI9yB,MAAMqC,UAAUpF,EAAM0G,GACnD,IAAI6E,EAAUs9B,GAAa7oC,EAAM0tC,EAAY7X,EAAItqB,SA7UgB,EA8U5DsqB,EAAItqB,SAAkD,GAAtBsqB,EAAIx1B,QAAQkF,SAAegG,GA9UC,GA+UjEL,KAAK2B,MAAM/G,KAAK,IAAIijC,GAAY/oC,EAAM0G,EAAOmvB,EAAIqT,YAAarT,EAAImT,aAAcC,EAAO,KAAM19B,IAC7FL,KAAK2+B,QAKPnE,GAAa/7B,UAAU8jC,WAAa,SAAqBjS,GACvD,IAAIr5B,EAAI+I,KAAK2B,MAAMtH,OAAS,EAC5B,GAAIpD,EAAI+I,KAAK2+B,KAAM,CACjB,KAAO1nC,EAAI+I,KAAK2+B,KAAM1nC,IAAO+I,KAAK2B,MAAM1K,EAAI,GAAG9B,QAAQyF,KAAKoF,KAAK2B,MAAM1K,GAAGyjC,OAAOpK,IACjFtwB,KAAK2B,MAAMtH,OAAS2F,KAAK2+B,KAAO,IAIpCnE,GAAa/7B,UAAUi8B,OAAS,WAG9B,OAFA16B,KAAK2+B,KAAO,EACZ3+B,KAAKuiC,WAAWviC,KAAK4+B,QACd5+B,KAAK2B,MAAM,GAAG+4B,OAAO16B,KAAK4+B,QAAU5+B,KAAKK,QAAQoiC,UAG1DjI,GAAa/7B,UAAU0iC,KAAO,SAAezrC,GAC3C,IAAK,IAAIuB,EAAI+I,KAAK2+B,KAAM1nC,GAAK,EAAGA,IAAO,GAAI+I,KAAK2B,MAAM1K,IAAMvB,EAE1D,YADAsK,KAAK2+B,KAAO1nC,IAKhBioC,GAAqBC,WAAW3S,IAAM,WACpCxsB,KAAKuiC,aAEL,IADA,IAAItsC,EAAM,EACDgB,EAAI+I,KAAK2+B,KAAM1nC,GAAK,EAAGA,IAAK,CAEnC,IADA,IAAI9B,EAAU6K,KAAK2B,MAAM1K,GAAG9B,QACnBue,EAAIve,EAAQkF,OAAS,EAAGqZ,GAAK,EAAGA,IACrCzd,GAAOd,EAAQue,GAAGxd,SAClBe,GAAKhB,IAEX,OAAOA,GAGTukC,GAAa/7B,UAAUwjC,YAAc,SAAsB/sC,EAAQwQ,GACjE,GAAI1F,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IACjD+I,KAAKoF,KAAKnO,GAAGX,MAAQpB,GAAU8K,KAAKoF,KAAKnO,GAAGyO,QAAUA,IACtD1F,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKm/B,aAIhC3E,GAAa/7B,UAAU+hC,WAAa,SAAqBtrC,GACvD,GAAI8K,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IAC7B,MAApB+I,KAAKoF,KAAKnO,GAAGhB,KAAkC,GAAnBf,EAAOqG,UAAiBrG,EAAOimB,SAASnb,KAAKoF,KAAKnO,GAAGX,QACjF0J,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKm/B,aAIhC3E,GAAa/7B,UAAUsjC,WAAa,SAAqB7sC,EAAQC,EAASP,GACxE,GAAIM,GAAUC,GAAW6K,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IAAK,CAC/E,GAAwB,MAApB+I,KAAKoF,KAAKnO,GAAGhB,KAAkC,GAAnBf,EAAOqG,UAAiBrG,EAAOimB,SAASnb,KAAKoF,KAAKnO,GAAGX,MACzEnB,EAAQutC,wBAAwB1iC,KAAKoF,KAAKnO,GAAGX,OAC5C1B,EAAS,EAAI,KACpBoL,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKm/B,cAKlC3E,GAAa/7B,UAAU8hC,WAAa,SAAqBoC,GACvD,GAAI3iC,KAAKoF,KAAQ,IAAK,IAAInO,EAAI,EAAGA,EAAI+I,KAAKoF,KAAK/K,OAAQpD,IACjD+I,KAAKoF,KAAKnO,GAAGX,MAAQqsC,IACrB3iC,KAAKoF,KAAKnO,GAAGhB,IAAM+J,KAAKm/B,YAAcwD,EAASxC,UAAU9lC,OAAS2F,KAAKoF,KAAKnO,GAAGyO,UAOvF80B,GAAa/7B,UAAUq8B,eAAiB,SAAyBv7B,GAC7D,IAAI26B,EAASl6B,KAEf,GAAIT,EAAQygB,QAAQ,MAAQ,EACxB,OAAOzgB,EAAQvG,MAAM,YAAYme,KAAKnX,KAAK86B,eAAgB96B,MAE/D,IAAIgK,EAAQzK,EAAQvG,MAAM,KACtB4pC,EAAS5iC,KAAKK,QAAQd,QACtBsjC,IAAW7iC,KAAK4+B,QAAYgE,GAAUA,EAAO1tC,OAAOJ,MAAQkL,KAAK2B,MAAM,GAAG7M,MAC1EguC,IAAaF,EAASA,EAAOxsC,MAAQ,EAAI,IAAMysC,EAAU,EAAI,GAC7DhrC,EAAQ,SAAUZ,EAAGb,GACvB,KAAOa,GAAK,EAAGA,IAAK,CAClB,IAAI8rC,EAAO/4B,EAAM/S,GACjB,GAAY,IAAR8rC,EAAY,CACd,GAAI9rC,GAAK+S,EAAM3P,OAAS,GAAU,GAALpD,EAAU,SACvC,KAAOb,GAAS0sC,EAAU1sC,IACtB,GAAIyB,EAAMZ,EAAI,EAAGb,GAAU,OAAO,EACtC,OAAO,EAEP,IAAIy8B,EAAOz8B,EAAQ,GAAe,GAATA,GAAcysC,EAAW3I,EAAOv4B,MAAMvL,GAAOtB,KAChE8tC,GAAUxsC,GAAS0sC,EAAWF,EAAOtsC,KAAKF,EAAQ0sC,GAAUhuC,KAC5D,KACN,IAAK+9B,GAASA,EAAK5yB,MAAQ8iC,IAAsC,GAA9BlQ,EAAK6E,OAAO1X,QAAQ+iB,GACnD,OAAO,EACX3sC,IAGJ,OAAO,GAET,OAAOyB,EAAMmS,EAAM3P,OAAS,EAAG2F,KAAK2+B,OAGtCnE,GAAa/7B,UAAU6jC,qBAAuB,WAC5C,IAAIU,EAAWhjC,KAAKK,QAAQd,QAC5B,GAAIyjC,EAAY,IAAK,IAAI3yB,EAAI2yB,EAAS5sC,MAAOia,GAAK,EAAGA,IAAK,CACxD,IAAIjX,EAAQ4pC,EAAS1sC,KAAK+Z,GAAGjY,eAAe4qC,EAAS7qC,WAAWkY,IAAI7M,YACpE,GAAIpK,GAASA,EAAMzC,aAAeyC,EAAMs6B,aAAgB,OAAOt6B,EAEjE,IAAK,IAAI6G,KAAQD,KAAKwI,OAAOhH,OAAOG,MAAO,CACzC,IAAI7M,EAAOkL,KAAKwI,OAAOhH,OAAOG,MAAM1B,GACpC,GAAInL,EAAK6B,aAAe7B,EAAK4+B,aAAgB,OAAO5+B,IAIxD0lC,GAAa/7B,UAAUuhC,eAAiB,SAAyBx6B,GAC/D,IAAIpI,EAuFN,SAA2BoI,EAAMoqB,GAC/B,IAAK,IAAI34B,EAAI,EAAGA,EAAI24B,EAAIv1B,OAAQpD,IAC9B,GAAIuO,EAAKgC,GAAGooB,EAAI34B,IAAO,OAAO24B,EAAI34B,GAzFxBgsC,CAAkBz9B,EAAMxF,KAAK2qB,IAAImT,cACzC1gC,GAAS4C,KAAK2qB,IAAIsT,WAAWrjC,KAAKwC,GACtC4C,KAAK2qB,IAAImT,aAAet4B,EAAKmqB,SAAS3vB,KAAK2qB,IAAImT,eAGjDtD,GAAa/7B,UAAUyhC,kBAAoB,SAA4B16B,EAAM09B,GAC3E,IAAK,IAAI9sC,EAAQ4J,KAAK2+B,KAAMvoC,GAAS,EAAGA,IAAS,CAC/C,IAAI+sC,EAAQnjC,KAAK2B,MAAMvL,GAEvB,GADY+sC,EAAMrF,aAAa5W,YAAY1hB,IAC9B,EACX29B,EAAMrF,aAAet4B,EAAKuqB,cAAcoT,EAAMrF,kBACzC,CACLqF,EAAMnF,YAAcx4B,EAAKuqB,cAAcoT,EAAMnF,aAC7C,IAAIoF,EAAYD,EAAMhF,iBAAiB34B,GACnC49B,GAAaD,EAAMruC,MAAQquC,EAAMruC,KAAKkkC,eAAeoK,EAAUtuC,QAC/DquC,EAAMnF,YAAcoF,EAAUzT,SAASwT,EAAMnF,cAEnD,GAAImF,GAASD,EAAQ,QAIzB1kC,OAAO6wB,iBAAkBmL,GAAa/7B,UAAWygC,IA4FjD,IAAImE,GAAgB,SAAuB1hC,EAAOgD,GAGhD3E,KAAK2B,MAAQA,GAAS,GAGtB3B,KAAK2E,MAAQA,GAAS,IAiKxB,SAAS2+B,GAAYl3B,GACnB,IAAI/B,EAAS,GACb,IAAK,IAAIpK,KAAQmM,EAAK,CACpB,IAAIiS,EAAQjS,EAAInM,GAAMlL,KAAKspB,MACvBA,IAAShU,EAAOpK,GAAQoe,GAE9B,OAAOhU,EAGT,SAAS9U,GAAI8K,GAEX,OAAOA,EAAQsG,UAAYhE,OAAOgE,SApKpC08B,GAAc5kC,UAAU2Z,kBAAoB,SAA4BF,EAAU7X,EAAS3L,GACvF,IAAIwlC,EAASl6B,UACI,IAAZK,IAAqBA,EAAU,IAEjC3L,IAAUA,EAASa,GAAI8K,GAASkjC,0BAErC,IAAI5Y,EAAMj2B,EAAQsiC,EAAS,KA4B3B,OA3BA9e,EAAS/Y,SAAQ,SAAU7I,GACzB,GAAI0gC,GAAU1gC,EAAKqO,MAAMtK,OAAQ,CAC1B28B,IAAUA,EAAS,IAExB,IADA,IAAIwM,EAAO,EAAGlnB,EAAW,EAClBknB,EAAOxM,EAAO38B,QAAUiiB,EAAWhmB,EAAKqO,MAAMtK,QAAQ,CAC3D,IAAIw4B,EAAOv8B,EAAKqO,MAAM2X,GACtB,GAAK4d,EAAOv1B,MAAMkuB,EAAK/9B,KAAKmL,MAA5B,CACA,IAAK4yB,EAAKrrB,GAAGwvB,EAAOwM,MAAsC,IAA5B3Q,EAAK/9B,KAAKC,KAAK2pB,SAAsB,MACnE8kB,GAAQ,EAAGlnB,SAF0BA,IAIvC,KAAOknB,EAAOxM,EAAO38B,QACnBswB,EAAMqM,EAAOI,MACbJ,EAAOI,MAET,KAAO9a,EAAWhmB,EAAKqO,MAAMtK,QAAQ,CACnC,IAAIopC,EAAMntC,EAAKqO,MAAM2X,KACjBonB,EAAUxJ,EAAOyJ,cAAcF,EAAKntC,EAAK4E,SAAUmF,GACnDqjC,IACF1M,EAAOp8B,KAAK6oC,EAAK9Y,GACjBA,EAAIlS,YAAYirB,EAAQhhC,KACxBioB,EAAM+Y,EAAQ/e,YAAc+e,EAAQhhC,MAI1CioB,EAAIlS,YAAYyhB,EAAO0J,mBAAmBttC,EAAM+J,OAG3C3L,GAGT2uC,GAAc5kC,UAAUmlC,mBAAqB,SAA6BttC,EAAM+J,QAC3D,IAAZA,IAAqBA,EAAU,IAEtC,IAAIvJ,EACAusC,GAAcQ,WAAWtuC,GAAI8K,GAAUL,KAAK2B,MAAMrL,EAAKxB,KAAKmL,MAAM3J,IAChEoM,EAAM5L,EAAI4L,IACViiB,EAAa7tB,EAAI6tB,WACvB,GAAIA,EAAY,CACd,GAAIruB,EAAKiwB,OACL,MAAM,IAAIkI,WAAW,gDACrBpuB,EAAQyjC,UACRzjC,EAAQyjC,UAAUxtC,EAAMquB,EAAYtkB,GAEpCL,KAAKoY,kBAAkB9hB,EAAKnB,QAASkL,EAASskB,GAEpD,OAAOjiB,GAST2gC,GAAc5kC,UAAUslC,cAAgB,SAAwBztC,EAAM+J,QACjD,IAAZA,IAAqBA,EAAU,IAGtC,IADA,IAAIqC,EAAM1C,KAAK4jC,mBAAmBttC,EAAM+J,GAC/BpJ,EAAIX,EAAKqO,MAAMtK,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAC/C,IAAImD,EAAO4F,KAAK2jC,cAAcrtC,EAAKqO,MAAM1N,GAAIX,EAAK4E,SAAUmF,GACxDjG,KACPA,EAAKuqB,YAAcvqB,EAAKsI,KAAK+V,YAAY/V,GACpCA,EAAMtI,EAAKsI,KAGf,OAAOA,GAGT2gC,GAAc5kC,UAAUklC,cAAgB,SAAwBn+B,EAAMuY,EAAQ1d,QACzD,IAAZA,IAAqBA,EAAU,IAEtC,IAAIge,EAAQre,KAAK2E,MAAMa,EAAK1Q,KAAKmL,MACjC,OAAOoe,GAASglB,GAAcQ,WAAWtuC,GAAI8K,GAAUge,EAAM7Y,EAAMuY,KAOrEslB,GAAcQ,WAAa,SAAqBtuC,EAAKyuC,EAAWC,GAG9D,QAFiB,IAAVA,IAAmBA,EAAQ,MAEV,iBAAbD,EACP,MAAO,CAACthC,IAAKnN,EAAIksC,eAAeuC,IACpC,GAA0B,MAAtBA,EAAUzoC,SACV,MAAO,CAACmH,IAAKshC,GACjB,GAAIA,EAAUthC,KAAiC,MAA1BshC,EAAUthC,IAAInH,SAC/B,OAAOyoC,EACX,IAAIre,EAAUqe,EAAU,GAAIE,EAAQve,EAAQ3F,QAAQ,KAChDkkB,EAAQ,IACVD,EAAQte,EAAQlwB,MAAM,EAAGyuC,GACzBve,EAAUA,EAAQlwB,MAAMyuC,EAAQ,IAElC,IAAIvf,EAAa,KAAMjiB,EAAMuhC,EAAQ1uC,EAAI4uC,gBAAgBF,EAAOte,GAAWpwB,EAAIijB,cAAcmN,GACzFnqB,EAAQwoC,EAAU,GAAI7oC,EAAQ,EAClC,GAAIK,GAAyB,iBAATA,GAAuC,MAAlBA,EAAMD,WAAqB4K,MAAMC,QAAQ5K,GAEhF,IAAK,IAAIyE,KADT9E,EAAQ,EACSK,EAAS,GAAmB,MAAfA,EAAMyE,GAAe,CACjD,IAAImkC,EAAUnkC,EAAK+f,QAAQ,KACvBokB,EAAU,EAAK1hC,EAAI2hC,eAAepkC,EAAKxK,MAAM,EAAG2uC,GAAUnkC,EAAKxK,MAAM2uC,EAAU,GAAI5oC,EAAMyE,IACtFyC,EAAImgB,aAAa5iB,EAAMzE,EAAMyE,IAGxC,IAAK,IAAIhJ,EAAIkE,EAAOlE,EAAI+sC,EAAU3pC,OAAQpD,IAAK,CAC7C,IAAIwG,EAAQumC,EAAU/sC,GACtB,GAAc,IAAVwG,EAAa,CACf,GAAIxG,EAAI+sC,EAAU3pC,OAAS,GAAKpD,EAAIkE,EAChC,MAAM,IAAIszB,WAAW,0DACzB,MAAO,CAAC/rB,IAAKA,EAAKiiB,WAAYjiB,GAE9B,IAAI5L,EAAMusC,GAAcQ,WAAWtuC,EAAKkI,EAAOwmC,GACzC/0B,EAAQpY,EAAI4L,IACZ4hC,EAAextC,EAAI6tB,WAEzB,GADAjiB,EAAI+V,YAAYvJ,GACZo1B,EAAc,CAChB,GAAI3f,EAAc,MAAM,IAAI8J,WAAW,0BACvC9J,EAAa2f,GAInB,MAAO,CAAC5hC,IAAKA,EAAKiiB,WAAYA,IAMhC0e,GAAcjI,WAAa,SAAqB55B,GAC9C,OAAOA,EAAO4xB,OAAOmR,gBAClB/iC,EAAO4xB,OAAOmR,cAAgB,IAAIlB,GAAcrjC,KAAKwkC,gBAAgBhjC,GAASxB,KAAKykC,gBAAgBjjC,MAMxG6hC,GAAcmB,gBAAkB,SAA0BhjC,GACxD,IAAI6I,EAASi5B,GAAY9hC,EAAOG,OAEhC,OADK0I,EAAOrJ,OAAQqJ,EAAOrJ,KAAO,SAAU1K,GAAQ,OAAOA,EAAK0K,OACzDqJ,GAKTg5B,GAAcoB,gBAAkB,SAA0BjjC,GACxD,OAAO8hC,GAAY9hC,EAAOmD,S,yPCj4GxB+/B,EAAclmC,OAAOlE,OAAO,MAI5BqqC,EAAY,SAAmBntC,EAAST,EAAOmL,GAGjDlC,KAAKkC,OAASA,GAAU,CAAC,IAAI0iC,EAAeptC,EAAQ2K,IAAIpL,GAAQS,EAAQ8J,IAAIvK,KAI5EiJ,KAAKxI,QAAUA,EAIfwI,KAAKjJ,MAAQA,GAGXg3B,EAAqB,CAAE8W,OAAQ,CAAE7W,cAAc,GAAOsP,KAAM,CAAEtP,cAAc,GAAOr4B,KAAM,CAAEq4B,cAAc,GAAOt4B,GAAI,CAAEs4B,cAAc,GAAOt1B,MAAO,CAAEs1B,cAAc,GAAOr1B,IAAK,CAAEq1B,cAAc,GAAOl6B,MAAO,CAAEk6B,cAAc,IAIhOD,EAAmB8W,OAAOrY,IAAM,WAAc,OAAOxsB,KAAKxI,QAAQvB,KAIlE83B,EAAmBuP,KAAK9Q,IAAM,WAAc,OAAOxsB,KAAKjJ,MAAMd,KAI9D83B,EAAmBp4B,KAAK62B,IAAM,WAAc,OAAOxsB,KAAKtH,MAAMzC,KAI9D83B,EAAmBr4B,GAAG82B,IAAM,WAAc,OAAOxsB,KAAKrH,IAAI1C,KAI1D83B,EAAmBr1B,MAAM8zB,IAAM,WAC7B,OAAOxsB,KAAKkC,OAAO,GAAGxJ,OAKxBq1B,EAAmBp1B,IAAI6zB,IAAM,WAC3B,OAAOxsB,KAAKkC,OAAO,GAAGvJ,KAKxBo1B,EAAmBj6B,MAAM04B,IAAM,WAE7B,IADA,IAAItqB,EAASlC,KAAKkC,OACTjL,EAAI,EAAGA,EAAIiL,EAAO7H,OAAQpD,IAC/B,GAAIiL,EAAOjL,GAAGyB,MAAMzC,KAAOiM,EAAOjL,GAAG0B,IAAI1C,IAAO,OAAO,EAC3D,OAAO,GAYT0uC,EAAUlmC,UAAUtJ,QAAU,WAC5B,OAAO6K,KAAKtH,MAAMpC,KAAK,GAAGb,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAI,IAMtDivC,EAAUlmC,UAAUiS,QAAU,SAAkB3c,EAAIoB,QAC/B,IAAZA,IAAqBA,EAAU,YAMtC,IADA,IAAI2vC,EAAW3vC,EAAQA,QAAQuB,UAAWquC,EAAa,KAC9C9tC,EAAI,EAAGA,EAAI9B,EAAQm7B,QAASr5B,IACnC8tC,EAAaD,EACbA,EAAWA,EAASpuC,UAItB,IADA,IAAIsuC,EAAUjxC,EAAGsV,MAAMhP,OAAQ6H,EAASlC,KAAKkC,OACpClH,EAAM,EAAGA,EAAMkH,EAAO7H,OAAQW,IAAO,CAC5C,IAAIlE,EAAMoL,EAAOlH,GACXtC,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACV5C,EAAUhC,EAAGgC,QAAQN,MAAMuvC,GACjCjxC,EAAGkxC,aAAalvC,EAAQC,IAAI0C,EAAMzC,KAAMF,EAAQC,IAAI2C,EAAI1C,KAAM+E,EAAM,WAAc7F,GACvE,GAAP6F,GACA2O,EAAwB5V,EAAIixC,GAAUF,EAAWA,EAAS5pC,SAAW6pC,GAAcA,EAAWpuC,cAAgB,EAAI,KAO1HguC,EAAUlmC,UAAUnG,YAAc,SAAsBvE,EAAIuC,GAE1D,IADA,IAAI0uC,EAAUjxC,EAAGsV,MAAMhP,OAAQ6H,EAASlC,KAAKkC,OACpCjL,EAAI,EAAGA,EAAIiL,EAAO7H,OAAQpD,IAAK,CACtC,IAAIH,EAAMoL,EAAOjL,GACXyB,EAAQ5B,EAAI4B,MACZC,EAAM7B,EAAI6B,IACV5C,EAAUhC,EAAGgC,QAAQN,MAAMuvC,GAC7BrvC,EAAOI,EAAQC,IAAI0C,EAAMzC,KAAMP,EAAKK,EAAQC,IAAI2C,EAAI1C,KACpDgB,EACFlD,EAAGqQ,YAAYzO,EAAMD,IAErB3B,EAAGmxC,iBAAiBvvC,EAAMD,EAAIY,GAC9BqT,EAAwB5V,EAAIixC,EAAS1uC,EAAK4E,UAAY,EAAI,MAiBhEypC,EAAUQ,SAAW,SAAmBnuC,EAAMouC,EAAKC,GACjD,IAAIn2B,EAAQlY,EAAK9B,OAAO0D,cAAgB,IAAI0sC,EAActuC,GACpDuuC,EAAgBvuC,EAAKV,KAAK,GAAIU,EAAK9B,OAAQ8B,EAAKf,IAAKe,EAAKE,QAASkuC,EAAKC,GAC9E,GAAIn2B,EAAS,OAAOA,EAEpB,IAAK,IAAI9Y,EAAQY,EAAKZ,MAAQ,EAAGA,GAAS,EAAGA,IAAS,CACpD,IAAIgH,EAAQgoC,EAAM,EACZG,EAAgBvuC,EAAKV,KAAK,GAAIU,EAAKV,KAAKF,GAAQY,EAAKpC,OAAOwB,EAAQ,GAAIY,EAAKE,MAAMd,GAAQgvC,EAAKC,GAChGE,EAAgBvuC,EAAKV,KAAK,GAAIU,EAAKV,KAAKF,GAAQY,EAAKxB,MAAMY,EAAQ,GAAIY,EAAKE,MAAMd,GAAS,EAAGgvC,EAAKC,GACzG,GAAIjoC,EAAS,OAAOA,IAQxBunC,EAAUa,KAAO,SAAexuC,EAAMmS,GAGpC,YAFgB,IAATA,IAAkBA,EAAO,GAEzBnJ,KAAKmlC,SAASnuC,EAAMmS,IAASnJ,KAAKmlC,SAASnuC,GAAOmS,IAAS,IAAIs8B,EAAazuC,EAAKV,KAAK,KAQ/FquC,EAAUzmC,QAAU,SAAkB3I,GACpC,OAAOgwC,EAAgBhwC,EAAKA,EAAK,EAAG,EAAG,IAAM,IAAIkwC,EAAalwC,IAMhEovC,EAAUxrC,MAAQ,SAAgB5D,GAChC,OAAOgwC,EAAgBhwC,EAAKA,EAAKA,EAAIJ,QAAQC,KAAMG,EAAIqB,YAAa,IAAM,IAAI6uC,EAAalwC,IAM7FovC,EAAUzV,SAAW,SAAmB35B,EAAKy6B,GAC3C,IAAKA,IAASA,EAAKl7B,KAAQ,MAAM,IAAI25B,WAAW,wCAChD,IAAIiX,EAAMhB,EAAY1U,EAAKl7B,MAC3B,IAAK4wC,EAAO,MAAM,IAAIjX,WAAY,qBAAwBuB,EAAS,KAAI,YACvE,OAAO0V,EAAIxW,SAAS35B,EAAKy6B,IAQ3B2U,EAAUgB,OAAS,SAAiBC,EAAIC,GACtC,GAAID,KAAMlB,EAAe,MAAM,IAAIjW,WAAW,sCAAwCmX,GAGtF,OAFAlB,EAAYkB,GAAMC,EAClBA,EAAepnC,UAAUknC,OAASC,EAC3BC,GAWTlB,EAAUlmC,UAAUqnC,YAAc,WAChC,OAAOR,EAAcS,QAAQ/lC,KAAKxI,QAASwI,KAAKjJ,OAAO+uC,eAGzDtnC,OAAO6wB,iBAAkBsV,EAAUlmC,UAAWsvB,GAM9C4W,EAAUlmC,UAAUunC,SAAU,EAiB9B,IAAIpB,EAAiB,SAAwBlsC,EAAOC,GAGlDqH,KAAKtH,MAAQA,EAGbsH,KAAKrH,IAAMA,GAOT2sC,EAA8B,SAAUX,GAC1C,SAASW,EAAc9tC,EAAST,QACf,IAAVA,IAAmBA,EAAQS,GAEhCmtC,EAAUhmC,KAAKqB,KAAMxI,EAAST,GAG3B4tC,IAAYW,EAAchjC,UAAYqiC,GAC3CW,EAAc7mC,UAAYD,OAAOlE,OAAQqqC,GAAaA,EAAUlmC,WAChE6mC,EAAc7mC,UAAUI,YAAcymC,EAEtC,IAAI/U,EAAuB,CAAEp8B,QAAS,CAAE65B,cAAc,IA+EtD,OA1EAuC,EAAqBp8B,QAAQq4B,IAAM,WAAc,OAAOxsB,KAAKxI,QAAQvB,KAAO+J,KAAKjJ,MAAMd,IAAM+J,KAAKjJ,MAAQ,MAE1GuuC,EAAc7mC,UAAUzI,IAAM,SAAcT,EAAKQ,GAC/C,IAAIgB,EAAQxB,EAAIO,QAAQC,EAAQC,IAAIgK,KAAKs9B,OACzC,IAAKvmC,EAAM7B,OAAO0D,cAAiB,OAAO+rC,EAAUa,KAAKzuC,GACzD,IAAIS,EAAUjC,EAAIO,QAAQC,EAAQC,IAAIgK,KAAK6kC,SAC3C,OAAO,IAAIS,EAAc9tC,EAAQtC,OAAO0D,cAAgBpB,EAAUT,EAAOA,IAG3EuuC,EAAc7mC,UAAUiS,QAAU,SAAkB3c,EAAIoB,GAItD,QAHiB,IAAZA,IAAqBA,EAAU,YAEpCwvC,EAAUlmC,UAAUiS,QAAQ/R,KAAKqB,KAAMjM,EAAIoB,GACvCA,GAAW,WAAa,CAC1B,IAAIwP,EAAQ3E,KAAKtH,MAAMk6B,YAAY5yB,KAAKrH,KACpCgM,GAAS5Q,EAAG0b,YAAY9K,KAIhC2gC,EAAc7mC,UAAU+I,GAAK,SAAa2mB,GACxC,OAAOA,aAAiBmX,GAAiBnX,EAAM0W,QAAU7kC,KAAK6kC,QAAU1W,EAAMmP,MAAQt9B,KAAKs9B,MAG7FgI,EAAc7mC,UAAUqnC,YAAc,WACpC,OAAO,IAAIG,EAAajmC,KAAK6kC,OAAQ7kC,KAAKs9B,OAG5CgI,EAAc7mC,UAAU0W,OAAS,WAC/B,MAAO,CAACrgB,KAAM,OAAQ+vC,OAAQ7kC,KAAK6kC,OAAQvH,KAAMt9B,KAAKs9B,OAGxDgI,EAAcpW,SAAW,SAAmB35B,EAAKy6B,GAC/C,GAA0B,iBAAfA,EAAK6U,QAA0C,iBAAb7U,EAAKsN,KAC9C,MAAM,IAAI7O,WAAW,4CACzB,OAAO,IAAI6W,EAAc/vC,EAAIO,QAAQk6B,EAAK6U,QAAStvC,EAAIO,QAAQk6B,EAAKsN,QAKtEgI,EAAchrC,OAAS,SAAiB/E,EAAKsvC,EAAQvH,QACrC,IAATA,IAAkBA,EAAOuH,GAE9B,IAAIrtC,EAAUjC,EAAIO,QAAQ+uC,GAC1B,OAAO,IAAI7kC,KAAKxI,EAAS8lC,GAAQuH,EAASrtC,EAAUjC,EAAIO,QAAQwnC,KAUlEgI,EAAcS,QAAU,SAAkBvuC,EAAST,EAAOoS,GACxD,IAAI+8B,EAAO1uC,EAAQvB,IAAMc,EAAMd,IAE/B,GADKkT,IAAQ+8B,IAAQ/8B,EAAO+8B,GAAQ,EAAI,GAAK,IACxCnvC,EAAM7B,OAAO0D,cAAe,CAC/B,IAAIwE,EAAQunC,EAAUQ,SAASpuC,EAAOoS,GAAM,IAASw7B,EAAUQ,SAASpuC,GAAQoS,GAAM,GACtF,IAAI/L,EACG,OAAOunC,EAAUa,KAAKzuC,EAAOoS,GADvBpS,EAAQqG,EAAMrG,MAW7B,OARKS,EAAQtC,OAAO0D,gBACN,GAARstC,IAGF1uC,GAAWmtC,EAAUQ,SAAS3tC,GAAU2R,GAAM,IAASw7B,EAAUQ,SAAS3tC,EAAS2R,GAAM,IAAO3R,SACnFvB,IAAMc,EAAMd,KAASiwC,EAAO,KAHzC1uC,EAAUT,GAMP,IAAIuuC,EAAc9tC,EAAST,IAGpCyH,OAAO6wB,iBAAkBiW,EAAc7mC,UAAW8xB,GAE3C+U,EA1FwB,CA2F/BX,GAEFA,EAAUgB,OAAO,OAAQL,GAEzB,IAAIW,EAAe,SAAsBpB,EAAQvH,GAC/Ct9B,KAAK6kC,OAASA,EACd7kC,KAAKs9B,KAAOA,GAEd2I,EAAaxnC,UAAUzI,IAAM,SAAcD,GACzC,OAAO,IAAIkwC,EAAalwC,EAAQC,IAAIgK,KAAK6kC,QAAS9uC,EAAQC,IAAIgK,KAAKs9B,QAErE2I,EAAaxnC,UAAU3I,QAAU,SAAkBP,GACjD,OAAO+vC,EAAcS,QAAQxwC,EAAIO,QAAQkK,KAAK6kC,QAAStvC,EAAIO,QAAQkK,KAAKs9B,QAQ1E,IAAI6I,EAA8B,SAAUxB,GAC1C,SAASwB,EAAcnvC,GACrB,IAAIV,EAAOU,EAAKK,UACZw6B,EAAO76B,EAAKV,KAAK,GAAGR,QAAQkB,EAAKf,IAAMK,EAAKJ,UAChDyuC,EAAUhmC,KAAKqB,KAAMhJ,EAAM66B,GAE3B7xB,KAAK1J,KAAOA,EAiDd,OA9CKquC,IAAYwB,EAAc7jC,UAAYqiC,GAC3CwB,EAAc1nC,UAAYD,OAAOlE,OAAQqqC,GAAaA,EAAUlmC,WAChE0nC,EAAc1nC,UAAUI,YAAcsnC,EAEtCA,EAAc1nC,UAAUzI,IAAM,SAAcT,EAAKQ,GAC/C,IAAIe,EAAMf,EAAQ+wB,UAAU9mB,KAAK6kC,QAC7Bje,EAAU9vB,EAAI8vB,QACd3wB,EAAMa,EAAIb,IACVe,EAAOzB,EAAIO,QAAQG,GACvB,OAAI2wB,EAAkB+d,EAAUa,KAAKxuC,GAC9B,IAAImvC,EAAcnvC,IAG3BmvC,EAAc1nC,UAAUtJ,QAAU,WAChC,OAAO,IAAI,KAAM,UAAc6K,KAAK1J,MAAO,EAAG,IAGhD6vC,EAAc1nC,UAAU+I,GAAK,SAAa2mB,GACxC,OAAOA,aAAiBgY,GAAiBhY,EAAM0W,QAAU7kC,KAAK6kC,QAGhEsB,EAAc1nC,UAAU0W,OAAS,WAC/B,MAAO,CAACrgB,KAAM,OAAQ+vC,OAAQ7kC,KAAK6kC,SAGrCsB,EAAc1nC,UAAUqnC,YAAc,WAA0B,OAAO,IAAIM,EAAapmC,KAAK6kC,SAE7FsB,EAAcjX,SAAW,SAAmB35B,EAAKy6B,GAC/C,GAA0B,iBAAfA,EAAK6U,OACZ,MAAM,IAAIpW,WAAW,4CACzB,OAAO,IAAI0X,EAAc5wC,EAAIO,QAAQk6B,EAAK6U,UAK5CsB,EAAc7rC,OAAS,SAAiB/E,EAAKI,GAC3C,OAAO,IAAIqK,KAAKzK,EAAIO,QAAQH,KAM9BwwC,EAAcrgB,aAAe,SAAuBxvB,GAClD,OAAQA,EAAK8K,SAAwC,IAA9B9K,EAAKxB,KAAKC,KAAKkpB,YAGjCkoB,EAvDwB,CAwD/BxB,GAEFwB,EAAc1nC,UAAUunC,SAAU,EAElCrB,EAAUgB,OAAO,OAAQQ,GAEzB,IAAIC,EAAe,SAAsBvB,GACvC7kC,KAAK6kC,OAASA,GAEhBuB,EAAa3nC,UAAUzI,IAAM,SAAcD,GACzC,IAAIe,EAAMf,EAAQ+wB,UAAU9mB,KAAK6kC,QAC3Bje,EAAU9vB,EAAI8vB,QACd3wB,EAAMa,EAAIb,IAChB,OAAO2wB,EAAU,IAAIqf,EAAahwC,EAAKA,GAAO,IAAImwC,EAAanwC,IAEjEmwC,EAAa3nC,UAAU3I,QAAU,SAAkBP,GACjD,IAAIyB,EAAOzB,EAAIO,QAAQkK,KAAK6kC,QAASvuC,EAAOU,EAAKK,UACjD,OAAIf,GAAQ6vC,EAAcrgB,aAAaxvB,GAAgB,IAAI6vC,EAAcnvC,GAClE2tC,EAAUa,KAAKxuC,IAOxB,IAAIyuC,EAA6B,SAAUd,GACzC,SAASc,EAAalwC,GACpBovC,EAAUhmC,KAAKqB,KAAMzK,EAAIO,QAAQ,GAAIP,EAAIO,QAAQP,EAAIJ,QAAQC,OA6B/D,OA1BKuvC,IAAYc,EAAanjC,UAAYqiC,GAC1Cc,EAAahnC,UAAYD,OAAOlE,OAAQqqC,GAAaA,EAAUlmC,WAC/DgnC,EAAahnC,UAAUI,YAAc4mC,EAErCA,EAAahnC,UAAUiS,QAAU,SAAkB3c,EAAIoB,GAGrD,QAFiB,IAAZA,IAAqBA,EAAU,YAEhCA,GAAW,WAAa,CAC1BpB,EAAGsC,OAAO,EAAGtC,EAAGwB,IAAIJ,QAAQC,MAC5B,IAAIqD,EAAMksC,EAAUzmC,QAAQnK,EAAGwB,KAC1BkD,EAAI+O,GAAGzT,EAAGF,YAAcE,EAAG8B,aAAa4C,QAE7CksC,EAAUlmC,UAAUiS,QAAQ/R,KAAKqB,KAAMjM,EAAIoB,IAI/CswC,EAAahnC,UAAU0W,OAAS,WAAqB,MAAO,CAACrgB,KAAM,QAEnE2wC,EAAavW,SAAW,SAAmB35B,GAAO,OAAO,IAAIkwC,EAAalwC,IAE1EkwC,EAAahnC,UAAUzI,IAAM,SAAcT,GAAO,OAAO,IAAIkwC,EAAalwC,IAE1EkwC,EAAahnC,UAAU+I,GAAK,SAAa2mB,GAAS,OAAOA,aAAiBsX,GAE1EA,EAAahnC,UAAUqnC,YAAc,WAA0B,OAAOO,GAE/DZ,EA/BuB,CAgC9Bd,GAEFA,EAAUgB,OAAO,MAAOF,GAExB,IAAIY,EAAc,CAChBrwC,IAAK,WAAiB,OAAOgK,MAC7BlK,QAAS,SAAiBP,GAAO,OAAO,IAAIkwC,EAAalwC,KAQ3D,SAASgwC,EAAgBhwC,EAAKe,EAAML,EAAKiB,EAAOkuC,EAAKpkC,GACnD,GAAI1K,EAAKsC,cAAiB,OAAO0sC,EAAchrC,OAAO/E,EAAKU,GAC3D,IAAK,IAAIgB,EAAIC,GAASkuC,EAAM,EAAI,EAAI,GAAIA,EAAM,EAAInuC,EAAIX,EAAKM,WAAaK,GAAK,EAAGA,GAAKmuC,EAAK,CACxF,IAAI3nC,EAAQnH,EAAKmH,MAAMxG,GACvB,GAAKwG,EAAMtH,QAGJ,IAAK6K,GAAQmlC,EAAcrgB,aAAaroB,GAC7C,OAAO0oC,EAAc7rC,OAAO/E,EAAKU,GAAOmvC,EAAM,EAAI3nC,EAAMvH,SAAW,QAJlD,CACjB,IAAIgZ,EAAQq2B,EAAgBhwC,EAAKkI,EAAOxH,EAAMmvC,EAAKA,EAAM,EAAI3nC,EAAM7G,WAAa,EAAGwuC,EAAKpkC,GACxF,GAAIkO,EAAS,OAAOA,EAItBjZ,GAAOwH,EAAMvH,SAAWkvC,GAI5B,SAASz7B,EAAwB5V,EAAImV,EAAUC,GAC7C,IAAIC,EAAOrV,EAAGsV,MAAMhP,OAAS,EAC7B,KAAI+O,EAAOF,GAAX,CACA,IAEiCnQ,EAF7BnD,EAAO7B,EAAGsV,MAAMD,GACpB,GAAMxT,aAAgB,MAAeA,aAAgB,KAC3C7B,EAAGgC,QAAQuT,KAAKF,GACtBjK,SAAQ,SAAUoK,EAAOC,EAAKC,EAAUC,GAAoB,MAAP3Q,IAAeA,EAAM2Q,MAC9E3V,EAAG8B,aAAa8uC,EAAUa,KAAKzxC,EAAGwB,IAAIO,QAAQiD,GAAMoQ,KAGtD,IAmBIm9B,EAA4B,SAAUC,GACxC,SAASD,EAAY3yC,GACnB4yC,EAAU5nC,KAAKqB,KAAMrM,EAAM4B,KAI3ByK,KAAKwmC,KAAOC,KAAKC,MACjB1mC,KAAK2mC,aAAehzC,EAAME,UAE1BmM,KAAK4mC,gBAAkB,EAGvB5mC,KAAKyH,YAAc9T,EAAM8T,YAGzBzH,KAAK6mC,QAAU,EAEf7mC,KAAKoK,KAAO5L,OAAOlE,OAAO,MAGvBisC,IAAYD,EAAYhkC,UAAYikC,GACzCD,EAAY7nC,UAAYD,OAAOlE,OAAQisC,GAAaA,EAAU9nC,WAC9D6nC,EAAY7nC,UAAUI,YAAcynC,EAEpC,IAAIvY,EAAqB,CAAEl6B,UAAW,CAAEm6B,cAAc,GAAO/T,aAAc,CAAE+T,cAAc,GAAO8Y,eAAgB,CAAE9Y,cAAc,GAAO+Y,UAAW,CAAE/Y,cAAc,GAAOgZ,iBAAkB,CAAEhZ,cAAc,IAwK7M,OAjKAD,EAAmBl6B,UAAU24B,IAAM,WAKjC,OAJIxsB,KAAK4mC,gBAAkB5mC,KAAKqJ,MAAMhP,SACpC2F,KAAK2mC,aAAe3mC,KAAK2mC,aAAa3wC,IAAIgK,KAAKzK,IAAKyK,KAAKjK,QAAQN,MAAMuK,KAAK4mC,kBAC5E5mC,KAAK4mC,gBAAkB5mC,KAAKqJ,MAAMhP,QAE7B2F,KAAK2mC,cAMdL,EAAY7nC,UAAU5I,aAAe,SAAuBhC,GAC1D,GAAIA,EAAU6E,MAAMnD,KAAOyK,KAAKzK,IAC5B,MAAM,IAAIk5B,WAAW,uEAKzB,OAJAzuB,KAAK2mC,aAAe9yC,EACpBmM,KAAK4mC,gBAAkB5mC,KAAKqJ,MAAMhP,OAClC2F,KAAK6mC,SAAyC,GAlEhC,EAkEE7mC,KAAK6mC,SACrB7mC,KAAKyH,YAAc,KACZzH,MAKT+tB,EAAmB9T,aAAauS,IAAM,WACpC,OA1Ec,EA0ENxsB,KAAK6mC,SAAyB,GAKxCP,EAAY7nC,UAAUiJ,eAAiB,SAAyB/C,GAG9D,OAFA3E,KAAKyH,YAAc9C,EACnB3E,KAAK6mC,SAjF4B,EAkF1B7mC,MAOTsmC,EAAY7nC,UAAUgR,YAAc,SAAsB9K,GAGxD,OAFK,aAAa3E,KAAKyH,aAAezH,KAAKnM,UAAU6E,MAAMiM,QAASA,IAChE3E,KAAK0H,eAAe/C,GACjB3E,MAKTsmC,EAAY7nC,UAAUyP,cAAgB,SAAwB1I,GAC5D,OAAOxF,KAAKyP,YAAYjK,EAAKmqB,SAAS3vB,KAAKyH,aAAezH,KAAKnM,UAAUkD,MAAM4N,WAKjF2hC,EAAY7nC,UAAUwV,iBAAmB,SAA2BzO,GAClE,OAAOxF,KAAKyP,YAAYjK,EAAKuqB,cAAc/vB,KAAKyH,aAAezH,KAAKnM,UAAUkD,MAAM4N,WAKtFopB,EAAmB+Y,eAAeta,IAAM,WACtC,OA9GiC,EA8GzBxsB,KAAK6mC,SAA2B,GAG1CP,EAAY7nC,UAAUwoC,QAAU,SAAkBrxC,EAAML,GACtDgxC,EAAU9nC,UAAUwoC,QAAQtoC,KAAKqB,KAAMpK,EAAML,GAC7CyK,KAAK6mC,SAAyB,EAAf7mC,KAAK6mC,QACpB7mC,KAAKyH,YAAc,MAKrB6+B,EAAY7nC,UAAUyoC,QAAU,SAAkBV,GAEhD,OADAxmC,KAAKwmC,KAAOA,EACLxmC,MAKTsmC,EAAY7nC,UAAU0oC,iBAAmB,SAA2B1xC,GAElE,OADAuK,KAAKnM,UAAU6c,QAAQ1Q,KAAMvK,GACtBuK,MAOTsmC,EAAY7nC,UAAUkP,qBAAuB,SAA+BrX,EAAM8wC,GAChF,IAAIvzC,EAAYmM,KAAKnM,UAIrB,OAHqB,IAAjBuzC,IACA9wC,EAAOA,EAAKkP,KAAKxF,KAAKyH,cAAgB5T,EAAUC,MAAQD,EAAU6E,MAAMiM,QAAW9Q,EAAU6E,MAAMk6B,YAAY/+B,EAAU8E,MAAQ,aACrI9E,EAAUyE,YAAY0H,KAAM1J,GACrB0J,MAKTsmC,EAAY7nC,UAAU/K,gBAAkB,WAEtC,OADAsM,KAAKnM,UAAU6c,QAAQ1Q,MAChBA,MAMTsmC,EAAY7nC,UAAU9G,WAAa,SAAqBqJ,EAAMrL,EAAMD,QACtD,IAAPA,IAAgBA,EAAKC,GAE1B,IAAI6L,EAASxB,KAAKzK,IAAIT,KAAK0M,OAC3B,GAAY,MAAR7L,EACF,OAAKqL,EACEhB,KAAK2N,qBAAqBnM,EAAOR,KAAKA,IAAO,GADhChB,KAAKtM,kBAGzB,IAAKsN,EAAQ,OAAOhB,KAAKoE,YAAYzO,EAAMD,GAC3C,IAAIiP,EAAQ3E,KAAKyH,YACjB,IAAK9C,EAAO,CACV,IAAIjM,EAAQsH,KAAKzK,IAAIO,QAAQH,GAC7BgP,EAAQjP,GAAMC,EAAO+C,EAAMiM,QAAUjM,EAAMk6B,YAAY5yB,KAAKzK,IAAIO,QAAQJ,IAI1E,OAFAsK,KAAKklC,iBAAiBvvC,EAAMD,EAAI8L,EAAOR,KAAKA,EAAM2D,IAC7C3E,KAAKnM,UAAUC,OAASkM,KAAKnK,aAAa8uC,EAAUa,KAAKxlC,KAAKnM,UAAU8E,MACtEqH,MAOXsmC,EAAY7nC,UAAUmP,QAAU,SAAkBxR,EAAKmC,GAErD,OADAyB,KAAKoK,KAAmB,iBAAPhO,EAAkBA,EAAMA,EAAIA,KAAOmC,EAC7CyB,MAKTsmC,EAAY7nC,UAAUkX,QAAU,SAAkBvZ,GAChD,OAAO4D,KAAKoK,KAAmB,iBAAPhO,EAAkBA,EAAMA,EAAIA,MAMtD2xB,EAAmBgZ,UAAUva,IAAM,WACjC,IAAK,IAAI9C,KAAK1pB,KAAKoK,KAAQ,OAAO,EAClC,OAAO,GAMTk8B,EAAY7nC,UAAUzK,eAAiB,WAErC,OADAgM,KAAK6mC,SAzMgD,EA0M9C7mC,MAGT+tB,EAAmBiZ,iBAAiBxa,IAAM,WACxC,OA9MqD,EA8M7CxsB,KAAK6mC,SAA4B,GAG3CroC,OAAO6wB,iBAAkBiX,EAAY7nC,UAAWsvB,GAEzCuY,EAhMsB,CAiM7B,MAEF,SAAS7mC,EAAK0L,EAAGwhB,GACf,OAAQA,GAASxhB,EAAQA,EAAE1L,KAAKktB,GAAXxhB,EAGvB,IAAIk8B,EAAY,SAAmBpnC,EAAMqnC,EAAM3a,GAC7C3sB,KAAKC,KAAOA,EACZD,KAAK8Z,KAAOra,EAAK6nC,EAAKxtB,KAAM6S,GAC5B3sB,KAAKgV,MAAQvV,EAAK6nC,EAAKtyB,MAAO2X,IAG5B4a,EAAa,CACf,IAAIF,EAAU,MAAO,CACnBvtB,KAAM,SAAcha,GAAU,OAAOA,EAAOvK,KAAOuK,EAAO0B,OAAO+oB,YAAYhyB,iBAC7Eyc,MAAO,SAAejhB,GAAM,OAAOA,EAAGwB,OAGxC,IAAI8xC,EAAU,YAAa,CACzBvtB,KAAM,SAAcha,EAAQu5B,GAAY,OAAOv5B,EAAOjM,WAAa8wC,EAAUzmC,QAAQm7B,EAAS9jC,MAC9Fyf,MAAO,SAAejhB,GAAM,OAAOA,EAAGF,aAGxC,IAAIwzC,EAAU,cAAe,CAC3BvtB,KAAM,SAAcha,GAAU,OAAOA,EAAO2H,aAAe,MAC3DuN,MAAO,SAAejhB,EAAIyzC,EAAQC,EAAM9zC,GAAS,OAAOA,EAAME,UAAUM,QAAUJ,EAAG0T,YAAc,QAGrG,IAAI4/B,EAAU,oBAAqB,CACjCvtB,KAAM,WAAkB,OAAO,GAC/B9E,MAAO,SAAejhB,EAAIgmB,GAAQ,OAAOhmB,EAAGizC,iBAAmBjtB,EAAO,EAAIA,MAM1E2tB,EAAgB,SAAuBlmC,EAAQ2R,GACjD,IAAI+mB,EAASl6B,KAEbA,KAAKwB,OAASA,EACdxB,KAAK6d,OAAS0pB,EAAWxa,SACzB/sB,KAAKmT,QAAU,GACfnT,KAAK2nC,aAAenpC,OAAOlE,OAAO,MAC9B6Y,GAAWA,EAAQhU,SAAQ,SAAUiU,GACvC,GAAI8mB,EAAOyN,aAAav0B,EAAOhX,KAC3B,MAAM,IAAIqyB,WAAW,iDAAmDrb,EAAOhX,IAAM,KACzF89B,EAAO/mB,QAAQvY,KAAKwY,GACpB8mB,EAAOyN,aAAav0B,EAAOhX,KAAOgX,EAC9BA,EAAOre,KAAKpB,OACZumC,EAAOrc,OAAOjjB,KAAK,IAAIysC,EAAUj0B,EAAOhX,IAAKgX,EAAOre,KAAKpB,MAAOyf,QAWpEw0B,EAAc,SAAqB9nC,GACrCE,KAAKF,OAASA,GAGZywB,EAAuB,CAAE/uB,OAAQ,CAAEwsB,cAAc,GAAO7a,QAAS,CAAE6a,cAAc,GAAOj6B,GAAI,CAAEi6B,cAAc,IAchHuC,EAAqB/uB,OAAOgrB,IAAM,WAChC,OAAOxsB,KAAKF,OAAO0B,QAKrB+uB,EAAqBpd,QAAQqZ,IAAM,WACjC,OAAOxsB,KAAKF,OAAOqT,SAKrBy0B,EAAYnpC,UAAUuW,MAAQ,SAAgBjhB,GAC5C,OAAOiM,KAAKiV,iBAAiBlhB,GAAIJ,OAInCi0C,EAAYnpC,UAAUopC,kBAAoB,SAA4B9zC,EAAIgtC,QACtD,IAAXA,IAAoBA,GAAU,GAErC,IAAK,IAAI9pC,EAAI,EAAGA,EAAI+I,KAAKF,OAAOqT,QAAQ9Y,OAAQpD,IAAO,GAAIA,GAAK8pC,EAAQ,CACtE,IAAI3tB,EAASpT,KAAKF,OAAOqT,QAAQlc,GACjC,GAAImc,EAAOre,KAAK8yC,oBAAsBz0B,EAAOre,KAAK8yC,kBAAkBlpC,KAAKyU,EAAQrf,EAAIiM,MACjF,OAAO,EAEb,OAAO,GAST4nC,EAAYnpC,UAAUwW,iBAAmB,SAA2B6yB,GAClE,IAAK9nC,KAAK6nC,kBAAkBC,GAAW,MAAO,CAACn0C,MAAOqM,KAAMgX,aAAc,IAMzE,IAJD,IAAI+wB,EAAM,CAACD,GAAS5wB,EAAWlX,KAAKgoC,WAAWF,GAASxe,EAAO,OAIrD,CAER,IADA,IAAI2e,GAAU,EACLhxC,EAAI,EAAGA,EAAI+I,KAAKF,OAAOqT,QAAQ9Y,OAAQpD,IAAK,CACnD,IAAImc,EAASpT,KAAKF,OAAOqT,QAAQlc,GACjC,GAAImc,EAAOre,KAAKgiB,kBAAmB,CACjC,IAAIpG,EAAI2Y,EAAOA,EAAKryB,GAAG0Z,EAAI,EAAGsG,EAAWqS,EAAOA,EAAKryB,GAAGtD,MAAQqM,KAC5DjM,EAAK4c,EAAIo3B,EAAI1tC,QACb+Y,EAAOre,KAAKgiB,kBAAkBpY,KAAKyU,EAAQzC,EAAIo3B,EAAItyC,MAAMkb,GAAKo3B,EAAK9wB,EAAUC,GACjF,GAAInjB,GAAMmjB,EAAS2wB,kBAAkB9zC,EAAIkD,GAAI,CAE3C,GADAlD,EAAG6Z,QAAQ,sBAAuBk6B,IAC7Bxe,EAAM,CACTA,EAAO,GACP,IAAK,IAAI5V,EAAI,EAAGA,EAAI1T,KAAKF,OAAOqT,QAAQ9Y,OAAQqZ,IAC5C4V,EAAK1uB,KAAK8Y,EAAIzc,EAAI,CAACtD,MAAOujB,EAAUvG,EAAGo3B,EAAI1tC,QAAU,CAAC1G,MAAOqM,KAAM2Q,EAAG,IAE5Eo3B,EAAIntC,KAAK7G,GACTmjB,EAAWA,EAAS8wB,WAAWj0C,GAC/Bk0C,GAAU,EAER3e,IAAQA,EAAKryB,GAAK,CAACtD,MAAOujB,EAAUvG,EAAGo3B,EAAI1tC,UAGnD,IAAK4tC,EAAW,MAAO,CAACt0C,MAAOujB,EAAUF,aAAc+wB,KAK3DH,EAAYnpC,UAAUupC,WAAa,SAAqBj0C,GACtD,IAAKA,EAAGa,OAAO4S,GAAGxH,KAAKzK,KAAQ,MAAM,IAAIk5B,WAAW,qCAEpD,IADA,IAAIyZ,EAAc,IAAIN,EAAY5nC,KAAKF,QAAS+d,EAAS7d,KAAKF,OAAO+d,OAC5D5mB,EAAI,EAAGA,EAAI4mB,EAAOxjB,OAAQpD,IAAK,CACtC,IAAI2I,EAAQie,EAAO5mB,GACnBixC,EAAYtoC,EAAMK,MAAQL,EAAMoV,MAAMjhB,EAAIiM,KAAKJ,EAAMK,MAAOD,KAAMkoC,GAEpE,IAAK,IAAIltC,EAAM,EAAGA,EAAMmtC,EAAe9tC,OAAQW,IAASmtC,EAAentC,GAAKgF,KAAMjM,EAAIm0C,GACtF,OAAOA,GAKT3X,EAAqBx8B,GAAGy4B,IAAM,WAAc,OAAO,IAAI8Z,EAAYtmC,OAqBnE4nC,EAAYttC,OAAS,SAAiBwF,GAGpC,IAFA,IAAIsoC,EAAU,IAAIV,EAAc5nC,EAAOvK,IAAMuK,EAAOvK,IAAIT,KAAK0M,OAAS1B,EAAO0B,OAAQ1B,EAAOqT,SACxFkmB,EAAW,IAAIuO,EAAYQ,GACtBnxC,EAAI,EAAGA,EAAImxC,EAAQvqB,OAAOxjB,OAAQpD,IACvCoiC,EAAS+O,EAAQvqB,OAAO5mB,GAAGgJ,MAAQmoC,EAAQvqB,OAAO5mB,GAAG6iB,KAAKha,EAAQu5B,GACtE,OAAOA,GAeTuO,EAAYnpC,UAAUyW,YAAc,SAAsBpV,GAGxD,IAFA,IAAIsoC,EAAU,IAAIV,EAAc1nC,KAAKwB,OAAQ1B,EAAOqT,SAChD0K,EAASuqB,EAAQvqB,OAAQwb,EAAW,IAAIuO,EAAYQ,GAC/CnxC,EAAI,EAAGA,EAAI4mB,EAAOxjB,OAAQpD,IAAK,CACtC,IAAIgJ,EAAO4d,EAAO5mB,GAAGgJ,KACrBo5B,EAASp5B,GAAQD,KAAKupB,eAAetpB,GAAQD,KAAKC,GAAQ4d,EAAO5mB,GAAG6iB,KAAKha,EAAQu5B,GAEnF,OAAOA,GASTuO,EAAYnpC,UAAU0W,OAAS,SAAiBkzB,GAC9C,IAAIh+B,EAAS,CAAC9U,IAAKyK,KAAKzK,IAAI4f,SAAUthB,UAAWmM,KAAKnM,UAAUshB,UAEhE,GADInV,KAAKyH,cAAe4C,EAAO5C,YAAczH,KAAKyH,YAAYzR,KAAI,SAAUs+B,GAAK,OAAOA,EAAEnf,aACtFkzB,GAAuC,iBAAhBA,EAA4B,IAAK,IAAI97B,KAAQ87B,EAAc,CACpF,GAAY,OAAR97B,GAAyB,aAARA,EACjB,MAAM,IAAIkiB,WAAW,sDACzB,IAAIrb,EAASi1B,EAAa97B,GAAO5Y,EAAQyf,EAAOre,KAAKpB,MACjDA,GAASA,EAAMwhB,SAAU9K,EAAOkC,GAAQ5Y,EAAMwhB,OAAOxW,KAAKyU,EAAQpT,KAAKoT,EAAOhX,OAEpF,OAAOiO,GAiBTu9B,EAAY1Y,SAAW,SAAmBpvB,EAAQkwB,EAAMqY,GACtD,IAAKrY,EAAQ,MAAM,IAAIvB,WAAW,0CAClC,IAAK3uB,EAAO0B,OAAU,MAAM,IAAIitB,WAAW,0CAC3C,IAAI2Z,EAAU,IAAIV,EAAc5nC,EAAO0B,OAAQ1B,EAAOqT,SAClDkmB,EAAW,IAAIuO,EAAYQ,GAqB/B,OApBAA,EAAQvqB,OAAO1e,SAAQ,SAAUS,GAC/B,GAAkB,OAAdA,EAAMK,KACRo5B,EAAS9jC,IAAM,cAAcuK,EAAO0B,OAAQwuB,EAAKz6B,UAC5C,GAAkB,aAAdqK,EAAMK,KACfo5B,EAASxlC,UAAY8wC,EAAUzV,SAASmK,EAAS9jC,IAAKy6B,EAAKn8B,gBACtD,GAAkB,eAAd+L,EAAMK,KACX+vB,EAAKvoB,cAAe4xB,EAAS5xB,YAAcuoB,EAAKvoB,YAAYzR,IAAI8J,EAAO0B,OAAO+yB,mBAC7E,CACL,GAAI8T,EAAgB,IAAK,IAAI97B,KAAQ87B,EAAc,CACjD,IAAIj1B,EAASi1B,EAAa97B,GAAO5Y,EAAQyf,EAAOre,KAAKpB,MACrD,GAAIyf,EAAOhX,KAAOwD,EAAMK,MAAQtM,GAASA,EAAMu7B,UAC3C1wB,OAAOC,UAAU8qB,eAAe5qB,KAAKqxB,EAAMzjB,GAG7C,YADA8sB,EAASz5B,EAAMK,MAAQtM,EAAMu7B,SAASvwB,KAAKyU,EAAQtT,EAAQkwB,EAAKzjB,GAAO8sB,IAI3EA,EAASz5B,EAAMK,MAAQL,EAAMka,KAAKha,EAAQu5B,OAGvCA,GASTuO,EAAYU,iBAAmB,SAA2Bn9B,GACxDg9B,EAAevtC,KAAKuQ,IAEtBy8B,EAAYW,oBAAsB,SAA8Bp9B,GAC9D,IAAI/N,EAAQ+qC,EAAenoB,QAAQ7U,GAC/B/N,GAAS,GAAK+qC,EAAetb,OAAOzvB,EAAO,IAGjDoB,OAAO6wB,iBAAkBuY,EAAYnpC,UAAW8xB,GAEhD,IAAI4X,EAAiB,GAoDrB,SAASK,EAAUp8B,EAAKugB,EAAMj4B,GAC5B,IAAK,IAAI6X,KAAQH,EAAK,CACpB,IAAIomB,EAAMpmB,EAAIG,GACVimB,aAAeiW,SAAYjW,EAAMA,EAAI/yB,KAAKktB,GAC7B,mBAARpgB,IAA6BimB,EAAMgW,EAAUhW,EAAK7F,EAAM,KACjEj4B,EAAO6X,GAAQimB,EAEjB,OAAO99B,EAMT,IAAIg0C,EAAS,SAAgB3zC,GAG3BiL,KAAKR,MAAQ,GACTzK,EAAKyK,OAASgpC,EAAUzzC,EAAKyK,MAAOQ,KAAMA,KAAKR,OAGnDQ,KAAKjL,KAAOA,EACZiL,KAAK5D,IAAMrH,EAAKqH,IAAMrH,EAAKqH,IAAIA,IAAMusC,EAAU,WAKjDD,EAAOjqC,UAAU8U,SAAW,SAAmB5f,GAAS,OAAOA,EAAMqM,KAAK5D,MA4B1E,IAAI8C,EAAOV,OAAOlE,OAAO,MAEzB,SAASquC,EAAU1oC,GACjB,OAAIA,KAAQf,EAAee,EAAO,OAAQf,EAAKe,IAC/Cf,EAAKe,GAAQ,EACNA,EAAO,KAOhB,IAAI2oC,EAAY,SAAmB3oC,QACrB,IAATA,IAAkBA,EAAO,OAC7BD,KAAK5D,IAAMusC,EAAU1oC,IAKtB2oC,EAAUnqC,UAAU+tB,IAAM,SAAc74B,GAAS,OAAOA,EAAMmM,OAAO6nC,aAAa3nC,KAAK5D,MAIvFwsC,EAAUnqC,UAAU8U,SAAW,SAAmB5f,GAAS,OAAOA,EAAMqM,KAAK5D,O,8RC3kCzEysC,EAAWxnC,KAAKynC,IAAI,EAAG,IAG3B,SAASC,EAAaxqC,GAAS,OAJjB,MAIwBA,EAKtC,IAAIyqC,EAAY,SAAmB/yC,EAAK2wB,EAASqiB,QAC9B,IAAZriB,IAAqBA,GAAU,QACnB,IAAZqiB,IAAqBA,EAAU,MAGpCjpC,KAAK/J,IAAMA,EAGX+J,KAAK4mB,QAAUA,EACf5mB,KAAKipC,QAAUA,GAQbC,EAAU,SAASA,EAAQhnC,EAAQinC,GAGrC,QAFkB,IAAbA,IAAsBA,GAAW,IAEjCjnC,EAAO7H,QAAU6uC,EAAQp1C,MAAS,OAAOo1C,EAAQp1C,MACtDkM,KAAKkC,OAASA,EACdlC,KAAKmpC,SAAWA,GAGlBD,EAAQzqC,UAAUwqC,QAAU,SAAkB1qC,GAC5C,IAAI6qC,EAAO,EAAGlyC,EAAQ6xC,EAAaxqC,GACnC,IAAKyB,KAAKmpC,SAAY,IAAK,IAAIlyC,EAAI,EAAGA,EAAIC,EAAOD,IAC7CmyC,GAAQppC,KAAKkC,OAAW,EAAJjL,EAAQ,GAAK+I,KAAKkC,OAAW,EAAJjL,EAAQ,GACzD,OAAO+I,KAAKkC,OAAe,EAARhL,GAAakyC,EAjClC,SAAuB7qC,GAAS,OAAQA,GAL1B,MAKmCA,IAAoBsqC,EAiC5BQ,CAAc9qC,IAIvD2qC,EAAQzqC,UAAUqoB,UAAY,SAAoB7wB,EAAKqzC,GAEtD,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BtpC,KAAKupC,KAAKtzC,EAAKqzC,GAAO,IAG9BJ,EAAQzqC,UAAUzI,IAAM,SAAcC,EAAKqzC,GAE1C,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BtpC,KAAKupC,KAAKtzC,EAAKqzC,GAAO,IAE9BJ,EAAQzqC,UAAU8qC,KAAO,SAAetzC,EAAKqzC,EAAOE,GAElD,IADA,IAAIJ,EAAO,EAAGK,EAAWzpC,KAAKmpC,SAAW,EAAI,EAAGO,EAAW1pC,KAAKmpC,SAAW,EAAI,EACtElyC,EAAI,EAAGA,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CAC9C,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,IAAM+I,KAAKmpC,SAAWC,EAAO,GACrD,GAAIjuC,EAAQlF,EAAO,MACnB,IAAI0zC,EAAU3pC,KAAKkC,OAAOjL,EAAIwyC,GAAWG,EAAU5pC,KAAKkC,OAAOjL,EAAIyyC,GAAW3wC,EAAMoC,EAAQwuC,EAC5F,GAAI1zC,GAAO8C,EAAK,CACd,IACIsR,EAASlP,EAAQiuC,IADTO,EAAkB1zC,GAAOkF,GAAS,EAAIlF,GAAO8C,EAAM,EAAIuwC,EAA7CA,GACc,EAAI,EAAIM,GAC5C,GAAIJ,EAAU,OAAOn/B,EACrB,IAAI4+B,EAAUhzC,IAAQqzC,EAAQ,EAAInuC,EAAQpC,GAAO,KAAmB9B,EAAI,GAAGhB,EAAMkF,GA1DzB0tC,EA2DxD,OAAO,IAAIG,EAAU3+B,EAAQi/B,EAAQ,EAAIrzC,GAAOkF,EAAQlF,GAAO8C,EAAKkwC,GAEtEG,GAAQQ,EAAUD,EAEpB,OAAOH,EAASvzC,EAAMmzC,EAAO,IAAIJ,EAAU/yC,EAAMmzC,IAGnDF,EAAQzqC,UAAUorC,QAAU,SAAkB5zC,EAAKgzC,GAGjD,IAFA,IAAIG,EAAO,EAAGlyC,EAAQ6xC,EAAaE,GAC/BQ,EAAWzpC,KAAKmpC,SAAW,EAAI,EAAGO,EAAW1pC,KAAKmpC,SAAW,EAAI,EAC5DlyC,EAAI,EAAGA,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CAC9C,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,IAAM+I,KAAKmpC,SAAWC,EAAO,GACrD,GAAIjuC,EAAQlF,EAAO,MACnB,IAAI0zC,EAAU3pC,KAAKkC,OAAOjL,EAAIwyC,GAC9B,GAAIxzC,GAD2CkF,EAAQwuC,GACrC1yC,GAAa,EAARC,EAAa,OAAO,EAC3CkyC,GAAQppC,KAAKkC,OAAOjL,EAAIyyC,GAAYC,EAEtC,OAAO,GAMTT,EAAQzqC,UAAUU,QAAU,SAAkBgM,GAE5C,IADA,IAAIs+B,EAAWzpC,KAAKmpC,SAAW,EAAI,EAAGO,EAAW1pC,KAAKmpC,SAAW,EAAI,EAC5DlyC,EAAI,EAAGmyC,EAAO,EAAGnyC,EAAI+I,KAAKkC,OAAO7H,OAAQpD,GAAK,EAAG,CACxD,IAAIkE,EAAQ6E,KAAKkC,OAAOjL,GAAIizB,EAAW/uB,GAAS6E,KAAKmpC,SAAWC,EAAO,GAAIpf,EAAW7uB,GAAS6E,KAAKmpC,SAAW,EAAIC,GAC/GO,EAAU3pC,KAAKkC,OAAOjL,EAAIwyC,GAAWG,EAAU5pC,KAAKkC,OAAOjL,EAAIyyC,GACnEv+B,EAAE+e,EAAUA,EAAWyf,EAAS3f,EAAUA,EAAW4f,GACrDR,GAAQQ,EAAUD,IAOtBT,EAAQzqC,UAAUkV,OAAS,WACzB,OAAO,IAAIu1B,EAAQlpC,KAAKkC,QAASlC,KAAKmpC,WAGxCD,EAAQzqC,UAAUC,SAAW,WAC3B,OAAQsB,KAAKmpC,SAAW,IAAM,IAAMrwB,KAAKC,UAAU/Y,KAAKkC,SAO1DgnC,EAAQxjC,OAAS,SAAiBiL,GAChC,OAAY,GAALA,EAASu4B,EAAQp1C,MAAQ,IAAIo1C,EAAQv4B,EAAI,EAAI,CAAC,GAAIA,EAAG,GAAK,CAAC,EAAG,EAAGA,KAG1Eu4B,EAAQp1C,MAAQ,IAAIo1C,EAAQ,IAS5B,IAAIY,EAAU,SAAiBxgC,EAAMygC,EAAQp0C,EAAMD,GAGjDsK,KAAKsJ,KAAOA,GAAQ,GAIpBtJ,KAAKrK,KAAOA,GAAQ,EAGpBqK,KAAKtK,GAAW,MAANA,EAAasK,KAAKsJ,KAAKjP,OAAS3E,EAC1CsK,KAAK+pC,OAASA,GAyGhB,SAASC,EAAeva,GACtB,IAAIC,EAAM3rB,MAAMpF,KAAKqB,KAAMyvB,GAE3B,OADAC,EAAIptB,UAAY0nC,EAAevrC,UACxBixB,EAvGToa,EAAQrrC,UAAUhJ,MAAQ,SAAgBE,EAAMD,GAI9C,YAHgB,IAATC,IAAkBA,EAAO,QAClB,IAAPD,IAAgBA,EAAKsK,KAAKsJ,KAAKjP,QAE/B,IAAIyvC,EAAQ9pC,KAAKsJ,KAAMtJ,KAAK+pC,OAAQp0C,EAAMD,IAGnDo0C,EAAQrrC,UAAUlE,KAAO,WACvB,OAAO,IAAIuvC,EAAQ9pC,KAAKsJ,KAAK7T,QAASuK,KAAK+pC,QAAU/pC,KAAK+pC,OAAOt0C,QAASuK,KAAKrK,KAAMqK,KAAKtK,KAO5Fo0C,EAAQrrC,UAAUwrC,UAAY,SAAoBj0C,EAAKk0C,GACrDlqC,KAAKtK,GAAKsK,KAAKsJ,KAAK1O,KAAK5E,GACV,MAAXk0C,GAAmBlqC,KAAKmqC,UAAUnqC,KAAKsJ,KAAKjP,OAAS,EAAG6vC,IAM9DJ,EAAQrrC,UAAU2rC,cAAgB,SAAwBr0C,GACxD,IAAK,IAAIkB,EAAI,EAAGozC,EAAYrqC,KAAKsJ,KAAKjP,OAAQpD,EAAIlB,EAAQuT,KAAKjP,OAAQpD,IAAK,CAC1E,IAAIqzC,EAAOv0C,EAAQw0C,UAAUtzC,GAC7B+I,KAAKiqC,UAAUl0C,EAAQuT,KAAKrS,GAAY,MAARqzC,GAAgBA,EAAOrzC,EAAIozC,EAAYC,EAAO,QAQlFR,EAAQrrC,UAAU8rC,UAAY,SAAoB55B,GAChD,GAAI3Q,KAAK+pC,OAAU,IAAK,IAAI9yC,EAAI,EAAGA,EAAI+I,KAAK+pC,OAAO1vC,OAAQpD,IACvD,GAAI+I,KAAK+pC,OAAO9yC,IAAM0Z,EAAK,OAAO3Q,KAAK+pC,OAAO9yC,GAAKA,EAAI,GAAK,EAAI,KAGtE6yC,EAAQrrC,UAAU0rC,UAAY,SAAoBx5B,EAAG2jB,GAC9Ct0B,KAAK+pC,SAAU/pC,KAAK+pC,OAAS,IAClC/pC,KAAK+pC,OAAOnvC,KAAK+V,EAAG2jB,IAKtBwV,EAAQrrC,UAAU+rC,sBAAwB,SAAgCz0C,GACxE,IAAK,IAAIkB,EAAIlB,EAAQuT,KAAKjP,OAAS,EAAGowC,EAAYzqC,KAAKsJ,KAAKjP,OAAStE,EAAQuT,KAAKjP,OAAQpD,GAAK,EAAGA,IAAK,CACrG,IAAIqzC,EAAOv0C,EAAQw0C,UAAUtzC,GAC7B+I,KAAKiqC,UAAUl0C,EAAQuT,KAAKrS,GAAG0c,SAAkB,MAAR22B,GAAgBA,EAAOrzC,EAAIwzC,EAAYH,EAAO,EAAI,QAM/FR,EAAQrrC,UAAUkV,OAAS,WACzB,IAAI+2B,EAAU,IAAIZ,EAElB,OADAY,EAAQF,sBAAsBxqC,MACvB0qC,GAKTZ,EAAQrrC,UAAUzI,IAAM,SAAcC,EAAKqzC,GAGzC,QAFiB,IAAVA,IAAmBA,EAAQ,GAE9BtpC,KAAK+pC,OAAU,OAAO/pC,KAAKupC,KAAKtzC,EAAKqzC,GAAO,GAChD,IAAK,IAAIryC,EAAI+I,KAAKrK,KAAMsB,EAAI+I,KAAKtK,GAAIuB,IACjChB,EAAM+J,KAAKsJ,KAAKrS,GAAGjB,IAAIC,EAAKqzC,GAChC,OAAOrzC,GAMT6zC,EAAQrrC,UAAUqoB,UAAY,SAAoB7wB,EAAKqzC,GAEtD,YADgB,IAAVA,IAAmBA,EAAQ,GAC1BtpC,KAAKupC,KAAKtzC,EAAKqzC,GAAO,IAE9BQ,EAAQrrC,UAAU8qC,KAAO,SAAetzC,EAAKqzC,EAAOE,GAGlD,IAFA,IAAI5iB,GAAU,EAEL3vB,EAAI+I,KAAKrK,KAAMsB,EAAI+I,KAAKtK,GAAIuB,IAAK,CACxC,IAAwBoT,EAAdrK,KAAKsJ,KAAKrS,GAAiB6vB,UAAU7wB,EAAKqzC,GACpD,GAAsB,MAAlBj/B,EAAO4+B,QAAiB,CAC1B,IAAI0B,EAAO3qC,KAAKuqC,UAAUtzC,GAC1B,GAAY,MAAR0zC,GAAgBA,EAAO1zC,GAAK0zC,EAAO3qC,KAAKtK,GAAI,CAC9CuB,EAAI0zC,EACJ10C,EAAM+J,KAAKsJ,KAAKqhC,GAAM1B,QAAQ5+B,EAAO4+B,SACrC,UAIA5+B,EAAOuc,UAAWA,GAAU,GAChC3wB,EAAMoU,EAAOpU,IAGf,OAAOuzC,EAASvzC,EAAM,IAAI+yC,EAAU/yC,EAAK2wB,IAS3CojB,EAAevrC,UAAYD,OAAOlE,OAAOyJ,MAAMtF,WAC/CurC,EAAevrC,UAAUI,YAAcmrC,EACvCA,EAAevrC,UAAUwB,KAAO,iBAOhC,IAAIsmC,EAAY,SAAmBhxC,GAIjCyK,KAAKzK,IAAMA,EAGXyK,KAAKqJ,MAAQ,GAGbrJ,KAAK4T,KAAO,GAGZ5T,KAAKjK,QAAU,IAAI+zC,GAGjB/b,EAAqB,CAAEn5B,OAAQ,CAAEo5B,cAAc,GAAO5W,WAAY,CAAE4W,cAAc,IAuCtF,SAAS4c,IAAiB,MAAM,IAAI7mC,MAAM,eApC1CgqB,EAAmBn5B,OAAO43B,IAAM,WAAc,OAAOxsB,KAAK4T,KAAKvZ,OAAS2F,KAAK4T,KAAK,GAAK5T,KAAKzK,KAK5FgxC,EAAU9nC,UAAU7I,KAAO,SAAe2nC,GACxC,IAAIlzB,EAASrK,KAAKqL,UAAUkyB,GAC5B,GAAIlzB,EAAOwgC,OAAU,MAAM,IAAIb,EAAe3/B,EAAOwgC,QACrD,OAAO7qC,MAMTumC,EAAU9nC,UAAU4M,UAAY,SAAoBzV,GAClD,IAAIyU,EAASzU,EAAKof,MAAMhV,KAAKzK,KAE7B,OADK8U,EAAOwgC,QAAU7qC,KAAKinC,QAAQrxC,EAAMyU,EAAO9U,KACzC8U,GAMT0jB,EAAmB3W,WAAWoV,IAAM,WAClC,OAAOxsB,KAAKqJ,MAAMhP,OAAS,GAG7BksC,EAAU9nC,UAAUwoC,QAAU,SAAkBrxC,EAAML,GACpDyK,KAAK4T,KAAKhZ,KAAKoF,KAAKzK,KACpByK,KAAKqJ,MAAMzO,KAAKhF,GAChBoK,KAAKjK,QAAQk0C,UAAUr0C,EAAKmxB,UAC5B/mB,KAAKzK,IAAMA,GAGbiJ,OAAO6wB,iBAAkBkX,EAAU9nC,UAAWsvB,GAI9C,IAAI+c,EAAYtsC,OAAOlE,OAAO,MAW1BywC,EAAO,aAEXA,EAAKtsC,UAAUuW,MAAQ,SAAgBg2B,GAAQ,OAAOJ,KAMtDG,EAAKtsC,UAAUsoB,OAAS,WAAqB,OAAOmiB,EAAQp1C,OAK5Di3C,EAAKtsC,UAAUkV,OAAS,SAAiBq3B,GAAQ,OAAOJ,KAMxDG,EAAKtsC,UAAUzI,IAAM,SAAci1C,GAAY,OAAOL,KAMtDG,EAAKtsC,UAAUysC,MAAQ,SAAgBC,GAAU,OAAO,MAOxDJ,EAAKtsC,UAAU0W,OAAS,WAAqB,OAAOy1B,KAKpDG,EAAK7b,SAAW,SAAmB1tB,EAAQwuB,GACzC,IAAKA,IAASA,EAAKob,SAAY,MAAM,IAAI3c,WAAW,mCACpD,IAAI35B,EAAOg2C,EAAU9a,EAAKob,UAC1B,IAAKt2C,EAAQ,MAAM,IAAI25B,WAAY,gBAAmBuB,EAAa,SAAI,YACvE,OAAOl7B,EAAKo6B,SAAS1tB,EAAQwuB,IAQ/B+a,EAAKpF,OAAS,SAAiBC,EAAIyF,GACjC,GAAIzF,KAAMkF,EAAa,MAAM,IAAIrc,WAAW,iCAAmCmX,GAG/E,OAFAkF,EAAUlF,GAAMyF,EAChBA,EAAU5sC,UAAUknC,OAASC,EACtByF,GAKT,IAAIC,EAAa,SAAoB/1C,EAAKs1C,GAExC7qC,KAAKzK,IAAMA,EAEXyK,KAAK6qC,OAASA,GAKhBS,EAAWvR,GAAK,SAAaxkC,GAAO,OAAO,IAAI+1C,EAAW/1C,EAAK,OAI/D+1C,EAAWC,KAAO,SAAe9b,GAAW,OAAO,IAAI6b,EAAW,KAAM7b,IAMxE6b,EAAWE,YAAc,SAAsBj2C,EAAKI,EAAMD,EAAID,GAC5D,IACE,OAAO61C,EAAWvR,GAAGxkC,EAAImb,QAAQ/a,EAAMD,EAAID,IAC3C,MAAO+H,GACP,GAAIA,aAAa,KAAgB,OAAO8tC,EAAWC,KAAK/tC,EAAEiyB,SAC1D,MAAMjyB,IAKV,IAAIiuC,EAA4B,SAAUV,GACxC,SAASU,EAAY91C,EAAMD,EAAID,EAAOuuC,GACpC+G,EAAKpsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKvK,MAAQA,EACbuK,KAAKgkC,YAAcA,EAwDrB,OArDK+G,IAAOU,EAAYnpC,UAAYyoC,GACpCU,EAAYhtC,UAAYD,OAAOlE,OAAQywC,GAAQA,EAAKtsC,WACpDgtC,EAAYhtC,UAAUI,YAAc4sC,EAEpCA,EAAYhtC,UAAUuW,MAAQ,SAAgBzf,GAC5C,OAAIyK,KAAKgkC,WAAa0H,EAAen2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,IAC/C41C,EAAWC,KAAK,6CACpBD,EAAWE,YAAYj2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKvK,QAG9Dg2C,EAAYhtC,UAAUsoB,OAAS,WAC7B,OAAO,IAAImiB,EAAQ,CAAClpC,KAAKrK,KAAMqK,KAAKtK,GAAKsK,KAAKrK,KAAMqK,KAAKvK,MAAML,QAGjEq2C,EAAYhtC,UAAUkV,OAAS,SAAiBpe,GAC9C,OAAO,IAAIk2C,EAAYzrC,KAAKrK,KAAMqK,KAAKrK,KAAOqK,KAAKvK,MAAML,KAAMG,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,MAG3F+1C,EAAYhtC,UAAUzI,IAAM,SAAcD,GACxC,IAAIJ,EAAOI,EAAQ+wB,UAAU9mB,KAAKrK,KAAM,GAAID,EAAKK,EAAQ+wB,UAAU9mB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKixB,SAAWlxB,EAAGkxB,QAAkB,KAClC,IAAI6kB,EAAY91C,EAAKM,IAAKoL,KAAKC,IAAI3L,EAAKM,IAAKP,EAAGO,KAAM+J,KAAKvK,QAGpEg2C,EAAYhtC,UAAUysC,MAAQ,SAAgB/c,GAC5C,KAAMA,aAAiBsd,IAAgBtd,EAAM6V,WAAahkC,KAAKgkC,UAAa,OAAO,KAEnF,GAAIhkC,KAAKrK,KAAOqK,KAAKvK,MAAML,MAAQ+4B,EAAMx4B,MAASqK,KAAKvK,MAAM66B,SAAYnC,EAAM14B,MAAM46B,UAI9E,IAAIlC,EAAMz4B,IAAMsK,KAAKrK,MAASqK,KAAKvK,MAAM46B,WAAclC,EAAM14B,MAAM66B,QAKxE,OAAO,KAJP,IAAIqb,EAAU3rC,KAAKvK,MAAML,KAAO+4B,EAAM14B,MAAML,MAAQ,EAAI,WAClD,IAAI,KAAM+4B,EAAM14B,MAAMN,QAAQiJ,OAAO4B,KAAKvK,MAAMN,SAAUg5B,EAAM14B,MAAM46B,UAAWrwB,KAAKvK,MAAM66B,SAClG,OAAO,IAAImb,EAAYtd,EAAMx4B,KAAMqK,KAAKtK,GAAIi2C,EAAS3rC,KAAKgkC,WAN1D,IAAIvuC,EAAQuK,KAAKvK,MAAML,KAAO+4B,EAAM14B,MAAML,MAAQ,EAAI,WAChD,IAAI,KAAM4K,KAAKvK,MAAMN,QAAQiJ,OAAO+vB,EAAM14B,MAAMN,SAAU6K,KAAKvK,MAAM46B,UAAWlC,EAAM14B,MAAM66B,SAClG,OAAO,IAAImb,EAAYzrC,KAAKrK,KAAMqK,KAAKtK,IAAMy4B,EAAMz4B,GAAKy4B,EAAMx4B,MAAOF,EAAOuK,KAAKgkC,YAUrFyH,EAAYhtC,UAAU0W,OAAS,WAC7B,IAAI6a,EAAO,CAACob,SAAU,UAAWz1C,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,IAG3D,OAFIsK,KAAKvK,MAAML,OAAQ46B,EAAKv6B,MAAQuK,KAAKvK,MAAM0f,UAC3CnV,KAAKgkC,YAAahU,EAAKgU,WAAY,GAChChU,GAGTyb,EAAYvc,SAAW,SAAmB1tB,EAAQwuB,GAChD,GAAwB,iBAAbA,EAAKr6B,MAAsC,iBAAXq6B,EAAKt6B,GAC5C,MAAM,IAAI+4B,WAAW,0CACzB,OAAO,IAAIgd,EAAYzb,EAAKr6B,KAAMq6B,EAAKt6B,GAAI,cAAe8L,EAAQwuB,EAAKv6B,SAAUu6B,EAAKgU,YAGjFyH,EApEsB,CAqE7BV,GAEFA,EAAKpF,OAAO,UAAW8F,GAKvB,IAAIG,EAAkC,SAAUb,GAC9C,SAASa,EAAkBj2C,EAAMD,EAAIm2C,EAASC,EAAOr2C,EAAOoD,EAAQmrC,GAClE+G,EAAKpsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAK6rC,QAAUA,EAGf7rC,KAAK8rC,MAAQA,EAGb9rC,KAAKvK,MAAQA,EAIbuK,KAAKnH,OAASA,EACdmH,KAAKgkC,YAAcA,EAwDrB,OArDK+G,IAAOa,EAAkBtpC,UAAYyoC,GAC1Ca,EAAkBntC,UAAYD,OAAOlE,OAAQywC,GAAQA,EAAKtsC,WAC1DmtC,EAAkBntC,UAAUI,YAAc+sC,EAE1CA,EAAkBntC,UAAUuW,MAAQ,SAAgBzf,GAClD,GAAIyK,KAAKgkC,YAAc0H,EAAen2C,EAAKyK,KAAKrK,KAAMqK,KAAK6rC,UACpCH,EAAen2C,EAAKyK,KAAK8rC,MAAO9rC,KAAKtK,KACxD,OAAO41C,EAAWC,KAAK,iDAE3B,IAAIQ,EAAMx2C,EAAIE,MAAMuK,KAAK6rC,QAAS7rC,KAAK8rC,OACvC,GAAIC,EAAI1b,WAAa0b,EAAIzb,QACrB,OAAOgb,EAAWC,KAAK,2BAC3B,IAAIS,EAAWhsC,KAAKvK,MAAMs8B,SAAS/xB,KAAKnH,OAAQkzC,EAAI52C,SACpD,OAAK62C,EACEV,EAAWE,YAAYj2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAIs2C,GAD/BV,EAAWC,KAAK,gCAI1CK,EAAkBntC,UAAUsoB,OAAS,WACnC,OAAO,IAAImiB,EAAQ,CAAClpC,KAAKrK,KAAMqK,KAAK6rC,QAAU7rC,KAAKrK,KAAMqK,KAAKnH,OAC1CmH,KAAK8rC,MAAO9rC,KAAKtK,GAAKsK,KAAK8rC,MAAO9rC,KAAKvK,MAAML,KAAO4K,KAAKnH,UAG/E+yC,EAAkBntC,UAAUkV,OAAS,SAAiBpe,GACpD,IAAIw2C,EAAM/rC,KAAK8rC,MAAQ9rC,KAAK6rC,QAC5B,OAAO,IAAID,EAAkB5rC,KAAKrK,KAAMqK,KAAKrK,KAAOqK,KAAKvK,MAAML,KAAO22C,EACzC/rC,KAAKrK,KAAOqK,KAAKnH,OAAQmH,KAAKrK,KAAOqK,KAAKnH,OAASkzC,EACnDx2C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAIs8B,cAAchyB,KAAK6rC,QAAU7rC,KAAKrK,KAAMqK,KAAK8rC,MAAQ9rC,KAAKrK,MACxFqK,KAAK6rC,QAAU7rC,KAAKrK,KAAMqK,KAAKgkC,YAG9D4H,EAAkBntC,UAAUzI,IAAM,SAAcD,GAC9C,IAAIJ,EAAOI,EAAQ+wB,UAAU9mB,KAAKrK,KAAM,GAAID,EAAKK,EAAQ+wB,UAAU9mB,KAAKtK,IAAK,GACzEm2C,EAAU91C,EAAQC,IAAIgK,KAAK6rC,SAAU,GAAIC,EAAQ/1C,EAAQC,IAAIgK,KAAK8rC,MAAO,GAC7E,OAAKn2C,EAAKixB,SAAWlxB,EAAGkxB,SAAYilB,EAAUl2C,EAAKM,KAAO61C,EAAQp2C,EAAGO,IAAc,KAC5E,IAAI21C,EAAkBj2C,EAAKM,IAAKP,EAAGO,IAAK41C,EAASC,EAAO9rC,KAAKvK,MAAOuK,KAAKnH,OAAQmH,KAAKgkC,YAG/F4H,EAAkBntC,UAAU0W,OAAS,WACnC,IAAI6a,EAAO,CAACob,SAAU,gBAAiBz1C,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,GACrDm2C,QAAS7rC,KAAK6rC,QAASC,MAAO9rC,KAAK8rC,MAAOjzC,OAAQmH,KAAKnH,QAGnE,OAFImH,KAAKvK,MAAML,OAAQ46B,EAAKv6B,MAAQuK,KAAKvK,MAAM0f,UAC3CnV,KAAKgkC,YAAahU,EAAKgU,WAAY,GAChChU,GAGT4b,EAAkB1c,SAAW,SAAmB1tB,EAAQwuB,GACtD,GAAwB,iBAAbA,EAAKr6B,MAAsC,iBAAXq6B,EAAKt6B,IACrB,iBAAhBs6B,EAAK6b,SAA4C,iBAAd7b,EAAK8b,OAA2C,iBAAf9b,EAAKn3B,OAChF,MAAM,IAAI41B,WAAW,gDACzB,OAAO,IAAImd,EAAkB5b,EAAKr6B,KAAMq6B,EAAKt6B,GAAIs6B,EAAK6b,QAAS7b,EAAK8b,MACvC,cAAetqC,EAAQwuB,EAAKv6B,OAAQu6B,EAAKn3B,SAAUm3B,EAAKgU,YAGhF4H,EA9E4B,CA+EnCb,GAIF,SAASW,EAAen2C,EAAKI,EAAMD,GAEjC,IADA,IAAIgD,EAAQnD,EAAIO,QAAQH,GAAOk7B,EAAOn7B,EAAKC,EAAMS,EAAQsC,EAAMtC,MACxDy6B,EAAO,GAAKz6B,EAAQ,GAAKsC,EAAMP,WAAW/B,IAAUsC,EAAMpC,KAAKF,GAAOQ,YAC3ER,IACAy6B,IAEF,GAAIA,EAAO,EAET,IADA,IAAIgC,EAAOn6B,EAAMpC,KAAKF,GAAOs4B,WAAWh2B,EAAMP,WAAW/B,IAClDy6B,EAAO,GAAG,CACf,IAAKgC,GAAQA,EAAKtM,OAAU,OAAO,EACnCsM,EAAOA,EAAKp8B,WACZo6B,IAGJ,OAAO,EAGT,SAASob,EAAO31C,EAAM6E,EAAOpC,GAC3B,OAAiB,GAAToC,GAAc7E,EAAKsD,WAAWuB,EAAO7E,EAAKM,eAC/CmC,GAAOzC,EAAKM,YAAcN,EAAKsD,WAAW,EAAGb,IAOlD,SAASmzC,EAAW13C,GAGlB,IAFA,IACIW,EADSX,EAAMU,OACEC,QAAQm5B,WAAW95B,EAAMuI,WAAYvI,EAAMyI,UACvD7G,EAAQ5B,EAAM4B,SAAUA,EAAO,CACtC,IAAIE,EAAO9B,EAAMkE,MAAMpC,KAAKF,GACxBc,EAAQ1C,EAAMkE,MAAMxB,MAAMd,GAAQ6G,EAAWzI,EAAMmE,IAAIR,WAAW/B,GACtE,GAAIA,EAAQ5B,EAAM4B,OAASE,EAAKsD,WAAW1C,EAAO+F,EAAU9H,GACxD,OAAOiB,EACX,GAAa,GAATA,GAAcE,EAAKxB,KAAKC,KAAKC,YAAci3C,EAAO31C,EAAMY,EAAO+F,GAAa,OAiDpF,SAAShD,EAAazF,EAAO+G,EAAUC,EAAO2wC,QACxB,IAAfA,IAAwBA,EAAa33C,GAE1C,IAAI43C,EAQN,SAA6B53C,EAAOM,GAClC,IAAII,EAASV,EAAMU,OACf6H,EAAavI,EAAMuI,WACnBE,EAAWzI,EAAMyI,SACjBmvC,EAASl3C,EAAOkD,eAAe2E,GAAY9C,aAAanF,GAC5D,IAAKs3C,EAAU,OAAO,KACtB,IAAIC,EAAQD,EAAO/xC,OAAS+xC,EAAO,GAAKt3C,EACxC,OAAOI,EAAOmD,eAAe0E,EAAYE,EAAUovC,GAASD,EAAS,KAfxDE,CAAoB93C,EAAO+G,GACpC2T,EAAQk9B,GAiBd,SAA4B53C,EAAOM,GACjC,IAAII,EAASV,EAAMU,OACf6H,EAAavI,EAAMuI,WACnBE,EAAWzI,EAAMyI,SACjBiS,EAAQha,EAAOuI,MAAMV,GACrBwvC,EAASz3C,EAAK2b,aAAaxW,aAAaiV,EAAMpa,MAClD,IAAKy3C,EAAU,OAAO,KAGtB,IAFA,IACIC,GADWD,EAAOlyC,OAASkyC,EAAOA,EAAOlyC,OAAS,GAAKvF,GACjC2b,aACjBxZ,EAAI8F,EAAYyvC,GAAcv1C,EAAIgG,EAAUhG,IACjDu1C,EAAaA,EAAWtyC,UAAUhF,EAAOuI,MAAMxG,GAAGnC,MACtD,IAAK03C,IAAeA,EAAWryC,SAAY,OAAO,KAClD,OAAOoyC,EA7BeE,CAAmBN,EAAY5wC,GACrD,OAAK2T,EACEk9B,EAAOp2C,IAAI02C,GAAW3f,OAAO,CAACj4B,KAAMyG,EAAUC,MAAOA,IAAQuxB,OAAO7d,EAAMlZ,IAAI02C,IADhE,KAIvB,SAASA,EAAU53C,GAAQ,MAAO,CAACA,KAAMA,EAAM0G,MAAO,MA8FtD,SAASmxC,EAASp3C,EAAKU,EAAKG,EAAOw2C,QAClB,IAAVx2C,IAAmBA,EAAQ,GAEhC,IAAIY,EAAOzB,EAAIO,QAAQG,GAAMg1B,EAAOj0B,EAAKZ,MAAQA,EAC7Cy2C,EAAaD,GAAcA,EAAWA,EAAWvyC,OAAS,IAAOrD,EAAK9B,OAC1E,GAAI+1B,EAAO,GAAKj0B,EAAK9B,OAAOJ,KAAKC,KAAKC,YACjCgC,EAAK9B,OAAO0E,WAAW5C,EAAKE,QAASF,EAAK9B,OAAO0B,cACjDi2C,EAAU/3C,KAAKid,aAAa/a,EAAK9B,OAAOC,QAAQm5B,WAAWt3B,EAAKE,QAASF,EAAK9B,OAAO0B,aACtF,OAAO,EACX,IAAK,IAAIyZ,EAAIrZ,EAAKZ,MAAQ,EAAGa,EAAIb,EAAQ,EAAGia,EAAI4a,EAAM5a,IAAKpZ,IAAK,CAC9D,IAAIX,EAAOU,EAAKV,KAAK+Z,GAAIy8B,EAAU91C,EAAKE,MAAMmZ,GAC9C,GAAI/Z,EAAKxB,KAAKC,KAAKC,UAAa,OAAO,EACvC,IAAI+3C,EAAOz2C,EAAKnB,QAAQm5B,WAAWwe,EAASx2C,EAAKM,YAC7CpB,EAASo3C,GAAcA,EAAW31C,IAAOX,EAE7C,GADId,GAASc,IAAQy2C,EAAOA,EAAKxe,aAAa,EAAG/4B,EAAMV,KAAKwF,OAAO9E,EAAMgG,UACpElF,EAAKsD,WAAWkzC,EAAU,EAAGx2C,EAAKM,cAAgBpB,EAAMV,KAAKid,aAAag7B,GAC3E,OAAO,EAEb,IAAI71C,EAAQF,EAAKmB,WAAW8yB,GACxB+hB,EAAWJ,GAAcA,EAAW,GACxC,OAAO51C,EAAKV,KAAK20B,GAAM5yB,eAAenB,EAAOA,EAAO81C,EAAWA,EAASl4C,KAAOkC,EAAKV,KAAK20B,EAAO,GAAGn2B,MAwBrG,SAASm4C,EAAQ13C,EAAKU,GACpB,IAAIe,EAAOzB,EAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAC1C,OAAOs6B,EAASx6B,EAAKnC,WAAYmC,EAAKK,YACpCL,EAAK9B,OAAO0E,WAAW1C,EAAOA,EAAQ,GAG1C,SAASs6B,EAASnR,EAAGrE,GACnB,OAAOqE,GAAKrE,IAAMqE,EAAEkG,QAAUlG,EAAEgU,UAAUrY,GAqE5C,SAASkxB,EAAU33C,EAAKU,EAAKR,GAC3B,IAAIuB,EAAOzB,EAAIO,QAAQG,GACvB,IAAKR,EAAMN,QAAQC,KAAQ,OAAOa,EAElC,IADA,IAAId,EAAUM,EAAMN,QACX8B,EAAI,EAAGA,EAAIxB,EAAM46B,UAAWp5B,IAAO9B,EAAUA,EAAQsB,WAAWtB,QACzE,IAAK,IAAIg4C,EAAO,EAAGA,IAA4B,GAAnB13C,EAAM46B,WAAkB56B,EAAML,KAAO,EAAI,GAAI+3C,IACvE,IAAK,IAAI98B,EAAIrZ,EAAKZ,MAAOia,GAAK,EAAGA,IAAK,CACpC,IAAIlH,EAAOkH,GAAKrZ,EAAKZ,MAAQ,EAAIY,EAAKf,MAAQe,EAAKmE,MAAMkV,EAAI,GAAKrZ,EAAK+B,IAAIsX,EAAI,IAAM,GAAK,EAAI,EAC1F+8B,EAAYp2C,EAAKE,MAAMmZ,IAAMlH,EAAO,EAAI,EAAI,GAC5CjU,EAAS8B,EAAKV,KAAK+Z,GAAIg9B,GAAO,EAClC,GAAY,GAARF,EACFE,EAAOn4C,EAAO0E,WAAWwzC,EAAWA,EAAWj4C,OAC1C,CACL,IAAIkf,EAAWnf,EAAOkD,eAAeg1C,GAAWnzC,aAAa9E,EAAQsB,WAAW3B,MAChFu4C,EAAOh5B,GAAYnf,EAAOmD,eAAe+0C,EAAWA,EAAW/4B,EAAS,IAE1E,GAAIg5B,EACA,OAAe,GAARlkC,EAAYnS,EAAKf,IAAMkT,EAAO,EAAInS,EAAKpC,OAAOyb,EAAI,GAAKrZ,EAAKxB,MAAM6a,EAAI,GAGrF,OAAO,KAGT,SAASi9B,EAAYp1B,EAAU/M,EAAGjW,GAEhC,IADA,IAAIq4C,EAAS,GACJt2C,EAAI,EAAGA,EAAIihB,EAASthB,WAAYK,IAAK,CAC5C,IAAIwG,EAAQya,EAASza,MAAMxG,GACvBwG,EAAMtI,QAAQC,OAAQqI,EAAQA,EAAMlD,KAAK+yC,EAAY7vC,EAAMtI,QAASgW,EAAG1N,KACvEA,EAAMvC,WAAYuC,EAAQ0N,EAAE1N,EAAOvI,EAAQ+B,IAC/Cs2C,EAAO3yC,KAAK6C,GAEd,OAAO,eAAmB8vC,GAnV5BxC,EAAKpF,OAAO,gBAAiBiG,GA8C7BrF,EAAU9nC,UAAU9J,KAAO,SAASH,EAAOE,GASzC,IARA,IAAIgE,EAAQlE,EAAMkE,MACdC,EAAMnE,EAAMmE,IACZvC,EAAQ5B,EAAM4B,MAEdo3C,EAAW90C,EAAM9D,OAAOwB,EAAQ,GAAIq3C,EAAS90C,EAAInD,MAAMY,EAAQ,GAC/D+E,EAAQqyC,EAAUz0C,EAAM00C,EAExB74C,EAAS,WAAgBy7B,EAAY,EAChChgB,EAAIja,EAAOs3C,GAAY,EAAOr9B,EAAI3b,EAAQ2b,IAC3Cq9B,GAAah1C,EAAMxB,MAAMmZ,GAAK,GAClCq9B,GAAY,EACZ94C,EAAS,UAAc8D,EAAMpC,KAAK+Z,GAAG9V,KAAK3F,IAC1Cy7B,KAEAl1B,IAGJ,IADA,IAAI3F,EAAQ,WAAgB86B,EAAU,EAC7Bqd,EAAMv3C,EAAOw3C,GAAc,EAAOD,EAAMj5C,EAAQi5C,IACjDC,GAAej1C,EAAInD,MAAMm4C,EAAM,GAAKh1C,EAAII,IAAI40C,IAChDC,GAAc,EACdp4C,EAAQ,UAAcmD,EAAIrC,KAAKq3C,GAAKpzC,KAAK/E,IACzC86B,KAEAv3B,IAGJ,OAAOiH,KAAKpK,KAAK,IAAIg2C,EAAkBzwC,EAAOpC,EAAKy0C,EAAUC,EACtB,IAAI,KAAM74C,EAAOwJ,OAAO5I,GAAQ66B,EAAWC,GAC3C17B,EAAOQ,KAAOi7B,GAAW,KAkDlEkW,EAAU9nC,UAAUrE,KAAO,SAAS5F,EAAO0I,GAEzC,IADA,IAAI/H,EAAU,WACL8B,EAAIiG,EAAS7C,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAC7C,GAAI9B,EAAQC,KAAM,CAChB,IAAIyC,EAAQqF,EAASjG,GAAGnC,KAAK2b,aAAaujB,cAAc7+B,GACxD,IAAK0C,IAAUA,EAAMsC,SACjB,MAAM,IAAIs0B,WAAW,0FAE3Bt5B,EAAU,UAAc+H,EAASjG,GAAGnC,KAAKwF,OAAO4C,EAASjG,GAAGuE,MAAOrG,IAGrE,IAAIgG,EAAQ3G,EAAM2G,MAAOpC,EAAMvE,EAAMuE,IACrC,OAAOiH,KAAKpK,KAAK,IAAIg2C,EAAkBzwC,EAAOpC,EAAKoC,EAAOpC,EAAK,IAAI,KAAM5D,EAAS,EAAG,GAAI+H,EAAS7C,QAAQ,KAM5GksC,EAAU9nC,UAAUnD,aAAe,SAAS3F,EAAMD,EAAIZ,EAAM0G,GAC1D,IAAI0+B,EAASl6B,KAGb,QAFY,IAAPtK,IAAgBA,EAAKC,IAErBb,EAAK6B,YAAe,MAAM,IAAI83B,WAAW,oDAC9C,IAAIuW,EAAUhlC,KAAKqJ,MAAMhP,OAYzB,OAXA2F,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC9C,GAAIK,EAAKK,cAAgBL,EAAKqF,UAAU7G,EAAM0G,IAalD,SAAuBjG,EAAKU,EAAKnB,GAC/B,IAAIkC,EAAOzB,EAAIO,QAAQG,GAAMiB,EAAQF,EAAKE,QAC1C,OAAOF,EAAK9B,OAAOmD,eAAenB,EAAOA,EAAQ,EAAGpC,GAfM+4C,CAAc3T,EAAO3kC,IAAK2kC,EAAOnkC,QAAQN,MAAMuvC,GAAShvC,IAAIC,GAAMnB,GAAO,CAE/HolC,EAAOrgC,kBAAkBqgC,EAAOnkC,QAAQN,MAAMuvC,GAAShvC,IAAIC,EAAK,GAAInB,GACpE,IAAIiB,EAAUmkC,EAAOnkC,QAAQN,MAAMuvC,GAC/B8I,EAAS/3C,EAAQC,IAAIC,EAAK,GAAI83C,EAAOh4C,EAAQC,IAAIC,EAAMK,EAAKJ,SAAU,GAG1E,OAFAgkC,EAAOtkC,KAAK,IAAIg2C,EAAkBkC,EAAQC,EAAMD,EAAS,EAAGC,EAAO,EACnC,IAAI,KAAM,UAAcj5C,EAAKwF,OAAOkB,EAAO,KAAMlF,EAAKqO,QAAS,EAAG,GAAI,GAAG,KAClG,MAGJ3E,MAWTumC,EAAU9nC,UAAUhF,cAAgB,SAASxD,EAAKnB,EAAM0G,EAAOmJ,GAC7D,IAAIrO,EAAO0J,KAAKzK,IAAIic,OAAOvb,GAC3B,IAAKK,EAAQ,MAAM,IAAIm4B,WAAW,6BAC7B35B,IAAQA,EAAOwB,EAAKxB,MACzB,IAAIk5C,EAAUl5C,EAAKwF,OAAOkB,EAAO,KAAMmJ,GAASrO,EAAKqO,OACrD,GAAIrO,EAAKiwB,OACL,OAAOvmB,KAAK1H,YAAYrC,EAAKA,EAAMK,EAAKJ,SAAU83C,GAEtD,IAAKl5C,EAAKid,aAAazb,EAAKnB,SACxB,MAAM,IAAIs5B,WAAW,iCAAmC35B,EAAKmL,MAEjE,OAAOD,KAAKpK,KAAK,IAAIg2C,EAAkB31C,EAAKA,EAAMK,EAAKJ,SAAUD,EAAM,EAAGA,EAAMK,EAAKJ,SAAW,EACzD,IAAI,KAAM,UAAc83C,GAAU,EAAG,GAAI,GAAG,KAkCrFzH,EAAU9nC,UAAUzF,MAAQ,SAAS/C,EAAKG,EAAOw2C,QAChC,IAAVx2C,IAAmBA,EAAQ,GAGhC,IADA,IAAIY,EAAOgJ,KAAKzK,IAAIO,QAAQG,GAAMrB,EAAS,WAAgBY,EAAQ,WAC1D6a,EAAIrZ,EAAKZ,MAAOoH,EAAIxG,EAAKZ,MAAQA,EAAOa,EAAIb,EAAQ,EAAGia,EAAI7S,EAAG6S,IAAKpZ,IAAK,CAC/ErC,EAAS,UAAcoC,EAAKV,KAAK+Z,GAAG9V,KAAK3F,IACzC,IAAIq5C,EAAYrB,GAAcA,EAAW31C,GACzCzB,EAAQ,UAAcy4C,EAAYA,EAAUn5C,KAAKwF,OAAO2zC,EAAUzyC,MAAOhG,GAASwB,EAAKV,KAAK+Z,GAAG9V,KAAK/E,IAEtG,OAAOwK,KAAKpK,KAAK,IAAI61C,EAAYx1C,EAAKA,EAAK,IAAI,KAAMrB,EAAOwJ,OAAO5I,GAAQY,EAAOA,IAAQ,KA+C5FmwC,EAAU9nC,UAAU3E,KAAO,SAAS7D,EAAKG,QACxB,IAAVA,IAAmBA,EAAQ,GAEhC,IAAIR,EAAO,IAAI61C,EAAYx1C,EAAMG,EAAOH,EAAMG,EAAO,YAAa,GAClE,OAAO4J,KAAKpK,KAAKA,IAkEnB,IAAIs4C,EAA4B,SAAUnD,GACxC,SAASmD,EAAYv4C,EAAMD,EAAI8P,GAC7BulC,EAAKpsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKwF,KAAOA,EAgDd,OA7CKulC,IAAOmD,EAAY5rC,UAAYyoC,GACpCmD,EAAYzvC,UAAYD,OAAOlE,OAAQywC,GAAQA,EAAKtsC,WACpDyvC,EAAYzvC,UAAUI,YAAcqvC,EAEpCA,EAAYzvC,UAAUuW,MAAQ,SAAgBzf,GAC5C,IAAI2kC,EAASl6B,KAETmuC,EAAW54C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IAAKgD,EAAQnD,EAAIO,QAAQkK,KAAKrK,MACnET,EAASwD,EAAMpC,KAAKoC,EAAM4U,YAAYtN,KAAKtK,KAC3CD,EAAQ,IAAI,KAAM63C,EAAYa,EAASh5C,SAAS,SAAUmB,EAAMpB,GAClE,OAAKoB,EAAKH,QAAWjB,EAAOJ,KAAKkkC,eAAekB,EAAO10B,KAAK1Q,MACrDwB,EAAKkP,KAAK00B,EAAO10B,KAAKmqB,SAASr5B,EAAKqO,QADiCrO,IAE3EpB,GAASi5C,EAAS9d,UAAW8d,EAAS7d,SACzC,OAAOgb,EAAWE,YAAYj2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAID,IAGzDy4C,EAAYzvC,UAAUkV,OAAS,WAC7B,OAAO,IAAIy6B,EAAepuC,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKwF,OAGrD0oC,EAAYzvC,UAAUzI,IAAM,SAAcD,GACxC,IAAIJ,EAAOI,EAAQ+wB,UAAU9mB,KAAKrK,KAAM,GAAID,EAAKK,EAAQ+wB,UAAU9mB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKixB,SAAWlxB,EAAGkxB,SAAWjxB,EAAKM,KAAOP,EAAGO,IAAc,KACxD,IAAIi4C,EAAYv4C,EAAKM,IAAKP,EAAGO,IAAK+J,KAAKwF,OAGhD0oC,EAAYzvC,UAAUysC,MAAQ,SAAgB/c,GAC5C,GAAIA,aAAiB+f,GACjB/f,EAAM3oB,KAAKgC,GAAGxH,KAAKwF,OACnBxF,KAAKrK,MAAQw4B,EAAMz4B,IAAMsK,KAAKtK,IAAMy4B,EAAMx4B,KAC1C,OAAO,IAAIu4C,EAAY7sC,KAAKc,IAAInC,KAAKrK,KAAMw4B,EAAMx4B,MAC5B0L,KAAKC,IAAItB,KAAKtK,GAAIy4B,EAAMz4B,IAAKsK,KAAKwF,OAG7D0oC,EAAYzvC,UAAU0W,OAAS,WAC7B,MAAO,CAACi2B,SAAU,UAAW5lC,KAAMxF,KAAKwF,KAAK2P,SACrCxf,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,KAGpCw4C,EAAYhf,SAAW,SAAmB1tB,EAAQwuB,GAChD,GAAwB,iBAAbA,EAAKr6B,MAAsC,iBAAXq6B,EAAKt6B,GAC5C,MAAM,IAAI+4B,WAAW,0CACzB,OAAO,IAAIyf,EAAYle,EAAKr6B,KAAMq6B,EAAKt6B,GAAI8L,EAAO+yB,aAAavE,EAAKxqB,QAG/D0oC,EA3DsB,CA4D7BnD,GAEFA,EAAKpF,OAAO,UAAWuI,GAGvB,IAAIE,EAA+B,SAAUrD,GAC3C,SAASqD,EAAez4C,EAAMD,EAAI8P,GAChCulC,EAAKpsC,KAAKqB,MAGVA,KAAKrK,KAAOA,EAGZqK,KAAKtK,GAAKA,EAGVsK,KAAKwF,KAAOA,EA8Cd,OA3CKulC,IAAOqD,EAAe9rC,UAAYyoC,GACvCqD,EAAe3vC,UAAYD,OAAOlE,OAAQywC,GAAQA,EAAKtsC,WACvD2vC,EAAe3vC,UAAUI,YAAcuvC,EAEvCA,EAAe3vC,UAAUuW,MAAQ,SAAgBzf,GAC/C,IAAI2kC,EAASl6B,KAETmuC,EAAW54C,EAAIE,MAAMuK,KAAKrK,KAAMqK,KAAKtK,IACrCD,EAAQ,IAAI,KAAM63C,EAAYa,EAASh5C,SAAS,SAAUmB,GAC5D,OAAOA,EAAKkP,KAAK00B,EAAO10B,KAAKuqB,cAAcz5B,EAAKqO,WAC9CwpC,EAAS9d,UAAW8d,EAAS7d,SACjC,OAAOgb,EAAWE,YAAYj2C,EAAKyK,KAAKrK,KAAMqK,KAAKtK,GAAID,IAGzD24C,EAAe3vC,UAAUkV,OAAS,WAChC,OAAO,IAAIu6B,EAAYluC,KAAKrK,KAAMqK,KAAKtK,GAAIsK,KAAKwF,OAGlD4oC,EAAe3vC,UAAUzI,IAAM,SAAcD,GAC3C,IAAIJ,EAAOI,EAAQ+wB,UAAU9mB,KAAKrK,KAAM,GAAID,EAAKK,EAAQ+wB,UAAU9mB,KAAKtK,IAAK,GAC7E,OAAIC,EAAKixB,SAAWlxB,EAAGkxB,SAAWjxB,EAAKM,KAAOP,EAAGO,IAAc,KACxD,IAAIm4C,EAAez4C,EAAKM,IAAKP,EAAGO,IAAK+J,KAAKwF,OAGnD4oC,EAAe3vC,UAAUysC,MAAQ,SAAgB/c,GAC/C,GAAIA,aAAiBigB,GACjBjgB,EAAM3oB,KAAKgC,GAAGxH,KAAKwF,OACnBxF,KAAKrK,MAAQw4B,EAAMz4B,IAAMsK,KAAKtK,IAAMy4B,EAAMx4B,KAC1C,OAAO,IAAIy4C,EAAe/sC,KAAKc,IAAInC,KAAKrK,KAAMw4B,EAAMx4B,MAC5B0L,KAAKC,IAAItB,KAAKtK,GAAIy4B,EAAMz4B,IAAKsK,KAAKwF,OAGhE4oC,EAAe3vC,UAAU0W,OAAS,WAChC,MAAO,CAACi2B,SAAU,aAAc5lC,KAAMxF,KAAKwF,KAAK2P,SACxCxf,KAAMqK,KAAKrK,KAAMD,GAAIsK,KAAKtK,KAGpC04C,EAAelf,SAAW,SAAmB1tB,EAAQwuB,GACnD,GAAwB,iBAAbA,EAAKr6B,MAAsC,iBAAXq6B,EAAKt6B,GAC5C,MAAM,IAAI+4B,WAAW,6CACzB,OAAO,IAAI2f,EAAepe,EAAKr6B,KAAMq6B,EAAKt6B,GAAI8L,EAAO+yB,aAAavE,EAAKxqB,QAGlE4oC,EAzDyB,CA0DhCrD,GAuHF,SAASsD,EAAY94C,EAAKI,EAAMD,EAAID,GAIlC,QAHY,IAAPC,IAAgBA,EAAKC,QACX,IAAVF,IAAmBA,EAAQ,YAE5BE,GAAQD,IAAOD,EAAML,KAAQ,OAAO,KAExC,IAAIsD,EAAQnD,EAAIO,QAAQH,GAAOgD,EAAMpD,EAAIO,QAAQJ,GAEjD,OAAI44C,EAAc51C,EAAOC,EAAKlD,GAAiB,IAAIg2C,EAAY91C,EAAMD,EAAID,GAClE,IAAI84C,EAAO71C,EAAOC,EAAKlD,GAAO+4C,MAkCvC,SAASF,EAAc51C,EAAOC,EAAKlD,GACjC,OAAQA,EAAM46B,YAAc56B,EAAM66B,SAAW53B,EAAMyC,SAAWxC,EAAIwC,SAChEzC,EAAMxD,OAAO0E,WAAWlB,EAAMxB,QAASyB,EAAIzB,QAASzB,EAAMN,SAlK9D41C,EAAKpF,OAAO,aAAcyI,GAI1B7H,EAAU9nC,UAAUmO,QAAU,SAASjX,EAAMD,EAAI8P,GAC/C,IAAI00B,EAASl6B,KAETyuC,EAAU,GAAIC,EAAQ,GAAIC,EAAW,KAAMC,EAAS,KA0BxD,OAzBA5uC,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,EAAKf,GACnD,GAAKoB,EAAK4E,SAAV,CACA,IAAIyJ,EAAQrO,EAAKqO,MACjB,IAAKa,EAAKI,QAAQjB,IAAUzP,EAAOJ,KAAKkkC,eAAexzB,EAAK1Q,MAAO,CAIjE,IAHA,IAAIqG,EAAQkG,KAAKC,IAAIrL,EAAKN,GAAOoD,EAAMsI,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GACjEm5C,EAASrpC,EAAKmqB,SAAShrB,GAElB1N,EAAI,EAAGA,EAAI0N,EAAMtK,OAAQpD,IAC3B0N,EAAM1N,GAAG2O,QAAQipC,KAChBF,GAAYA,EAASj5C,IAAMyF,GAASwzC,EAASnpC,KAAKgC,GAAG7C,EAAM1N,IAC3D03C,EAASj5C,GAAKqD,EAEd01C,EAAQ7zC,KAAK+zC,EAAW,IAAIP,EAAejzC,EAAOpC,EAAK4L,EAAM1N,MAIjE23C,GAAUA,EAAOl5C,IAAMyF,EACvByzC,EAAOl5C,GAAKqD,EAEZ21C,EAAM9zC,KAAKg0C,EAAS,IAAIV,EAAY/yC,EAAOpC,EAAKyM,SAIxDipC,EAAQtvC,SAAQ,SAAU2vC,GAAK,OAAO5U,EAAOtkC,KAAKk5C,MAClDJ,EAAMvvC,SAAQ,SAAU2vC,GAAK,OAAO5U,EAAOtkC,KAAKk5C,MACzC9uC,MAQTumC,EAAU9nC,UAAUsV,WAAa,SAASpe,EAAMD,EAAI8P,GAClD,IAAI00B,EAASl6B,UACC,IAATwF,IAAkBA,EAAO,MAE9B,IAAI6T,EAAU,GAAIzjB,EAAO,EAkCzB,OAjCAoK,KAAKzK,IAAImG,aAAa/F,EAAMD,GAAI,SAAUY,EAAML,GAC9C,GAAKK,EAAK4E,SAAV,CACAtF,IACA,IAAIm5C,EAAW,KACf,GAAIvpC,aAAgB,KAElB,IADA,IAAsBpI,EAAlBwyB,EAAMt5B,EAAKqO,MACRvH,EAAQoI,EAAKI,QAAQgqB,KACjCmf,IAAaA,EAAW,KAAKn0C,KAAKwC,GAC3BwyB,EAAMxyB,EAAM2yB,cAAcH,QAEnBpqB,EACLA,EAAKI,QAAQtP,EAAKqO,SAAUoqC,EAAW,CAACvpC,IAE5CupC,EAAWz4C,EAAKqO,MAElB,GAAIoqC,GAAYA,EAAS10C,OAEvB,IADA,IAAItB,EAAMsI,KAAKc,IAAIlM,EAAMK,EAAKJ,SAAUR,GAC/BuB,EAAI,EAAGA,EAAI83C,EAAS10C,OAAQpD,IAAK,CAExC,IADA,IAAIkmB,EAAQ4xB,EAAS93C,GAAI+3C,OAAU,EAC1Bt7B,EAAI,EAAGA,EAAI2F,EAAQhf,OAAQqZ,IAAK,CACvC,IAAI4gB,EAAIjb,EAAQ3F,GACZ4gB,EAAE1+B,MAAQA,EAAO,GAAKunB,EAAM3V,GAAG6R,EAAQ3F,GAAGyJ,SAAU6xB,EAAU1a,GAEhE0a,GACFA,EAAQt5C,GAAKqD,EACbi2C,EAAQp5C,KAAOA,GAEfyjB,EAAQze,KAAK,CAACuiB,MAAOA,EAAOxnB,KAAM0L,KAAKC,IAAIrL,EAAKN,GAAOD,GAAIqD,EAAKnD,KAAMA,SAK9EyjB,EAAQla,SAAQ,SAAUm1B,GAAK,OAAO4F,EAAOtkC,KAAK,IAAIw4C,EAAe9Z,EAAE3+B,KAAM2+B,EAAE5+B,GAAI4+B,EAAEnX,WAC9End,MAQTumC,EAAU9nC,UAAU5E,kBAAoB,SAAS5D,EAAKg5C,EAAYp3C,QACjD,IAAVA,IAAmBA,EAAQo3C,EAAWx+B,cAI3C,IAFA,IAAIna,EAAO0J,KAAKzK,IAAIic,OAAOvb,GACvBi5C,EAAW,GAAIhZ,EAAMjgC,EAAM,EACtBgB,EAAI,EAAGA,EAAIX,EAAKM,WAAYK,IAAK,CACxC,IAAIwG,EAAQnH,EAAKmH,MAAMxG,GAAI8B,EAAMm9B,EAAMz4B,EAAMvH,SACzCi5C,EAAUt3C,EAAMqC,UAAUuD,EAAM3I,KAAM2I,EAAMjC,OAChD,GAAK2zC,EAEE,CACLt3C,EAAQs3C,EACR,IAAK,IAAIz7B,EAAI,EAAGA,EAAIjW,EAAMkH,MAAMtK,OAAQqZ,IAAYu7B,EAAWjW,eAAev7B,EAAMkH,MAAM+O,GAAG5e,OACzFkL,KAAKpK,KAAK,IAAIw4C,EAAelY,EAAKn9B,EAAK0E,EAAMkH,MAAM+O,UAJvDw7B,EAASt0C,KAAK,IAAI6wC,EAAYvV,EAAKn9B,EAAK,aAM1Cm9B,EAAMn9B,EAER,IAAKlB,EAAMsC,SAAU,CACnB,IAAI+jC,EAAOrmC,EAAM6+B,WAAW,YAAgB,GAC5C12B,KAAK0Q,QAAQwlB,EAAKA,EAAK,IAAI,KAAMgI,EAAM,EAAG,IAE5C,IAAK,IAAIljC,EAAMk0C,EAAS70C,OAAS,EAAGW,GAAO,EAAGA,IAASgF,KAAKpK,KAAKs5C,EAASl0C,IAC1E,OAAOgF,MAuBTumC,EAAU9nC,UAAUiS,QAAU,SAAS/a,EAAMD,EAAID,QACnC,IAAPC,IAAgBA,EAAKC,QACX,IAAVF,IAAmBA,EAAQ,YAEhC,IAAIG,EAAOy4C,EAAYruC,KAAKzK,IAAKI,EAAMD,EAAID,GAE3C,OADIG,GAAQoK,KAAKpK,KAAKA,GACfoK,MAMTumC,EAAU9nC,UAAUnG,YAAc,SAAS3C,EAAMD,EAAIP,GACnD,OAAO6K,KAAK0Q,QAAQ/a,EAAMD,EAAI,IAAI,KAAM,UAAcP,GAAU,EAAG,KAKrEoxC,EAAU9nC,UAAUpI,OAAS,SAASV,EAAMD,GAC1C,OAAOsK,KAAK0Q,QAAQ/a,EAAMD,EAAI,aAKhC6wC,EAAU9nC,UAAU5F,OAAS,SAAS5C,EAAKd,GACzC,OAAO6K,KAAK1H,YAAYrC,EAAKA,EAAKd,IA4BpC,IAAIo5C,EAAS,SAAgB71C,EAAOC,EAAKlD,GACvCuK,KAAKrH,IAAMA,EACXqH,KAAKtH,MAAQA,EACbsH,KAAKovC,SAAW35C,EAEhBuK,KAAKqvC,SAAW,GAChB,IAAK,IAAIp4C,EAAI,EAAGA,GAAKyB,EAAMtC,MAAOa,IAAK,CACrC,IAAIX,EAAOoC,EAAMpC,KAAKW,GACtB+I,KAAKqvC,SAASz0C,KAAK,CACjB9F,KAAMwB,EAAKxB,KACX+C,MAAOvB,EAAK8B,eAAeM,EAAMP,WAAWlB,MAIhD+I,KAAK6vB,OAAS,WACd,IAAK,IAAI70B,EAAMtC,EAAMtC,MAAO4E,EAAM,EAAGA,IACjCgF,KAAK6vB,OAAS,UAAcn3B,EAAMpC,KAAK0E,GAAKT,KAAKyF,KAAK6vB,UAGxDU,EAAuB,CAAEn6B,MAAO,CAAE43B,cAAc,IAqOpD,SAASshB,EAAiBp3B,EAAU9hB,EAAOm5C,GACzC,OAAa,GAATn5C,EAAqB8hB,EAASoW,WAAWihB,GACtCr3B,EAASqW,aAAa,EAAGrW,EAASzhB,WAAW8D,KAAK+0C,EAAiBp3B,EAASzhB,WAAWtB,QAASiB,EAAQ,EAAGm5C,KAGpH,SAASC,EAAct3B,EAAU9hB,EAAOjB,GACtC,OAAa,GAATiB,EAAqB8hB,EAAS9Z,OAAOjJ,GAClC+iB,EAASqW,aAAarW,EAASthB,WAAa,EACtBshB,EAASxhB,UAAU6D,KAAKi1C,EAAct3B,EAASxhB,UAAUvB,QAASiB,EAAQ,EAAGjB,KAG5G,SAASs6C,EAAUv3B,EAAU9hB,GAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAIb,EAAOa,IAAOihB,EAAWA,EAASzhB,WAAWtB,QACjE,OAAO+iB,EAGT,SAASw3B,EAAep5C,EAAM+5B,EAAWC,GACvC,GAAID,GAAa,EAAK,OAAO/5B,EAC7B,IAAIkgC,EAAOlgC,EAAKnB,QAOhB,OANIk7B,EAAY,IACZmG,EAAOA,EAAKjI,aAAa,EAAGmhB,EAAelZ,EAAK//B,WAAY45B,EAAY,EAAsB,GAAnBmG,EAAK5/B,WAAkB05B,EAAU,EAAI,KAChHD,EAAY,IACdmG,EAAOlgC,EAAKxB,KAAK2b,aAAaimB,WAAWF,GAAMp4B,OAAOo4B,GAClDlG,GAAW,IAAKkG,EAAOA,EAAKp4B,OAAO9H,EAAKxB,KAAK2b,aAAaujB,cAAcwC,GAAME,WAAW,YAAgB,MAExGpgC,EAAKiE,KAAKi8B,GAGnB,SAASmZ,EAAiBh3C,EAAKvC,EAAOtB,EAAM+C,EAAO8mC,GACjD,IAAIroC,EAAOqC,EAAIrC,KAAKF,GAAQc,EAAQynC,EAAOhmC,EAAIR,WAAW/B,GAASuC,EAAIzB,MAAMd,GAC7E,GAAIc,GAASZ,EAAKM,aAAe9B,EAAK6E,kBAAkBrD,EAAKxB,MAAS,OAAO,KAC7E,IAAI05C,EAAM32C,EAAM6+B,WAAWpgC,EAAKnB,SAAS,EAAM+B,GAC/C,OAAOs3C,IAGT,SAAsB15C,EAAMojB,EAAU/c,GACpC,IAAK,IAAIlE,EAAIkE,EAAOlE,EAAIihB,EAASthB,WAAYK,IACzC,IAAKnC,EAAKs/B,YAAYlc,EAASza,MAAMxG,GAAG0N,OAAU,OAAO,EAC7D,OAAO,EANQirC,CAAa96C,EAAMwB,EAAKnB,QAAS+B,GAASs3C,EAAM,KAiGjE,SAASqB,EAAc33B,EAAU9hB,EAAO05C,EAASC,EAAS76C,GACxD,GAAIkB,EAAQ05C,EAAS,CACnB,IAAIv2C,EAAQ2e,EAASzhB,WACrByhB,EAAWA,EAASqW,aAAa,EAAGh1B,EAAMgB,KAAKs1C,EAAct2C,EAAMpE,QAASiB,EAAQ,EAAG05C,EAASC,EAASx2C,KAE3G,GAAInD,EAAQ25C,EAAS,CACnB,IAAIl4C,EAAQ3C,EAAOkD,eAAe,GAC9B+C,EAAQtD,EAAM6+B,WAAWxe,GAAU9Z,OAAO8Z,GAC9CA,EAAW/c,EAAMiD,OAAOvG,EAAMm8B,cAAc74B,GAAOu7B,WAAW,YAAgB,IAEhF,OAAOxe,EA0CT,SAAS83B,EAAct3C,EAAOC,GAE5B,IADA,IAAI0R,EAAS,GACJgG,EADmBhP,KAAKc,IAAIzJ,EAAMtC,MAAOuC,EAAIvC,OAC/Bia,GAAK,EAAGA,IAAK,CAClC,IAAIlV,EAAQzC,EAAMyC,MAAMkV,GACxB,GAAIlV,EAAQzC,EAAMzC,KAAOyC,EAAMtC,MAAQia,IACnC1X,EAAII,IAAIsX,GAAK1X,EAAI1C,KAAO0C,EAAIvC,MAAQia,IACpC3X,EAAMpC,KAAK+Z,GAAGvb,KAAKC,KAAKC,WACxB2D,EAAIrC,KAAK+Z,GAAGvb,KAAKC,KAAKC,UAAa,OACnCmG,GAASxC,EAAIwC,MAAMkV,IAClBA,GAAK3X,EAAMtC,OAASia,GAAK1X,EAAIvC,OAASsC,EAAMxD,OAAO0D,eAAiBD,EAAIzD,OAAO0D,eAC/EyX,GAAK1X,EAAIwC,MAAMkV,EAAI,IAAMlV,EAAQ,IAClCkP,EAAOzP,KAAKyV,GAElB,OAAOhG,EAraTkmB,EAAqBn6B,MAAMo2B,IAAM,WAAc,OAAOxsB,KAAKqvC,SAASh1C,OAAS,GAE7Ek0C,EAAO9vC,UAAU+vC,IAAM,WAIrB,KAAOxuC,KAAKovC,SAASh6C,MAAM,CACzB,IAAIo5C,EAAMxuC,KAAKiwC,eACXzB,EAAOxuC,KAAKkwC,WAAW1B,GACpBxuC,KAAKmwC,YAAcnwC,KAAKowC,WAOjC,IAAIC,EAAarwC,KAAKswC,iBAAkBC,EAAavwC,KAAK6vB,OAAOz6B,KAAO4K,KAAK5J,MAAQ4J,KAAKtH,MAAMtC,MAC5FsC,EAAQsH,KAAKtH,MAAOC,EAAMqH,KAAKwwC,MAAMH,EAAa,EAAIrwC,KAAKrH,IAAMD,EAAMnD,IAAIO,QAAQu6C,IACvF,IAAK13C,EAAO,OAAO,KAInB,IADA,IAAIxD,EAAU6K,KAAK6vB,OAAQQ,EAAY33B,EAAMtC,MAAOk6B,EAAU33B,EAAIvC,MAC3Di6B,GAAaC,GAAiC,GAAtBn7B,EAAQyB,YACrCzB,EAAUA,EAAQsB,WAAWtB,QAC7Bk7B,IAAaC,IAEf,IAAI76B,EAAQ,IAAI,KAAMN,EAASk7B,EAAWC,GAC1C,OAAI+f,GAAc,EACP,IAAIzE,EAAkBlzC,EAAMzC,IAAKo6C,EAAYrwC,KAAKrH,IAAI1C,IAAK+J,KAAKrH,IAAII,MAAOtD,EAAO86C,GACzF96C,EAAML,MAAQsD,EAAMzC,KAAO+J,KAAKrH,IAAI1C,IAC7B,IAAIw1C,EAAY/yC,EAAMzC,IAAK0C,EAAI1C,IAAKR,QAD/C,GAOF84C,EAAO9vC,UAAUwxC,aAAe,WAG9B,IAAK,IAAI9C,EAAO,EAAGA,GAAQ,EAAGA,IAC5B,IAAK,IAAIsD,EAAazwC,KAAKovC,SAAS/e,UAAWogB,GAAc,EAAGA,IAS9D,IARA,IAAyBv7C,OAAS,EAO9BqE,GANAk3C,GACFv7C,EAASu6C,EAAUzvC,KAAKovC,SAASj6C,QAASs7C,EAAa,GAAGh6C,YACxCtB,QAEP6K,KAAKovC,SAASj6C,SAENsB,WACZi6C,EAAgB1wC,KAAK5J,MAAOs6C,GAAiB,EAAGA,IAAiB,CACxE,IAAI55C,EAAMkJ,KAAKqvC,SAASqB,GAClB57C,EAAOgC,EAAIhC,KACX+C,EAAQf,EAAIe,MACZuC,OAAO,EAAUu2C,OAAS,EAIhC,GAAY,GAARxD,IAAc5zC,EAAQ1B,EAAMqC,UAAUX,EAAMzE,QAAU67C,EAAS94C,EAAM6+B,WAAW,UAAcn9B,IAAQ,IACtFzE,EAAK6E,kBAAkBzE,EAAOJ,OAC9C,MAAO,CAAC27C,WAAYA,EAAYC,cAAeA,EAAex7C,OAAQA,EAAQy7C,OAAQA,GAGrF,GAAY,GAARxD,GAAa5zC,IAAUa,EAAOvC,EAAMoC,aAAaV,EAAMzE,OAC5D,MAAO,CAAC27C,WAAYA,EAAYC,cAAeA,EAAex7C,OAAQA,EAAQkF,KAAMA,GAGxF,GAAIlF,GAAU2C,EAAMqC,UAAUhF,EAAOJ,MAAS,QAMtDy5C,EAAO9vC,UAAU0xC,SAAW,WAC1B,IAAIr5C,EAAMkJ,KAAKovC,SACTj6C,EAAU2B,EAAI3B,QACdk7B,EAAYv5B,EAAIu5B,UAChBC,EAAUx5B,EAAIw5B,QAChBphB,EAAQugC,EAAUt6C,EAASk7B,GAC/B,SAAKnhB,EAAMtY,YAAcsY,EAAMzY,WAAW8vB,UAC1CvmB,KAAKovC,SAAW,IAAI,KAAMj6C,EAASk7B,EAAY,EACrBhvB,KAAKC,IAAIgvB,EAASphB,EAAM9Z,KAAOi7B,GAAal7B,EAAQC,KAAOk7B,EAAUD,EAAY,EAAI,KACxG,IAGTke,EAAO9vC,UAAU2xC,SAAW,WAC1B,IAAIt5C,EAAMkJ,KAAKovC,SACTj6C,EAAU2B,EAAI3B,QACdk7B,EAAYv5B,EAAIu5B,UAChBC,EAAUx5B,EAAIw5B,QAChBphB,EAAQugC,EAAUt6C,EAASk7B,GAC/B,GAAInhB,EAAMtY,YAAc,GAAKy5B,EAAY,EAAG,CAC1C,IAAIugB,EAAYz7C,EAAQC,KAAOi7B,GAAaA,EAAYnhB,EAAM9Z,KAC9D4K,KAAKovC,SAAW,IAAI,KAAME,EAAiBn6C,EAASk7B,EAAY,EAAG,GAAIA,EAAY,EACzDugB,EAAYvgB,EAAY,EAAIC,QAEtDtwB,KAAKovC,SAAW,IAAI,KAAME,EAAiBn6C,EAASk7B,EAAW,GAAIA,EAAWC,IAQlFie,EAAO9vC,UAAUyxC,WAAa,SAAqBp5C,GAOjD,IANE,IAAI25C,EAAa35C,EAAI25C,WACjBC,EAAgB55C,EAAI45C,cACpBx7C,EAAS4B,EAAI5B,OACby7C,EAAS75C,EAAI65C,OACbv2C,EAAOtD,EAAIsD,KAEV4F,KAAK5J,MAAQs6C,GAAiB1wC,KAAK6wC,oBAC1C,GAAIz2C,EAAQ,IAAK,IAAInD,EAAI,EAAGA,EAAImD,EAAKC,OAAQpD,IAAO+I,KAAK8wC,iBAAiB12C,EAAKnD,IAE/E,IAAIxB,EAAQuK,KAAKovC,SAAUl3B,EAAWhjB,EAASA,EAAOC,QAAUM,EAAMN,QAClEk7B,EAAY56B,EAAM46B,UAAYogB,EAC9BM,EAAQ,EAAGtN,EAAM,GACjBhT,EAAQzwB,KAAKqvC,SAASqB,GACpB74C,EAAQ44B,EAAM54B,MACd/C,EAAO27B,EAAM37B,KACnB,GAAI67C,EAAQ,CACV,IAAK,IAAI31C,EAAM,EAAGA,EAAM21C,EAAO/5C,WAAYoE,IAASyoC,EAAI7oC,KAAK+1C,EAAOlzC,MAAMzC,IAC1EnD,EAAQA,EAAMm8B,cAAc2c,GAQ9B,IAHA,IAAIK,EAAgB94B,EAAS9iB,KAAOq7C,GAAeh7C,EAAMN,QAAQC,KAAOK,EAAM66B,SAGvEygB,EAAQ74B,EAASthB,YAAY,CAClC,IAAIi8B,EAAO3a,EAASza,MAAMszC,GAAQr2B,EAAU7iB,EAAMqC,UAAU24B,EAAK/9B,MACjE,IAAK4lB,EAAW,SAChBq2B,EACY,GAAkB,GAAb1gB,GAAkBwC,EAAK19B,QAAQC,QAC9CyC,EAAQ6iB,EACR+oB,EAAI7oC,KAAK80C,EAAe7c,EAAKrtB,KAAK1Q,EAAKmkC,aAAapG,EAAKluB,QAAkB,GAATosC,EAAa1gB,EAAY,EACnE0gB,GAAS74B,EAASthB,WAAao6C,GAAgB,KAG3E,IAAIra,EAAQoa,GAAS74B,EAASthB,WACzB+/B,IAASqa,GAAgB,GAE9BhxC,KAAK6vB,OAAS2f,EAAcxvC,KAAK6vB,OAAQ6gB,EAAe,UAAcjN,IACtEzjC,KAAKqvC,SAASqB,GAAe74C,MAAQA,EAIjC8+B,GAASqa,EAAe,GAAK97C,GAAUA,EAAOJ,MAAQkL,KAAKqvC,SAASrvC,KAAK5J,OAAOtB,MAAQkL,KAAKqvC,SAASh1C,OAAS,GAC/G2F,KAAK6wC,oBAGT,IAAK,IAAItzC,EAAM,EAAG24B,EAAMhe,EAAU3a,EAAMyzC,EAAczzC,IAAO,CAC3D,IAAIjH,EAAO4/B,EAAIx/B,UACfsJ,KAAKqvC,SAASz0C,KAAK,CAAC9F,KAAMwB,EAAKxB,KAAM+C,MAAOvB,EAAK8B,eAAe9B,EAAKM,cACrEs/B,EAAM5/B,EAAKnB,QAMb6K,KAAKovC,SAAYzY,EACC,GAAd8Z,EAAkB,WAClB,IAAI,KAAMnB,EAAiB75C,EAAMN,QAASs7C,EAAa,EAAG,GAChDA,EAAa,EAAGO,EAAe,EAAIv7C,EAAM66B,QAAUmgB,EAAa,GAHrD,IAAI,KAAMnB,EAAiB75C,EAAMN,QAASs7C,EAAYM,GAAQt7C,EAAM46B,UAAW56B,EAAM66B,UAMhHie,EAAO9vC,UAAU6xC,eAAiB,WAChC,IAAKtwC,KAAKrH,IAAIzD,OAAOyB,aAAeqJ,KAAKrH,IAAII,OAASiH,KAAKrH,IAAI1C,IAAO,OAAQ,EAC9E,IAAqCktC,EAAjCxY,EAAM3qB,KAAKqvC,SAASrvC,KAAK5J,OAC7B,IAAKu0B,EAAI71B,KAAK6B,cAAgBg5C,EAAiB3vC,KAAKrH,IAAKqH,KAAKrH,IAAIvC,MAAOu0B,EAAI71B,KAAM61B,EAAI9yB,OAAO,IACzFmI,KAAKrH,IAAIvC,OAAS4J,KAAK5J,QAAU+sC,EAAQnjC,KAAKixC,eAAejxC,KAAKrH,OAASwqC,EAAM/sC,OAAS4J,KAAK5J,MAAU,OAAQ,EAKtH,IAHA,IACMA,EADI4J,KAAKrH,IACGvC,MACZZ,EAAQwK,KAAKrH,IAAInD,MAAMY,GACtBA,EAAQ,GAAKZ,GAASwK,KAAKrH,IAAII,MAAM3C,MAAYZ,EACxD,OAAOA,GAGT+4C,EAAO9vC,UAAUwyC,eAAiB,SAAyBt4C,GACzDu+B,EAAM,IAAK,IAAIjgC,EAAIoK,KAAKc,IAAInC,KAAK5J,MAAOuC,EAAIvC,OAAQa,GAAK,EAAGA,IAAK,CAC/D,IAAIH,EAAMkJ,KAAKqvC,SAASp4C,GAClBY,EAAQf,EAAIe,MACZ/C,EAAOgC,EAAIhC,KACbo8C,EAAYj6C,EAAI0B,EAAIvC,OAASuC,EAAII,IAAI9B,EAAI,IAAM0B,EAAI1C,KAAO0C,EAAIvC,OAASa,EAAI,IAC3Eu3C,EAAMmB,EAAiBh3C,EAAK1B,EAAGnC,EAAM+C,EAAOq5C,GAChD,GAAK1C,EAAL,CACA,IAAK,IAAIn+B,EAAIpZ,EAAI,EAAGoZ,GAAK,EAAGA,IAAK,CAC/B,IAAIogB,EAAQzwB,KAAKqvC,SAASh/B,GACpB8gC,EAAU1gB,EAAM54B,MAElB6iB,EAAUi1B,EAAiBh3C,EAAK0X,EADrBogB,EAAM37B,KAC0Bq8C,GAAS,GACxD,IAAKz2B,GAAWA,EAAQ9jB,WAAc,SAASsgC,EAEjD,MAAO,CAAC9gC,MAAOa,EAAGu3C,IAAKA,EAAK4C,KAAMF,EAAYv4C,EAAIpD,IAAIO,QAAQ6C,EAAInD,MAAMyB,EAAI,IAAM0B,MAItF41C,EAAO9vC,UAAU+xC,MAAQ,SAAgB73C,GACvC,IAAI63C,EAAQxwC,KAAKixC,eAAet4C,GAChC,IAAK63C,EAAS,OAAO,KAErB,KAAOxwC,KAAK5J,MAAQo6C,EAAMp6C,OAAS4J,KAAK6wC,oBACpCL,EAAMhC,IAAI53C,aAAcoJ,KAAK6vB,OAAS2f,EAAcxvC,KAAK6vB,OAAQ2gB,EAAMp6C,MAAOo6C,EAAMhC,MACxF71C,EAAM63C,EAAMY,KACZ,IAAK,IAAI/gC,EAAImgC,EAAMp6C,MAAQ,EAAGia,GAAK1X,EAAIvC,MAAOia,IAAK,CACjD,IAAI/Z,EAAOqC,EAAIrC,KAAK+Z,GAAIozB,EAAMntC,EAAKxB,KAAK2b,aAAaimB,WAAWpgC,EAAKnB,SAAS,EAAMwD,EAAIzB,MAAMmZ,IAC9FrQ,KAAK8wC,iBAAiBx6C,EAAKxB,KAAMwB,EAAKkF,MAAOioC,GAE/C,OAAO9qC,GAGT41C,EAAO9vC,UAAUqyC,iBAAmB,SAA2Bh8C,EAAM0G,EAAOrG,GAC1E,IAAIw1B,EAAM3qB,KAAKqvC,SAASrvC,KAAK5J,OAC7Bu0B,EAAI9yB,MAAQ8yB,EAAI9yB,MAAMqC,UAAUpF,GAChCkL,KAAK6vB,OAAS2f,EAAcxvC,KAAK6vB,OAAQ7vB,KAAK5J,MAAO,UAActB,EAAKwF,OAAOkB,EAAOrG,KACtF6K,KAAKqvC,SAASz0C,KAAK,CAAC9F,KAAMA,EAAM+C,MAAO/C,EAAK2b,gBAG9C89B,EAAO9vC,UAAUoyC,kBAAoB,WACnC,IACIpN,EADOzjC,KAAKqvC,SAASjY,MACVv/B,MAAM6+B,WAAW,YAAgB,GAC5C+M,EAAI7sC,aAAcoJ,KAAK6vB,OAAS2f,EAAcxvC,KAAK6vB,OAAQ7vB,KAAKqvC,SAASh1C,OAAQopC,KAGvFjlC,OAAO6wB,iBAAkBkf,EAAO9vC,UAAW8xB,GA2D3CgW,EAAU9nC,UAAUwmC,aAAe,SAAStvC,EAAMD,EAAID,GACpD,IAAKA,EAAML,KAAQ,OAAO4K,KAAKoE,YAAYzO,EAAMD,GAEjD,IAAIgD,EAAQsH,KAAKzK,IAAIO,QAAQH,GAAOgD,EAAMqH,KAAKzK,IAAIO,QAAQJ,GAC3D,GAAI44C,EAAc51C,EAAOC,EAAKlD,GAC1B,OAAOuK,KAAKpK,KAAK,IAAI61C,EAAY91C,EAAMD,EAAID,IAE/C,IAAI47C,EAAerB,EAAct3C,EAAOsH,KAAKzK,IAAIO,QAAQJ,IAEZ,GAAzC27C,EAAaA,EAAah3C,OAAS,IAAWg3C,EAAaja,MAG/D,IAAIka,IAAoB54C,EAAMtC,MAAQ,GACtCi7C,EAAaE,QAAQD,GAKrB,IAAK,IAAIjhC,EAAI3X,EAAMtC,MAAOH,EAAMyC,EAAMzC,IAAM,EAAGoa,EAAI,EAAGA,IAAKpa,IAAO,CAChE,IAAIlB,EAAO2D,EAAMpC,KAAK+Z,GAAGvb,KAAKC,KAC9B,GAAIA,EAAKopB,UAAYppB,EAAKC,UAAa,MACnCq8C,EAAarxB,QAAQ3P,IAAM,EAAKihC,EAAkBjhC,EAC7C3X,EAAM9D,OAAOyb,IAAMpa,GAAOo7C,EAAaxkB,OAAO,EAAG,GAAIxc,GAOhE,IAHA,IAAImhC,EAAuBH,EAAarxB,QAAQsxB,GAE5CG,EAAY,GAAIC,EAAiBj8C,EAAM46B,UAClCl7B,EAAUM,EAAMN,QAAS8B,EAAI,GAAIA,IAAK,CAC7C,IAAIX,EAAOnB,EAAQsB,WAEnB,GADAg7C,EAAU72C,KAAKtE,GACXW,GAAKxB,EAAM46B,UAAa,MAC5Bl7B,EAAUmB,EAAKnB,QAIbu8C,EAAiB,GAAKD,EAAUC,EAAiB,GAAG58C,KAAKC,KAAKopB,UAC9DzlB,EAAMpC,KAAKk7C,GAAsB18C,MAAQ28C,EAAUC,EAAiB,GAAG58C,KACvE48C,GAAkB,EACbA,GAAkB,GAAKD,EAAUC,EAAiB,GAAG/6C,aAAe86C,EAAUC,EAAiB,GAAG58C,KAAKC,KAAKopB,UAC5GzlB,EAAMpC,KAAKk7C,GAAsB18C,MAAQ28C,EAAUC,EAAiB,GAAG58C,OAC5E48C,GAAkB,GAEtB,IAAK,IAAIh+B,EAAIje,EAAM46B,UAAW3c,GAAK,EAAGA,IAAK,CACzC,IAAIi+B,GAAaj+B,EAAIg+B,EAAiB,IAAMj8C,EAAM46B,UAAY,GAC1Dx3B,EAAS44C,EAAUE,GACvB,GAAK94C,EACL,IAAK,IAAImC,EAAM,EAAGA,EAAMq2C,EAAah3C,OAAQW,IAAO,CAGlD,IAAI42C,EAAcP,GAAcr2C,EAAMw2C,GAAwBH,EAAah3C,QAASw3C,GAAS,EACzFD,EAAc,IAAKC,GAAS,EAAOD,GAAeA,GACtD,IAAI18C,EAASwD,EAAMpC,KAAKs7C,EAAc,GAAI16C,EAAQwB,EAAMxB,MAAM06C,EAAc,GAC5E,GAAI18C,EAAOmD,eAAenB,EAAOA,EAAO2B,EAAO/D,KAAM+D,EAAO8L,OACxD,OAAO3E,KAAK0Q,QAAQhY,EAAM9D,OAAOg9C,GAAcC,EAASl5C,EAAInD,MAAMo8C,GAAel8C,EAC/D,IAAI,KAAMm6C,EAAcp6C,EAAMN,QAAS,EAAGM,EAAM46B,UAAWshB,GACjDA,EAAWl8C,EAAM66B,WAKrD,IADA,IAAIwhB,EAAa9xC,KAAKqJ,MAAMhP,OACnBkD,EAAM8zC,EAAah3C,OAAS,EAAGkD,GAAO,IAC7CyC,KAAK0Q,QAAQ/a,EAAMD,EAAID,KACnBuK,KAAKqJ,MAAMhP,OAASy3C,IAFwBv0C,IAAO,CAGvD,IAAInH,EAAQi7C,EAAa9zC,GACrBnH,EAAQ,IACZT,EAAO+C,EAAM9D,OAAOwB,GAAQV,EAAKiD,EAAInD,MAAMY,IAE7C,OAAO4J,MAwBTumC,EAAU9nC,UAAUymC,iBAAmB,SAASvvC,EAAMD,EAAIY,GACxD,IAAKA,EAAK4E,UAAYvF,GAAQD,GAAMsK,KAAKzK,IAAIO,QAAQH,GAAMT,OAAOC,QAAQC,KAAM,CAC9E,IAAI28C,EAhwBR,SAAqBx8C,EAAKU,EAAKsF,GAC7B,IAAIvE,EAAOzB,EAAIO,QAAQG,GACvB,GAAIe,EAAK9B,OAAOmD,eAAerB,EAAKE,QAASF,EAAKE,QAASqE,GAAa,OAAOtF,EAE/E,GAAyB,GAArBe,EAAK3C,aACL,IAAK,IAAIgc,EAAIrZ,EAAKZ,MAAQ,EAAGia,GAAK,EAAGA,IAAK,CAC1C,IAAInZ,EAAQF,EAAKE,MAAMmZ,GACvB,GAAIrZ,EAAKV,KAAK+Z,GAAGhY,eAAenB,EAAOA,EAAOqE,GAAa,OAAOvE,EAAKpC,OAAOyb,EAAI,GAClF,GAAInZ,EAAQ,EAAK,OAAO,KAE5B,GAAIF,EAAK3C,cAAgB2C,EAAK9B,OAAOC,QAAQC,KACzC,IAAK,IAAIu4C,EAAM32C,EAAKZ,MAAQ,EAAGu3C,GAAO,EAAGA,IAAO,CAChD,IAAIb,EAAU91C,EAAKmB,WAAWw1C,GAC9B,GAAI32C,EAAKV,KAAKq3C,GAAKt1C,eAAey0C,EAASA,EAASvxC,GAAa,OAAOvE,EAAKxB,MAAMm4C,EAAM,GACzF,GAAIb,EAAU91C,EAAKV,KAAKq3C,GAAK/2C,WAAc,OAAO,MAkvBxCo7C,CAAYhyC,KAAKzK,IAAKI,EAAMW,EAAKxB,MAChC,MAATi9C,IAAiBp8C,EAAOD,EAAKq8C,GAEnC,OAAO/xC,KAAKilC,aAAatvC,EAAMD,EAAI,IAAI,KAAM,UAAcY,GAAO,EAAG,KAMvEiwC,EAAU9nC,UAAU2F,YAAc,SAASzO,EAAMD,GAG/C,IAFA,IAAIgD,EAAQsH,KAAKzK,IAAIO,QAAQH,GAAOgD,EAAMqH,KAAKzK,IAAIO,QAAQJ,GACvDu8C,EAAUjC,EAAct3C,EAAOC,GAC1B1B,EAAI,EAAGA,EAAIg7C,EAAQ53C,OAAQpD,IAAK,CACvC,IAAIb,EAAQ67C,EAAQh7C,GAAImS,EAAOnS,GAAKg7C,EAAQ53C,OAAS,EACrD,GAAK+O,GAAiB,GAAThT,GAAesC,EAAMpC,KAAKF,GAAOtB,KAAK2b,aAAatW,SAC5D,OAAO6F,KAAK3J,OAAOqC,EAAMyC,MAAM/E,GAAQuC,EAAII,IAAI3C,IACnD,GAAIA,EAAQ,IAAMgT,GAAQ1Q,EAAMpC,KAAKF,EAAQ,GAAGwD,WAAWlB,EAAMxB,MAAMd,EAAQ,GAAIuC,EAAIR,WAAW/B,EAAQ,KACtG,OAAO4J,KAAK3J,OAAOqC,EAAM9D,OAAOwB,GAAQuC,EAAInD,MAAMY,IAExD,IAAK,IAAIia,EAAI,EAAGA,GAAK3X,EAAMtC,OAASia,GAAK1X,EAAIvC,MAAOia,IAClD,GAAI1a,EAAO+C,EAAMyC,MAAMkV,IAAM3X,EAAMtC,MAAQia,GAAK3a,EAAKgD,EAAMK,IAAIsX,IAAM1X,EAAII,IAAIsX,GAAK3a,GAAMiD,EAAIvC,MAAQia,EAChG,OAAOrQ,KAAK3J,OAAOqC,EAAM9D,OAAOyb,GAAI3a,GAE1C,OAAOsK,KAAK3J,OAAOV,EAAMD,K,8ICpoDvB2U,EAAS,GAEb,GAAwB,oBAAb9N,WAA+C,oBAAZoK,SAAyB,CACrE,IAAIurC,EAAU,cAAc14B,KAAKjd,UAAUmK,WACvCyrC,EAAY,UAAU31C,KAAKD,UAAUmK,WACrC0rC,EAAU,wCAAwC54B,KAAKjd,UAAUmK,WAEjE6kB,EAAKlhB,EAAOkhB,MAAQ4mB,GAAaC,GAAWF,GAChD7nC,EAAOgoC,WAAaF,EAAYxrC,SAAS2rC,cAAgB,EAAIF,GAAWA,EAAQ,GAAKF,GAAWA,EAAQ,GAAK,KAC7G7nC,EAAOghB,OAASE,GAAM,gBAAgB/uB,KAAKD,UAAUmK,WACrD2D,EAAOkoC,cAAgBloC,EAAOghB,SAAW,iBAAiB7R,KAAKjd,UAAUmK,YAAc,CAAC,EAAG,IAAI,GAC/F,IAAIwkB,GAAUK,GAAM,gBAAgB/R,KAAKjd,UAAUmK,WACnD2D,EAAO6gB,SAAWA,EAClB7gB,EAAOmoC,eAAiBtnB,IAAWA,EAAO,GAE1C7gB,EAAO8gB,QAAUI,GAAM,iBAAiB/uB,KAAKD,UAAU6uB,QACvD/gB,EAAOooC,IAAMpoC,EAAO8gB,SAAW,cAAc3uB,KAAKD,UAAUmK,YAAcnK,UAAUm2C,eAAiB,GACrGroC,EAAOihB,IAAMjhB,EAAOooC,KAAO,MAAMj2C,KAAKD,UAAUE,UAChD4N,EAAOsoC,QAAU,aAAan2C,KAAKD,UAAUmK,WAC7C2D,EAAOuoC,OAAS,wBAAyBjsC,SAASksC,gBAAgB11B,MAClE9S,EAAOyoC,eAAiBzoC,EAAOuoC,UAAY,uBAAuBp5B,KAAKjd,UAAUmK,YAAc,CAAC,EAAG,IAAI,GAGzG,IAAIqsC,EAAW,SAASz8C,GACtB,IAAK,IAAIY,EAAQ,GAAIA,IAEnB,KADAZ,EAAOA,EAAK+pC,iBACC,OAAOnpC,GAIpBsnC,EAAa,SAASloC,GACxB,IAAIpB,EAASoB,EAAK08C,cAAgB18C,EAAKkoC,WACvC,OAAOtpC,GAA6B,IAAnBA,EAAOqG,SAAiBrG,EAAO+9C,KAAO/9C,GAGrDg+C,EAAc,KAKdC,EAAY,SAAS78C,EAAMX,EAAMD,GACnC,IAAIlB,EAAQ0+C,IAAgBA,EAAcvsC,SAASysC,eAGnD,OAFA5+C,EAAM6+C,OAAO/8C,EAAY,MAANZ,EAAaY,EAAK6pC,UAAU9lC,OAAS3E,GACxDlB,EAAM8+C,SAASh9C,EAAMX,GAAQ,GACtBnB,GAML++C,EAAuB,SAASj9C,EAAMorB,EAAK8xB,EAAYC,GACzD,OAAOD,IAAeE,EAAQp9C,EAAMorB,EAAK8xB,EAAYC,GAAY,IAC3CC,EAAQp9C,EAAMorB,EAAK8xB,EAAYC,EAAW,KAG9DE,EAAe,gCAEnB,SAASD,EAAQp9C,EAAMorB,EAAK8xB,EAAYC,EAAWrO,GACjD,OAAS,CACP,GAAI9uC,GAAQk9C,GAAc9xB,GAAO+xB,EAAa,OAAO,EACrD,GAAI/xB,IAAQ0jB,EAAM,EAAI,EAAIlvC,EAASI,IAAQ,CACzC,IAAIpB,EAASoB,EAAKkoC,WAClB,GAAuB,GAAnBtpC,EAAOqG,UAAiBq4C,EAAat9C,IAASq9C,EAAan3C,KAAKlG,EAAKmoC,WAAqC,SAAxBnoC,EAAKu9C,gBACvF,OAAO,EACXnyB,EAAMqxB,EAASz8C,IAAS8uC,EAAM,EAAI,EAAI,GACtC9uC,EAAOpB,MACF,IAAqB,GAAjBoB,EAAKiF,SAKd,OAAO,EAHP,GAA4B,UAD5BjF,EAAOA,EAAK0rC,WAAWtgB,GAAO0jB,EAAM,GAAK,EAAI,KACpCyO,gBAA8B,OAAO,EAC9CnyB,EAAM0jB,EAAM,EAAIlvC,EAASI,GAAQ,IAOvC,SAASJ,EAASI,GAChB,OAAwB,GAAjBA,EAAKiF,SAAgBjF,EAAK6pC,UAAU9lC,OAAS/D,EAAK0rC,WAAW3nC,OActE,SAASu5C,EAAalxC,GAEpB,IADA,IAAI4kC,EACKpR,EAAMxzB,EAAKwzB,KAAiCoR,EAAOpR,EAAI4d,YAAvC5d,EAAMA,EAAIsI,YACnC,OAAO8I,GAAQA,EAAKhxC,MAAQgxC,EAAKhxC,KAAK4C,UAAYouC,EAAK5kC,KAAOA,GAAO4kC,EAAK3iB,YAAcjiB,GAK1F,IAAIqxC,EAAqB,SAASC,GAChC,IAAIC,EAAYD,EAAOE,YAGvB,OAFID,GAAa5pC,EAAO6gB,QAAU8oB,EAAOG,aAAeH,EAAOI,WAAW,GAAGH,YACzEA,GAAY,GACTA,GAGT,SAASI,EAASroB,EAAS5vB,GACzB,IAAIoO,EAAQ7D,SAAS2tC,YAAY,SAIjC,OAHA9pC,EAAM+pC,UAAU,WAAW,GAAM,GACjC/pC,EAAMwhB,QAAUA,EAChBxhB,EAAMpO,IAAMoO,EAAM/S,KAAO2E,EAClBoO,EAGT,SAASgqC,EAAWj/C,GAClB,MAAO,CAACs1B,KAAM,EAAGC,MAAOv1B,EAAIs9C,gBAAgB4B,YACpC9pB,IAAK,EAAGC,OAAQr1B,EAAIs9C,gBAAgB6B,cAG9C,SAASC,EAAQp2C,EAAOhI,GACtB,MAAuB,iBAATgI,EAAoBA,EAAQA,EAAMhI,GAGlD,SAASq+C,EAAWt+C,GAClB,IAAIu+C,EAAOv+C,EAAK8uB,wBAEZ0vB,EAAUD,EAAK9pB,MAAQz0B,EAAKy+C,aAAgB,EAC5CC,EAAUH,EAAK7pB,OAAS10B,EAAK2+C,cAAiB,EAElD,MAAO,CAACpqB,KAAMgqB,EAAKhqB,KAAMC,MAAO+pB,EAAKhqB,KAAOv0B,EAAKm+C,YAAcK,EACvDnqB,IAAKkqB,EAAKlqB,IAAKC,OAAQiqB,EAAKlqB,IAAMr0B,EAAKo+C,aAAeM,GAGhE,SAASE,EAAmBhhD,EAAM2gD,EAAMM,GAGtC,IAFA,IAAIC,EAAkBlhD,EAAKgX,SAAS,oBAAsB,EAAGmqC,EAAenhD,EAAKgX,SAAS,iBAAmB,EACzG3V,EAAMrB,EAAKwO,IAAI8+B,cACVtsC,EAASigD,GAAYjhD,EAAKwO,IAC5BxN,EADkCA,EAASspC,EAAWtpC,GAE3D,GAAuB,GAAnBA,EAAOqG,SAAX,CACA,IAAI+5C,EAAQpgD,GAAUK,EAAI4S,MAA2B,GAAnBjT,EAAOqG,SACrCg6C,EAAWD,EAAQd,EAAWj/C,GAAOq/C,EAAW1/C,GAChDsgD,EAAQ,EAAGC,EAAQ,EASvB,GARIZ,EAAKlqB,IAAM4qB,EAAS5qB,IAAMgqB,EAAQS,EAAiB,OACnDK,IAAUF,EAAS5qB,IAAMkqB,EAAKlqB,IAAMgqB,EAAQU,EAAc,QACrDR,EAAKjqB,OAAS2qB,EAAS3qB,OAAS+pB,EAAQS,EAAiB,YAC9DK,EAAQZ,EAAKjqB,OAAS2qB,EAAS3qB,OAAS+pB,EAAQU,EAAc,WAC9DR,EAAKhqB,KAAO0qB,EAAS1qB,KAAO8pB,EAAQS,EAAiB,QACrDI,IAAUD,EAAS1qB,KAAOgqB,EAAKhqB,KAAO8pB,EAAQU,EAAc,SACvDR,EAAK/pB,MAAQyqB,EAASzqB,MAAQ6pB,EAAQS,EAAiB,WAC5DI,EAAQX,EAAK/pB,MAAQyqB,EAASzqB,MAAQ6pB,EAAQU,EAAc,UAC5DG,GAASC,EACX,GAAIH,EACF//C,EAAImgD,YAAYC,SAASH,EAAOC,OAC3B,CACL,IAAIG,EAAS1gD,EAAO2gD,WAAYC,EAAS5gD,EAAO6gD,UAC5CN,IAASvgD,EAAO6gD,WAAaN,GAC7BD,IAAStgD,EAAO2gD,YAAcL,GAClC,IAAIQ,EAAK9gD,EAAO2gD,WAAaD,EAAQK,EAAK/gD,EAAO6gD,UAAYD,EAC7DjB,EAAO,CAAChqB,KAAMgqB,EAAKhqB,KAAOmrB,EAAIrrB,IAAKkqB,EAAKlqB,IAAMsrB,EAAInrB,MAAO+pB,EAAK/pB,MAAQkrB,EAAIprB,OAAQiqB,EAAKjqB,OAASqrB,GAGpG,GAAIX,EAAS,OAyBjB,SAASY,EAAYxzC,GAEnB,IADA,IAAIyzC,EAAQ,GAAI5gD,EAAMmN,EAAI8+B,cACnB9+B,IACLyzC,EAAMv7C,KAAK,CAAC8H,IAAKA,EAAKioB,IAAKjoB,EAAIqzC,UAAWlrB,KAAMnoB,EAAImzC,aAChDnzC,GAAOnN,GAFDmN,EAAM87B,EAAW97B,IAI7B,OAAOyzC,EAcT,SAASC,EAAmBD,EAAOE,GACjC,IAAK,IAAIp/C,EAAI,EAAGA,EAAIk/C,EAAM97C,OAAQpD,IAAK,CACrC,IAAIH,EAAMq/C,EAAMl/C,GACZyL,EAAM5L,EAAI4L,IACVioB,EAAM7zB,EAAI6zB,IACVE,EAAO/zB,EAAI+zB,KACXnoB,EAAIqzC,WAAaprB,EAAM0rB,IAAQ3zC,EAAIqzC,UAAYprB,EAAM0rB,GACrD3zC,EAAImzC,YAAchrB,IAAQnoB,EAAImzC,WAAahrB,IAInD,IAAIyrB,EAAyB,KAoB7B,SAASC,EAAiBjgD,EAAMkgD,GAG9B,IAFA,IAAIxxB,EAA0ByxB,EAAjBC,EAAY,IAAoBhxC,EAAS,EAClDixC,EAASH,EAAO7rB,IAAKisB,EAASJ,EAAO7rB,IAChCltB,EAAQnH,EAAKG,WAAYogD,EAAa,EAAGp5C,EAAOA,EAAQA,EAAMmjC,YAAaiW,IAAc,CAChG,IAAIC,OAAQ,EACZ,GAAsB,GAAlBr5C,EAAMlC,SAAiBu7C,EAAQr5C,EAAMs5C,qBACpC,IAAsB,GAAlBt5C,EAAMlC,SACR,SADyBu7C,EAAQ3D,EAAU11C,GAAOs5C,iBAGzD,IAAK,IAAI9/C,EAAI,EAAGA,EAAI6/C,EAAMz8C,OAAQpD,IAAK,CACrC,IAAI49C,EAAOiC,EAAM7/C,GACjB,GAAI49C,EAAKlqB,KAAOgsB,GAAU9B,EAAKjqB,QAAUgsB,EAAQ,CAC/CD,EAASt1C,KAAKC,IAAIuzC,EAAKjqB,OAAQ+rB,GAC/BC,EAASv1C,KAAKc,IAAI0yC,EAAKlqB,IAAKisB,GAC5B,IAAII,EAAKnC,EAAKhqB,KAAO2rB,EAAO3rB,KAAOgqB,EAAKhqB,KAAO2rB,EAAO3rB,KAChDgqB,EAAK/pB,MAAQ0rB,EAAO3rB,KAAO2rB,EAAO3rB,KAAOgqB,EAAK/pB,MAAQ,EAC5D,GAAIksB,EAAKN,EAAW,CAClB1xB,EAAUvnB,EACVi5C,EAAYM,EACZP,EAAgBO,GAA0B,GAApBhyB,EAAQzpB,SAAgB,CAACsvB,KAAMgqB,EAAK/pB,MAAQ0rB,EAAO3rB,KAAOgqB,EAAK/pB,MAAQ+pB,EAAKhqB,KAAMF,IAAK6rB,EAAO7rB,KAAO6rB,EACrG,GAAlB/4C,EAAMlC,UAAiBy7C,IACvBtxC,EAASmxC,GAAcL,EAAO3rB,OAASgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,EAAI,IAC7E,WAGC9F,IAAYwxB,EAAO3rB,MAAQgqB,EAAK/pB,OAAS0rB,EAAO7rB,KAAOkqB,EAAKlqB,KAChD6rB,EAAO3rB,MAAQgqB,EAAKhqB,MAAQ2rB,EAAO7rB,KAAOkqB,EAAKjqB,UAC5DllB,EAASmxC,EAAa,IAG9B,OAAI7xB,GAA+B,GAApBA,EAAQzpB,SAKzB,SAA0BjF,EAAMkgD,GAG9B,IAFA,IAAI16C,EAAMxF,EAAK6pC,UAAU9lC,OACrB7F,EAAQmS,SAASysC,cACZn8C,EAAI,EAAGA,EAAI6E,EAAK7E,IAAK,CAC5BzC,EAAM6+C,OAAO/8C,EAAMW,EAAI,GACvBzC,EAAM8+C,SAASh9C,EAAMW,GACrB,IAAI49C,EAAOoC,EAAWziD,EAAO,GAC7B,GAAIqgD,EAAKlqB,KAAOkqB,EAAKjqB,QACjBssB,EAAOV,EAAQ3B,GACf,MAAO,CAACv+C,KAAMA,EAAMoP,OAAQzO,GAAKu/C,EAAO3rB,OAASgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,EAAI,IAEzF,MAAO,CAACx0B,KAAMA,EAAMoP,OAAQ,GAhBmByxC,CAAiBnyB,EAASyxB,IACpEzxB,GAAY0xB,GAAiC,GAApB1xB,EAAQzpB,SAAyB,CAACjF,KAAMA,EAAMoP,OAAQA,GAC7E6wC,EAAiBvxB,EAASyxB,GAiBnC,SAASS,EAAOV,EAAQ3B,GACtB,OAAO2B,EAAO3rB,MAAQgqB,EAAKhqB,KAAO,GAAK2rB,EAAO3rB,MAAQgqB,EAAK/pB,MAAQ,GACjE0rB,EAAO7rB,KAAOkqB,EAAKlqB,IAAM,GAAK6rB,EAAO7rB,KAAOkqB,EAAKjqB,OAAS,EA6C9D,SAASwsB,EAAiBv1B,EAAS20B,EAAQa,GACzC,IAAIv7C,EAAM+lB,EAAQmgB,WAAW3nC,OAC7B,GAAIyB,GAAOu7C,EAAI1sB,IAAM0sB,EAAIzsB,OACvB,IAAK,IAAI0sB,EAASj2C,KAAKC,IAAI,EAAGD,KAAKc,IAAIrG,EAAM,EAAGuF,KAAKk2C,MAAMz7C,GAAO06C,EAAO7rB,IAAM0sB,EAAI1sB,MAAQ0sB,EAAIzsB,OAASysB,EAAI1sB,MAAQ,IAAK1zB,EAAIqgD,IAAU,CACrI,IAAI75C,EAAQokB,EAAQmgB,WAAW/qC,GAC/B,GAAsB,GAAlBwG,EAAMlC,SAER,IADA,IAAIu7C,EAAQr5C,EAAMs5C,iBACTrjC,EAAI,EAAGA,EAAIojC,EAAMz8C,OAAQqZ,IAAK,CACrC,IAAImhC,EAAOiC,EAAMpjC,GACjB,GAAIwjC,EAAOV,EAAQ3B,GAAS,OAAOuC,EAAiB35C,EAAO+4C,EAAQ3B,GAGvE,IAAK59C,GAAKA,EAAI,GAAK6E,IAAQw7C,EAAU,MAGzC,OAAOz1B,EAIT,SAAS21B,EAAYtjD,EAAMsiD,GACzB,IAAIp3C,EAAQq4C,EAEsBnhD,EAAMoP,EAApCnQ,EAAMrB,EAAKwO,IAAI8+B,cACnB,GAAIjsC,EAAImiD,uBACN,IACE,IAAIC,EAAQpiD,EAAImiD,uBAAuBlB,EAAO3rB,KAAM2rB,EAAO7rB,KACvDgtB,IAA2BrhD,GAAhB8I,EAASu4C,GAAqBC,WAAYlyC,EAAStG,EAAOsG,QACzE,MAAOgkB,IAEX,IAAKpzB,GAAQf,EAAIsiD,oBAAqB,CACpC,IAAIrjD,EAAQe,EAAIsiD,oBAAoBrB,EAAO3rB,KAAM2rB,EAAO7rB,KACpDn2B,IAA6B8B,GAAlBmhD,EAAWjjD,GAAuBsjD,eAAgBpyC,EAAS+xC,EAASptB,aAGrF,IAAwGp0B,EAApG8hD,GAAO7jD,EAAK8jD,KAAKZ,iBAAmBljD,EAAK8jD,KAAOziD,GAAK6hD,iBAAiBZ,EAAO3rB,KAAM2rB,EAAO7rB,IAAM,GACpG,IAAKotB,IAAQ7jD,EAAKwO,IAAIyY,SAAyB,GAAhB48B,EAAIx8C,SAAgBw8C,EAAIvZ,WAAauZ,GAAM,CACxE,IAAIV,EAAMnjD,EAAKwO,IAAI0iB,wBACnB,IAAK8xB,EAAOV,EAAQa,GAAQ,OAAO,KAEnC,KADAU,EAAMX,EAAiBljD,EAAKwO,IAAK8zC,EAAQa,IAC7B,OAAO,KAGrB,GAAIhtC,EAAO8gB,OACT,IAAK,IAAIwD,EAAIopB,EAAKzhD,GAAQq4B,EAAGA,EAAI6P,EAAW7P,GACpCA,EAAEzQ,YAAa5nB,EAAOoP,EAAS,MAGzC,GADAqyC,EAxFF,SAAsBr1C,EAAK8zC,GACzB,IAAIthD,EAASwN,EAAI87B,WACjB,OAAItpC,GAAU,QAAQsH,KAAKtH,EAAOupC,WAAa+X,EAAO3rB,KAAOnoB,EAAI0iB,wBAAwByF,KAC9E31B,EACJwN,EAoFDu1C,CAAaF,EAAKvB,GACpBlgD,EAAM,CACR,GAAI+T,EAAOghB,OAA0B,GAAjB/0B,EAAKiF,WAGvBmK,EAASrE,KAAKc,IAAIuD,EAAQpP,EAAK0rC,WAAW3nC,SAG7B/D,EAAK0rC,WAAW3nC,OAAQ,CACnC,IAAoC69C,EAAhCrlB,EAAOv8B,EAAK0rC,WAAWt8B,GACN,OAAjBmtB,EAAK4L,WAAsByZ,EAAQrlB,EAAKzN,yBAAyB0F,OAAS0rB,EAAO3rB,MACjFqtB,EAAMttB,OAAS4rB,EAAO7rB,KACtBjlB,IAKJpP,GAAQpC,EAAKwO,KAAOgD,GAAUpP,EAAK0rC,WAAW3nC,OAAS,GAAgC,GAA3B/D,EAAKI,UAAU6E,UAC3Ei7C,EAAO7rB,IAAMr0B,EAAKI,UAAU0uB,wBAAwBwF,OACpD30B,EAAM/B,EAAKP,MAAM4B,IAAIJ,QAAQC,KAId,GAAVsQ,GAAgC,GAAjBpP,EAAKiF,UAAyD,MAAxCjF,EAAK0rC,WAAWt8B,EAAS,GAAG+4B,WACtExoC,EA7FR,SAAsB/B,EAAMoC,EAAMoP,EAAQ8wC,GAQxC,IADA,IAAI2B,GAAW,EACNjiB,EAAM5/B,EACT4/B,GAAOhiC,EAAKwO,KADK,CAErB,IAAI4kC,EAAOpzC,EAAKgwB,QAAQk0B,YAAYliB,GAAK,GACzC,IAAKoR,EAAQ,OAAO,KACpB,GAAIA,EAAKhxC,KAAK4C,SAAWouC,EAAKpyC,OAAQ,CACpC,IAAI2/C,EAAOvN,EAAK5kC,IAAI0iB,wBACpB,GAAIyvB,EAAKhqB,KAAO2rB,EAAO3rB,MAAQgqB,EAAKlqB,IAAM6rB,EAAO7rB,IAAOwtB,EAAU7Q,EAAK+Q,cAClE,MAAIxD,EAAK/pB,MAAQ0rB,EAAO3rB,MAAQgqB,EAAKjqB,OAAS4rB,EAAO7rB,KACnD,MAD0DwtB,EAAU7Q,EAAKgR,UAGlFpiB,EAAMoR,EAAK5kC,IAAI87B,WAEjB,OAAO2Z,GAAW,EAAIA,EAAUjkD,EAAKgwB,QAAQq0B,WAAWjiD,EAAMoP,GAyElD8yC,CAAatkD,EAAMoC,EAAMoP,EAAQ8wC,IAElC,MAAPvgD,IAAeA,EA3GrB,SAAwB/B,EAAM6jD,EAAKvB,GACjC,IAAI1/C,EAAMy/C,EAAiBwB,EAAKvB,GAC5BlgD,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACbyD,GAAQ,EACZ,GAAqB,GAAjB7S,EAAKiF,WAAkBjF,EAAKG,WAAY,CAC1C,IAAIo+C,EAAOv+C,EAAK8uB,wBAChBjc,EAAO0rC,EAAKhqB,MAAQgqB,EAAK/pB,OAAS0rB,EAAO3rB,MAAQgqB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAI,GAAK,EAEtF,OAAO52B,EAAKgwB,QAAQq0B,WAAWjiD,EAAMoP,EAAQyD,GAkGpBsvC,CAAevkD,EAAM6jD,EAAKvB,IAEnD,IAAIlP,EAAOpzC,EAAKgwB,QAAQk0B,YAAYL,GAAK,GACzC,MAAO,CAAC9hD,IAAKA,EAAKs2C,OAAQjF,EAAOA,EAAKoR,WAAapR,EAAKqR,QAAU,GAGpE,SAAS1B,EAAW1Z,EAAQp0B,GAC1B,IAAI2tC,EAAQvZ,EAAOwZ,iBACnB,OAAQD,EAAMz8C,OAA0Cy8C,EAAM3tC,EAAO,EAAI,EAAI2tC,EAAMz8C,OAAS,GAArEkjC,EAAOnY,wBAGhC,IAAIwzB,EAAO,4CAKX,SAASluB,EAAYx2B,EAAM+B,EAAKM,GAC9B,IAAIO,EAAM5C,EAAKgwB,QAAQ20B,WAAW5iD,EAAKM,EAAO,GAAK,EAAI,GACnDD,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OAEbozC,EAAoBzuC,EAAOuoC,QAAUvoC,EAAOghB,MAChD,GAAqB,GAAjB/0B,EAAKiF,SAAe,CAGtB,IAAIu9C,IAAsBF,EAAKp8C,KAAKlG,EAAK6pC,aAAe5pC,EAAO,EAAKmP,EAASA,GAAUpP,EAAK6pC,UAAU9lC,QAc/F,CACL,IAAI1E,EAAO+P,EAAQhQ,EAAKgQ,EAAQqzC,EAAWxiD,EAAO,EAAI,GAAK,EAK3D,OAJIA,EAAO,IAAMmP,GAAUhQ,IAAMqjD,GAAY,GACpCxiD,GAAQ,GAAKmP,GAAUpP,EAAK6pC,UAAU9lC,QAAU1E,IAAQojD,EAAW,GACnExiD,EAAO,EAAKZ,IACdD,IACAsjD,EAAS/B,EAAW9D,EAAU78C,EAAMX,EAAMD,GAAKqjD,GAAWA,EAAW,GAnB5E,IAAIlE,EAAOoC,EAAW9D,EAAU78C,EAAMoP,EAAQA,GAASnP,GAIvD,GAAI8T,EAAOghB,OAAS3lB,GAAU,KAAKlJ,KAAKlG,EAAK6pC,UAAUz6B,EAAS,KAAOA,EAASpP,EAAK6pC,UAAU9lC,OAAQ,CACrG,IAAI4+C,EAAahC,EAAW9D,EAAU78C,EAAMoP,EAAS,EAAGA,EAAS,IAAK,GACtE,GAAIuzC,EAAWtuB,KAAOkqB,EAAKlqB,IAAK,CAC9B,IAAIuuB,EAAYjC,EAAW9D,EAAU78C,EAAMoP,EAAQA,EAAS,IAAK,GACjE,GAAIwzC,EAAUvuB,KAAOkqB,EAAKlqB,IACtB,OAAOquB,EAASE,EAAWA,EAAUruB,KAAOouB,EAAWpuB,OAG/D,OAAOgqB,EAYX,IAAK3gD,EAAKP,MAAM4B,IAAIO,QAAQG,GAAKf,OAAO0D,cAAe,CACrD,GAAI8M,IAAWnP,EAAO,GAAKmP,GAAUxP,EAASI,IAAQ,CACpD,IAAI1B,EAAS0B,EAAK0rC,WAAWt8B,EAAS,GACtC,GAAuB,GAAnB9Q,EAAO2G,SAAiB,OAAO49C,EAASvkD,EAAOwwB,yBAAyB,GAE9E,GAAI1f,EAASxP,EAASI,GAAO,CAC3B,IAAId,EAAQc,EAAK0rC,WAAWt8B,GAC5B,GAAsB,GAAlBlQ,EAAM+F,SAAiB,OAAO49C,EAAS3jD,EAAM4vB,yBAAyB,GAE5E,OAAO+zB,EAAS7iD,EAAK8uB,wBAAyB7uB,GAAQ,GAIxD,GAAImP,IAAWnP,EAAO,GAAKmP,GAAUxP,EAASI,IAAQ,CACpD,IAAI8iD,EAAW9iD,EAAK0rC,WAAWt8B,EAAS,GACpChR,EAA8B,GAArB0kD,EAAS79C,SAAgB43C,EAAUiG,EAAUljD,EAASkjD,IAAaN,EAAoB,EAAI,IAG7E,GAArBM,EAAS79C,UAAuC,MAArB69C,EAAS3a,UAAqB2a,EAASxY,YAA0B,KAAXwY,EACvF,GAAI1kD,EAAU,OAAOskD,EAAS/B,EAAWviD,EAAQ,IAAI,GAEvD,GAAIgR,EAASxP,EAASI,GAAO,CAE3B,IADA,IAAI+iD,EAAU/iD,EAAK0rC,WAAWt8B,GACvB2zC,EAAQvF,YAAcuF,EAAQvF,WAAWwF,iBAAmBD,EAAUA,EAAQzY,YACrF,IAAI2Y,EAAYF,EAAqC,GAApBA,EAAQ99C,SAAgB43C,EAAUkG,EAAS,EAAIP,EAAoB,EAAI,GAC9E,GAApBO,EAAQ99C,SAAgB89C,EAAU,KADd,KAE1B,GAAIE,EAAY,OAAOP,EAAS/B,EAAWsC,GAAW,IAAI,GAG5D,OAAOP,EAAS/B,EAA4B,GAAjB3gD,EAAKiF,SAAgB43C,EAAU78C,GAAQA,GAAOC,GAAOA,GAAQ,GAG1F,SAASyiD,EAASnE,EAAMhqB,GACtB,GAAkB,GAAdgqB,EAAK9pB,MAAc,OAAO8pB,EAC9B,IAAI5vB,EAAI4F,EAAOgqB,EAAKhqB,KAAOgqB,EAAK/pB,MAChC,MAAO,CAACH,IAAKkqB,EAAKlqB,IAAKC,OAAQiqB,EAAKjqB,OAAQC,KAAM5F,EAAG6F,MAAO7F,GAG9D,SAASk0B,EAAStE,EAAMlqB,GACtB,GAAmB,GAAfkqB,EAAK7pB,OAAe,OAAO6pB,EAC/B,IAAI3vB,EAAIyF,EAAMkqB,EAAKlqB,IAAMkqB,EAAKjqB,OAC9B,MAAO,CAACD,IAAKzF,EAAG0F,OAAQ1F,EAAG2F,KAAMgqB,EAAKhqB,KAAMC,MAAO+pB,EAAK/pB,OAG1D,SAAS0uB,EAAiBtlD,EAAMP,EAAOwX,GACrC,IAAIsuC,EAAYvlD,EAAKP,MAAOqjC,EAAS9iC,EAAK8jD,KAAK0B,cAC3CD,GAAa9lD,GAASO,EAAK+uB,YAAYtvB,GACvCqjC,GAAU9iC,EAAKwO,KAAOxO,EAAKkT,QAC/B,IACE,OAAO+D,IACP,QACIsuC,GAAa9lD,GAASO,EAAK+uB,YAAYw2B,GACvCziB,GAAU9iC,EAAKwO,KAAOs0B,GAAUA,EAAO5vB,SAqC/C,IAAIuyC,EAAW,kBAiCf,IAAIC,EAAc,KAAMC,EAAY,KAAMC,GAAe,EACzD,SAAS1lD,EAAeF,EAAMP,EAAOyxC,GACnC,OAAIwU,GAAejmD,GAASkmD,GAAazU,EAAc0U,GACvDF,EAAcjmD,EAAOkmD,EAAYzU,EAC1B0U,EAAsB,MAAP1U,GAAsB,QAAPA,EAnEvC,SAAgClxC,EAAMP,EAAOyxC,GAC3C,IAAI3sC,EAAM9E,EAAME,UACZmD,EAAc,MAAPouC,EAAc3sC,EAAIC,MAAQD,EAAIE,IACzC,OAAO6gD,EAAiBtlD,EAAMP,GAAO,WAGnC,IAFA,IACI+O,EADMxO,EAAKgwB,QAAQ20B,WAAW7hD,EAAKf,IAAY,MAAPmvC,GAAe,EAAI,GACjD9uC,OACL,CACP,IAAIyjD,EAAU7lD,EAAKgwB,QAAQk0B,YAAY11C,GAAK,GAC5C,IAAKq3C,EAAW,MAChB,GAAIA,EAAQzjD,KAAK4C,QAAS,CAAEwJ,EAAMq3C,EAAQr3C,IAAK,MAC/CA,EAAMq3C,EAAQr3C,IAAI87B,WAGpB,IADA,IAAIgY,EAAS9rB,EAAYx2B,EAAM8C,EAAKf,IAAK,GAChCwH,EAAQiF,EAAIjM,WAAYgH,EAAOA,EAAQA,EAAMmjC,YAAa,CACjE,IAAIoZ,OAAQ,EACZ,GAAsB,GAAlBv8C,EAAMlC,SAAiBy+C,EAAQv8C,EAAMs5C,qBACpC,IAAsB,GAAlBt5C,EAAMlC,SACR,SADyBy+C,EAAQ7G,EAAU11C,EAAO,EAAGA,EAAM0iC,UAAU9lC,QAAQ08C,iBAEpF,IAAK,IAAI9/C,EAAI,EAAGA,EAAI+iD,EAAM3/C,OAAQpD,IAAK,CACrC,IAAIogD,EAAM2C,EAAM/iD,GAChB,GAAIogD,EAAIzsB,OAASysB,EAAI1sB,IAAM,IACf,MAAPya,EAAcoR,EAAO7rB,IAAM0sB,EAAI1sB,IAAkC,GAA3B0sB,EAAIzsB,OAAS4rB,EAAO7rB,KACxD0sB,EAAIzsB,OAAS4rB,EAAO5rB,OAAqC,GAA3B4rB,EAAO5rB,OAASysB,EAAI1sB,MACrD,OAAO,GAGf,OAAO,KA0CLsvB,CAAuB/lD,EAAMP,EAAOyxC,GApC1C,SAAkClxC,EAAMP,EAAOyxC,GAC7C,IACIruC,EADMpD,EAAME,UACAkD,MAChB,IAAKA,EAAM7B,OAAOyB,YAAe,OAAO,EACxC,IAAI+O,EAAS3O,EAAM1C,aAAc6J,GAAWwH,EAAQvM,EAAQuM,GAAU3O,EAAM7B,OAAOC,QAAQC,KACvFqD,EAAMvE,EAAK8jD,KAAKp1C,eAGpB,OAAK+2C,EAASn9C,KAAKzF,EAAM7B,OAAOqhB,cAAiB9d,EAAIyhD,OAG9CV,EAAiBtlD,EAAMP,GAAO,WAMnC,IAAIi2B,EAAWnxB,EAAI27C,WAAW,GAAI+F,EAAU1hD,EAAI2hD,UAAWC,EAAS5hD,EAAI6hD,YACpEC,EAAe9hD,EAAI+hD,eACvB/hD,EAAIyhD,OAAO,OAAQ9U,EAAK,aACxB,IACI/6B,IADYtT,EAAMX,MAAQlC,EAAKgwB,QAAQu2B,YAAY1jD,EAAMnC,UAAYV,EAAKwO,KACtDyY,SAAmC,GAA1B1iB,EAAI2hD,UAAU7+C,SAAgB9C,EAAI2hD,UAAY3hD,EAAI2hD,UAAU5b,aACxF2b,GAAW1hD,EAAI2hD,WAAaC,GAAU5hD,EAAI6hD,YAK/C,OAHA7hD,EAAIoK,kBACJpK,EAAIm5B,SAAShI,GACO,MAAhB2wB,IAAwB9hD,EAAI+hD,eAAiBD,GAC1ClwC,KAlBS,QAAP+6B,GAAwB,YAAPA,EAAoBlnC,EAAU/E,EA4BtDuhD,CAAyBxmD,EAAMP,EAAOyxC,IAwF5C,IAIIuV,EAAW,SAAkBzlD,EAAQ0lD,EAAUl4C,EAAKiiB,GACtD3kB,KAAK9K,OAASA,EACd8K,KAAK46C,SAAWA,EAChB56C,KAAK0C,IAAMA,EAGXA,EAAIoxC,WAAa9zC,KAGjBA,KAAK2kB,WAAaA,EAClB3kB,KAAK66C,MAdS,GAiBZ9sB,EAAqB,CAAE34B,KAAM,CAAE44B,cAAc,GAAO2qB,OAAQ,CAAE3qB,cAAc,GAAOqqB,UAAW,CAAErqB,cAAc,GAAO0qB,WAAY,CAAE1qB,cAAc,GAAOsqB,SAAU,CAAEtqB,cAAc,GAAO8sB,SAAU,CAAE9sB,cAAc,GAAO+sB,YAAa,CAAE/sB,cAAc,GAAOgtB,QAAS,CAAEhtB,cAAc,GAAOsrB,gBAAiB,CAAEtrB,cAAc,IAInU2sB,EAASl8C,UAAUw8C,cAAgB,WAA4B,OAAO,GACtEN,EAASl8C,UAAUy8C,YAAc,WAA0B,OAAO,GAClEP,EAASl8C,UAAU08C,YAAc,WAA0B,OAAO,GAClER,EAASl8C,UAAU28C,YAAc,SAAsBC,GAAa,OAAO,GAM3EV,EAASl8C,UAAUye,UAAY,WAAwB,OAAO,MAK9Dy9B,EAASl8C,UAAU+lB,UAAY,WAAwB,OAAO,GAG9DuJ,EAAmB34B,KAAKo3B,IAAM,WAE5B,IADA,IAAIp3B,EAAO,EACF6B,EAAI,EAAGA,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAO7B,GAAQ4K,KAAK46C,SAAS3jD,GAAG7B,KAC1E,OAAOA,GAKT24B,EAAmB4qB,OAAOnsB,IAAM,WAAc,OAAO,GAErDmuB,EAASl8C,UAAU4c,QAAU,WAC3Brb,KAAK9K,OAAS,KACV8K,KAAK0C,IAAIoxC,YAAc9zC,OAAQA,KAAK0C,IAAIoxC,WAAa,MACzD,IAAK,IAAI78C,EAAI,EAAGA,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IACtC+I,KAAK46C,SAAS3jD,GAAGokB,WAGvBs/B,EAASl8C,UAAU68C,eAAiB,SAAyB79C,GAC3D,IAAK,IAAIxG,EAAI,EAAGhB,EAAM+J,KAAK04C,WAAYzhD,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAK,CACpE,IAAIi/B,EAAMl2B,KAAK46C,SAAS3jD,GACxB,GAAIi/B,GAAOz4B,EAAS,OAAOxH,EAC3BA,GAAOigC,EAAI9gC,OAIf24B,EAAmBsqB,UAAU7rB,IAAM,WACjC,OAAOxsB,KAAK9K,OAAOomD,eAAet7C,OAGpC+tB,EAAmB2qB,WAAWlsB,IAAM,WAClC,OAAOxsB,KAAK9K,OAAS8K,KAAK9K,OAAOomD,eAAet7C,MAAQA,KAAK24C,OAAS,GAGxE5qB,EAAmBuqB,SAAS9rB,IAAM,WAChC,OAAOxsB,KAAKq4C,UAAYr4C,KAAK5K,MAG/B24B,EAAmB+sB,SAAStuB,IAAM,WAChC,OAAOxsB,KAAK04C,WAAa14C,KAAK5K,KAAO,EAAI4K,KAAK24C,QAIhDgC,EAASl8C,UAAU88C,gBAAkB,SAA0B74C,EAAKgD,EAAQyD,GAG1E,GAAInJ,KAAK2kB,YAAc3kB,KAAK2kB,WAAWxJ,SAAyB,GAAhBzY,EAAInH,SAAgBmH,EAAMA,EAAI87B,YAAa,CACzF,GAAIr1B,EAAO,EAAG,CACZ,IAAIqyC,EAAWlU,EACf,GAAI5kC,GAAO1C,KAAK2kB,WACd62B,EAAY94C,EAAIs/B,WAAWt8B,EAAS,OAC/B,CACL,KAAOhD,EAAI87B,YAAcx+B,KAAK2kB,YAAcjiB,EAAMA,EAAI87B,WACtDgd,EAAY94C,EAAI29B,gBAElB,KAAOmb,MAAgBlU,EAAOkU,EAAU1H,aAAexM,EAAKpyC,QAAU8K,OAASw7C,EAAYA,EAAUnb,gBACrG,OAAOmb,EAAYx7C,KAAKs7C,eAAehU,GAAQA,EAAKlyC,KAAO4K,KAAK04C,WAEhE,IAAI+C,EAAUC,EACd,GAAIh5C,GAAO1C,KAAK2kB,WACd82B,EAAW/4C,EAAIs/B,WAAWt8B,OACrB,CACL,KAAOhD,EAAI87B,YAAcx+B,KAAK2kB,YAAcjiB,EAAMA,EAAI87B,WACtDid,EAAW/4C,EAAIk+B,YAEjB,KAAO6a,MAAeC,EAASD,EAAS3H,aAAe4H,EAAOxmD,QAAU8K,OAASy7C,EAAWA,EAAS7a,YACrG,OAAO6a,EAAWz7C,KAAKs7C,eAAeI,GAAU17C,KAAK86C,SAMzD,IAAI3hD,EACJ,GAAIuJ,GAAO1C,KAAK0C,KAAO1C,KAAK2kB,WAC1BxrB,EAAQuM,EAASqtC,EAAS/yC,KAAK2kB,iBAC1B,GAAI3kB,KAAK2kB,YAAc3kB,KAAK2kB,YAAc3kB,KAAK0C,KAAO1C,KAAK0C,IAAIyY,SAASnb,KAAK2kB,YAClFxrB,EAAuD,EAA/CuJ,EAAIggC,wBAAwB1iC,KAAK2kB,iBACpC,GAAI3kB,KAAK0C,IAAIjM,WAAY,CAC9B,GAAc,GAAViP,EAAe,IAAK,IAAIgiB,EAAShlB,GAAMglB,EAASA,EAAO8W,WAAY,CACrE,GAAI9W,GAAU1nB,KAAK0C,IAAK,CAAEvJ,GAAQ,EAAO,MACzC,GAAIuuB,EAAO8W,WAAW/nC,YAAcixB,EAAU,MAEhD,GAAa,MAATvuB,GAAiBuM,GAAUhD,EAAIs/B,WAAW3nC,OAAU,IAAK,IAAIshD,EAAWj5C,GAAMi5C,EAAWA,EAASnd,WAAY,CAChH,GAAImd,GAAY37C,KAAK0C,IAAK,CAAEvJ,GAAQ,EAAM,MAC1C,GAAIwiD,EAASnd,WAAW9nC,WAAailD,EAAY,OAGrD,OAAiB,MAATxiD,EAAgBgQ,EAAO,EAAIhQ,GAAS6G,KAAK86C,SAAW96C,KAAK04C,YAKnEiC,EAASl8C,UAAU25C,YAAc,SAAsB11C,EAAKk5C,GAC1D,IAAK,IAAIriD,GAAQ,EAAM28B,EAAMxzB,EAAKwzB,EAAKA,EAAMA,EAAIsI,WAAY,CAC3D,IAAI8I,EAAOtnC,KAAK67C,QAAQ3lB,GACxB,GAAIoR,KAAUsU,GAAatU,EAAKhxC,MAAO,CAErC,IAAIiD,IAAS+tC,EAAKwU,UACa,GAAzBxU,EAAKwU,QAAQvgD,SAAgB+rC,EAAKwU,QAAQ3gC,SAAyB,GAAhBzY,EAAInH,SAAgBmH,EAAMA,EAAI87B,YAAc8I,EAAKwU,SAAWp5C,GAGjH,OAAO4kC,EAFP/tC,GAAQ,KAOlBohD,EAASl8C,UAAUo9C,QAAU,SAAkBn5C,GAE7C,IADA,IAAI4kC,EAAO5kC,EAAIoxC,WACN5d,EAAMoR,EAAMpR,EAAKA,EAAMA,EAAIhhC,OAAU,GAAIghC,GAAOl2B,KAAQ,OAAOsnC,GAG1EqT,EAASl8C,UAAU85C,WAAa,SAAqB71C,EAAKgD,EAAQyD,GAChE,IAAK,IAAI+tB,EAAOx0B,EAAKw0B,EAAMA,EAAOA,EAAKsH,WAAY,CACjD,IAAI8I,EAAOtnC,KAAK67C,QAAQ3kB,GACxB,GAAIoQ,EAAQ,OAAOA,EAAKiU,gBAAgB74C,EAAKgD,EAAQyD,GAEvD,OAAQ,GAMVwxC,EAASl8C,UAAUs9C,OAAS,SAAiB9lD,GAC3C,IAAK,IAAIgB,EAAI,EAAGyO,EAAS,EAAGzO,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK46C,SAAS3jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIsQ,GAAUzP,GAAO8C,GAAO2M,EAAQ,CAClC,MAAQjI,EAAMk7C,QAAUl7C,EAAMm9C,SAASvgD,QAAUoD,EAAQA,EAAMm9C,SAAS,GACxE,OAAOn9C,EAET,GAAIxH,EAAM8C,EAAO,OAAO0E,EAAMs+C,OAAO9lD,EAAMyP,EAASjI,EAAMk7C,QAC1DjzC,EAAS3M,IAKb4hD,EAASl8C,UAAUo6C,WAAa,SAAqB5iD,EAAKM,GACxD,IAAKyJ,KAAK2kB,WAAc,MAAO,CAACruB,KAAM0J,KAAK0C,IAAKgD,OAAQ,GAGxD,IADA,IAAIzO,EAAI,EAAGyO,EAAS,EACXspB,EAAS,EAAG/3B,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAK,CAClD,IAAIwG,EAAQuC,KAAK46C,SAAS3jD,GAAI8B,EAAMi2B,EAASvxB,EAAMrI,KACnD,GAAI2D,EAAM9C,GAAOwH,aAAiBu+C,GAAsB,CAAEt2C,EAASzP,EAAM+4B,EAAQ,MACjFA,EAASj2B,EAGX,GAAI2M,EAAU,OAAO1F,KAAK46C,SAAS3jD,GAAG4hD,WAAWnzC,EAAS1F,KAAK46C,SAAS3jD,GAAG0hD,OAAQpiD,GAEnF,IAAK,IAAIwjB,OAAO,EAAU9iB,KAAO8iB,EAAO/Z,KAAK46C,SAAS3jD,EAAI,IAAI7B,MAAQ2kB,aAAgBkiC,GAAkBliC,EAAKmiC,OAAOpnD,KAAKyB,MAAQ,EAAGU,KAEpI,GAAIV,GAAQ,EAAG,CAEb,IADA,IAAI4lD,EAAQ53C,GAAQ,GAElB43C,EAASllD,EAAI+I,KAAK46C,SAAS3jD,EAAI,GAAK,OACrBklD,EAAOz5C,IAAI87B,YAAcx+B,KAAK2kB,WAFvC1tB,IAAKsN,GAAQ,GAIrB,OAAI43C,GAAU5lD,GAAQgO,IAAU43C,EAAOxD,SAAWwD,EAAOnB,QAAkBmB,EAAOtD,WAAWsD,EAAO/mD,KAAMmB,GACnG,CAACD,KAAM0J,KAAK2kB,WAAYjf,OAAQy2C,EAASpJ,EAASoJ,EAAOz5C,KAAO,EAAI,GAG3E,IADA,IAAImwB,EAAMvuB,GAAU,GAElBuuB,EAAO57B,EAAI+I,KAAK46C,SAASvgD,OAAS2F,KAAK46C,SAAS3jD,GAAK,OACxC47B,EAAKnwB,IAAI87B,YAAcx+B,KAAK2kB,WAFnC1tB,IAAKqN,GAAU,GAIvB,OAAIuuB,GAAQvuB,IAAYuuB,EAAK8lB,SAAW9lB,EAAKmoB,QAAkBnoB,EAAKgmB,WAAW,EAAGtiD,GAC3E,CAACD,KAAM0J,KAAK2kB,WAAYjf,OAAQmtB,EAAOkgB,EAASlgB,EAAKnwB,KAAO1C,KAAK2kB,WAAWqd,WAAW3nC,SAMlGsgD,EAASl8C,UAAU29C,WAAa,SAAqBzmD,EAAMD,EAAIu1B,GAG7D,QAFgB,IAATA,IAAkBA,EAAO,GAEJ,GAAxBjrB,KAAK46C,SAASvgD,OACd,MAAO,CAAC/D,KAAM0J,KAAK2kB,WAAYhvB,KAAMA,EAAMD,GAAIA,EAAI2mD,WAAY,EAAGC,SAAUt8C,KAAK2kB,WAAWqd,WAAW3nC,QAG3G,IADA,IAAIgiD,GAAc,EAAGC,GAAY,EACxB52C,EAASulB,EAAMh0B,EAAI,GAAIA,IAAK,CACnC,IAAIwG,EAAQuC,KAAK46C,SAAS3jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,IAAmB,GAAfinD,GAAoB1mD,GAAQoD,EAAK,CACnC,IAAIwjD,EAAY72C,EAASjI,EAAMk7C,OAE/B,GAAIhjD,GAAQ4mD,GAAa7mD,GAAMqD,EAAM0E,EAAMk7C,QAAUl7C,EAAMnH,MACvDmH,EAAMknB,YAAc3kB,KAAK2kB,WAAWxJ,SAAS1d,EAAMknB,YACnD,OAAOlnB,EAAM2+C,WAAWzmD,EAAMD,EAAI6mD,GAEtC5mD,EAAO+P,EACP,IAAK,IAAIgO,EAAIzc,EAAGyc,EAAI,EAAGA,IAAK,CAC1B,IAAIqG,EAAO/Z,KAAK46C,SAASlnC,EAAI,GAC7B,GAAIqG,EAAK3kB,MAAQ2kB,EAAKrX,IAAI87B,YAAcx+B,KAAK2kB,aAAe5K,EAAKyiC,aAAa,GAAI,CAChFH,EAAatJ,EAASh5B,EAAKrX,KAAO,EAClC,MAEF/M,GAAQokB,EAAK3kB,MAEI,GAAfinD,IAAoBA,EAAa,GAEvC,GAAIA,GAAc,IAAMtjD,EAAMrD,GAAMuB,GAAK+I,KAAK46C,SAASvgD,OAAS,GAAI,CAClE3E,EAAKqD,EACL,IAAK,IAAI0jD,EAAMxlD,EAAI,EAAGwlD,EAAMz8C,KAAK46C,SAASvgD,OAAQoiD,IAAO,CACvD,IAAI5pB,EAAO7yB,KAAK46C,SAAS6B,GACzB,GAAI5pB,EAAKz9B,MAAQy9B,EAAKnwB,IAAI87B,YAAcx+B,KAAK2kB,aAAekO,EAAK2pB,cAAc,GAAI,CACjFF,EAAWvJ,EAASlgB,EAAKnwB,KACzB,MAEFhN,GAAMm9B,EAAKz9B,MAEI,GAAbknD,IAAkBA,EAAWt8C,KAAK2kB,WAAWqd,WAAW3nC,QAC5D,MAEFqL,EAAS3M,EAEX,MAAO,CAACzC,KAAM0J,KAAK2kB,WAAYhvB,KAAMA,EAAMD,GAAIA,EAAI2mD,WAAYA,EAAYC,SAAUA,IAGvF3B,EAASl8C,UAAU+9C,aAAe,SAAuBjmD,GACvD,GAAIyJ,KAAK24C,SAAW34C,KAAK2kB,aAAe3kB,KAAK46C,SAASvgD,OAAU,OAAO,EACvE,IAAIoD,EAAQuC,KAAK46C,SAASrkD,EAAO,EAAI,EAAIyJ,KAAK46C,SAASvgD,OAAS,GAChE,OAAqB,GAAdoD,EAAMrI,MAAaqI,EAAM++C,aAAajmD,IAI/CokD,EAASl8C,UAAUg8C,YAAc,SAAsBxkD,GACrD,IAAIa,EAAMkJ,KAAK64C,WAAW5iD,EAAK,GACzBK,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACnB,GAAqB,GAAjBpP,EAAKiF,UAAiBmK,GAAUpP,EAAK0rC,WAAW3nC,OAChD,MAAM,IAAIo0B,WAAW,qBAAuBx4B,GAChD,OAAOK,EAAK0rC,WAAWt8B,IASzBi1C,EAASl8C,UAAU5I,aAAe,SAAuBgvC,EAAQvH,EAAM0a,EAAM0E,GAG3E,IADA,IAAI/mD,EAAO0L,KAAKc,IAAI0iC,EAAQvH,GAAO5nC,EAAK2L,KAAKC,IAAIujC,EAAQvH,GAChDrmC,EAAI,EAAGyO,EAAS,EAAGzO,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK46C,SAAS3jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIO,EAAO+P,GAAUhQ,EAAKqD,EACtB,OAAO0E,EAAM5H,aAAagvC,EAASn/B,EAASjI,EAAMk7C,OAAQrb,EAAO53B,EAASjI,EAAMk7C,OAAQX,EAAM0E,GAClGh3C,EAAS3M,EAGX,IAAI4jD,EAAY38C,KAAK64C,WAAWhU,EAAQA,GAAU,EAAI,GAClD+X,EAAUtf,GAAQuH,EAAS8X,EAAY38C,KAAK64C,WAAWvb,EAAMA,GAAQ,EAAI,GACzE0W,EAASgE,EAAKp1C,eAEdi6C,GAAW,EAKf,IAAKxyC,EAAOghB,OAAShhB,EAAO8gB,SAAW0Z,GAAUvH,EAAM,CACrD,IAAIhnC,EAAOqmD,EAAUrmD,KACfwmD,EAAWH,EAAUj3C,OAC3B,GAAqB,GAAjBpP,EAAKiF,UAGP,IAFAshD,EAAWC,GAA4C,MAAhCxmD,EAAK6pC,UAAU2c,EAAW,KAEjCA,GAAYxmD,EAAK6pC,UAAU9lC,OACzC,IAAK,IAAI68B,EAAO5gC,EAAMd,OAAQ,EAAU0hC,EAAMA,EAAOA,EAAKsH,WAAY,CACpE,GAAIhpC,EAAQ0hC,EAAK0J,YAAa,CACN,MAAlBprC,EAAMipC,WACNke,EAAYC,EAAU,CAACtmD,KAAMd,EAAMgpC,WAAY94B,OAAQqtC,EAASv9C,GAAS,IAC7E,MAEF,IAAI8xC,EAAOpQ,EAAK4c,WAChB,GAAIxM,GAAQA,EAAKhxC,MAAQgxC,EAAKhxC,KAAK4C,QAAW,WAG7C,CACL,IAAI6gB,EAAOzjB,EAAK0rC,WAAW8a,EAAW,GACtCD,EAAW9iC,IAA0B,MAAjBA,EAAK0kB,UAA4C,SAAxB1kB,EAAK85B,kBAKtD,GAAIxpC,EAAOghB,OAAS2oB,EAAOoG,WAAapG,EAAOoG,WAAawC,EAAQtmD,MAAqC,GAA7B09C,EAAOoG,UAAU7+C,SAAe,CAC1G,IAAI89C,EAAUrF,EAAOoG,UAAUpY,WAAWgS,EAAOsG,aAC7CjB,GAAsC,SAA3BA,EAAQxF,kBAA8B6I,GAAQ,GAG/D,GAAMA,GAASG,GAAYxyC,EAAO8gB,SAC9BooB,EAAqBoJ,EAAUrmD,KAAMqmD,EAAUj3C,OAAQsuC,EAAO+I,WAAY/I,EAAOgJ,gBACjFzJ,EAAqBqJ,EAAQtmD,KAAMsmD,EAAQl3C,OAAQsuC,EAAOoG,UAAWpG,EAAOsG,aAFhF,CAQA,IAAI2C,GAAiB,EACrB,IAAKjJ,EAAOtzC,QAAUmkC,GAAUvH,KAAUuf,EAAU,CAClD7I,EAAOkJ,SAASP,EAAUrmD,KAAMqmD,EAAUj3C,QAC1C,IACMm/B,GAAUvH,GAAQ0W,EAAOtzC,OAAOk8C,EAAQtmD,KAAMsmD,EAAQl3C,QAC1Du3C,GAAiB,EACjB,MAAOvtB,GAKP,KAAMA,aAAeytB,cAAiB,MAAMztB,GAIhD,IAAKutB,EAAgB,CACnB,GAAIpY,EAASvH,EAAM,CAAE,IAAI3K,EAAMgqB,EAAWA,EAAYC,EAASA,EAAUjqB,EACzE,IAAIn+B,EAAQmS,SAASysC,cACrB5+C,EAAM6+C,OAAOuJ,EAAQtmD,KAAMsmD,EAAQl3C,QACnClR,EAAM8+C,SAASqJ,EAAUrmD,KAAMqmD,EAAUj3C,QACzCsuC,EAAOnxC,kBACPmxC,EAAOpiB,SAASp9B,MAKpBmmD,EAASl8C,UAAUgmB,eAAiB,SAAyB6B,GAC3D,OAAQtmB,KAAK2kB,YAA+B,aAAjB2B,EAASxxB,MAGtCi5B,EAAmBgtB,YAAYvuB,IAAM,WACnC,OAAOxsB,KAAK2kB,YAAc3kB,KAAK2kB,YAAc3kB,KAAK0C,MAAQ1C,KAAK0C,IAAIyY,SAASnb,KAAK2kB,aAKnFg2B,EAASl8C,UAAU2+C,UAAY,SAAoBznD,EAAMD,GACvD,IAAK,IAAIgQ,EAAS,EAAGzO,EAAI,EAAGA,EAAI+I,KAAK46C,SAASvgD,OAAQpD,IAAK,CACzD,IAAIwG,EAAQuC,KAAK46C,SAAS3jD,GAAI8B,EAAM2M,EAASjI,EAAMrI,KACnD,GAAIsQ,GAAU3M,EAAMpD,GAAQoD,GAAOrD,GAAMgQ,EAAS/P,EAAOoD,GAAOrD,EAAKgQ,EAAQ,CAC3E,IAAI23C,EAAc33C,EAASjI,EAAMk7C,OAAQ2E,EAAYvkD,EAAM0E,EAAMk7C,OACjE,GAAIhjD,GAAQ0nD,GAAe3nD,GAAM4nD,EAK/B,OAJAt9C,KAAK66C,MAAQllD,GAAQ+P,GAAUhQ,GAAMqD,EApXO,EAAnB,OAqXrBpD,GAAQ0nD,GAAe3nD,GAAM4nD,IAC5B7/C,EAAMs9C,aAAet9C,EAAMiF,IAAI87B,YAAcx+B,KAAK2kB,WAChDlnB,EAAM2/C,UAAUznD,EAAO0nD,EAAa3nD,EAAK2nD,GADsB5/C,EAAMo9C,MAtXhB,GA0X5Dp9C,EAAMo9C,MAAQp9C,EAAMiF,KAAOjF,EAAMknB,YAAclnB,EAAMiF,IAAI87B,YAAcx+B,KAAK2kB,YAAelnB,EAAMm9C,SAASvgD,OA1X9C,EAAhB,EA8XhDqL,EAAS3M,EAEXiH,KAAK66C,MAhY6C,GAmYpDF,EAASl8C,UAAU8+C,iBAAmB,WAEpC,IADA,IAAIpa,EAAQ,EACH7sC,EAAO0J,KAAK9K,OAAQoB,EAAMA,EAAOA,EAAKpB,OAAQiuC,IAAS,CAC9D,IAAI0X,EAAiB,GAAT1X,EAtYoC,EAAnB,EAuYzB7sC,EAAKukD,MAAQA,IAASvkD,EAAKukD,MAAQA,KAI3C9sB,EAAmBitB,QAAQxuB,IAAM,WAAc,OAAO,GAEtDuB,EAAmBurB,gBAAgB9sB,IAAM,WAAc,OAAO,GAE9DhuB,OAAO6wB,iBAAkBsrB,EAASl8C,UAAWsvB,GAI7C,IAAIyvB,EAAU,GAIVvB,EAA+B,SAAUtB,GAC3C,SAASsB,EAAe/mD,EAAQgnD,EAAQhoD,EAAM+B,GAC5C,IAAI02B,EAAMjqB,EAAMw5C,EAAOpnD,KAAKupB,MAK5B,GAJkB,mBAAP3b,IAAqBA,EAAMA,EAAIxO,GAAM,WAC9C,OAAKy4B,EACDA,EAAKz3B,OAAiBy3B,EAAKz3B,OAAOomD,eAAe3uB,QAArD,EADoB12B,OAGjBimD,EAAOpnD,KAAKC,KAAK0oD,IAAK,CACzB,GAAoB,GAAhB/6C,EAAInH,SAAe,CACrB,IAAInB,EAAOuM,SAAS6R,cAAc,QAClCpe,EAAKqe,YAAY/V,GACjBA,EAAMtI,EAERsI,EAAImxC,iBAAkB,EACtBnxC,EAAIg7C,UAAUja,IAAI,sBAEpBkX,EAASh8C,KAAKqB,KAAM9K,EAAQsoD,EAAS96C,EAAK,MAC1C1C,KAAKk8C,OAASA,EACdvvB,EAAO3sB,KAGJ26C,IAAWsB,EAAe35C,UAAYq4C,GAC3CsB,EAAex9C,UAAYD,OAAOlE,OAAQqgD,GAAYA,EAASl8C,WAC/Dw9C,EAAex9C,UAAUI,YAAco9C,EAEvC,IAAI1rB,EAAuB,CAAEyqB,QAAS,CAAEhtB,cAAc,IA0BtD,OAxBAiuB,EAAex9C,UAAUw8C,cAAgB,SAAwBiB,GAC/D,OAnbY,GAmbLl8C,KAAK66C,OAAsBqB,EAAOpnD,KAAK0S,GAAGxH,KAAKk8C,OAAOpnD,OAG/DmnD,EAAex9C,UAAUye,UAAY,WAAwB,MAAO,CAAC6jB,QAAQ,IAE7Ekb,EAAex9C,UAAU+lB,UAAY,SAAoBha,GACvD,IAAImzC,EAAO39C,KAAKk8C,OAAOnnD,KAAKyvB,UAC5B,QAAOm5B,GAAOA,EAAKnzC,IAGrByxC,EAAex9C,UAAUgmB,eAAiB,SAAyB6B,GACjE,MAAwB,aAAjBA,EAASxxB,MAAuBkL,KAAKk8C,OAAOnnD,KAAK6oD,iBAG1D3B,EAAex9C,UAAU4c,QAAU,WACjCrb,KAAKk8C,OAAOpnD,KAAKumB,QAAQrb,KAAK0C,KAC9Bi4C,EAASl8C,UAAU4c,QAAQ1c,KAAKqB,OAGlCuwB,EAAqByqB,QAAQxuB,IAAM,WAAc,OAAO,GAExDhuB,OAAO6wB,iBAAkB4sB,EAAex9C,UAAW8xB,GAE5C0rB,EAnDyB,CAoDhCtB,GAEEkD,EAAoC,SAAUlD,GAChD,SAASkD,EAAoB3oD,EAAQwN,EAAKo7C,EAAS98C,GACjD25C,EAASh8C,KAAKqB,KAAM9K,EAAQsoD,EAAS96C,EAAK,MAC1C1C,KAAK89C,QAAUA,EACf99C,KAAKgB,KAAOA,EAGT25C,IAAWkD,EAAoBv7C,UAAYq4C,GAChDkD,EAAoBp/C,UAAYD,OAAOlE,OAAQqgD,GAAYA,EAASl8C,WACpEo/C,EAAoBp/C,UAAUI,YAAcg/C,EAE5C,IAAIvrB,EAAuB,CAAEl9B,KAAM,CAAE44B,cAAc,IAmBnD,OAjBAsE,EAAqBl9B,KAAKo3B,IAAM,WAAc,OAAOxsB,KAAKgB,KAAK3G,QAE/DwjD,EAAoBp/C,UAAU88C,gBAAkB,SAA0B74C,EAAKgD,GAC7E,OAAIhD,GAAO1C,KAAK89C,QAAkB99C,KAAK04C,YAAchzC,EAAS1F,KAAK5K,KAAO,GACnE4K,KAAK04C,WAAahzC,GAG3Bm4C,EAAoBp/C,UAAUo6C,WAAa,SAAqB5iD,GAC9D,MAAO,CAACK,KAAM0J,KAAK89C,QAASp4C,OAAQzP,IAGtC4nD,EAAoBp/C,UAAUgmB,eAAiB,SAAyBs5B,GACtE,MAAoB,kBAAbA,EAAIjpD,MAA4BipD,EAAIrpD,OAAOyrC,WAAa4d,EAAIC,UAGrEx/C,OAAO6wB,iBAAkBwuB,EAAoBp/C,UAAW6zB,GAEjDurB,EA9B8B,CA+BrClD,GAOEsD,EAA6B,SAAUtD,GACzC,SAASsD,EAAa/oD,EAAQsQ,EAAM9C,EAAKiiB,GACvCg2B,EAASh8C,KAAKqB,KAAM9K,EAAQ,GAAIwN,EAAKiiB,GACrC3kB,KAAKwF,KAAOA,EA2Cd,OAxCKm1C,IAAWsD,EAAa37C,UAAYq4C,GACzCsD,EAAax/C,UAAYD,OAAOlE,OAAQqgD,GAAYA,EAASl8C,WAC7Dw/C,EAAax/C,UAAUI,YAAco/C,EAErCA,EAAa3jD,OAAS,SAAiBpF,EAAQsQ,EAAMuY,EAAQ7pB,GAC3D,IAAIgqD,EAAShqD,EAAKktB,UAAU5b,EAAK1Q,KAAKmL,MAClClL,EAAOmpD,GAAUA,EAAO14C,EAAMtR,EAAM6pB,GAGxC,OAFKhpB,GAASA,EAAK2N,MACf3N,EAAO,gBAAyB4R,SAAUnB,EAAK1Q,KAAKC,KAAKspB,MAAM7Y,EAAMuY,KAClE,IAAIkgC,EAAa/oD,EAAQsQ,EAAMzQ,EAAK2N,IAAK3N,EAAK4vB,YAAc5vB,EAAK2N,MAG1Eu7C,EAAax/C,UAAUye,UAAY,WACjC,OAtgBgE,EAsgB3Dld,KAAK66C,OAAuB76C,KAAKwF,KAAK1Q,KAAKC,KAAKopD,cAAwB,KACtE,CAAC34C,KAAMxF,KAAKwF,KAAK1Q,KAAKmL,KAAMzE,MAAOwE,KAAKwF,KAAKhK,MAAOsmC,eAAgB9hC,KAAK2kB,aAGlFs5B,EAAax/C,UAAUy8C,YAAc,SAAsB11C,GAAQ,OA1gBD,GA0gBQxF,KAAK66C,OAAuB76C,KAAKwF,KAAKgC,GAAGhC,IAEnHy4C,EAAax/C,UAAU2+C,UAAY,SAAoBznD,EAAMD,GAG3D,GAFAilD,EAASl8C,UAAU2+C,UAAUz+C,KAAKqB,KAAMrK,EAAMD,GA7gBlC,GA+gBRsK,KAAK66C,MAAoB,CAE3B,IADA,IAAI3lD,EAAS8K,KAAK9K,QACVA,EAAOoB,MAAQpB,EAASA,EAAOA,OACnCA,EAAO2lD,MAAQ76C,KAAK66C,QAAS3lD,EAAO2lD,MAAQ76C,KAAK66C,OACrD76C,KAAK66C,MAnhBK,IAuhBdoD,EAAax/C,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIxB,GACvD,IAAIqG,EAAO0jD,EAAa3jD,OAAO0F,KAAK9K,OAAQ8K,KAAKwF,MAAM,EAAMtR,GACzDyN,EAAQ3B,KAAK46C,SAAUxlD,EAAO4K,KAAK5K,KACnCM,EAAKN,IAAQuM,EAAQy8C,GAAaz8C,EAAOjM,EAAIN,EAAMlB,IACnDyB,EAAO,IAAKgM,EAAQy8C,GAAaz8C,EAAO,EAAGhM,EAAMzB,IACrD,IAAK,IAAI+C,EAAI,EAAGA,EAAI0K,EAAMtH,OAAQpD,IAAO0K,EAAM1K,GAAG/B,OAASqF,EAE3D,OADAA,EAAKqgD,SAAWj5C,EACTpH,GAGF0jD,EA9CuB,CA+C9BtD,GAKE0D,EAA6B,SAAU1D,GACzC,SAAS0D,EAAanpD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKiiB,EAAYm3B,EAAS5nD,EAAM+B,GACxF0kD,EAASh8C,KAAKqB,KAAM9K,EAAQoB,EAAKiwB,OAASi3B,EAAU,GAAI96C,EAAKiiB,GAC7D3kB,KAAK87C,QAAUA,EACf97C,KAAK1J,KAAOA,EACZ0J,KAAKs+C,UAAYA,EACjBt+C,KAAKu+C,UAAYA,EACb55B,GAAc3kB,KAAKw+C,eAAetqD,EAAM+B,GAGzC0kD,IAAW0D,EAAa/7C,UAAYq4C,GACzC0D,EAAa5/C,UAAYD,OAAOlE,OAAQqgD,GAAYA,EAASl8C,WAC7D4/C,EAAa5/C,UAAUI,YAAcw/C,EAErC,IAAI5qB,EAAuB,CAAEr+B,KAAM,CAAE44B,cAAc,GAAO2qB,OAAQ,CAAE3qB,cAAc,GAAOgtB,QAAS,CAAEhtB,cAAc,IAqNlH,OA1MAqwB,EAAa/jD,OAAS,SAAiBpF,EAAQoB,EAAMgoD,EAAWC,EAAWrqD,EAAM+B,GAC/E,IAAImJ,EAEyCq/C,EAAzCP,EAAShqD,EAAKktB,UAAU9qB,EAAKxB,KAAKmL,MAClClL,EAAOmpD,GAAUA,EAAO5nD,EAAMpC,GAAM,WAGtC,OAAKuqD,EACDA,EAAQvpD,OAAiBupD,EAAQvpD,OAAOomD,eAAemD,QAA3D,EADuBxoD,IAEtBqoD,EAAWC,GAEV77C,EAAM3N,GAAQA,EAAK2N,IAAKiiB,EAAa5vB,GAAQA,EAAK4vB,WACtD,GAAIruB,EAAK8K,OACP,GAAKsB,GACA,GAAoB,GAAhBA,EAAInH,SAAiB,MAAM,IAAIkzB,WAAW,iDADvC/rB,EAAMiE,SAAS86B,eAAenrC,EAAK0K,WAErC0B,IAC2DA,GAAzEtD,EAAS,gBAAyBuH,SAAUrQ,EAAKxB,KAAKC,KAAKspB,MAAM/nB,KAAqBoM,IAAKiiB,EAAavlB,EAAOulB,YAExGA,GAAeruB,EAAK8K,QAA0B,MAAhBsB,EAAI+7B,WAChC/7B,EAAIg8C,aAAa,qBAAsBh8C,EAAImxC,iBAAkB,GAC9Dv9C,EAAKxB,KAAKC,KAAKmpB,YAAaxb,EAAIwb,WAAY,IAGlD,IAAI49B,EAAUp5C,EAGd,OAFAA,EAAMi8C,GAAej8C,EAAK47C,EAAWhoD,GAEjCvB,EACO0pD,EAAU,IAAIG,GAAmB1pD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKiiB,EAAYm3B,EACvD/mD,EAAMb,EAAM+B,EAAM,GACnDK,EAAK8K,OACH,IAAIy9C,EAAa3pD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKo5C,EAAS5nD,GAEnE,IAAImqD,EAAanpD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKiiB,EAAYm3B,EAAS5nD,EAAM+B,EAAM,IAGxGooD,EAAa5/C,UAAUye,UAAY,WACjC,IAAIgd,EAASl6B,KAGb,GAAIA,KAAK1J,KAAKxB,KAAKC,KAAKopD,cAAiB,OAAO,KAKhD,IAAI5kC,EAAO,CAACjjB,KAAM0J,KAAK1J,KAAKxB,KAAKmL,KAAMzE,MAAOwE,KAAK1J,KAAKkF,OAIxD,MAHiC,OAA7BwE,KAAK1J,KAAKxB,KAAK+jC,aAAuBtf,EAAK1Q,mBAAqB,QAChE7I,KAAK2kB,aAAe3kB,KAAK+6C,YAAexhC,EAAKuoB,eAAiB9hC,KAAK2kB,WAChEpL,EAAKsoB,WAAa,WAAc,OAAO3H,EAAOvV,WAAa,WAAiBuV,EAAO5jC,KAAKnB,SACxFokB,GAGT8kC,EAAa5/C,UAAU08C,YAAc,SAAsB7kD,EAAMgoD,EAAWC,GAC1E,OApnBY,GAonBLv+C,KAAK66C,OAAsBvkD,EAAKkR,GAAGxH,KAAK1J,OAC7CwoD,GAAcR,EAAWt+C,KAAKs+C,YAAcC,EAAU/2C,GAAGxH,KAAKu+C,YAGlE9qB,EAAqBr+B,KAAKo3B,IAAM,WAAc,OAAOxsB,KAAK1J,KAAKJ,UAE/Du9B,EAAqBklB,OAAOnsB,IAAM,WAAc,OAAOxsB,KAAK1J,KAAKiwB,OAAS,EAAI,GAM9E83B,EAAa5/C,UAAU+/C,eAAiB,SAAyBtqD,EAAM+B,GACrE,IAAIikC,EAASl6B,KAET+d,EAAS/d,KAAK1J,KAAKsC,cAAe8oB,EAAMzrB,EACxC8oD,EAAc7qD,EAAKklB,WAAapZ,KAAKg/C,qBAAqB9qD,EAAM+B,GAChEgpD,EAAmBF,GAAeA,EAAY9oD,KAAO,EAAI8oD,EAAc,KACvEG,EAAqBH,GAAeA,EAAY9oD,IAAM,EACtDkpD,EAAU,IAAIC,GAAgBp/C,KAAMi/C,GAAoBA,EAAiB3oD,OAipBjF,SAAkBpB,EAAQmqD,EAAMC,EAAUC,GACxC,IAAIC,EAASH,EAAKG,OAAOtqD,GAASwQ,EAAS,EAE3C,GAAqB,GAAjB85C,EAAOnlD,OAAa,CACtB,IAAK,IAAIpD,EAAI,EAAGA,EAAI/B,EAAO0B,WAAYK,IAAK,CAC1C,IAAIwG,EAAQvI,EAAOuI,MAAMxG,GACzBsoD,EAAO9hD,EAAO+hD,EAAQH,EAAKI,SAAS/5C,EAAQjI,GAAQxG,GACpDyO,GAAUjI,EAAMvH,SAElB,OAIF,IADA,IAAIwpD,EAAY,EAAG1oB,EAAS,GAAI2oB,EAAW,KAClCC,EAAc,IAAK,CAC1B,GAAIF,EAAYF,EAAOnlD,QAAUmlD,EAAOE,GAAWhqD,IAAMgQ,EAAQ,CAE/D,IADA,IAAIw2C,EAASsD,EAAOE,KAAcG,OAAU,EACrCH,EAAYF,EAAOnlD,QAAUmlD,EAAOE,GAAWhqD,IAAMgQ,IACvDm6C,IAAYA,EAAU,CAAC3D,KAAUthD,KAAK4kD,EAAOE,MAClD,GAAIG,EAAS,CACXA,EAAQlgC,KAAKmgC,IACb,IAAK,IAAI9kD,EAAM,EAAGA,EAAM6kD,EAAQxlD,OAAQW,IAASskD,EAASO,EAAQ7kD,GAAM4kD,IAAeD,QAEvFL,EAASpD,EAAQ0D,IAAeD,GAIpC,IAAII,OAAU,EAAU7oD,OAAQ,EAChC,GAAIyoD,EACFzoD,GAAS,EACT6oD,EAAUJ,EACVA,EAAW,SACN,MAAIC,EAAc1qD,EAAO0B,YAI9B,MAHAM,EAAQ0oD,EACRG,EAAU7qD,EAAOuI,MAAMmiD,KAKzB,IAAK,IAAIriD,EAAM,EAAGA,EAAMy5B,EAAO38B,OAAQkD,IAAay5B,EAAOz5B,GAAK7H,IAAMgQ,GAAUsxB,EAAOnK,OAAOtvB,IAAO,GACrG,KAAOmiD,EAAYF,EAAOnlD,QAAUmlD,EAAOE,GAAW/pD,MAAQ+P,GAAU85C,EAAOE,GAAWhqD,GAAKgQ,GAC3FsxB,EAAOp8B,KAAK4kD,EAAOE,MAEvB,IAAI3mD,EAAM2M,EAASq6C,EAAQ7pD,SAC3B,GAAI6pD,EAAQ3+C,OAAQ,CAClB,IAAI4+C,EAAQjnD,EACR2mD,EAAYF,EAAOnlD,QAAUmlD,EAAOE,GAAW/pD,KAAOqqD,IAASA,EAAQR,EAAOE,GAAW/pD,MAC7F,IAAK,IAAIsqD,EAAM,EAAGA,EAAMjpB,EAAO38B,OAAQ4lD,IAAajpB,EAAOipB,GAAKvqD,GAAKsqD,IAASA,EAAQhpB,EAAOipB,GAAKvqD,IAC9FsqD,EAAQjnD,IACV4mD,EAAWI,EAAQ1xB,IAAI2xB,EAAQt6C,GAC/Bq6C,EAAUA,EAAQ1xB,IAAI,EAAG2xB,EAAQt6C,GACjC3M,EAAMinD,EACN9oD,GAAS,GAObqoD,EAAOQ,EAHU/oB,EAAO38B,OAClB0lD,EAAQ7kD,WAAa6kD,EAAQx5B,OAASyQ,EAAOp1B,QAAO,SAAUyO,GAAK,OAAQA,EAAE0N,UAC7EiZ,EAAOvhC,QAFoB+nD,EAGN6B,EAAKI,SAAS/5C,EAAQq6C,GAAU7oD,GAC3DwO,EAAS3M,GA3sBTmnD,CAASlgD,KAAK1J,KAAM0J,KAAKu+C,WAAW,SAAUrC,EAAQjlD,EAAGkpD,GACnDjE,EAAOnnD,KAAK4P,MACZw6C,EAAQiB,YAAYlE,EAAOnnD,KAAK4P,MAAOoZ,EAAQ7pB,GAC1CgoD,EAAOpnD,KAAKyB,MAAQ,IAAM4pD,GAC/BhB,EAAQiB,YAAYnpD,GAAKijC,EAAO5jC,KAAKM,WAAa,UAAYsjC,EAAO5jC,KAAKmH,MAAMxG,GAAG0N,MAAOoZ,EAAQ7pB,GAGtGirD,EAAQkB,YAAYnE,EAAQhoD,EAAMwtB,MACjC,SAAUjkB,EAAO6gD,EAAWC,EAAWtnD,GAIxC,IAAIqpD,EAFJnB,EAAQiB,YAAY3iD,EAAMkH,MAAOoZ,EAAQ7pB,GAGrCirD,EAAQoB,cAAc9iD,EAAO6gD,EAAWC,EAAWtnD,IAAeioD,GAAsBhrD,EAAKP,MAAME,UAAU8B,KAAO+rB,GAC7GxtB,EAAKP,MAAME,UAAU6B,GAAKgsB,EAAMjkB,EAAMvH,WACrCoqD,EAAYnB,EAAQqB,mBAAmBzB,EAAYzoD,QAAU,GAC9D6oD,EAAQsB,aAAahjD,EAAO6gD,EAAWC,EAAW+B,EAAWpsD,IAAkBirD,EAAQuB,eAAejjD,EAAO6gD,EAAWC,EAAWrqD,EAAM+C,IAElJkoD,EAAQxtB,QAAQl0B,EAAO6gD,EAAWC,EAAWrqD,EAAMwtB,GAErDA,GAAOjkB,EAAMvH,YAGfipD,EAAQiB,YAAY5C,EAASz/B,EAAQ7pB,GACjC8L,KAAK1J,KAAKK,aAAewoD,EAAQwB,oBACrCxB,EAAQyB,eAGJzB,EAAQ0B,SApqBoC,GAoqBzB7gD,KAAK66C,SAEtBoE,GAAoBj/C,KAAK8gD,wBAAwB5sD,EAAM+qD,GAC3D8B,GAAY/gD,KAAK2kB,WAAY3kB,KAAK46C,SAAU1mD,GACxCmW,EAAOooC,KAirBjB,SAAkB/vC,GAChB,GAAoB,MAAhBA,EAAI+7B,UAAoC,MAAhB/7B,EAAI+7B,SAAkB,CAChD,IAAIuiB,EAASt+C,EAAIya,MAAM8jC,QACvBv+C,EAAIya,MAAM8jC,QAAUD,EAAS,kCAC7Br+C,OAAOu+C,iBAAiBx+C,GAAKy+C,UAC7Bz+C,EAAIya,MAAM8jC,QAAUD,GAtrBAI,CAASphD,KAAK0C,OAIpC27C,EAAa5/C,UAAUugD,qBAAuB,SAA+B9qD,EAAM+B,GAGjF,IAAIa,EAAM5C,EAAKP,MAAME,UACjB8B,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GACb,OAAMxB,EAAKP,MAAME,qBAAqB,OAAkB8B,EAAOM,GAAOP,EAAKO,EAAM+J,KAAK1J,KAAKnB,QAAQC,MAAnG,CACA,IAAIqD,EAAMvE,EAAK8jD,KAAKp1C,eAChB+/B,EA8qBR,SAAwBrsC,EAAMoP,GAC5B,OAAS,CACP,GAAqB,GAAjBpP,EAAKiF,SAAiB,OAAOjF,EACjC,GAAqB,GAAjBA,EAAKiF,UAAiBmK,EAAS,EAAG,CACpC,GAAIpP,EAAK0rC,WAAW3nC,OAASqL,GAA8C,GAApCpP,EAAK0rC,WAAWt8B,GAAQnK,SAC3D,OAAOjF,EAAK0rC,WAAWt8B,GAE3BA,EAASxP,EADTI,EAAOA,EAAK0rC,WAAWt8B,EAAS,QAE3B,MAAqB,GAAjBpP,EAAKiF,UAAiBmK,EAASpP,EAAK0rC,WAAW3nC,QAIxD,OAAO,KAHP/D,EAAOA,EAAK0rC,WAAWt8B,GACvBA,EAAS,IAxrBI27C,CAAe5oD,EAAI2hD,UAAW3hD,EAAI6hD,aACjD,GAAK3X,GAAa3iC,KAAK0C,IAAIyY,SAASwnB,EAASnE,YAA7C,CAEA,GAAIx+B,KAAK1J,KAAKsC,cAAe,CAI3B,IAAIoI,EAAO2hC,EAASxC,UAChBmhB,EAwrBV,SAA4B9qB,EAAMx1B,EAAMrL,EAAMD,GAC5C,IAAK,IAAIuB,EAAI,EAAGhB,EAAM,EAAGgB,EAAIu/B,EAAK5/B,YAAcX,GAAOP,GAAK,CAC1D,IAAI+H,EAAQ+4B,EAAK/4B,MAAMxG,KAAMsqD,EAAatrD,EAE1C,GADAA,GAAOwH,EAAMvH,SACRuH,EAAM2D,OAAX,CAEA,IADA,IAAI4xB,EAAMv1B,EAAMuD,KACT/J,EAAIu/B,EAAK5/B,YAAY,CAC1B,IAAIi8B,EAAO2D,EAAK/4B,MAAMxG,KAEtB,GADAhB,GAAO48B,EAAK38B,UACP28B,EAAKzxB,OAAU,MACpB4xB,GAAOH,EAAK7xB,KAEd,GAAI/K,GAAON,GAAQ4rD,EAAa7rD,EAAI,CAClC,IAAI0H,EAAQ41B,EAAI9L,YAAYlmB,EAAMtL,EAAK6rD,EAAa,GACpD,GAAInkD,GAAS,GAAKA,EAAQ4D,EAAK3G,OAASknD,GAAc5rD,EAClD,OAAO4rD,EAAankD,IAG5B,OAAQ,EA1sBUokD,CAAmBxhD,KAAK1J,KAAKnB,QAAS6L,EAAMrL,EAAOM,EAAKP,EAAKO,GAC3E,OAAOqrD,EAAU,EAAI,KAAO,CAAChrD,KAAMqsC,EAAU1sC,IAAKqrD,EAAStgD,KAAMA,GAEjE,MAAO,CAAC1K,KAAMqsC,EAAU1sC,KAAM,MAIlCooD,EAAa5/C,UAAUqiD,wBAA0B,SAAkC5sD,EAAM4C,GACvF,IAAIR,EAAOQ,EAAIR,KACXL,EAAMa,EAAIb,IACV+K,EAAOlK,EAAIkK,KAGf,IAAIhB,KAAK67C,QAAQvlD,GAAjB,CAIA,IADA,IAAIsnB,EAAUtnB,EAERsnB,EAAQ4gB,YAAcx+B,KAAK2kB,WADzB/G,EAAUA,EAAQ4gB,WAAY,CAEpC,KAAO5gB,EAAQyiB,iBAAmBziB,EAAQ4gB,WAAWijB,YAAY7jC,EAAQyiB,iBACzE,KAAOziB,EAAQgjB,aAAehjB,EAAQ4gB,WAAWijB,YAAY7jC,EAAQgjB,aACjEhjB,EAAQk2B,aAAcl2B,EAAQk2B,WAAa,MAEjD,IAAIxM,EAAO,IAAIuW,EAAoB79C,KAAM4d,EAAStnB,EAAM0K,GACxD9M,EAAKwtD,iBAAiB9mD,KAAK0sC,GAG3BtnC,KAAK46C,SAAWwD,GAAap+C,KAAK46C,SAAU3kD,EAAKA,EAAM+K,EAAK3G,OAAQnG,EAAMozC,KAM5E+W,EAAa5/C,UAAUguB,OAAS,SAAiBn2B,EAAMgoD,EAAWC,EAAWrqD,GAC3E,QA9tBgE,GA8tB5D8L,KAAK66C,QACJvkD,EAAKk3B,WAAWxtB,KAAK1J,SAC1B0J,KAAK2hD,YAAYrrD,EAAMgoD,EAAWC,EAAWrqD,IACtC,IAGTmqD,EAAa5/C,UAAUkjD,YAAc,SAAsBrrD,EAAMgoD,EAAWC,EAAWrqD,GACrF8L,KAAK4hD,gBAAgBtD,GACrBt+C,KAAK1J,KAAOA,EACZ0J,KAAKu+C,UAAYA,EACbv+C,KAAK2kB,YAAc3kB,KAAKw+C,eAAetqD,EAAM8L,KAAK04C,YACtD14C,KAAK66C,MAzuBO,GA4uBdwD,EAAa5/C,UAAUmjD,gBAAkB,SAA0BtD,GACjE,IAAIQ,GAAcR,EAAWt+C,KAAKs+C,WAAlC,CACA,IAAIuD,EAAqC,GAAzB7hD,KAAK87C,QAAQvgD,SACzBumD,EAAS9hD,KAAK0C,IAClB1C,KAAK0C,IAAMq/C,GAAe/hD,KAAK0C,IAAK1C,KAAK87C,QACfkG,GAAiBhiD,KAAKs+C,UAAWt+C,KAAK1J,KAAMurD,GAC5CG,GAAiB1D,EAAWt+C,KAAK1J,KAAMurD,IAC7D7hD,KAAK0C,KAAOo/C,IACdA,EAAOhO,WAAa,KACpB9zC,KAAK0C,IAAIoxC,WAAa9zC,MAExBA,KAAKs+C,UAAYA,IAInBD,EAAa5/C,UAAUwjD,WAAa,WAClCjiD,KAAK87C,QAAQ4B,UAAUja,IAAI,6BACvBzjC,KAAK2kB,YAAe3kB,KAAK1J,KAAKxB,KAAKC,KAAKmpB,YAAale,KAAK0C,IAAIwb,WAAY,IAIhFmgC,EAAa5/C,UAAUyjD,aAAe,WACpCliD,KAAK87C,QAAQ4B,UAAU9wB,OAAO,6BAC1B5sB,KAAK2kB,YAAe3kB,KAAK1J,KAAKxB,KAAKC,KAAKmpB,WAAale,KAAK0C,IAAIy/C,gBAAgB,cAGpF1uB,EAAqBunB,QAAQxuB,IAAM,WAAc,OAAOxsB,KAAK1J,KAAKH,QAElEqI,OAAO6wB,iBAAkBgvB,EAAa5/C,UAAWg1B,GAE1C4qB,EAnOuB,CAoO9B1D,GAIF,SAASyH,EAAY7sD,EAAK+oD,EAAWC,EAAW77C,EAAKxO,GAEnD,OADAyqD,GAAej8C,EAAK47C,EAAW/oD,GACxB,IAAI8oD,EAAa,KAAM9oD,EAAK+oD,EAAWC,EAAW77C,EAAKA,EAAKA,EAAKxO,EAAM,GAGhF,IAAI2qD,EAA6B,SAAUR,GACzC,SAASQ,EAAa3pD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKo5C,EAAS5nD,GACtEmqD,EAAa1/C,KAAKqB,KAAM9K,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAK,KAAMo5C,EAAS5nD,GAG7EmqD,IAAeQ,EAAav8C,UAAY+7C,GAC7CQ,EAAapgD,UAAYD,OAAOlE,OAAQ+jD,GAAgBA,EAAa5/C,WACrEogD,EAAapgD,UAAUI,YAAcggD,EAErC,IAAIlqB,EAAuB,CAAEqmB,QAAS,CAAEhtB,cAAc,IAuDtD,OArDA6wB,EAAapgD,UAAUye,UAAY,WAEjC,IADA,IAAI+jB,EAAOjhC,KAAK87C,QAAQtd,WACjByC,GAAQA,GAAQjhC,KAAK0C,MAAQu+B,EAAKohB,UAAYphB,EAAOA,EAAKzC,WACjE,MAAO,CAACyC,KAAMA,IAAQ,IAGxB4d,EAAapgD,UAAUguB,OAAS,SAAiBn2B,EAAMgoD,EAAW50B,EAAGx1B,GACnE,QAtyBgE,GAsyB5D8L,KAAK66C,OAtyBG,GAsyBqB76C,KAAK66C,QAAuB76C,KAAKsiD,aAC7DhsD,EAAKk3B,WAAWxtB,KAAK1J,SAC1B0J,KAAK4hD,gBAAgBtD,GAxyBT,GAyyBPt+C,KAAK66C,OAAsBvkD,EAAK0K,MAAQhB,KAAK1J,KAAK0K,MAAS1K,EAAK0K,MAAQhB,KAAK87C,QAAQ3b,YACxFngC,KAAK87C,QAAQ3b,UAAY7pC,EAAK0K,KAC1B9M,EAAKquD,aAAeviD,KAAK87C,UAAW5nD,EAAKquD,YAAc,OAE7DviD,KAAK1J,KAAOA,EACZ0J,KAAK66C,MA9yBO,GA+yBL,IAGTgE,EAAapgD,UAAU6jD,SAAW,WAEhC,IADA,IAAIE,EAAYxiD,KAAK9K,OAAOyvB,WACnBhU,EAAI3Q,KAAK87C,QAASnrC,EAAGA,EAAIA,EAAE6tB,WAAc,GAAI7tB,GAAK6xC,EAAa,OAAO,EAC/E,OAAO,GAGT3D,EAAapgD,UAAUo6C,WAAa,SAAqB5iD,GACvD,MAAO,CAACK,KAAM0J,KAAK87C,QAASp2C,OAAQzP,IAGtC4oD,EAAapgD,UAAU88C,gBAAkB,SAA0B74C,EAAKgD,EAAQyD,GAC9E,OAAIzG,GAAO1C,KAAK87C,QAAkB97C,KAAK04C,WAAar3C,KAAKc,IAAIuD,EAAQ1F,KAAK1J,KAAK0K,KAAK3G,QAC7EgkD,EAAa5/C,UAAU88C,gBAAgB58C,KAAKqB,KAAM0C,EAAKgD,EAAQyD,IAGxE01C,EAAapgD,UAAUgmB,eAAiB,SAAyB6B,GAC/D,MAAwB,iBAAjBA,EAASxxB,MAA4C,aAAjBwxB,EAASxxB,MAGtD+pD,EAAapgD,UAAUhJ,MAAQ,SAAgBE,EAAMD,EAAIxB,GACvD,IAAIoC,EAAO0J,KAAK1J,KAAK+3B,IAAI14B,EAAMD,GAAKgN,EAAMiE,SAAS86B,eAAenrC,EAAK0K,MACvE,OAAO,IAAI69C,EAAa7+C,KAAK9K,OAAQoB,EAAM0J,KAAKs+C,UAAWt+C,KAAKu+C,UAAW77C,EAAKA,EAAKxO,IAGvF2qD,EAAapgD,UAAU2+C,UAAY,SAAoBznD,EAAMD,GAC3D2oD,EAAa5/C,UAAU2+C,UAAUz+C,KAAKqB,KAAMrK,EAAMD,GAC9CsK,KAAK0C,KAAO1C,KAAK87C,SAAoB,GAARnmD,GAAaD,GAAMsK,KAAK87C,QAAQ3b,UAAU9lC,SACvE2F,KAAK66C,MA70BuD,IAg1BlElmB,EAAqBqmB,QAAQxuB,IAAM,WAAc,OAAO,GAExDhuB,OAAO6wB,iBAAkBwvB,EAAapgD,UAAWk2B,GAE1CkqB,EAhEuB,CAiE9BR,GAIErC,GAAqC,SAAUrB,GACjD,SAASqB,IACPrB,EAAS3lC,MAAMhV,KAAMjE,WAGlB4+C,IAAWqB,EAAqB15C,UAAYq4C,GACjDqB,EAAqBv9C,UAAYD,OAAOlE,OAAQqgD,GAAYA,EAASl8C,WACrEu9C,EAAqBv9C,UAAUI,YAAcm9C,EAE7C,IAAIpjB,EAAuB,CAAEoiB,QAAS,CAAEhtB,cAAc,GAAOsrB,gBAAiB,CAAEtrB,cAAc,IAS9F,OAPAguB,EAAqBv9C,UAAUye,UAAY,WAAwB,MAAO,CAAC6jB,QAAQ,IACnFib,EAAqBv9C,UAAU28C,YAAc,SAAsB3c,GAAY,OAr2BjE,GAq2BwEz+B,KAAK66C,OAAsB76C,KAAK0C,IAAI+7B,UAAYA,GACtI7F,EAAqBoiB,QAAQxuB,IAAM,WAAc,OAAO,GACxDoM,EAAqB0gB,gBAAgB9sB,IAAM,WAAc,MAA4B,OAArBxsB,KAAK0C,IAAI+7B,UAEzEjgC,OAAO6wB,iBAAkB2sB,EAAqBv9C,UAAWm6B,GAElDojB,EAlB+B,CAmBtCrB,GAKEiE,GAAmC,SAAUP,GAC/C,SAASO,EAAmB1pD,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKiiB,EAAYm3B,EAAS/mD,EAAMb,EAAM+B,GACpGooD,EAAa1/C,KAAKqB,KAAM9K,EAAQoB,EAAMgoD,EAAWC,EAAW77C,EAAKiiB,EAAYm3B,EAAS5nD,EAAM+B,GAC5F+J,KAAKjL,KAAOA,EAiDd,OA9CKspD,IAAeO,EAAmBt8C,UAAY+7C,GACnDO,EAAmBngD,UAAYD,OAAOlE,OAAQ+jD,GAAgBA,EAAa5/C,WAC3EmgD,EAAmBngD,UAAUI,YAAc+/C,EAK3CA,EAAmBngD,UAAUguB,OAAS,SAAiBn2B,EAAMgoD,EAAWC,EAAWrqD,GACjF,GA/3BgE,GA+3B5D8L,KAAK66C,MAAuB,OAAO,EACvC,GAAI76C,KAAKjL,KAAK03B,OAAQ,CACpB,IAAIpiB,EAASrK,KAAKjL,KAAK03B,OAAOn2B,EAAMgoD,EAAWC,GAE/C,OADIl0C,GAAUrK,KAAK2hD,YAAYrrD,EAAMgoD,EAAWC,EAAWrqD,GACpDmW,EACF,SAAKrK,KAAK2kB,aAAeruB,EAAKiwB,SAG5B83B,EAAa5/C,UAAUguB,OAAO9tB,KAAKqB,KAAM1J,EAAMgoD,EAAWC,EAAWrqD,IAIhF0qD,EAAmBngD,UAAUwjD,WAAa,WACxCjiD,KAAKjL,KAAKktD,WAAajiD,KAAKjL,KAAKktD,aAAe5D,EAAa5/C,UAAUwjD,WAAWtjD,KAAKqB,OAGzF4+C,EAAmBngD,UAAUyjD,aAAe,WAC1CliD,KAAKjL,KAAKmtD,aAAeliD,KAAKjL,KAAKmtD,eAAiB7D,EAAa5/C,UAAUyjD,aAAavjD,KAAKqB,OAG/F4+C,EAAmBngD,UAAU5I,aAAe,SAAuBgvC,EAAQvH,EAAM0a,EAAM0E,GACrF18C,KAAKjL,KAAKc,aAAemK,KAAKjL,KAAKc,aAAagvC,EAAQvH,EAAM0a,GAC1DqG,EAAa5/C,UAAU5I,aAAa8I,KAAKqB,KAAM6kC,EAAQvH,EAAM0a,EAAM0E,IAGzEkC,EAAmBngD,UAAU4c,QAAU,WACjCrb,KAAKjL,KAAKsmB,SAAWrb,KAAKjL,KAAKsmB,UACnCgjC,EAAa5/C,UAAU4c,QAAQ1c,KAAKqB,OAGtC4+C,EAAmBngD,UAAU+lB,UAAY,SAAoBha,GAC3D,QAAOxK,KAAKjL,KAAKyvB,WAAYxkB,KAAKjL,KAAKyvB,UAAUha,IAGnDo0C,EAAmBngD,UAAUgmB,eAAiB,SAAyB6B,GACrE,OAAOtmB,KAAKjL,KAAK0vB,eAAiBzkB,KAAKjL,KAAK0vB,eAAe6B,GAAY+3B,EAAa5/C,UAAUgmB,eAAe9lB,KAAKqB,KAAMsmB,IAGnHs4B,EApD6B,CAqDpCP,GAMF,SAAS0C,GAAYyB,EAAWC,EAAOvuD,GAErC,IADA,IAAIwO,EAAM8/C,EAAU/rD,WAAYisD,GAAU,EACjCzrD,EAAI,EAAGA,EAAIwrD,EAAMpoD,OAAQpD,IAAK,CACrC,IAAIqwC,EAAOmb,EAAMxrD,GAAI0rD,EAAWrb,EAAK5kC,IACrC,GAAIigD,EAASnkB,YAAcgkB,EAAW,CACpC,KAAOG,GAAYjgD,GAAOA,EAAMkgD,GAAGlgD,GAAMggD,GAAU,EACnDhgD,EAAMA,EAAIk+B,iBAEV8hB,GAAU,EACVF,EAAUK,aAAaF,EAAUjgD,GAEnC,GAAI4kC,aAAgB2W,EAAc,CAChC,IAAIhoD,EAAMyM,EAAMA,EAAI29B,gBAAkBmiB,EAAU9rD,UAChDqqD,GAAYzZ,EAAK3iB,WAAY2iB,EAAKsT,SAAU1mD,GAC5CwO,EAAMzM,EAAMA,EAAI2qC,YAAc4hB,EAAU/rD,YAG5C,KAAOiM,GAAOA,EAAMkgD,GAAGlgD,GAAMggD,GAAU,EACnCA,GAAWxuD,EAAKquD,aAAeC,IAAatuD,EAAKquD,YAAc,MAGrE,SAASO,GAAerkB,GAClBA,IAAYz+B,KAAKy+B,SAAWA,GAElCqkB,GAAerkD,UAAYD,OAAOlE,OAAO,MAEzC,IAAIyoD,GAAS,CAAC,IAAID,IAElB,SAASd,GAAiB1D,EAAWhoD,EAAMurD,GACzC,GAAwB,GAApBvD,EAAUjkD,OAAe,OAAO0oD,GAIpC,IAFA,IAAIp4B,EAAMk3B,EAAYkB,GAAO,GAAK,IAAID,GAAgBz4C,EAAS,CAACsgB,GAEvD1zB,EAAI,EAAGA,EAAIqnD,EAAUjkD,OAAQpD,IAAK,CACzC,IAAIuE,EAAQ8iD,EAAUrnD,GAAGnC,KAAK0G,MAC9B,GAAKA,EAIL,IAAK,IAAIyE,KAHLzE,EAAMijC,UACNp0B,EAAOzP,KAAK+vB,EAAM,IAAIm4B,GAAetnD,EAAMijC,WAE9BjjC,EAAO,CACtB,IAAIg3B,EAAMh3B,EAAMyE,GACL,MAAPuyB,IACAqvB,GAA8B,GAAjBx3C,EAAOhQ,QACpBgQ,EAAOzP,KAAK+vB,EAAM,IAAIm4B,GAAexsD,EAAK4E,SAAW,OAAS,QACtD,SAAR+E,EAAmB0qB,EAAIq4B,OAASr4B,EAAIq4B,MAAQr4B,EAAIq4B,MAAQ,IAAM,IAAMxwB,EACvD,SAARvyB,EAAmB0qB,EAAIxN,OAASwN,EAAIxN,MAAQwN,EAAIxN,MAAQ,IAAM,IAAMqV,EAC5D,YAARvyB,IAAsB0qB,EAAI1qB,GAAQuyB,KAI/C,OAAOnoB,EAGT,SAAS03C,GAAekB,EAAUnH,EAASoH,EAAcC,GAEvD,GAAID,GAAgBH,IAAUI,GAAeJ,GAAU,OAAOjH,EAG9D,IADA,IAAIsH,EAAStH,EACJ7kD,EAAI,EAAGA,EAAIksD,EAAY9oD,OAAQpD,IAAK,CAC3C,IAAIooD,EAAO8D,EAAYlsD,GAAI8iB,EAAOmpC,EAAajsD,GAC/C,GAAIA,EAAG,CACL,IAAI/B,OAAS,EACT6kB,GAAQA,EAAK0kB,UAAY4gB,EAAK5gB,UAAY2kB,GAAUH,IACnD/tD,EAASkuD,EAAO5kB,aAAetpC,EAAOywB,QAAQ+Y,eAAiB2gB,EAAK5gB,YAGvEvpC,EAASyR,SAAS6R,cAAc6mC,EAAK5gB,WAC9B4jB,UAAW,EAClBntD,EAAOujB,YAAY2qC,GACnBrpC,EAAOgpC,GAAO,IALdK,EAASluD,EASbmuD,GAAgBD,EAAQrpC,GAAQgpC,GAAO,GAAI1D,GAE7C,OAAO+D,EAGT,SAASC,GAAgB3gD,EAAKqX,EAAMmc,GAClC,IAAK,IAAIj2B,KAAQ8Z,EACD,SAAR9Z,GAA2B,SAARA,GAA2B,YAARA,GAAwBA,KAAQi2B,GACxExzB,EAAIy/C,gBAAgBliD,GAC1B,IAAK,IAAIk7B,KAAUjF,EACD,SAAViF,GAA+B,SAAVA,GAA+B,YAAVA,GAAwBjF,EAAIiF,IAAWphB,EAAKohB,IACxFz4B,EAAImgB,aAAasY,EAAQjF,EAAIiF,IACnC,GAAIphB,EAAKipC,OAAS9sB,EAAI8sB,MAAO,CAG3B,IAFA,IAAIM,EAAWvpC,EAAKipC,MAAQjpC,EAAKipC,MAAMhqD,MAAM,KAAK4I,OAAO2hD,SAAW/F,EAChEgG,EAAUttB,EAAI8sB,MAAQ9sB,EAAI8sB,MAAMhqD,MAAM,KAAK4I,OAAO2hD,SAAW/F,EACxDvmD,EAAI,EAAGA,EAAIqsD,EAASjpD,OAAQpD,KAA4C,GAAjCusD,EAAQxjC,QAAQsjC,EAASrsD,KACrEyL,EAAIg7C,UAAU9wB,OAAO02B,EAASrsD,IAClC,IAAK,IAAI+D,EAAM,EAAGA,EAAMwoD,EAAQnpD,OAAQW,KAAgD,GAAnCsoD,EAAStjC,QAAQwjC,EAAQxoD,KAC1E0H,EAAIg7C,UAAUja,IAAI+f,EAAQxoD,IACF,GAAxB0H,EAAIg7C,UAAUrjD,QACdqI,EAAIy/C,gBAAgB,SAE1B,GAAIpoC,EAAKoD,OAAS+Y,EAAI/Y,MAAO,CAC3B,GAAIpD,EAAKoD,MAEP,IADA,IAA4FmX,EAAxF/nB,EAAO,gFACJ+nB,EAAI/nB,EAAKiN,KAAKO,EAAKoD,QACtBza,EAAIya,MAAMsmC,eAAenvB,EAAE,IAE7B4B,EAAI/Y,QACJza,EAAIya,MAAM8jC,SAAW/qB,EAAI/Y,QAIjC,SAASwhC,GAAej8C,EAAK28C,EAAM/oD,GACjC,OAAOyrD,GAAer/C,EAAKA,EAAKqgD,GAAQf,GAAiB3C,EAAM/oD,EAAsB,GAAhBoM,EAAInH,WAI3E,SAASujD,GAAcz+B,EAAGrE,GACxB,GAAIqE,EAAEhmB,QAAU2hB,EAAE3hB,OAAU,OAAO,EACnC,IAAK,IAAIpD,EAAI,EAAGA,EAAIopB,EAAEhmB,OAAQpD,IAAO,IAAKopB,EAAEppB,GAAGnC,KAAK0S,GAAGwU,EAAE/kB,GAAGnC,MAAS,OAAO,EAC5E,OAAO,EAIT,SAAS8tD,GAAGlgD,GACV,IAAImwB,EAAOnwB,EAAIk+B,YAEf,OADAl+B,EAAI87B,WAAWijB,YAAY/+C,GACpBmwB,EAKT,IAAIusB,GAAkB,SAAyBz0B,EAAK+4B,GAClD1jD,KAAK2qB,IAAMA,EACX3qB,KAAK2jD,KAAOD,EAGZ1jD,KAAK9I,MAAQ,EAGb8I,KAAKm2C,MAAQ,GAEbn2C,KAAK6gD,SAAU,EAEf7gD,KAAK4jD,SAyLP,SAAkBptB,EAAMqtB,GACtB,IAAIC,EAAUD,EAAYE,EAAQD,EAAQlJ,SAASvgD,OAC/C2pD,EAAKxtB,EAAK5/B,WAAYyiB,EAAU,IAAI4qC,IAAKvpC,EAAU,GACvD2xB,EAAO,KAAO2X,EAAK,GAAG,CAEpB,IADA,IAAI1c,OAAO,IAET,GAAIyc,EAAO,CACT,IAAIlxB,EAAOixB,EAAQlJ,SAASmJ,EAAQ,GACpC,KAAIlxB,aAAgBorB,GAGb,CACL3W,EAAOzU,EACPkxB,IACA,MALAD,EAAUjxB,EACVkxB,EAAQlxB,EAAK+nB,SAASvgD,WAMnB,IAAIypD,GAAWD,EACpB,MAAMxX,EAGN0X,EAAQD,EAAQ5uD,OAAO0lD,SAAS56B,QAAQ8jC,GACxCA,EAAUA,EAAQ5uD,OAGtB,IAAIoB,EAAOgxC,EAAKhxC,KAChB,GAAKA,EAAL,CACA,GAAIA,GAAQkgC,EAAK/4B,MAAMumD,EAAK,GAAM,QAChCA,EACF3qC,EAAQuW,IAAI0X,EAAM0c,GAClBtpC,EAAQ9f,KAAK0sC,IAEf,MAAO,CAACpwC,MAAO8sD,EAAI3qC,QAASA,EAASqB,QAASA,EAAQ7C,WAxNtC+rC,CAASj5B,EAAIr0B,KAAKnB,QAASw1B,IA2N7C,SAASm1B,GAAYz/B,EAAGrE,GAAK,OAAOqE,EAAEvrB,KAAKyB,KAAOylB,EAAElnB,KAAKyB,KA6HzD,SAAS6nD,GAAaz8C,EAAOhM,EAAMD,EAAIxB,EAAM+/B,GAE3C,IADA,IAAI5pB,EAAS,GACJpT,EAAI,EAAGyqB,EAAM,EAAGzqB,EAAI0K,EAAMtH,OAAQpD,IAAK,CAC9C,IAAIwG,EAAQkE,EAAM1K,GAAIkE,EAAQumB,EAAK3oB,EAAM2oB,GAAOjkB,EAAMrI,KAClD+F,GAASzF,GAAMqD,GAAOpD,EACxB0U,EAAOzP,KAAK6C,IAERtC,EAAQxF,GAAQ0U,EAAOzP,KAAK6C,EAAMhI,MAAM,EAAGE,EAAOwF,EAAOjH,IACzD+/B,IACF5pB,EAAOzP,KAAKq5B,GACZA,EAAc,MAEZl7B,EAAMrD,GAAM2U,EAAOzP,KAAK6C,EAAMhI,MAAMC,EAAKyF,EAAOsC,EAAMrI,KAAMlB,KAGpE,OAAOmW,EAGT,SAAS65C,GAAiBhwD,EAAMiwD,GAC9B,IAAInQ,EAAS9/C,EAAK8jD,KAAKp1C,eAAgBrN,EAAMrB,EAAKP,MAAM4B,IACxD,IAAKy+C,EAAOoG,UAAa,OAAO,KAChC,IAAIhC,EAAclkD,EAAKgwB,QAAQk0B,YAAYpE,EAAOoG,WAAYgK,EAAWhM,GAAmC,GAApBA,EAAYhjD,KAChGkoC,EAAOppC,EAAKgwB,QAAQq0B,WAAWvE,EAAOoG,UAAWpG,EAAOsG,aAC5D,GAAIhd,EAAO,EAAK,OAAO,KACvB,IAA+B9lC,EAAS3D,EAApCkD,EAAQxB,EAAIO,QAAQwnC,GACxB,GAAIyW,EAAmBC,GAAS,CAE9B,IADAx8C,EAAUT,EACHqhD,IAAgBA,EAAY9hD,MAAQ8hD,EAAcA,EAAYljD,OACrE,GAAIkjD,GAAeA,EAAY9hD,KAAKH,QAAU,kBAA2BiiD,EAAY9hD,OAAS8hD,EAAYljD,UACjGkjD,EAAY9hD,KAAK4E,WA1/D9B,SAAkB5E,EAAMoP,EAAQxQ,GAC9B,IAAK,IAAIgJ,EAAoB,GAAVwH,EAAavM,EAAQuM,GAAUxP,EAASI,GAAO4H,GAAW/E,GAAQ,CACnF,GAAI7C,GAAQpB,EAAU,OAAO,EAC7B,IAAIgC,EAAQ67C,EAASz8C,GAErB,KADAA,EAAOA,EAAKkoC,YACC,OAAO,EACpBtgC,EAAUA,GAAoB,GAAThH,EACrBiC,EAAQA,GAASjC,GAAShB,EAASI,IAm/DG+tD,CAASrQ,EAAOoG,UAAWpG,EAAOsG,YAAalC,EAAY11C,MAAO,CACtG,IAAIzM,EAAMmiD,EAAYC,UACtBxkD,EAAY,IAAI,KAAcypC,GAAQrnC,EAAMc,EAAQxB,EAAIO,QAAQG,SAE7D,CACL,IAAI4uC,EAAS3wC,EAAKgwB,QAAQq0B,WAAWvE,EAAO+I,WAAY/I,EAAOgJ,cAC/D,GAAInY,EAAS,EAAK,OAAO,KACzBrtC,EAAUjC,EAAIO,QAAQ+uC,GAGnBhxC,IAEHA,EAAYywD,GAAiBpwD,EAAMsD,EAAST,EADvB,WAAVotD,GAAwBjwD,EAAKP,MAAME,UAAUypC,KAAOvmC,EAAMd,MAAQmuD,EAAY,GAAK,IAGhG,OAAOvwD,EAGT,SAAS0wD,GAAoBrwD,GAC3B,OAAOA,EAAKwgB,SAAWxgB,EAAKoT,WAC1Bk9C,GAAatwD,IAASyS,SAAS+yC,eAAiB/yC,SAAS+yC,cAAcv+B,SAASjnB,EAAKwO,KAGzF,SAAS+hD,GAAevwD,EAAMwoD,GAC5B,IAAIjkD,EAAMvE,EAAKP,MAAME,UAGrB,GAFA6wD,GAAkBxwD,EAAMuE,GAEnB8rD,GAAoBrwD,GAAzB,CAKA,IAAKwoD,GAASxoD,EAAKywD,WAAazwD,EAAKywD,UAAUC,cAAgBv6C,EAAO6gB,OAAQ,CAC5E,IAAI8oB,EAAS9/C,EAAK8jD,KAAKp1C,eAAgBiiD,EAAS3wD,EAAK4wD,YAAYC,iBACjE,GAAI/Q,EAAO+I,YAAcxJ,EAAqBS,EAAO+I,WAAY/I,EAAOgJ,aAC1B6H,EAAO9H,WAAY8H,EAAO7H,cAGtE,OAFA9oD,EAAKywD,UAAUK,sBAAuB,OACtC9wD,EAAK4wD,YAAYG,kBAOrB,GAFA/wD,EAAK4wD,YAAYI,sBAEbhxD,EAAKixD,eA2EX,SAA6BjxD,GAC3B,IAAI8/C,EAAS9/C,EAAK8jD,KAAKp1C,eAAgBpO,EAAQmS,SAASysC,cACpD98C,EAAOpC,EAAKixD,cAAcziD,IAAK0iD,EAAuB,OAAjB9uD,EAAKmoC,SAC1C2mB,EAAO5wD,EAAM6+C,OAAO/8C,EAAKkoC,WAAYuU,EAASz8C,GAAQ,GACnD9B,EAAM6+C,OAAO/8C,EAAM,GAC1B9B,EAAM0oD,UAAS,GACflJ,EAAOnxC,kBACPmxC,EAAOpiB,SAASp9B,IAMX4wD,IAAQlxD,EAAKP,MAAME,UAAUmyC,SAAW37B,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,KAC7E/7C,EAAK+uD,UAAW,EAChB/uD,EAAK+uD,UAAW,GAzFhBC,CAAoBpxD,OACf,CACL,IAEIqxD,EAAmBC,EAFnB3gB,EAASpsC,EAAIosC,OACbvH,EAAO7kC,EAAI6kC,MAEXmoB,IAAmChtD,aAAe,OAC/CA,EAAIC,MAAMxD,OAAO0D,gBAClB2sD,EAAoBG,GAAwBxxD,EAAMuE,EAAI9C,OACrD8C,EAAI3E,OAAU2E,EAAIC,MAAMxD,OAAO0D,gBAChC4sD,EAAkBE,GAAwBxxD,EAAMuE,EAAI/C,MAE1DxB,EAAKgwB,QAAQruB,aAAagvC,EAAQvH,EAAMppC,EAAK8jD,KAAM0E,GAC/C+I,KACEF,GAAqBI,GAAcJ,GACnCC,GAAmBG,GAAcH,IAEnC/sD,EAAIutC,QACN9xC,EAAKwO,IAAIg7C,UAAU9wB,OAAO,8BAE1B14B,EAAKwO,IAAIg7C,UAAUja,IAAI,6BACnB,sBAAuB98B,UAsCjC,SAAsCzS,GACpC,IAAIqB,EAAMrB,EAAKwO,IAAI8+B,cACnBjsC,EAAI+lB,oBAAoB,kBAAmBpnB,EAAK0xD,oBAChD,IAAI5R,EAAS9/C,EAAK8jD,KAAKp1C,eACnBtM,EAAO09C,EAAO+I,WAAYr3C,EAASsuC,EAAOgJ,aAC9CznD,EAAI6lB,iBAAiB,kBAAmBlnB,EAAK0xD,mBAAqB,WAC5D5R,EAAO+I,YAAczmD,GAAQ09C,EAAOgJ,cAAgBt3C,IACtDnQ,EAAI+lB,oBAAoB,kBAAmBpnB,EAAK0xD,oBAChDxrC,YAAW,WACJmqC,GAAoBrwD,KAASA,EAAKP,MAAME,UAAUmyC,SACnD9xC,EAAKwO,IAAIg7C,UAAU9wB,OAAO,+BAC7B,OAjDoCi5B,CAA6B3xD,IAIxEA,EAAK4wD,YAAYG,kBACjB/wD,EAAK4wD,YAAYgB,oBArbnB1G,GAAgB3gD,UAAUsnD,eAAiB,SAAyB5qD,EAAOpC,GACzE,GAAIoC,GAASpC,EAAb,CACA,IAAK,IAAI9B,EAAIkE,EAAOlE,EAAI8B,EAAK9B,IAAO+I,KAAK2qB,IAAIiwB,SAAS3jD,GAAGokB,UACzDrb,KAAK2qB,IAAIiwB,SAAS/tB,OAAO1xB,EAAOpC,EAAMoC,GACtC6E,KAAK6gD,SAAU,IAIjBzB,GAAgB3gD,UAAUmiD,YAAc,WACtC5gD,KAAK+lD,eAAe/lD,KAAK9I,MAAO8I,KAAK2qB,IAAIiwB,SAASvgD,SAMpD+kD,GAAgB3gD,UAAU2hD,YAAc,SAAsBz7C,EAAOoZ,EAAQ7pB,GAG3E,IAFA,IAAIsvC,EAAO,EAAGptC,EAAQ4J,KAAKm2C,MAAM97C,QAAU,EACvC2rD,EAAU3kD,KAAKc,IAAI/L,EAAOuO,EAAMtK,QAC7BmpC,EAAOwiB,IACNxiB,GAAQptC,EAAQ,EAAI4J,KAAK2qB,IAAM3qB,KAAKm2C,MAAO3S,EAAO,GAAM,IAAI0X,YAAYv2C,EAAM6+B,MAA6C,IAAnC7+B,EAAM6+B,GAAM1uC,KAAKC,KAAK2pB,UAClH8kB,IAEJ,KAAOA,EAAOptC,GACZ4J,KAAK4gD,cACL5gD,KAAK2qB,IAAIkwB,MAnlCG,EAolCZ76C,KAAK9I,MAAQ8I,KAAKm2C,MAAM/e,MACxBp3B,KAAK2qB,IAAM3qB,KAAKm2C,MAAM/e,MACtBhhC,IAEF,KAAOA,EAAQuO,EAAMtK,QAAQ,CAC3B2F,KAAKm2C,MAAMv7C,KAAKoF,KAAK2qB,IAAK3qB,KAAK9I,MAAQ,GAEvC,IADA,IAAIkG,GAAS,EACJnG,EAAI+I,KAAK9I,MAAOD,EAAIoK,KAAKc,IAAInC,KAAK9I,MAAQ,EAAG8I,KAAK2qB,IAAIiwB,SAASvgD,QAASpD,IAC/E,GAAI+I,KAAK2qB,IAAIiwB,SAAS3jD,GAAGikD,YAAYv2C,EAAMvO,IAAS,CAAEgH,EAAQnG,EAAG,MAEnE,GAAImG,GAAS,EACPA,EAAQ4C,KAAK9I,QACf8I,KAAK6gD,SAAU,EACf7gD,KAAK+lD,eAAe/lD,KAAK9I,MAAOkG,IAElC4C,KAAK2qB,IAAM3qB,KAAK2qB,IAAIiwB,SAAS56C,KAAK9I,WAC7B,CACL,IAAI+uD,EAAWhI,EAAa3jD,OAAO0F,KAAK2qB,IAAKhmB,EAAMvO,GAAQ2nB,EAAQ7pB,GACnE8L,KAAK2qB,IAAIiwB,SAAS/tB,OAAO7sB,KAAK9I,MAAO,EAAG+uD,GACxCjmD,KAAK2qB,IAAMs7B,EACXjmD,KAAK6gD,SAAU,EAEjB7gD,KAAK9I,MAAQ,EACbd,MAOJgpD,GAAgB3gD,UAAU8hD,cAAgB,SAAwBjqD,EAAMgoD,EAAWC,EAAWrnD,GAC5F,IAAgBgvD,EAAZ9oD,GAAS,EACb,GAAIlG,GAAS8I,KAAK4jD,SAAS1sD,QACtBgvD,EAAalmD,KAAK4jD,SAASlpC,QAAQxjB,EAAQ8I,KAAK4jD,SAAS1sD,QAAQhC,QAAU8K,KAAK2qB,KACjFu7B,EAAW/K,YAAY7kD,EAAMgoD,EAAWC,GAC1CnhD,EAAQ4C,KAAK2qB,IAAIiwB,SAAS56B,QAAQkmC,EAAYlmD,KAAK9I,YAEnD,IAAK,IAAID,EAAI+I,KAAK9I,MAAOsG,EAAI6D,KAAKc,IAAInC,KAAK2qB,IAAIiwB,SAASvgD,OAAQpD,EAAI,GAAIA,EAAIuG,EAAGvG,IAAK,CAClF,IAAIwG,EAAQuC,KAAK2qB,IAAIiwB,SAAS3jD,GAC9B,GAAIwG,EAAM09C,YAAY7kD,EAAMgoD,EAAWC,KAAev+C,KAAK4jD,SAASvqC,QAAQ8sC,IAAI1oD,GAAQ,CACtFL,EAAQnG,EACR,OAIN,QAAImG,EAAQ,KACZ4C,KAAK+lD,eAAe/lD,KAAK9I,MAAOkG,GAChC4C,KAAK9I,SACE,IAGTkoD,GAAgB3gD,UAAUgiD,aAAe,SAAuBnqD,EAAMgoD,EAAWC,EAAWrnD,EAAOhD,GAEjG,QADY8L,KAAK2qB,IAAIiwB,SAAS1jD,GACnBu1B,OAAOn2B,EAAMgoD,EAAWC,EAAWrqD,KAC9C8L,KAAK+lD,eAAe/lD,KAAK9I,MAAOA,GAChC8I,KAAK9I,MAAQA,EAAQ,GACd,IAGTkoD,GAAgB3gD,UAAU+hD,mBAAqB,SAA6B4F,GAC1E,OAAS,CACP,IAAIlxD,EAASkxD,EAAQ5nB,WACrB,IAAKtpC,EAAU,OAAQ,EACvB,GAAIA,GAAU8K,KAAK2qB,IAAIhG,WAAY,CACjC,IAAI2iB,EAAO8e,EAAQtS,WACnB,GAAIxM,EAAQ,IAAK,IAAIrwC,EAAI+I,KAAK9I,MAAOD,EAAI+I,KAAK2qB,IAAIiwB,SAASvgD,OAAQpD,IACjE,GAAI+I,KAAK2qB,IAAIiwB,SAAS3jD,IAAMqwC,EAAQ,OAAOrwC,EAE7C,OAAQ,EAEVmvD,EAAUlxD,IAOdkqD,GAAgB3gD,UAAUiiD,eAAiB,SAAyBpqD,EAAMgoD,EAAWC,EAAWrqD,EAAMgD,GACpG,IAAK,IAAID,EAAI+I,KAAK9I,MAAOD,EAAI+I,KAAK2qB,IAAIiwB,SAASvgD,OAAQpD,IAAK,CAC1D,IAAI47B,EAAO7yB,KAAK2qB,IAAIiwB,SAAS3jD,GAC7B,GAAI47B,aAAgBwrB,EAAc,CAChC,IAAIuF,EAAW5jD,KAAK4jD,SAASvqC,QAAQmT,IAAIqG,GACzC,GAAgB,MAAZ+wB,GAAoBA,GAAY1sD,EAAS,OAAO,EACpD,IAAImvD,EAAUxzB,EAAKnwB,IAQnB,KAHa1C,KAAK2jD,OAAS0C,GAAWrmD,KAAK2jD,MAA4B,GAApB0C,EAAQ9qD,UAAiB8qD,EAAQlrC,SAASnb,KAAK2jD,KAAKnlB,gBACjGloC,EAAK8K,QAAUyxB,EAAKv8B,MAAQu8B,EAAKv8B,KAAK8K,QAAUyxB,EAAKipB,QAAQ3b,WAAa7pC,EAAK0K,MA7qCvB,GA8qCxD6xB,EAAKgoB,OAAuBiE,GAAcR,EAAWzrB,EAAKyrB,cACjDzrB,EAAKpG,OAAOn2B,EAAMgoD,EAAWC,EAAWrqD,GAIrD,OAHA8L,KAAK+lD,eAAe/lD,KAAK9I,MAAOD,GAC5B47B,EAAKnwB,KAAO2jD,IAAWrmD,KAAK6gD,SAAU,GAC1C7gD,KAAK9I,SACE,EAET,OAGJ,OAAO,GAKTkoD,GAAgB3gD,UAAUkzB,QAAU,SAAkBr7B,EAAMgoD,EAAWC,EAAWrqD,EAAM+B,GACtF+J,KAAK2qB,IAAIiwB,SAAS/tB,OAAO7sB,KAAK9I,QAAS,EAAGmnD,EAAa/jD,OAAO0F,KAAK2qB,IAAKr0B,EAAMgoD,EAAWC,EAAWrqD,EAAM+B,IAC1G+J,KAAK6gD,SAAU,GAGjBzB,GAAgB3gD,UAAU4hD,YAAc,SAAsBnE,EAAQhoD,EAAM+B,GAC1E,IAAI48B,EAAO7yB,KAAK9I,MAAQ8I,KAAK2qB,IAAIiwB,SAASvgD,OAAS2F,KAAK2qB,IAAIiwB,SAAS56C,KAAK9I,OAAS,KACnF,IAAI27B,IAAQA,EAAKooB,cAAciB,IAAYA,GAAUrpB,EAAKqpB,QAAWrpB,EAAKqpB,OAAOpnD,KAAKupB,MAAMmgB,WAErF,CACL,IAAI8I,EAAO,IAAI2U,EAAej8C,KAAK2qB,IAAKuxB,EAAQhoD,EAAM+B,GACtD+J,KAAK2qB,IAAIiwB,SAAS/tB,OAAO7sB,KAAK9I,QAAS,EAAGowC,GAC1CtnC,KAAK6gD,SAAU,OAJf7gD,KAAK9I,SAUTkoD,GAAgB3gD,UAAUkiD,kBAAoB,WAE5C,IADA,IAAIjqD,EAAYsJ,KAAK2qB,IAAIiwB,SAAS56C,KAAK9I,MAAQ,GACxCR,aAAqBunD,GAAgBvnD,EAAYA,EAAUkkD,SAASlkD,EAAUkkD,SAASvgD,OAAS,GAElG3D,GACCA,aAAqBmoD,IACvB,MAAMriD,KAAK9F,EAAUJ,KAAK0K,SAEvBqJ,EAAO8gB,QAAU9gB,EAAO6gB,SAAWx0B,GAA8C,SAAjCA,EAAUgM,IAAImxC,iBAC/D7zC,KAAKsmD,YAAY,OACrBtmD,KAAKsmD,YAAY,QAIrBlH,GAAgB3gD,UAAU6nD,YAAc,SAAsB7nB,GAC5D,GAAIz+B,KAAK9I,MAAQ8I,KAAK2qB,IAAIiwB,SAASvgD,QAAU2F,KAAK2qB,IAAIiwB,SAAS56C,KAAK9I,OAAOkkD,YAAY3c,GACrFz+B,KAAK9I,YACA,CACL,IAAIwL,EAAMiE,SAAS6R,cAAcimB,GACjB,OAAZA,IAAqB/7B,EAAI6jD,UAAY,yBACzB,MAAZ9nB,IAAoB/7B,EAAI6jD,UAAY,6BACxCvmD,KAAK2qB,IAAIiwB,SAAS/tB,OAAO7sB,KAAK9I,QAAS,EAAG,IAAI8kD,GAAqBh8C,KAAK2qB,IAAK6yB,EAAS96C,EAAK,OAC3F1C,KAAK6gD,SAAU,IAkRnB,IAAI4E,GAAgCp7C,EAAO8gB,QAAU9gB,EAAO6gB,QAAU7gB,EAAOmoC,eAAiB,GAE9F,SAASkT,GAAwBxxD,EAAM+B,GACrC,IAAIa,EAAM5C,EAAKgwB,QAAQ20B,WAAW5iD,EAAK,GACnCK,EAAOQ,EAAIR,KACXoP,EAAS5O,EAAI4O,OACblQ,EAAQkQ,EAASpP,EAAK0rC,WAAW3nC,OAAS/D,EAAK0rC,WAAWt8B,GAAU,KACpE9Q,EAAS8Q,EAASpP,EAAK0rC,WAAWt8B,EAAS,GAAK,KACpD,GAAI2E,EAAO8gB,QAAU31B,GAAkC,SAAzBA,EAAMq+C,gBAA8B,OAAO3wB,GAAY1tB,GACrF,KAAMA,GAAkC,SAAzBA,EAAMq+C,iBAAiCj/C,GAAoC,SAA1BA,EAAOi/C,iBAA6B,CAClG,GAAIr+C,EAAS,OAAO0tB,GAAY1tB,GAC3B,GAAIZ,EAAU,OAAOsuB,GAAYtuB,IAI1C,SAASsuB,GAAYrB,GAGnB,OAFAA,EAAQgyB,gBAAkB,OACtBxpC,EAAO8gB,QAAUtJ,EAAQ3D,YAAa2D,EAAQ3D,WAAY,EAAO2D,EAAQ2kC,cAAe,GACrF3kC,EAGT,SAAS8jC,GAAc9jC,GACrBA,EAAQgyB,gBAAkB,QACtBhyB,EAAQ2kC,eAAgB3kC,EAAQ3D,WAAY,EAAM2D,EAAQ2kC,aAAe,MAsC/E,SAAS9B,GAAkBxwD,EAAMuE,GAC/B,GAAIA,aAAe,KAAe,CAChC,IAAI6uC,EAAOpzC,EAAKgwB,QAAQ63B,OAAOtjD,EAAI9C,MAC/B2xC,GAAQpzC,EAAKuyD,uBACfC,GAAmBxyD,GACfozC,GAAQA,EAAK2a,aACjB/tD,EAAKuyD,qBAAuBnf,QAG9Bof,GAAmBxyD,GAKvB,SAASwyD,GAAmBxyD,GACtBA,EAAKuyD,uBACHvyD,EAAKuyD,qBAAqBvxD,QAC1BhB,EAAKuyD,qBAAqBvE,eAC9BhuD,EAAKuyD,qBAAuB,MAIhC,SAASnC,GAAiBpwD,EAAMsD,EAAST,EAAOoS,GAC9C,OAAOjV,EAAKgX,SAAS,0BAA0B,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsD,EAAST,OACjF,aAAsBS,EAAST,EAAOoS,GAQ7C,SAASq7C,GAAatwD,GACpB,IAAIuE,EAAMvE,EAAK8jD,KAAKp1C,eACpB,IAAKnK,EAAIskD,WAAc,OAAO,EAC9B,IAIE,OAAO7oD,EAAKwO,IAAIyY,SAAoC,GAA3B1iB,EAAIskD,WAAWxhD,SAAgB9C,EAAIskD,WAAWve,WAAa/lC,EAAIskD,cACrF7oD,EAAKwgB,UAAYxgB,EAAKwO,IAAIyY,SAAmC,GAA1B1iB,EAAI2hD,UAAU7+C,SAAgB9C,EAAI2hD,UAAU5b,WAAa/lC,EAAI2hD,YACnG,MAAM1wB,GACN,OAAO,GAUX,SAASi9B,GAAmBhzD,EAAOyxC,GACjC,IAAItuC,EAAMnD,EAAME,UACZ2D,EAAUV,EAAIU,QACdT,EAAQD,EAAIC,MACZ6vD,EAAQxhB,EAAM,EAAI5tC,EAAQ8J,IAAIvK,GAASS,EAAQ2K,IAAIpL,GACnDiH,EAAU4oD,EAAM1xD,OAAO0D,cAAwBguD,EAAMxwD,MAAQzC,EAAM4B,IAAIO,QAAQsvC,EAAM,EAAIwhB,EAAMpxD,QAAUoxD,EAAMhyD,UAAY,KAApFgyD,EAC3C,OAAO5oD,GAAU,cAAmBA,EAAQonC,GAG9C,SAASpwB,GAAM9gB,EAAMuE,GAEnB,OADAvE,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa4C,GAAKzE,mBACvC,EAGT,SAAS6yD,GAAmB3yD,EAAMkxC,EAAK0hB,GACrC,IAAIruD,EAAMvE,EAAKP,MAAME,UACrB,KAAI4E,aAAe,MAuBZ,IAAIA,aAAe,MAAiBA,EAAInC,KAAK4E,SAClD,OAAO8Z,GAAM9gB,EAAM,IAAI,KAAckxC,EAAM,EAAI3sC,EAAIE,IAAMF,EAAIC,QAE7D,IAAIy9B,EAASwwB,GAAmBzyD,EAAKP,MAAOyxC,GAC5C,QAAIjP,GAAiBnhB,GAAM9gB,EAAMiiC,GA1BjC,IAAK19B,EAAI3E,OAASgzD,EAAK9mC,QAAQ,MAAQ,EACrC,OAAO,EACF,GAAI9rB,EAAKE,eAAegxC,EAAM,EAAI,QAAU,QAAS,CAC1D,IAAIvS,EAAO8zB,GAAmBzyD,EAAKP,MAAOyxC,GAC1C,SAAIvS,GAASA,aAAgB,OAAyB7d,GAAM9gB,EAAM2+B,GAE7D,KAAMxoB,EAAOihB,KAAOw7B,EAAK9mC,QAAQ,MAAQ,GAAI,CAClD,IAAsGsnB,EAAlGvwC,EAAQ0B,EAAI1B,MAAOT,EAAOS,EAAM+6B,WAAa,KAAOsT,EAAM,EAAIruC,EAAMlC,WAAakC,EAAMM,UAC3F,IAAKf,GAAQA,EAAK8K,OAAU,OAAO,EACnC,IAAI2lD,EAAU3hB,EAAM,EAAIruC,EAAMd,IAAMK,EAAKJ,SAAWa,EAAMd,IAC1D,SAAMK,EAAKH,SAAWmxC,EAAOpzC,EAAKgwB,QAAQ63B,OAAOgL,MAAczf,EAAK3iB,cAChE,kBAA2BruB,GACtB0e,GAAM9gB,EAAM,IAAI,KAAckxC,EAAM,EAAIlxC,EAAKP,MAAM4B,IAAIO,QAAQiB,EAAMd,IAAMK,EAAKJ,UAAYa,MAC1FsT,EAAOuoC,QAIT59B,GAAM9gB,EAAM,IAAI,KAAcA,EAAKP,MAAM4B,IAAIO,QAAQsvC,EAAM,EAAI2hB,EAAUA,EAAUzwD,EAAKJ,cAcvG,SAAS8wD,GAAQ1wD,GACf,OAAwB,GAAjBA,EAAKiF,SAAgBjF,EAAK6pC,UAAU9lC,OAAS/D,EAAK0rC,WAAW3nC,OAGtE,SAAS4sD,GAAYvkD,GACnB,IAAI4kC,EAAO5kC,EAAIoxC,WACf,OAAOxM,GAAqB,GAAbA,EAAKlyC,OAAcsN,EAAIk+B,aAA+B,MAAhBl+B,EAAI+7B,UAK3D,SAASyoB,GAAqBhzD,GAC5B,IAAIuE,EAAMvE,EAAK8jD,KAAKp1C,eAChBtM,EAAOmC,EAAI2hD,UAAW10C,EAASjN,EAAI6hD,YACvC,GAAKhkD,EAAL,CACA,IAAI6wD,EAAUC,EAAY1K,GAAQ,EAKlC,IADIryC,EAAOghB,OAA0B,GAAjB/0B,EAAKiF,UAAiBmK,EAASshD,GAAQ1wD,IAAS2wD,GAAY3wD,EAAK0rC,WAAWt8B,MAAYg3C,GAAQ,KAElH,GAAIh3C,EAAS,EAAG,CACd,GAAqB,GAAjBpP,EAAKiF,SACP,MAEA,IAAI3G,EAAS0B,EAAK0rC,WAAWt8B,EAAS,GACtC,GAAIuhD,GAAYryD,GACduyD,EAAW7wD,EACX8wD,IAAe1hD,MACV,IAAuB,GAAnB9Q,EAAO2G,SAGT,MADPmK,GADApP,EAAO1B,GACOurC,UAAU9lC,YAGvB,IAAIgtD,GAAY/wD,GACrB,MAGA,IADA,IAAIyjB,EAAOzjB,EAAK+pC,gBACTtmB,GAAQktC,GAAYltC,IACzBotC,EAAW7wD,EAAKkoC,WAChB4oB,EAAarU,EAASh5B,GACtBA,EAAOA,EAAKsmB,gBAEd,GAAKtmB,EAMHrU,EAASshD,GADT1wD,EAAOyjB,OALE,CAET,IADAzjB,EAAOA,EAAKkoC,aACAtqC,EAAKwO,IAAO,MACxBgD,EAAS,GAOXg3C,EAAS4K,GAAYpzD,EAAMuE,EAAKnC,EAAMoP,GACjCyhD,GAAYG,GAAYpzD,EAAMuE,EAAK0uD,EAAUC,IAKxD,SAASG,GAAsBrzD,GAC7B,IAAIuE,EAAMvE,EAAK8jD,KAAKp1C,eAChBtM,EAAOmC,EAAI2hD,UAAW10C,EAASjN,EAAI6hD,YACvC,GAAKhkD,EAAL,CAGA,IAFA,IACI6wD,EAAUC,EADVtrD,EAAMkrD,GAAQ1wD,KAGhB,GAAIoP,EAAS5J,EAAK,CAChB,GAAqB,GAAjBxF,EAAKiF,SAAiB,MAE1B,IAAI0rD,GADQ3wD,EAAK0rC,WAAWt8B,IAKrB,MAHLyhD,EAAW7wD,EACX8wD,IAAe1hD,MAGZ,IAAI2hD,GAAY/wD,GACrB,MAGA,IADA,IAAIu8B,EAAOv8B,EAAKsqC,YACT/N,GAAQo0B,GAAYp0B,IACzBs0B,EAAWt0B,EAAK2L,WAChB4oB,EAAarU,EAASlgB,GAAQ,EAC9BA,EAAOA,EAAK+N,YAEd,GAAK/N,EAMHntB,EAAS,EACT5J,EAAMkrD,GAFN1wD,EAAOu8B,OALE,CAET,IADAv8B,EAAOA,EAAKkoC,aACAtqC,EAAKwO,IAAO,MACxBgD,EAAS5J,EAAM,GAQjBqrD,GAAYG,GAAYpzD,EAAMuE,EAAK0uD,EAAUC,IAGnD,SAASC,GAAY3kD,GACnB,IAAI4kC,EAAO5kC,EAAIoxC,WACf,OAAOxM,GAAQA,EAAKhxC,MAAQgxC,EAAKhxC,KAAK4C,QAGxC,SAASouD,GAAYpzD,EAAMuE,EAAKnC,EAAMoP,GACpC,GAAIquC,EAAmBt7C,GAAM,CAC3B,IAAIjE,EAAQmS,SAASysC,cACrB5+C,EAAM6+C,OAAO/8C,EAAMoP,GACnBlR,EAAM8+C,SAASh9C,EAAMoP,GACrBjN,EAAIoK,kBACJpK,EAAIm5B,SAASp9B,QACJiE,EAAIiI,QACbjI,EAAIiI,OAAOpK,EAAMoP,GAEnBxR,EAAK4wD,YAAYG,kBACjB,IAAItxD,EAAQO,EAAKP,MAEjBymB,YAAW,WACLlmB,EAAKP,OAASA,GAAS8wD,GAAevwD,KACzC,IAOL,SAASszD,GAAiBtzD,EAAMkxC,EAAK0hB,GACnC,IAAIruD,EAAMvE,EAAKP,MAAME,UACrB,GAAI4E,aAAe,OAAkBA,EAAI3E,OAASgzD,EAAK9mC,QAAQ,MAAQ,EAAK,OAAO,EACnF,GAAI3V,EAAOihB,KAAOw7B,EAAK9mC,QAAQ,MAAQ,EAAK,OAAO,EACnD,IAAItnB,EAAQD,EAAIC,MACZC,EAAMF,EAAIE,IAEd,IAAKD,EAAMxD,OAAO0D,eAAiB1E,EAAKE,eAAegxC,EAAM,EAAI,KAAO,QAAS,CAC/E,IAAIvS,EAAO8zB,GAAmBzyD,EAAKP,MAAOyxC,GAC1C,GAAIvS,GAASA,aAAgB,KACzB,OAAO7d,GAAM9gB,EAAM2+B,GAEzB,IAAKn6B,EAAMxD,OAAO0D,cAAe,CAC/B,IAAIrC,EAAO6uC,EAAM,EAAI1sC,EAAQC,EACzB8uD,EAAShvD,aAAe,KAAe,UAAelC,EAAM6uC,GAAO,cAAmB7uC,EAAM6uC,GAChG,QAAOqiB,GAASzyC,GAAM9gB,EAAMuzD,GAE9B,OAAO,EAGT,SAASC,GAA2BxzD,EAAMkxC,GACxC,KAAMlxC,EAAKP,MAAME,qBAAqB,MAAkB,OAAO,EAC/D,IAAIiD,EAAM5C,EAAKP,MAAME,UACjBkD,EAAQD,EAAIC,MACZS,EAAUV,EAAIU,QACd1D,EAAQgD,EAAIhD,MAChB,IAAKiD,EAAMW,WAAWF,GAAY,OAAO,EACzC,IAAK1D,EAAS,OAAO,EACrB,GAAII,EAAKE,eAAegxC,EAAM,EAAI,UAAY,YAAe,OAAO,EACpE,IAAIuiB,GAAY5wD,EAAM+6B,aAAesT,EAAM,EAAIruC,EAAMlC,WAAakC,EAAMM,WACxE,GAAIswD,IAAaA,EAASvmD,OAAQ,CAChC,IAAIrN,EAAKG,EAAKP,MAAMI,GAIpB,OAHIqxC,EAAM,EAAKrxC,EAAGsC,OAAOU,EAAMd,IAAM0xD,EAASzxD,SAAUa,EAAMd,KACvDlC,EAAGsC,OAAOU,EAAMd,IAAKc,EAAMd,IAAM0xD,EAASzxD,UACjDhC,EAAKN,SAASG,IACP,EAET,OAAO,EAGT,SAAS6zD,GAAe1zD,EAAMoC,EAAM3C,GAClCO,EAAK4wD,YAAYnH,OACjBrnD,EAAKu9C,gBAAkBlgD,EACvBO,EAAK4wD,YAAY3pD,QAqCnB,SAAS0sD,GAAe3zD,EAAMsW,GAC5B,IAAI/S,EAAO+S,EAAMwhB,QAAS86B,EAV5B,SAAiBt8C,GACf,IAAIH,EAAS,GAKb,OAJIG,EAAMG,UAAWN,GAAU,KAC3BG,EAAMI,UAAWP,GAAU,KAC3BG,EAAME,SAAUL,GAAU,KAC1BG,EAAMK,WAAYR,GAAU,KACzBA,EAI0By9C,CAAQt9C,GACzC,OAAY,GAAR/S,GAAc4S,EAAOihB,KAAe,IAAR7zB,GAAsB,KAARqvD,EACrCY,GAA2BxzD,GAAO,IAAMgzD,GAAqBhzD,GACnD,IAARuD,GAAe4S,EAAOihB,KAAe,IAAR7zB,GAAsB,KAARqvD,EAC7CY,GAA2BxzD,EAAM,IAAMqzD,GAAsBrzD,GACnD,IAARuD,GAAsB,IAARA,IAEN,IAARA,EACFovD,GAAmB3yD,GAAO,EAAG4yD,IAASI,GAAqBhzD,GACjD,IAARuD,EACFovD,GAAmB3yD,EAAM,EAAG4yD,IAASS,GAAsBrzD,GACjD,IAARuD,EACF+vD,GAAiBtzD,GAAO,EAAG4yD,IAASI,GAAqBhzD,GAC/C,IAARuD,EA3Cb,SAA4BvD,GAC1B,GAAKmW,EAAO8gB,UAAUj3B,EAAKP,MAAME,UAAUkD,MAAM1C,aAAe,GAAhE,CACA,IAAIyC,EAAM5C,EAAK8jD,KAAKp1C,eAChBw3C,EAAYtjD,EAAIsjD,UAChBE,EAAcxjD,EAAIwjD,YACtB,GAAIF,GAAmC,GAAtBA,EAAU7+C,UAAgC,GAAf++C,GACxCF,EAAU3jD,YAAsD,SAAxC2jD,EAAU3jD,WAAWo9C,gBAA4B,CAC3E,IAAIp2C,EAAQ28C,EAAU3jD,WACtBmxD,GAAe1zD,EAAMuJ,GAAO,GAC5B2c,YAAW,WAAc,OAAOwtC,GAAe1zD,EAAMuJ,GAAO,KAAW,MAmChEsqD,CAAmB7zD,IAASszD,GAAiBtzD,EAAM,EAAG4yD,IAASS,GAAsBrzD,GACnF4yD,IAASz8C,EAAOihB,IAAM,IAAM,OACnB,IAAR7zB,GAAsB,IAARA,GAAsB,IAARA,GAAsB,IAARA,IA2DxD,SAASqpC,GAAap+B,GACpB,IAAI4kC,EAAO5kC,EAAIoxC,WACf,GAAIxM,EACF,OAAOA,EAAKpqB,YACP,GAAoB,MAAhBxa,EAAI+7B,UAAoB/7B,EAAI87B,WAAY,CAIjD,GAAIn0B,EAAO8gB,QAAU,aAAa3uB,KAAKkG,EAAI87B,WAAWC,UAAW,CAC/D,IAAIwC,EAAOt6B,SAAS6R,cAAc,OAElC,OADAyoB,EAAKxoB,YAAY9R,SAAS6R,cAAc,OACjC,CAACyoB,KAAMA,GACT,GAAIv+B,EAAI87B,WAAW9nC,WAAagM,GAAO2H,EAAO8gB,QAAU,gBAAgB3uB,KAAKkG,EAAI87B,WAAWC,UACjG,MAAO,CAACsC,QAAQ,QAEb,GAAoB,OAAhBr+B,EAAI+7B,UAAqB/7B,EAAI6a,aAAa,oBACnD,MAAO,CAACwjB,QAAQ,GAIpB,SAASinB,GAAc9zD,EAAMyB,EAAMD,EAAIuyD,EAAUzhC,GAC/C,GAAI7wB,EAAO,EAAX,CACE,IAAIwuD,EAASjwD,EAAKg0D,kBAAoBzhB,KAAKC,MAAQ,GAAKxyC,EAAKi0D,oBAAsB,KAC/EC,EAASlE,GAAiBhwD,EAAMiwD,GACpC,GAAIiE,IAAWl0D,EAAKP,MAAME,UAAU2T,GAAG4gD,GAAS,CAC9C,IAAIC,EAAOn0D,EAAKP,MAAMI,GAAG8B,aAAauyD,GACxB,WAAVjE,EAAuBkE,EAAKz6C,QAAQ,WAAW,GAChC,OAAVu2C,GAAmBkE,EAAKr0D,iBACjCE,EAAKN,SAASy0D,QAPlB,CAYA,IAAI52B,EAAUv9B,EAAKP,MAAM4B,IAAIO,QAAQH,GACjC2yD,EAAS72B,EAAQnkB,YAAY5X,GACjCC,EAAO87B,EAAQ78B,OAAO0zD,EAAS,GAC/B5yD,EAAKxB,EAAKP,MAAM4B,IAAIO,QAAQJ,GAAIF,MAAM8yD,EAAS,GAE/C,IAAI7vD,EAAMvE,EAAKP,MAAME,UACjB6U,EAtFN,SAAsBxU,EAAMq0D,EAAOC,GACjC,IAAI1xD,EAAM5C,EAAKgwB,QAAQk4B,WAAWmM,EAAOC,GACrCtzD,EAAS4B,EAAIR,KACb+lD,EAAavlD,EAAIulD,WACjBC,EAAWxlD,EAAIwlD,SACf3mD,EAAOmB,EAAInB,KACXD,EAAKoB,EAAIpB,GAETs+C,EAAS9/C,EAAK8jD,KAAKp1C,eAAgBwC,EAAO,KAAMy/B,EAASmP,EAAO+I,WAQpE,GAPIlY,GAAU3wC,EAAKwO,IAAIyY,SAA4B,GAAnB0pB,EAAOtpC,SAAgBspC,EAASA,EAAOrG,cACrEp5B,EAAO,CAAC,CAAC9O,KAAMuuC,EAAQn/B,OAAQsuC,EAAOgJ,eACjCjJ,EAAmBC,IACpB5uC,EAAKxK,KAAK,CAACtE,KAAM09C,EAAOoG,UAAW10C,OAAQsuC,EAAOsG,eAIpDjwC,EAAO6gB,QAA+B,IAArBh3B,EAAKu0D,YACxB,IAAK,IAAI/mC,EAAM46B,EAAU56B,EAAM26B,EAAY36B,IAAO,CAChD,IAAIprB,EAAOpB,EAAO8sC,WAAWtgB,EAAM,GAAI4lB,EAAOhxC,EAAKw9C,WACnD,GAAqB,MAAjBx9C,EAAKmoC,WAAqB6I,EAAM,CAAEgV,EAAW56B,EAAK,MACtD,IAAK4lB,GAAQA,EAAKlyC,KAAQ,MAG9B,IAAIszD,EAAWx0D,EAAKP,MAAM4B,IACtBiT,EAAStU,EAAKgX,SAAS,cAAgB,gBAAqBhX,EAAKP,MAAM6N,QACvE9I,EAAQgwD,EAAS5yD,QAAQH,GAEzB8C,EAAM,KAAMlD,EAAMiT,EAAOE,MAAMxT,EAAQ,CACzC0oB,QAASllB,EAAMxD,OACf6pC,SAAUrmC,EAAMxD,OAAOkD,eAAeM,EAAMxB,SAC5CurC,SAAS,EACT9sC,KAAM0mD,EACN3mD,GAAI4mD,EACJzzC,mBAAoD,OAAhCnQ,EAAMxD,OAAOJ,KAAK+jC,YAAsB,OAC5D8vB,iBAAiB,EACjB3pB,cAAe55B,EACf07B,aAAcA,GACdvhC,QAAS7G,IAEX,GAAI0M,GAAuB,MAAfA,EAAK,GAAGnP,IAAa,CAC/B,IAAI2yD,EAAWxjD,EAAK,GAAGnP,IAAKqnC,EAAOl4B,EAAK,IAAMA,EAAK,GAAGnP,IAC1C,MAARqnC,IAAgBA,EAAOsrB,GAC3BnwD,EAAM,CAACosC,OAAQ+jB,EAAWjzD,EAAM2nC,KAAMA,EAAO3nC,GAE/C,MAAO,CAACJ,IAAKA,EAAKkD,IAAKA,EAAK9C,KAAMA,EAAMD,GAAIA,GA0ChCmzD,CAAa30D,EAAMyB,EAAMD,GAGrC,GAAI2U,EAAO6gB,QAAUh3B,EAAKixD,eAAiBz8C,EAAMjQ,KAAOiQ,EAAMjQ,IAAIosC,QAAU3wC,EAAKixD,cAAc9F,KAAK1pD,KAAM,CACxG,IAAIqL,EAAO9M,EAAKixD,cAAc9F,KAAKvqD,KAAKupB,MAAMuiB,YAC1CxrC,EAAO4L,GAAQA,EAAKm/B,UAAYn/B,EAAKm/B,UAAU9lC,OAAS,EAC5DqO,EAAMjQ,IAAM,CAACosC,OAAQn8B,EAAMjQ,IAAIosC,OAASzvC,EAAMkoC,KAAM50B,EAAMjQ,IAAIosC,OAASzvC,GAGzE,IACI0zD,EAAcC,EADdxzD,EAAMrB,EAAKP,MAAM4B,IAAKyzD,EAAUzzD,EAAIE,MAAMiT,EAAM/S,KAAM+S,EAAMhT,IAGvC,IAArBxB,EAAKu0D,aAAqBhiB,KAAKC,MAAQ,IAAMxyC,EAAK+0D,iBACpDH,EAAe50D,EAAKP,MAAME,UAAU6B,GACpCqzD,EAAgB,QAEhBD,EAAe50D,EAAKP,MAAME,UAAU8B,KACpCozD,EAAgB,SAElB70D,EAAKu0D,YAAc,KAEnB,IAAIh/B,EA+MN,SAAkBpJ,EAAGrE,EAAG/lB,EAAK6yD,EAAcC,GACzC,IAAI5tD,EAAQklB,EAAEvE,cAAcE,EAAG/lB,GAC/B,GAAa,MAATkF,EAAiB,OAAO,KAC5B,IAAIrE,EAAMupB,EAAEtE,YAAYC,EAAG/lB,EAAMoqB,EAAEjrB,KAAMa,EAAM+lB,EAAE5mB,MAC7C8zD,EAAOpyD,EAAIupB,EACX8oC,EAAOryD,EAAIklB,EACf,GAAqB,OAAjB+sC,EAAwB,CAE1BD,GAAgBI,EADH7nD,KAAKC,IAAI,EAAGnG,EAAQkG,KAAKc,IAAI+mD,EAAMC,IAChBhuD,EAElC,GAAI+tD,EAAO/tD,GAASklB,EAAEjrB,KAAO4mB,EAAE5mB,KAAM,CAGnC+zD,GADAhuD,GADW2tD,GAAgB3tD,GAAS2tD,GAAgBI,EAAO/tD,EAAQ2tD,EAAe,IAElEK,EAAOD,GACvBA,EAAO/tD,OACF,GAAIguD,EAAOhuD,EAAO,CAGvB+tD,GADA/tD,GADa2tD,GAAgB3tD,GAAS2tD,GAAgBK,EAAOhuD,EAAQ2tD,EAAe,IAEpEI,EAAOC,GACvBA,EAAOhuD,EAET,MAAO,CAACA,MAAOA,EAAO+tD,KAAMA,EAAMC,KAAMA,GApO3BC,CAASJ,EAAQ7zD,QAASuT,EAAMnT,IAAIJ,QAASuT,EAAM/S,KAAMmzD,EAAcC,GACpF,IAAKt/B,EAAQ,CACX,KAAIw+B,GAAYxvD,aAAe,OAAkBA,EAAI3E,OAAS2E,EAAI1B,MAAMW,WAAWe,EAAIjB,WAClFtD,EAAKklB,WAAe1Q,EAAMjQ,KAAOiQ,EAAMjQ,IAAIosC,QAAUn8B,EAAMjQ,IAAI6kC,KAE7D,KAAKjzB,EAAOooC,KAAOv+C,EAAKm1D,aAAe5iB,KAAKC,MAAQ,KAAOr8B,EAAOsoC,UAC9DnsB,EAAWrP,MAAK,SAAUxG,GAAK,MAAqB,OAAdA,EAAE8tB,UAAmC,KAAd9tB,EAAE8tB,aAC/DvqC,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,GAAI,aAEnF,YADAngD,EAAKm1D,aAAe,GAGpB,GAAI3gD,EAAMjQ,IAAK,CACb,IAAI6wD,EAAQC,GAAiBr1D,EAAMA,EAAKP,MAAM4B,IAAKmT,EAAMjQ,KACrD6wD,IAAUA,EAAM9hD,GAAGtT,EAAKP,MAAME,YAAcK,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAayzD,IAE3F,OAXA7/B,EAAS,CAACtuB,MAAO1C,EAAI9C,KAAMuzD,KAAMzwD,EAAI/C,GAAIyzD,KAAM1wD,EAAI/C,IAcvDxB,EAAKs1D,iBAIDt1D,EAAKP,MAAME,UAAU8B,KAAOzB,EAAKP,MAAME,UAAU6B,IACjD+zB,EAAOtuB,OAASsuB,EAAO0/B,MACvBj1D,EAAKP,MAAME,qBAAqB,OAC9B41B,EAAOtuB,MAAQjH,EAAKP,MAAME,UAAU8B,MAAQ8zB,EAAOtuB,OAASjH,EAAKP,MAAME,UAAU8B,KAAO,EAC1F8zB,EAAOtuB,MAAQjH,EAAKP,MAAME,UAAU8B,KAC3B8zB,EAAOy/B,KAAOh1D,EAAKP,MAAME,UAAU6B,IAAM+zB,EAAOy/B,MAAQh1D,EAAKP,MAAME,UAAU6B,GAAK,IAC3F+zB,EAAO0/B,MAASj1D,EAAKP,MAAME,UAAU6B,GAAK+zB,EAAOy/B,KACjDz/B,EAAOy/B,KAAOh1D,EAAKP,MAAME,UAAU6B,KAOnC2U,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,IAAM5oB,EAAO0/B,MAAQ1/B,EAAOtuB,MAAQ,GACtEsuB,EAAOy/B,MAAQz/B,EAAOtuB,OAASsuB,EAAOtuB,MAAQuN,EAAM/S,MACmC,MAAvF+S,EAAMnT,IAAIkiB,YAAYgS,EAAOtuB,MAAQuN,EAAM/S,KAAO,EAAG8zB,EAAOtuB,MAAQuN,EAAM/S,KAAO,KACnF8zB,EAAOtuB,QACPsuB,EAAOy/B,OACPz/B,EAAO0/B,QAGT,IAGIM,EAHA/wD,EAAQgQ,EAAMnT,IAAI07B,eAAexH,EAAOtuB,MAAQuN,EAAM/S,MACtDgD,EAAM+P,EAAMnT,IAAI07B,eAAexH,EAAO0/B,KAAOzgD,EAAM/S,MACnD+zD,EAAehxD,EAAMhB,WAAWiB,IAAQD,EAAMxD,OAAO0D,cAIzD,IAAMyR,EAAOooC,KAAOv+C,EAAKm1D,aAAe5iB,KAAKC,MAAQ,OAC7CgjB,GAAgBljC,EAAWrP,MAAK,SAAUxG,GAAK,MAAqB,OAAdA,EAAE8tB,UAAmC,KAAd9tB,EAAE8tB,eAChFirB,GAAgBhxD,EAAMzC,IAAMyS,EAAMnT,IAAIJ,QAAQC,OAC9Cq0D,EAAU,cAAmB/gD,EAAMnT,IAAIO,QAAQ4C,EAAMzC,IAAM,GAAI,GAAG,KACnEwzD,EAAQnsB,MAAQ3kC,EAAI1C,MACtB/B,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,GAAI,aAC5EngD,EAAKm1D,aAAe,OAItB,GAAIn1D,EAAKP,MAAME,UAAUgxC,OAASpb,EAAOtuB,OA4G3C,SAAuBwuD,EAAKxuD,EAAOpC,EAAK6wD,EAAWC,GACjD,IAAKD,EAAU10D,OAAOyB,aAElBoC,EAAMoC,GAAS0uD,EAAQ5zD,IAAM2zD,EAAU3zD,KAEvC6zD,GAAsBF,GAAW,GAAM,GAASC,EAAQ5zD,IACxD,OAAO,EAEX,IAAI+H,EAAS2rD,EAAI7zD,QAAQqF,GAEzB,GAAI6C,EAAO3J,aAAe2J,EAAO9I,OAAOC,QAAQC,OAAS4I,EAAO9I,OAAOyB,YACnE,OAAO,EACX,IAAIozD,EAAQJ,EAAI7zD,QAAQg0D,GAAsB9rD,GAAQ,GAAM,IAE5D,IAAK+rD,EAAM70D,OAAOyB,aAAeozD,EAAM9zD,IAAM8C,GACzC+wD,GAAsBC,GAAO,GAAM,GAAShxD,EAC5C,OAAO,EAGX,OAAO6wD,EAAU10D,OAAOC,QAAQk5B,IAAIu7B,EAAUv1D,cAAcmT,GAAGuiD,EAAM70D,OAAOC,SA9HxE60D,CAAcz0D,EAAKk0B,EAAOtuB,MAAOsuB,EAAOy/B,KAAMxwD,EAAOC,IACrDzE,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,EAAG,iBACvEhqC,EAAOsoC,SAAWtoC,EAAO6gB,QAAUh3B,EAAK4wD,YAAYmF,+BAH1D,CAUI5/C,EAAO6gB,QAAU7gB,EAAOsoC,SAAWlpB,EAAOygC,KAAOzgC,EAAO9zB,OACxDzB,EAAKi2D,kBAAoB1jB,KAAKC,OAU9Br8B,EAAOsoC,UAAY+W,GAAgBhxD,EAAMyC,SAAWxC,EAAIwC,SAA+B,GAApBxC,EAAItE,cAAqBqE,EAAMtC,OAASuC,EAAIvC,OAC/GsS,EAAMjQ,KAAOiQ,EAAMjQ,IAAIosC,QAAUn8B,EAAMjQ,IAAI6kC,MAAQ50B,EAAMjQ,IAAI6kC,MAAQ7T,EAAOy/B,OAC9Ez/B,EAAO0/B,MAAQ,EACfxwD,EAAM+P,EAAMnT,IAAI07B,eAAexH,EAAO0/B,KAAOzgD,EAAM/S,MACnDykB,YAAW,WACTlmB,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,GAAI,eACzE,KAGL,IAEItgD,EAAI0T,EAAa2iD,EAAYC,EAF7BC,EAAS7gC,EAAOtuB,MAAOovD,EAAO9gC,EAAOy/B,KAGzC,GAAIQ,EACF,GAAIhxD,EAAMzC,KAAO0C,EAAI1C,IAGfoU,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,IAA4B,GAAtB35C,EAAMrE,eAChDH,EAAK4wD,YAAYmF,2BACjB7vC,YAAW,WAAc,OAAOqqC,GAAevwD,KAAU,KAE3DH,EAAKG,EAAKP,MAAMI,GAAGsC,OAAOi0D,EAAQC,GAClC9iD,EAAclS,EAAIO,QAAQ2zB,EAAOtuB,OAAOy3B,YAAYr9B,EAAIO,QAAQ2zB,EAAOy/B,YAClE,GACLz/B,EAAOy/B,MAAQz/B,EAAO0/B,OAASkB,EAAS90D,EAAIO,QAAQ2zB,EAAOtuB,UAC1DivD,EA0CP,SAAsBl0B,EAAKnc,GAGzB,IAFA,IAC2CjlB,EAAM0Q,EAAMinB,EADnD+9B,EAAWt0B,EAAIz/B,WAAWkO,MAAO8lD,EAAY1wC,EAAKtjB,WAAWkO,MAC7D+pC,EAAQ8b,EAAU/b,EAAUgc,EACvBxzD,EAAI,EAAGA,EAAIwzD,EAAUpwD,OAAQpD,IAAOy3C,EAAQ+b,EAAUxzD,GAAG84B,cAAc2e,GAChF,IAAK,IAAI1zC,EAAM,EAAGA,EAAMwvD,EAASnwD,OAAQW,IAASyzC,EAAU+b,EAASxvD,GAAK+0B,cAAc0e,GACxF,GAAoB,GAAhBC,EAAMr0C,QAAiC,GAAlBo0C,EAAQp0C,OAC/BmL,EAAOkpC,EAAM,GACb55C,EAAO,MACP23B,EAAS,SAAUn2B,GAAQ,OAAOA,EAAKkP,KAAKA,EAAKmqB,SAASr5B,EAAKqO,aAC1D,IAAoB,GAAhB+pC,EAAMr0C,QAAiC,GAAlBo0C,EAAQp0C,OAKtC,OAAO,KAJPmL,EAAOipC,EAAQ,GACf35C,EAAO,SACP23B,EAAS,SAAUn2B,GAAQ,OAAOA,EAAKkP,KAAKA,EAAKuqB,cAAcz5B,EAAKqO,SAKtE,IADA,IAAIkiC,EAAU,GACLtpC,EAAM,EAAGA,EAAMwc,EAAKnjB,WAAY2G,IAASspC,EAAQjsC,KAAK6xB,EAAO1S,EAAKtc,MAAMF,KACjF,GAAI,UAAcspC,GAASr/B,GAAG0uB,GAAQ,MAAO,CAAC1wB,KAAMA,EAAM1Q,KAAMA,GA5D9C41D,CAAahyD,EAAMxD,OAAOC,QAAQk5B,IAAI31B,EAAMrE,aAAcsE,EAAItE,cACjDg2D,EAAOn1D,OAAOC,QAAQk5B,IAAIg8B,EAAOh2D,aAAco1B,EAAOy/B,KAAOmB,EAAOlvD,WAE/FpH,EAAKG,EAAKP,MAAMI,GACO,OAAnBq2D,EAAWt1D,KAAiBf,EAAG6Y,QAAQ09C,EAAQC,EAAMH,EAAW5kD,MAC7DzR,EAAGggB,WAAWu2C,EAAQC,EAAMH,EAAW5kD,WACzC,GAAI9M,EAAMxD,OAAOuI,MAAM/E,EAAMxB,SAASkK,QAAU1I,EAAMxB,SAAWyB,EAAIzB,SAAWyB,EAAIm5B,WAAa,EAAI,GAAI,CAE9G,IAAImI,EAASvhC,EAAMxD,OAAOuiB,YAAY/e,EAAMrE,aAAcsE,EAAItE,cAC9D,GAAIH,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMo2D,EAAQC,EAAMtwB,MAAe,OAChGlmC,EAAKG,EAAKP,MAAMI,GAAG4D,WAAWsiC,EAAQqwB,EAAQC,GAMlD,GAFKx2D,IACDA,EAAKG,EAAKP,MAAMI,GAAG2c,QAAQ45C,EAAQC,EAAM7hD,EAAMnT,IAAIE,MAAMg0B,EAAOtuB,MAAQuN,EAAM/S,KAAM8zB,EAAO0/B,KAAOzgD,EAAM/S,QACxG+S,EAAMjQ,IAAK,CACb,IAAIkyD,EAAQpB,GAAiBr1D,EAAMH,EAAGwB,IAAKmT,EAAMjQ,KAM7CkyD,KAAWtgD,EAAO6gB,QAAU7gB,EAAOsoC,SAAWz+C,EAAKklB,WAAauxC,EAAM72D,QAC5D21B,EAAOtuB,OAASsuB,EAAO0/B,MAAQj1D,EAAKi2D,kBAAoB1jB,KAAKC,MAAQ,OACrEikB,EAAMrtB,MAAQgtB,GAAUK,EAAMrtB,MAAQvpC,EAAGgC,QAAQC,IAAIu0D,GAAQ,IAC9DlgD,EAAOkhB,IAAMo/B,EAAM72D,OAAS62D,EAAMrtB,MAAQgtB,IACnDv2D,EAAG8B,aAAa80D,GAElBljD,GAAe1T,EAAG0b,YAAYhI,GAClCvT,EAAKN,SAASG,EAAGC,oBAGnB,SAASu1D,GAAiBr1D,EAAMqB,EAAKq1D,GACnC,OAAIvpD,KAAKC,IAAIspD,EAAU/lB,OAAQ+lB,EAAUttB,MAAQ/nC,EAAIJ,QAAQC,KAAe,KACrEkvD,GAAiBpwD,EAAMqB,EAAIO,QAAQ80D,EAAU/lB,QAAStvC,EAAIO,QAAQ80D,EAAUttB,OAkDrF,SAASwsB,GAAsB9yD,EAAM6zD,EAASC,GAE5C,IADA,IAAI10D,EAAQY,EAAKZ,MAAO2C,EAAM8xD,EAAU7zD,EAAK+B,MAAQ/B,EAAKf,IACnDG,EAAQ,IAAMy0D,GAAW7zD,EAAKmB,WAAW/B,IAAUY,EAAKV,KAAKF,GAAOQ,aACzER,IACA2C,IACA8xD,GAAU,EAEZ,GAAIC,EAEF,IADA,IAAIj4B,EAAO77B,EAAKV,KAAKF,GAAOs4B,WAAW13B,EAAKmB,WAAW/B,IAChDy8B,IAASA,EAAKtM,QACnBsM,EAAOA,EAAKp8B,WACZsC,IAGJ,OAAOA,EA2BT,SAASgyD,GAAsB72D,EAAMuB,GAKnC,IAJA,IAAI8J,EAAU,GACVpK,EAAUM,EAAMN,QAChBk7B,EAAY56B,EAAM46B,UAClBC,EAAU76B,EAAM66B,QACbD,EAAY,GAAKC,EAAU,GAA2B,GAAtBn7B,EAAQyB,YAAoD,GAAjCzB,EAAQsB,WAAWG,YAAiB,CACpGy5B,IACAC,IACA,IAAIh6B,EAAOnB,EAAQsB,WACnB8I,EAAQ3E,KAAKtE,EAAKxB,KAAKmL,KAAM3J,EAAKkF,OAASlF,EAAKxB,KAAK4+B,aAAep9B,EAAKkF,MAAQ,MACjFrG,EAAUmB,EAAKnB,QAGjB,IAAI61D,EAAa92D,EAAKgX,SAAS,wBAA0B,gBAAyBhX,EAAKP,MAAM6N,QACzFjM,EAAM01D,KAAe7wD,EAAO7E,EAAIijB,cAAc,OAClDpe,EAAKqe,YAAYuyC,EAAW5yC,kBAAkBjjB,EAAS,CAACwR,SAAUpR,KAGlE,IADA,IAAkCssD,EAA9BprD,EAAa2D,EAAK3D,WACfA,GAAqC,GAAvBA,EAAW8E,WAAkBsmD,EAAYqJ,GAAQz0D,EAAWgoC,SAASC,iBAAiB,CACzG,IAAK,IAAIznC,EAAI4qD,EAAUxnD,OAAS,EAAGpD,GAAK,EAAGA,IAAK,CAE9C,IADA,IAAIk0D,EAAU51D,EAAIijB,cAAcqpC,EAAU5qD,IACnCmD,EAAK3D,YAAc00D,EAAQ1yC,YAAYre,EAAK3D,YACnD2D,EAAKqe,YAAY0yC,GACG,SAAhBtJ,EAAU5qD,KACZo5B,IACAC,KAGJ75B,EAAa2D,EAAK3D,WASpB,OANIA,GAAqC,GAAvBA,EAAW8E,UACzB9E,EAAWosB,aAAa,gBAAkBwN,EAAY,IAAMC,EAAU,IAAOxX,KAAKC,UAAUxZ,IAKzF,CAACmD,IAAKtI,EAAM4G,KAHR9M,EAAKgX,SAAS,2BAA2B,SAAUC,GAAK,OAAOA,EAAE1V,OACxEA,EAAMN,QAAQsiB,YAAY,EAAGhiB,EAAMN,QAAQC,KAAM,SAOvD,SAASg2D,GAAmBl3D,EAAM8M,EAAMya,EAAM4vC,EAAWroB,GACvD,IAAItgC,EAA8CjN,EAAzC61D,EAAStoB,EAAS9tC,OAAOJ,KAAKC,KAAK0C,KAC5C,IAAKgkB,IAASza,EAAQ,OAAO,KAC7B,IAAIuqD,EAASvqD,IAASqqD,GAAaC,IAAW7vC,GAC9C,GAAI8vC,EAAQ,CAEV,GADAr3D,EAAKgX,SAAS,uBAAuB,SAAUC,GAAKnK,EAAOmK,EAAEnK,EAAMsqD,GAAUD,MACzEC,EAAU,OAAOtqD,EAAO,IAAI,KAAM,UAAc9M,EAAKP,MAAM6N,OAAOR,KAAKA,EAAK0P,QAAQ,SAAU,QAAS,EAAG,GAAK,WACnH,IAAI86C,EAASt3D,EAAKgX,SAAS,uBAAuB,SAAUC,GAAK,OAAOA,EAAEnK,EAAMgiC,EAAUqoB,MAC1F,GAAIG,EACF/1D,EAAQ+1D,MACH,CACL,IAAI7mD,EAAQq+B,EAASr+B,QAEjBnD,EADMtN,EAAKP,MACE6N,OACbwpD,EAAa,gBAAyBxpD,GAC1CkB,EAAMiE,SAAS6R,cAAc,OAC7BxX,EAAKhI,MAAM,iBAAiBmG,SAAQ,SAAUkjC,GAC5C,IAAI1T,EAAIjsB,EAAI+V,YAAY9R,SAAS6R,cAAc,MAC3C6pB,GAAS1T,EAAElW,YAAYuyC,EAAWjnB,cAAcviC,EAAOR,KAAKqhC,EAAO19B,cAI3EzQ,EAAKgX,SAAS,uBAAuB,SAAUC,GAAKsQ,EAAOtQ,EAAEsQ,MAC7D/Y,EA4IJ,SAAkB+Y,GAChB,IAAIgwC,EAAQ,sBAAsBjyC,KAAKiC,GACnCgwC,IAAShwC,EAAOA,EAAKhmB,MAAMg2D,EAAM,GAAGpxD,SACxC,IAC8CD,EAD1C29C,EAAMkT,KAAczyC,cAAc,OAClCkzC,EAAW,mBAAmBlyC,KAAKiC,IACnCrhB,EAAOsxD,GAAYR,GAAQQ,EAAS,GAAGhtB,kBACvCjjB,EAAOrhB,EAAKpE,KAAI,SAAU2a,GAAK,MAAO,IAAMA,EAAI,OAAQ7W,KAAK,IAAM2hB,EAAOrhB,EAAKpE,KAAI,SAAU2a,GAAK,MAAO,KAAOA,EAAI,OAAQkH,UAAU/d,KAAK,KAE/I,GADAi+C,EAAIr/B,UAAY+C,EACZrhB,EAAQ,IAAK,IAAInD,EAAI,EAAGA,EAAImD,EAAKC,OAAQpD,IAAO8gD,EAAMA,EAAIp1B,cAAcvoB,EAAKnD,KAAO8gD,EACxF,OAAOA,EArJC4T,CAASlwC,GACXpR,EAAOuoC,QA4Jf,SAA+BlwC,GAE7B,IADA,IAAIf,EAAQe,EAAIkpD,iBAAiBvhD,EAAO6gB,OAAS,iCAAmC,8BAC3Ej0B,EAAI,EAAGA,EAAI0K,EAAMtH,OAAQpD,IAAK,CACrC,IAAIX,EAAOqL,EAAM1K,GACa,GAA1BX,EAAK0rC,WAAW3nC,QAAmC,KAApB/D,EAAKigB,aAA2BjgB,EAAKkoC,YACpEloC,EAAKkoC,WAAWjQ,aAAa7rB,EAAI8+B,cAAcC,eAAe,KAAMnrC,IAjKnDu1D,CAAsBnpD,GAG7C,IAAIopD,EAAcppD,GAAOA,EAAIigB,cAAc,mBACvCopC,EAAYD,GAAe,oBAAoBtyC,KAAKsyC,EAAYvuC,aAAa,kBACjF,IAAK9nB,EAAO,CACV,IAAI+S,EAAStU,EAAKgX,SAAS,oBAAsBhX,EAAKgX,SAAS,cAAgB,gBAAqBhX,EAAKP,MAAM6N,QAC/G/L,EAAQ+S,EAAOC,WAAW/F,EAAK,CAC7BmG,sBAAuB0iD,IAAUQ,GACjCxsD,QAASyjC,EACTlC,aAAc,SAAsBp+B,GAClC,GAAoB,MAAhBA,EAAI+7B,WAAqB/7B,EAAIk+B,aAC7Bl+B,EAAI87B,aAAewtB,GAAcxvD,KAAKkG,EAAI87B,WAAWC,UAAa,MAAO,CAACsC,QAAQ,MAI5F,GAAIgrB,EACFt2D,EAoJJ,SAAoBA,EAAO8J,GACzB,IAAK9J,EAAML,KAAQ,OAAOK,EAC1B,IAAmD2zB,EAA/C5nB,EAAS/L,EAAMN,QAAQsB,WAAW3B,KAAK0M,OAC3C,IAAM4nB,EAAQtQ,KAAKpQ,MAAMnJ,GACzB,MAAM/B,GAAK,OAAO/H,EAIlB,IAHA,IAAIN,EAAUM,EAAMN,QAChBk7B,EAAY56B,EAAM46B,UAClBC,EAAU76B,EAAM66B,QACXr5B,EAAImyB,EAAM/uB,OAAS,EAAGpD,GAAK,EAAGA,GAAK,EAAG,CAC7C,IAAInC,EAAO0M,EAAOG,MAAMynB,EAAMnyB,IAC9B,IAAKnC,GAAQA,EAAKkD,mBAAsB,MACxC7C,EAAU,UAAcL,EAAKwF,OAAO8uB,EAAMnyB,EAAI,GAAI9B,IAClDk7B,IAAaC,IAEf,OAAO,IAAI,KAAMn7B,EAASk7B,EAAWC,GAlK3B27B,CAAWC,GAAWz2D,GAAQs2D,EAAU,IAAKA,EAAU,IAAKA,EAAU,SAG9E,GADAt2D,EAAQ,aAyBZ,SAA2ByiB,EAAU8qB,GACnC,GAAI9qB,EAASthB,WAAa,EAAK,OAAOshB,EAsBtC,IArBA,IAAI8d,EAAO,SAAW3lB,GACpB,IACIxY,EADSmrC,EAAS1sC,KAAK+Z,GACRjY,eAAe4qC,EAAS9rC,MAAMmZ,IAC7C87C,OAAW,EAAU9hD,EAAS,GAelC,GAdA6N,EAAS/Y,SAAQ,SAAU7I,GACzB,GAAK+T,EAAL,CACA,IAA0C+hD,EAAtChyD,EAAOvC,EAAMoC,aAAa3D,EAAKxB,MACnC,IAAKsF,EAAQ,OAAOiQ,EAAS,KAC7B,GAAI+hD,EAAS/hD,EAAOhQ,QAAU8xD,EAAS9xD,QAAUgyD,GAAajyD,EAAM+xD,EAAU71D,EAAM+T,EAAOA,EAAOhQ,OAAS,GAAI,GAC7GgQ,EAAOA,EAAOhQ,OAAS,GAAK+xD,MACvB,CACD/hD,EAAOhQ,SAAUgQ,EAAOA,EAAOhQ,OAAS,GAAKiyD,GAAWjiD,EAAOA,EAAOhQ,OAAS,GAAI8xD,EAAS9xD,SAChG,IAAIkyD,EAAUC,GAAal2D,EAAM8D,GACjCiQ,EAAOzP,KAAK2xD,GACZ10D,EAAQA,EAAMqC,UAAUqyD,EAAQz3D,KAAMy3D,EAAQ/wD,OAC9C2wD,EAAW/xD,OAGXiQ,EAAU,MAAO,CAAEm1B,EAAG,UAAcn1B,KAGjCgG,EAAI2yB,EAAS5sC,MAAOia,GAAK,EAAGA,IAAK,CACxC,IAAIovB,EAAWzJ,EAAM3lB,GAErB,GAAKovB,EAAW,OAAOA,EAASD,EAElC,OAAOtnB,EArDiBu0C,CAAkBh3D,EAAMN,QAAS6tC,IAAW,GAC9DvtC,EAAM46B,WAAa56B,EAAM66B,QAAS,CAEpC,IADA,IAAID,EAAY,EAAGC,EAAU,EACpBh6B,EAAOb,EAAMN,QAAQsB,WAAY45B,EAAY56B,EAAM46B,YAAc/5B,EAAKxB,KAAKC,KAAKC,UACpFq7B,IAAa/5B,EAAOA,EAAKG,YAC9B,IAAK,IAAIi2D,EAASj3D,EAAMN,QAAQuB,UAAW45B,EAAU76B,EAAM66B,UAAYo8B,EAAO53D,KAAKC,KAAKC,UACnFs7B,IAAWo8B,EAASA,EAAOh2D,WAChCjB,EAAQy2D,GAAWz2D,EAAO46B,EAAWC,GAKzC,OADAp8B,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK1V,EAAQ0V,EAAE1V,MACnDA,EAGT,IAAIu2D,GAAgB,gHAyCpB,SAASQ,GAAal2D,EAAM8D,EAAMzE,QAClB,IAATA,IAAkBA,EAAO,GAE9B,IAAK,IAAIsB,EAAImD,EAAKC,OAAS,EAAGpD,GAAKtB,EAAMsB,IACrCX,EAAO8D,EAAKnD,GAAGqD,OAAO,KAAM,UAAchE,IAC9C,OAAOA,EAKT,SAAS+1D,GAAajyD,EAAM+xD,EAAU71D,EAAMq2D,EAASv2D,GACnD,GAAIA,EAAQgE,EAAKC,QAAUjE,EAAQ+1D,EAAS9xD,QAAUD,EAAKhE,IAAU+1D,EAAS/1D,GAAQ,CACpF,IAAI8Y,EAAQm9C,GAAajyD,EAAM+xD,EAAU71D,EAAMq2D,EAAQj2D,UAAWN,EAAQ,GAC1E,GAAI8Y,EAAS,OAAOy9C,EAAQpyD,KAAKoyD,EAAQx3D,QAAQo5B,aAAao+B,EAAQ/1D,WAAa,EAAGsY,IAEtF,GADYy9C,EAAQv0D,eAAeu0D,EAAQ/1D,YACjCsD,UAAU9D,GAASgE,EAAKC,OAAS,EAAI/D,EAAKxB,KAAOsF,EAAKhE,EAAQ,IACpE,OAAOu2D,EAAQpyD,KAAKoyD,EAAQx3D,QAAQiJ,OAAO,UAAcouD,GAAal2D,EAAM8D,EAAMhE,EAAQ,OAIlG,SAASk2D,GAAWh2D,EAAMF,GACxB,GAAa,GAATA,EAAc,OAAOE,EACzB,IAAI4hB,EAAW5hB,EAAKnB,QAAQo5B,aAAaj4B,EAAKM,WAAa,EAAG01D,GAAWh2D,EAAKI,UAAWN,EAAQ,IAC7F8nC,EAAO5nC,EAAK8B,eAAe9B,EAAKM,YAAY8/B,WAAW,YAAgB,GAC3E,OAAOpgC,EAAKiE,KAAK2d,EAAS9Z,OAAO8/B,IAGnC,SAAS0uB,GAAW10C,EAAU3hB,EAAMZ,EAAMD,EAAIU,EAAOk6B,GACnD,IAAIh6B,EAAOC,EAAO,EAAI2hB,EAASzhB,WAAayhB,EAASxhB,UAAWwY,EAAQ5Y,EAAKnB,QAK7E,OAJIiB,EAAQV,EAAK,IAAKwZ,EAAQ09C,GAAW19C,EAAO3Y,EAAMZ,EAAMD,EAAIU,EAAQ,EAAGk6B,IACvEl6B,GAAST,IACTuZ,EAAQ3Y,EAAO,EAAID,EAAK8B,eAAe,GAAGs+B,WAAWxnB,EAAOgJ,EAASthB,WAAa,GAAK05B,GAAWl6B,GAAOgI,OAAO8Q,GAC9GA,EAAM9Q,OAAO9H,EAAK8B,eAAe9B,EAAKM,YAAY8/B,WAAW,YAAgB,KAC5Exe,EAASqW,aAAah4B,EAAO,EAAI,EAAI2hB,EAASthB,WAAa,EAAGN,EAAKiE,KAAK2U,IAGjF,SAASg9C,GAAWz2D,EAAO46B,EAAWC,GAKpC,OAJID,EAAY56B,EAAM46B,YAClB56B,EAAQ,IAAI,KAAMm3D,GAAWn3D,EAAMN,SAAU,EAAGk7B,EAAW56B,EAAM46B,UAAW,EAAG56B,EAAM66B,SAAUD,EAAW56B,EAAM66B,UAChHA,EAAU76B,EAAM66B,UAChB76B,EAAQ,IAAI,KAAMm3D,GAAWn3D,EAAMN,QAAS,EAAGm7B,EAAS76B,EAAM66B,QAAS,EAAG,GAAI76B,EAAM46B,UAAWC,IAC5F76B,EAMT,IAAIy1D,GAAU,CACZ2B,MAAO,CAAC,SACRC,MAAO,CAAC,SACR3vB,MAAO,CAAC,SACR4vB,QAAS,CAAC,SACVC,SAAU,CAAC,SACXC,IAAK,CAAC,QAAS,YACfl5D,GAAI,CAAC,QAAS,SACdm5D,GAAI,CAAC,QAAS,QAAS,MACvBC,GAAI,CAAC,QAAS,QAAS,OAGrBC,GAAe,KACnB,SAASnC,KACP,OAAOmC,KAAiBA,GAAezmD,SAAS2R,eAAeC,mBAAmB,UA8CpF,IAAI80C,GAAiB,CACnBC,WAAW,EACXC,eAAe,EACfC,uBAAuB,EACvBroD,YAAY,EACZsoD,mBAAmB,EACnBC,SAAS,GAGPC,GAActjD,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,GAEhDub,GAAiB,WACnB5tD,KAAK+8C,WAAa/8C,KAAKg9C,aAAeh9C,KAAKo6C,UAAYp6C,KAAKs6C,YAAc,MAG5EsT,GAAenvD,UAAUmxB,IAAM,SAAcn3B,GAC3CuH,KAAK+8C,WAAatkD,EAAIskD,WAAY/8C,KAAKg9C,aAAevkD,EAAIukD,aAC1Dh9C,KAAKo6C,UAAY3hD,EAAI2hD,UAAWp6C,KAAKs6C,YAAc7hD,EAAI6hD,aAGzDsT,GAAenvD,UAAU+I,GAAK,SAAa/O,GACzC,OAAOA,EAAIskD,YAAc/8C,KAAK+8C,YAActkD,EAAIukD,cAAgBh9C,KAAKg9C,cACnEvkD,EAAI2hD,WAAap6C,KAAKo6C,WAAa3hD,EAAI6hD,aAAet6C,KAAKs6C,aAG/D,IAAIuT,GAAc,SAAqB35D,EAAM45D,GAC3C,IAAI5zB,EAASl6B,KAEbA,KAAK9L,KAAOA,EACZ8L,KAAK8tD,gBAAkBA,EACvB9tD,KAAK+tD,MAAQ,GACb/tD,KAAKguD,cAAgB,EACrBhuD,KAAKiuD,SAAWtrD,OAAOurD,kBACrB,IAAIvrD,OAAOurD,kBAAiB,SAAUC,GACpC,IAAK,IAAIl3D,EAAI,EAAGA,EAAIk3D,EAAU9zD,OAAQpD,IAAOijC,EAAO6zB,MAAMnzD,KAAKuzD,EAAUl3D,IAKrEoT,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,IAAM8b,EAAUh3C,MACpD,SAAUmd,GAAK,MAAiB,aAAVA,EAAEx/B,MAAuBw/B,EAAE7N,aAAapsB,QAC/C,iBAAVi6B,EAAEx/B,MAA2Bw/B,EAAE0pB,SAAS3jD,OAASi6B,EAAE5/B,OAAOyrC,UAAU9lC,UACvE6/B,EAAOk0B,YAEPl0B,EAAOm0B,WAEfruD,KAAK+kD,iBAAmB,IAAI6I,GACxBD,KACF3tD,KAAKsuD,WAAa,SAAU9wD,GAC1B08B,EAAO6zB,MAAMnzD,KAAK,CAAClG,OAAQ8I,EAAE9I,OAAQI,KAAM,gBAAiBkpD,SAAUxgD,EAAE+wD,YACxEr0B,EAAOk0B,cAGXpuD,KAAKwuD,kBAAoBxuD,KAAKwuD,kBAAkB/uD,KAAKO,MACrDA,KAAKyuD,6BAA8B,GAGrCZ,GAAYpvD,UAAU2vD,UAAY,WAC9B,IAAIl0B,EAASl6B,KAEXA,KAAKguD,aAAe,IACpBhuD,KAAKguD,aAAerrD,OAAOyX,YAAW,WAAc8f,EAAO8zB,cAAgB,EAAG9zB,EAAOm0B,UAAY,MAGvGR,GAAYpvD,UAAUiwD,WAAa,WAC7B1uD,KAAKguD,cAAgB,IACvBrrD,OAAOgsD,aAAa3uD,KAAKguD,cACzBhuD,KAAKguD,cAAgB,EACrBhuD,KAAKquD,UAITR,GAAYpvD,UAAUtD,MAAQ,WACxB6E,KAAKiuD,UACLjuD,KAAKiuD,SAASW,QAAQ5uD,KAAK9L,KAAKwO,IAAK2qD,IACrCM,IACA3tD,KAAK9L,KAAKwO,IAAI0Y,iBAAiB,2BAA4Bpb,KAAKsuD,YACpEtuD,KAAK8lD,oBAGP+H,GAAYpvD,UAAUk/C,KAAO,WACzB,IAAIzjB,EAASl6B,KAEf,GAAIA,KAAKiuD,SAAU,CACjB,IAAIY,EAAO7uD,KAAKiuD,SAASa,cACzB,GAAID,EAAKx0D,OAAQ,CACf,IAAK,IAAIpD,EAAI,EAAGA,EAAI43D,EAAKx0D,OAAQpD,IAAO+I,KAAK+tD,MAAMnzD,KAAKi0D,EAAK53D,IAC7D0L,OAAOyX,YAAW,WAAc,OAAO8f,EAAOm0B,UAAY,IAE5DruD,KAAKiuD,SAASc,aAEZpB,IAAe3tD,KAAK9L,KAAKwO,IAAI4Y,oBAAoB,2BAA4Btb,KAAKsuD,YACtFtuD,KAAKklD,uBAGP2I,GAAYpvD,UAAUqnD,iBAAmB,WACvC9lD,KAAK9L,KAAKwO,IAAI8+B,cAAcpmB,iBAAiB,kBAAmBpb,KAAKwuD,oBAGvEX,GAAYpvD,UAAUymD,oBAAsB,WAC1CllD,KAAK9L,KAAKwO,IAAI8+B,cAAclmB,oBAAoB,kBAAmBtb,KAAKwuD,oBAG1EX,GAAYpvD,UAAUwrD,yBAA2B,WAC7C,IAAI/vB,EAASl6B,KAEfA,KAAKyuD,6BAA8B,EACnCr0C,YAAW,WAAc,OAAO8f,EAAOu0B,6BAA8B,IAAU,KAGjFZ,GAAYpvD,UAAU+vD,kBAAoB,WACxC,MA3+B4Bt6D,EA2+BF8L,KAAK9L,MA1+BtBwgB,UAAYxgB,EAAK8jD,KAAK0B,eAAiBxlD,EAAKwO,MAC9C8hD,GAAatwD,GAy+BpB,CA3+BF,IAA8BA,EA4+B5B,GAAI8L,KAAKyuD,4BAA+B,OAAOhK,GAAezkD,KAAK9L,MAInE,GAAImW,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,KAAOryC,KAAK9L,KAAKP,MAAME,UAAUC,MAAO,CAC5E,IAAI2E,EAAMuH,KAAK9L,KAAK8jD,KAAKp1C,eAEzB,GAAInK,EAAI2hD,WAAa7G,EAAqB96C,EAAI2hD,UAAW3hD,EAAI6hD,YAAa7hD,EAAIskD,WAAYtkD,EAAIukD,cAC1F,OAAOh9C,KAAKouD,YAElBpuD,KAAKquD,UAGPR,GAAYpvD,UAAUwmD,gBAAkB,WACtCjlD,KAAK+kD,iBAAiBn1B,IAAI5vB,KAAK9L,KAAK8jD,KAAKp1C,iBAG3CirD,GAAYpvD,UAAUuwD,sBAAwB,SAAgCv2D,GAC5E,GAAsB,GAAlBA,EAAI07C,WAAmB,OAAO,EAClC,IAAI97B,EAAY5f,EAAI27C,WAAW,GAAG6a,wBAC9B3nB,EAAOtnC,KAAK9L,KAAKgwB,QAAQk0B,YAAY//B,GACzC,OAAIivB,GAAQA,EAAK7iB,eAAe,CAAC3vB,KAAM,YAAaJ,OAA8B,GAAtB2jB,EAAU9c,SAAgB8c,EAAUmmB,WAAanmB,KAC3GrY,KAAKilD,mBACE,QAFT,GAMF4I,GAAYpvD,UAAU4vD,MAAQ,WAC5B,GAAKruD,KAAK9L,KAAKgwB,WAAWlkB,KAAKguD,cAAgB,GAA/C,CACA,IAAIG,EAAYnuD,KAAKiuD,SAAWjuD,KAAKiuD,SAASa,cAAgB,GAC1D9uD,KAAK+tD,MAAM1zD,SACb8zD,EAAYnuD,KAAK+tD,MAAMhhC,OAAOohC,GAC9BnuD,KAAK+tD,MAAM1zD,OAAS,GAGtB,IAAI5B,EAAMuH,KAAK9L,KAAK8jD,KAAKp1C,eACrBwlD,GAAUpoD,KAAKyuD,8BAAgCzuD,KAAK+kD,iBAAiBv9C,GAAG/O,IAAQ+rD,GAAaxkD,KAAK9L,QAAU8L,KAAKgvD,sBAAsBv2D,GAEvI9C,GAAQ,EAAGD,GAAM,EAAGuyD,GAAW,EAAOvZ,EAAQ,GAClD,GAAI1uC,KAAK9L,KAAKwgB,SACZ,IAAK,IAAIzd,EAAI,EAAGA,EAAIk3D,EAAU9zD,OAAQpD,IAAK,CACzC,IAAIi4D,EAAWlvD,KAAKmvD,iBAAiBhB,EAAUl3D,GAAIy3C,GAC/CwgB,IACFv5D,EAAOA,EAAO,EAAIu5D,EAASv5D,KAAO0L,KAAKc,IAAI+sD,EAASv5D,KAAMA,GAC1DD,EAAKA,EAAK,EAAIw5D,EAASx5D,GAAK2L,KAAKC,IAAI4tD,EAASx5D,GAAIA,GAC9Cw5D,EAASjH,WAAYA,GAAW,IAK1C,GAAI59C,EAAOghB,OAASqjB,EAAMr0C,OAAS,EAAG,CACpC,IAAI+0D,EAAM1gB,EAAM9sC,QAAO,SAAU+O,GAAK,MAAqB,MAAdA,EAAE8tB,YAC/C,GAAkB,GAAd2wB,EAAI/0D,OAAa,CACnB,IAAIgmB,EAAI+uC,EAAI,GACNpzC,EAAIozC,EAAI,GACV/uC,EAAEme,YAAcne,EAAEme,WAAWA,YAAcxiB,EAAEwiB,WAAcxiB,EAAE4Q,SAC1DvM,EAAEuM,WAITj3B,GAAQ,GAAKyyD,KACXzyD,GAAQ,IACVqK,KAAK9L,KAAKgwB,QAAQk5B,UAAUznD,EAAMD,GA6DxC,SAAkBxB,GAChB,GAAIm7D,GAAc,OAClBA,IAAa,EACgC,UAAzCnO,iBAAiBhtD,EAAKwO,KAAK4sD,YAC3BnvD,QAAc,KAAE,4KAhEhBovD,CAASvvD,KAAK9L,OAEhB8L,KAAK8tD,gBAAgBn4D,EAAMD,EAAIuyD,EAAUvZ,GACrC1uC,KAAK9L,KAAKgwB,QAAQ22B,MAAS76C,KAAK9L,KAAK+uB,YAAYjjB,KAAK9L,KAAKP,OACrDqM,KAAK+kD,iBAAiBv9C,GAAG/O,IAAQgsD,GAAezkD,KAAK9L,MAC/D8L,KAAK+kD,iBAAiBn1B,IAAIn3B,MAI9Bo1D,GAAYpvD,UAAU0wD,iBAAmB,SAA2BpR,EAAKrP,GAEvE,GAAIA,EAAM1uB,QAAQ+9B,EAAIrpD,SAAW,EAAK,OAAO,KAC7C,IAAI4yC,EAAOtnC,KAAK9L,KAAKgwB,QAAQk0B,YAAY2F,EAAIrpD,QAC7C,GAAgB,cAAZqpD,EAAIjpD,OACHwyC,GAAQtnC,KAAK9L,KAAKgwB,SAAgC,mBAArB65B,EAAIyR,eAEX,SAArBzR,EAAIyR,gBAA6BzR,EAAIC,WAAaD,EAAIrpD,OAAO6oB,aAAa,UAC5E,OAAO,KACX,IAAK+pB,GAAQA,EAAK7iB,eAAes5B,GAAQ,OAAO,KAEhD,GAAgB,aAAZA,EAAIjpD,KAAqB,CAC3B,IAAK,IAAImC,EAAI,EAAGA,EAAI8mD,EAAIv3B,WAAWnsB,OAAQpD,IAAOy3C,EAAM9zC,KAAKmjD,EAAIv3B,WAAWvvB,IAC5E,GAAIqwC,EAAK3iB,YAAc2iB,EAAK3iB,YAAc2iB,EAAK5kC,MAAQ4kC,EAAK3iB,WAAWxJ,SAAS4iC,EAAIrpD,QAChF,MAAO,CAACiB,KAAM2xC,EAAK+Q,UAAW3iD,GAAI4xC,EAAKgR,UAC3C,IAAIv+B,EAAOgkC,EAAI1d,gBAAiBxN,EAAOkrB,EAAInd,YAC3C,GAAIv2B,EAAOkhB,IAAMlhB,EAAOgoC,YAAc,IAAM0L,EAAIv3B,WAAWnsB,OAGzD,IAAK,IAAIW,EAAM,EAAGA,EAAM+iD,EAAIv3B,WAAWnsB,OAAQW,IAAO,CACpD,IAAIlE,EAAMinD,EAAIv3B,WAAWxrB,GACnBqlC,EAAkBvpC,EAAIupC,gBACtBO,EAAc9pC,EAAI8pC,cACnBP,GAAmBl6B,MAAM1H,UAAUuhB,QAAQrhB,KAAKo/C,EAAIv3B,WAAY6Z,GAAmB,KAAKtmB,EAAOsmB,KAC/FO,GAAez6B,MAAM1H,UAAUuhB,QAAQrhB,KAAKo/C,EAAIv3B,WAAYoa,GAAe,KAAK/N,EAAO+N,GAGhG,IAAIyb,EAAatiC,GAAQA,EAAKykB,YAAcuf,EAAIrpD,OAC1Cq+C,EAASh5B,GAAQ,EAAI,EACvBpkB,EAAO2xC,EAAKiU,gBAAgBwC,EAAIrpD,OAAQ2nD,GAAa,GACrDC,EAAWzpB,GAAQA,EAAK2L,YAAcuf,EAAIrpD,OACxCq+C,EAASlgB,GAAQkrB,EAAIrpD,OAAOstC,WAAW3nC,OAE7C,MAAO,CAAC1E,KAAMA,EAAMD,GADX4xC,EAAKiU,gBAAgBwC,EAAIrpD,OAAQ4nD,EAAU,IAE/C,MAAgB,cAAZyB,EAAIjpD,KACN,CAACa,KAAM2xC,EAAKoR,WAAapR,EAAKqR,OAAQjjD,GAAI4xC,EAAKwT,SAAWxT,EAAKqR,QAE/D,CACLhjD,KAAM2xC,EAAKoR,WACXhjD,GAAI4xC,EAAKwT,SAKTmN,SAAUlK,EAAIrpD,OAAOyrC,WAAa4d,EAAIC,WAK5C,IAAIqR,IAAa,EAWjB,IAAI90C,GAAW,GAAIk1C,GAAe,GA4ClC,SAASC,GAAmBx7D,EAAMiwD,GAChCjwD,EAAKi0D,oBAAsBhE,EAC3BjwD,EAAKg0D,kBAAoBzhB,KAAKC,MAWhC,SAASipB,GAAgBz7D,GACvBA,EAAKgX,SAAS,mBAAmB,SAAU0kD,GACzC,IAAK,IAAI96D,KAAQ86D,EAAwB17D,EAAK27D,cAAc/6D,IACxDZ,EAAKwO,IAAI0Y,iBAAiBtmB,EAAMZ,EAAK27D,cAAc/6D,GAAQ,SAAU0V,GAAS,OAAOslD,GAAiB57D,EAAMsW,QAIpH,SAASslD,GAAiB57D,EAAMsW,GAC9B,OAAOtW,EAAKgX,SAAS,mBAAmB,SAAUqP,GAChD,IAAItB,EAAUsB,EAAS/P,EAAM1V,MAC7B,QAAOmkB,IAAUA,EAAQ/kB,EAAMsW,IAAUA,EAAMulD,qBAyEnD,SAASC,GAAYxlD,GAAS,MAAO,CAACqgB,KAAMrgB,EAAMylD,QAAStlC,IAAKngB,EAAM0lD,SAOtE,SAASC,GAAoBj8D,EAAMk8D,EAAUn6D,EAAKs2C,EAAQ/hC,GACxD,IAAe,GAAX+hC,EAAgB,OAAO,EAQ3B,IAPA,IAAIv1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQy2C,GAC9BvW,EAAO,SAAW/+B,GACpB,GAAI/C,EAAKgX,SAASklD,GAAU,SAAUjlD,GAAK,OAAOlU,EAAID,EAAKZ,MAAQ+U,EAAEjX,EAAM+B,EAAKe,EAAKK,UAAWL,EAAKpC,OAAOqC,GAAIuT,GAAO,GACrEW,EAAEjX,EAAM+B,EAAKe,EAAKV,KAAKW,GAAID,EAAKpC,OAAOqC,GAAIuT,GAAO,MAChG,MAAO,CAAEg1B,GAAG,IAGTvoC,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAIwoC,EAAWzJ,EAAM/+B,GAErB,GAAKwoC,EAAW,OAAOA,EAASD,EAElC,OAAO,EAGT,SAAS52B,GAAgB1U,EAAML,EAAWswD,GACnCjwD,EAAKm8D,SAAWn8D,EAAKkT,QAC1B,IAAIrT,EAAKG,EAAKP,MAAMI,GAAG8B,aAAahC,GACtB,WAAVswD,GAAuBpwD,EAAG6Z,QAAQ,WAAW,GACjD1Z,EAAKN,SAASG,GAuChB,SAASu8D,GAAkBp8D,EAAM+B,EAAKs2C,EAAQ/hC,EAAOy3C,GACnD,OAAOkO,GAAoBj8D,EAAM,gBAAiB+B,EAAKs2C,EAAQ/hC,IAC7DtW,EAAKgX,SAAS,eAAe,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,QAC/Dy3C,EA7BL,SAA2B/tD,EAAMq4C,GAC/B,IAAe,GAAXA,EAAgB,OAAO,EAC3B,IAAgCgkB,EAAcC,EAA1C/3D,EAAMvE,EAAKP,MAAME,UACjB4E,aAAe,OAAiB83D,EAAe93D,EAAInC,MAGvD,IADA,IAAIU,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQy2C,GACzBt1C,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAIX,EAAOW,EAAID,EAAKZ,MAAQY,EAAKK,UAAYL,EAAKV,KAAKW,GACvD,GAAI,kBAA2BX,GAAO,CAGhCk6D,EAFAD,GAAgB93D,EAAIC,MAAMtC,MAAQ,GAClCa,GAAKwB,EAAIC,MAAMtC,OAASY,EAAKpC,OAAO6D,EAAIC,MAAMtC,MAAQ,IAAMqC,EAAIC,MAAMzC,IAC3De,EAAKpC,OAAO6D,EAAIC,MAAMtC,OAEtBY,EAAKpC,OAAOqC,GAC3B,OAIJ,OAAgB,MAAZu5D,IACF5nD,GAAgB1U,EAAM,YAAqBA,EAAKP,MAAM4B,IAAKi7D,GAAW,YAC/D,GASOC,CAAkBv8D,EAAMq4C,GAvC1C,SAA2Br4C,EAAMq4C,GAC/B,IAAe,GAAXA,EAAgB,OAAO,EAC3B,IAAIv1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQy2C,GAASj2C,EAAOU,EAAKK,UACvD,SAAIf,GAAQA,EAAKH,QAAU,kBAA2BG,MACpDsS,GAAgB1U,EAAM,IAAI,KAAc8C,GAAO,YACxC,GAkCyC05D,CAAkBx8D,EAAMq4C,IAG5E,SAASokB,GAAkBz8D,EAAM+B,EAAKs2C,EAAQ/hC,GAC5C,OAAO2lD,GAAoBj8D,EAAM,sBAAuB+B,EAAKs2C,EAAQ/hC,IACnEtW,EAAKgX,SAAS,qBAAqB,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,MAG1E,SAASomD,GAAkB18D,EAAM+B,EAAKs2C,EAAQ/hC,GAC5C,OAAO2lD,GAAoBj8D,EAAM,sBAAuB+B,EAAKs2C,EAAQ/hC,IACnEtW,EAAKgX,SAAS,qBAAqB,SAAUC,GAAK,OAAOA,EAAEjX,EAAM+B,EAAKuU,OAI1E,SAA4BtW,EAAMq4C,EAAQ/hC,GACxC,GAAoB,GAAhBA,EAAMqmD,OAAe,OAAO,EAChC,IAAIt7D,EAAMrB,EAAKP,MAAM4B,IACrB,IAAe,GAAXg3C,EACF,QAAIh3C,EAAIqD,gBACNgQ,GAAgB1U,EAAM,YAAqBqB,EAAK,EAAGA,EAAIJ,QAAQC,MAAO,YAC/D,GAMX,IADA,IAAI4B,EAAOzB,EAAIO,QAAQy2C,GACdt1C,EAAID,EAAKZ,MAAQ,EAAGa,EAAI,EAAGA,IAAK,CACvC,IAAIX,EAAOW,EAAID,EAAKZ,MAAQY,EAAKK,UAAYL,EAAKV,KAAKW,GACnD8vD,EAAU/vD,EAAKpC,OAAOqC,GAC1B,GAAIX,EAAKsC,cACLgQ,GAAgB1U,EAAM,YAAqBqB,EAAKwxD,EAAU,EAAGA,EAAU,EAAIzwD,EAAKnB,QAAQC,MAAO,eAC9F,KAAI,kBAA2BkB,GAGhC,SAFAsS,GAAgB1U,EAAM,YAAqBqB,EAAKwxD,GAAU,WAG9D,OAAO,GAxBP+J,CAAmB58D,EAAMq4C,EAAQ/hC,GA4BrC,SAASumD,GAAc78D,GACrB,OAAO88D,GAAe98D,GAnKxBu7D,GAAawB,QAAU,SAAU/8D,EAAMsW,GAErC,GADAtW,EAAK2W,SAA4B,IAAjBL,EAAMwhB,SAAiBxhB,EAAMK,UACzCqmD,GAAoBh9D,EAAMsW,KAC9BtW,EAAKu0D,YAAcj+C,EAAMwhB,QACzB93B,EAAK+0D,gBAAkBxiB,KAAKC,OAIxBr8B,EAAOsoC,UAAWtoC,EAAO6gB,QAA2B,IAAjB1gB,EAAMwhB,SAO7C,GANqB,KAAjBxhB,EAAMwhB,SAAkB93B,EAAK4wD,YAAY4J,cAMzCrkD,EAAOooC,KAAwB,IAAjBjoC,EAAMwhB,SAAkBxhB,EAAMG,SAAYH,EAAME,QAAWF,EAAMI,QASxE1W,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsW,OAAcq9C,GAAe3zD,EAAMsW,GACzGA,EAAM4b,iBAENspC,GAAmBx7D,EAAM,WAZiE,CAC1F,IAAIwyC,EAAMD,KAAKC,MACfxyC,EAAKm1D,aAAe3iB,EACpBxyC,EAAKi9D,4BAA8B/2C,YAAW,WACxClmB,EAAKm1D,cAAgB3iB,IACvBxyC,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,GAAI,aAC1EngD,EAAKm1D,aAAe,KAErB,OAQPoG,GAAa2B,MAAQ,SAAUl9D,EAAMsJ,GAClB,IAAbA,EAAEwuB,UAAiB93B,EAAK2W,UAAW,IAGzC4kD,GAAa4B,SAAW,SAAUn9D,EAAMsW,GACtC,KAAI0mD,GAAoBh9D,EAAMsW,KAAWA,EAAM8mD,UAC3C9mD,EAAMG,UAAYH,EAAME,QAAUL,EAAOihB,KAAO9gB,EAAMI,SAE1D,GAAI1W,EAAKgX,SAAS,kBAAkB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsW,MAChEA,EAAM4b,qBADR,CAKA,IAAI3tB,EAAMvE,EAAKP,MAAME,UACrB,KAAM4E,aAAe,MAAmBA,EAAIC,MAAMhB,WAAWe,EAAIE,MAAM,CACrE,IAAIqI,EAAOyqB,OAAOC,aAAalhB,EAAM8mD,UAChCp9D,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMuE,EAAIC,MAAMzC,IAAKwC,EAAIE,IAAI1C,IAAK+K,OAC5F9M,EAAKN,SAASM,EAAKP,MAAMI,GAAG4D,WAAWqJ,GAAMhN,kBACjDwW,EAAM4b,oBAqHV,IAAImrC,GAAqBlnD,EAAOihB,IAAM,UAAY,UAElD/Q,GAASi3C,UAAY,SAAUt9D,EAAMsW,GACnCtW,EAAK2W,SAAWL,EAAMK,SACtB,IAAI4mD,EAAUV,GAAc78D,GACxBwyC,EAAMD,KAAKC,MAAO5xC,EAAO,cACzB4xC,EAAMxyC,EAAKw9D,UAAUlrB,KAAO,KArHlC,SAAgBh8B,EAAOmnD,GACrB,IAAI3a,EAAK2a,EAAM1sC,EAAIza,EAAMylD,QAAS2B,EAAKD,EAAMzsC,EAAI1a,EAAM0lD,QACvD,OAAOlZ,EAAKA,EAAK4a,EAAKA,EAAK,IAmHYC,CAAOrnD,EAAOtW,EAAKw9D,aAAelnD,EAAM+mD,MAClD,eAAvBr9D,EAAKw9D,UAAU58D,KAAyBA,EAAO,cACnB,eAAvBZ,EAAKw9D,UAAU58D,OAAyBA,EAAO,gBAE1DZ,EAAKw9D,UAAY,CAAClrB,KAAME,EAAKzhB,EAAGza,EAAMylD,QAAS/qC,EAAG1a,EAAM0lD,QAASp7D,KAAMA,GAEvE,IAAImB,EAAM/B,EAAKsjD,YAAYwY,GAAYxlD,IAClCvU,IAEO,eAARnB,GACEZ,EAAKywD,WAAazwD,EAAKywD,UAAUmN,OACrC59D,EAAKywD,UAAY,IAAIoN,GAAU79D,EAAM+B,EAAKuU,EAAOinD,KAC/B,eAAR38D,EAAwB67D,GAAoBC,IAAmB18D,EAAM+B,EAAIA,IAAKA,EAAIs2C,OAAQ/hC,GACpGA,EAAM4b,iBAENspC,GAAmBx7D,EAAM,aAI7B,IAAI69D,GAAY,SAAmB79D,EAAM+B,EAAKuU,EAAOinD,GACnD,IAWIje,EAAYwe,EAXZ93B,EAASl6B,KAYb,GAVAA,KAAK9L,KAAOA,EACZ8L,KAAK0oD,SAAWx0D,EAAKP,MAAM4B,IAC3ByK,KAAK/J,IAAMA,EACX+J,KAAKwK,MAAQA,EACbxK,KAAKyxD,QAAUA,EACfzxD,KAAKiiD,WAAaz3C,EAAM+mD,IACxBvxD,KAAK4kD,aAAep6C,EAAMK,SAC1B7K,KAAKglD,sBAAuB,EAGxB/uD,EAAIs2C,QAAU,EAChBiH,EAAat/C,EAAKP,MAAM4B,IAAIic,OAAOvb,EAAIs2C,QACvCylB,EAAY/7D,EAAIs2C,WACX,CACL,IAAIv1C,EAAO9C,EAAKP,MAAM4B,IAAIO,QAAQG,EAAIA,KACtCu9C,EAAax8C,EAAK9B,OAClB88D,EAAYh7D,EAAKZ,MAAQY,EAAKpC,SAAW,EAG3CoL,KAAKiyD,UAAY,KAEjB,IAAIv9D,EAAS+8D,EAAU,KAAOjnD,EAAM9V,OAChCwxD,EAAaxxD,EAASR,EAAKgwB,QAAQk0B,YAAY1jD,GAAQ,GAAQ,KACnEsL,KAAKtL,OAASwxD,EAAaA,EAAWxjD,IAAM,KAE5C,IACI7O,EADMK,EAAKP,MACKE,WACA,GAAhB2W,EAAMqmD,QACNrd,EAAW1+C,KAAKC,KAAKmpB,YAAiD,IAApCs1B,EAAW1+C,KAAKC,KAAKkpB,YACvDpqB,aAAqB,MAAiBA,EAAU8B,MAAQq8D,GAAan+D,EAAU6B,GAAKs8D,KACpFhyD,KAAKiyD,UAAY,CAAC37D,KAAMk9C,EACRv9C,IAAK+7D,EACLE,QAASlyD,KAAKtL,SAAWsL,KAAKtL,OAAOwpB,UACrCi0C,cAAenyD,KAAKtL,QAAU2V,EAAOghB,QAAUrrB,KAAKtL,OAAOgqD,aAAa,qBAExF1+C,KAAKtL,QAAUsL,KAAKiyD,YAAcjyD,KAAKiyD,UAAUC,SAAWlyD,KAAKiyD,UAAUE,iBAC7EnyD,KAAK9L,KAAK4wD,YAAYnH,OAClB39C,KAAKiyD,UAAUC,UAAWlyD,KAAKtL,OAAOwpB,WAAY,GAClDle,KAAKiyD,UAAUE,eACf/3C,YAAW,WACP8f,EAAOhmC,KAAKywD,WAAazqB,GAAUA,EAAOxlC,OAAOmuB,aAAa,kBAAmB,WACpF,IACL7iB,KAAK9L,KAAK4wD,YAAY3pD,SAGxBjH,EAAK8jD,KAAK58B,iBAAiB,UAAWpb,KAAKoyD,GAAKpyD,KAAKoyD,GAAG3yD,KAAKO,OAC7D9L,EAAK8jD,KAAK58B,iBAAiB,YAAapb,KAAKoxC,KAAOpxC,KAAKoxC,KAAK3xC,KAAKO,OACnE0vD,GAAmBx7D,EAAM,YAmE3B,SAASg9D,GAAoBh9D,EAAMsW,GACjC,QAAItW,EAAKklB,cAWL/O,EAAO8gB,QAAU9pB,KAAKgxD,IAAI7nD,EAAM8nD,UAAYp+D,EAAKq+D,oBAAsB,OACzEr+D,EAAKq+D,oBAAsB,KACpB,GA9EXR,GAAUtzD,UAAUqzD,KAAO,WACvB,IAAI53B,EAASl6B,KAEfA,KAAK9L,KAAK8jD,KAAK18B,oBAAoB,UAAWtb,KAAKoyD,IACnDpyD,KAAK9L,KAAK8jD,KAAK18B,oBAAoB,YAAatb,KAAKoxC,MACjDpxC,KAAKiyD,WAAajyD,KAAKtL,SACzBsL,KAAK9L,KAAK4wD,YAAYnH,OAClB39C,KAAKiyD,UAAUC,SAAWlyD,KAAKtL,OAAOytD,gBAAgB,aACtDniD,KAAKiyD,UAAUE,eAAiBnyD,KAAKtL,OAAOytD,gBAAgB,mBAChEniD,KAAK9L,KAAK4wD,YAAY3pD,SAEpB6E,KAAKglD,sBAAwB5qC,YAAW,WAAc,OAAOqqC,GAAevqB,EAAOhmC,SACvF8L,KAAK9L,KAAKywD,UAAY,MAGxBoN,GAAUtzD,UAAU2zD,GAAK,SAAa5nD,GAGpC,GAFAxK,KAAK8xD,OAEA9xD,KAAK9L,KAAKwO,IAAIyY,SAAkC,GAAzB3Q,EAAM9V,OAAO6G,SAAgBiP,EAAM9V,OAAO8pC,WAAah0B,EAAM9V,QAAzF,CAGA,IAAIuB,EAAM+J,KAAK/J,IACX+J,KAAK9L,KAAKP,MAAM4B,KAAOyK,KAAK0oD,WAAYzyD,EAAM+J,KAAK9L,KAAKsjD,YAAYwY,GAAYxlD,KAEhFxK,KAAK4kD,eAAiB3uD,EACxBy5D,GAAmB1vD,KAAK9L,KAAM,WACrBo8D,GAAkBtwD,KAAK9L,KAAM+B,EAAIA,IAAKA,EAAIs2C,OAAQ/hC,EAAOxK,KAAKiiD,YACvEz3C,EAAM4b,iBACmB,GAAhB5b,EAAMqmD,SACL7wD,KAAKyxD,SAEJpnD,EAAO8gB,QAAUnrB,KAAKiyD,YAAcjyD,KAAKiyD,UAAU37D,KAAKH,QAQxDkU,EAAO6gB,UAAYlrB,KAAK9L,KAAKP,MAAME,qBAAqB,OACxDwN,KAAKc,IAAId,KAAKgxD,IAAIp8D,EAAIA,IAAM+J,KAAK9L,KAAKP,MAAME,UAAU8B,MAC7C0L,KAAKgxD,IAAIp8D,EAAIA,IAAM+J,KAAK9L,KAAKP,MAAME,UAAU6B,MAAQ,IACzEkT,GAAgB5I,KAAK9L,KAAM,UAAe8L,KAAK9L,KAAKP,MAAM4B,IAAIO,QAAQG,EAAIA,MAAO,WACjFuU,EAAM4b,kBAENspC,GAAmB1vD,KAAK9L,KAAM,aAIlC69D,GAAUtzD,UAAU2yC,KAAO,SAAe5mC,IACnCxK,KAAK4kD,eAAiBvjD,KAAKgxD,IAAIryD,KAAKwK,MAAMya,EAAIza,EAAMylD,SAAW,GACzC5uD,KAAKgxD,IAAIryD,KAAKwK,MAAM0a,EAAI1a,EAAM0lD,SAAW,KAChElwD,KAAK4kD,cAAe,GACxB8K,GAAmB1vD,KAAK9L,KAAM,WACT,GAAjBsW,EAAMgoD,SAAgBxyD,KAAK8xD,QAGjCv3C,GAASk4C,UAAY,SAAUv+D,GAC7B68D,GAAc78D,GACdw7D,GAAmBx7D,EAAM,YAG3BqmB,GAASm4C,YAAc,SAAUx+D,GAAQ,OAAO68D,GAAc78D,IAsB9D,IAAIy+D,GAAqBtoD,EAAOsoC,QAAU,KAAQ,EA+ClD,SAASigB,GAAmB1+D,EAAM2+D,GAChClE,aAAaz6D,EAAK4+D,kBACdD,GAAS,IAAK3+D,EAAK4+D,iBAAmB14C,YAAW,WAAc,OAAO42C,GAAe98D,KAAU2+D,IAGrG,SAASE,GAAiB7+D,GAQ1B,IACMsW,EAJJ,IAJItW,EAAKklB,YACPllB,EAAKklB,WAAY,EACjBllB,EAAKq+D,qBAMH/nD,EAAQ7D,SAAS2tC,YAAY,UAC3BC,UAAU,SAAS,GAAM,GACxB/pC,EAAM8nD,YANNp+D,EAAKwtD,iBAAiBrnD,OAAS,GAAKnG,EAAKwtD,iBAAiBtqB,MAAMmmB,mBASzE,SAASyT,GAAe98D,EAAM8+D,GAC5B,KAAI3oD,EAAOsoC,SAAWz+C,EAAK4wD,YAAYkJ,cAAgB,GAAvD,CAGA,GAFA95D,EAAK4wD,YAAY4J,aACjBqE,GAAiB7+D,GACb8+D,GAAe9+D,EAAKgwB,QAAQ22B,MAAO,CACrC,IAAIpiD,EAAMyrD,GAAiBhwD,GAG3B,OAFIuE,IAAQA,EAAI+O,GAAGtT,EAAKP,MAAME,WAAcK,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa4C,IAC9EvE,EAAK+uB,YAAY/uB,EAAKP,QACtB,EAET,OAAO,GA1ET87D,GAAawD,iBAAmBxD,GAAayD,kBAAoB,SAAUh/D,GACzE,IAAKA,EAAKklB,UAAW,CACnBllB,EAAK4wD,YAAYuJ,QACjB,IAAI16D,EAAQO,EAAKP,MACbqD,EAAOrD,EAAME,UAAU6E,MAC3B,GAAI/E,EAAME,UAAUC,QACfH,EAAM8T,cACJzQ,EAAK86B,YAAc96B,EAAK3C,cAAgB2C,EAAKnC,WAAW8P,MAAMwS,MAAK,SAAUmd,GAAK,OAAiC,IAA1BA,EAAEx/B,KAAKC,KAAK0pB,cAE1GvqB,EAAKi/D,WAAaj/D,EAAKP,MAAM8T,aAAezQ,EAAK2N,QACjDqsD,GAAe98D,GAAM,GACrBA,EAAKi/D,WAAa,UAMlB,GAJAnC,GAAe98D,GAIXmW,EAAOghB,OAAS13B,EAAME,UAAUC,OAASkD,EAAK3C,eAAiB2C,EAAK86B,YAAc96B,EAAKnC,WAAW8P,MAAMtK,OAE1G,IADA,IAAI5B,EAAMvE,EAAK8jD,KAAKp1C,eACXtM,EAAOmC,EAAI2hD,UAAW10C,EAASjN,EAAI6hD,YAAahkD,GAAyB,GAAjBA,EAAKiF,UAA2B,GAAVmK,GAAc,CACnG,IAAI9Q,EAAS8Q,EAAS,EAAIpP,EAAKI,UAAYJ,EAAK0rC,WAAWt8B,EAAS,GACpE,IAAK9Q,EAAU,MACf,GAAuB,GAAnBA,EAAO2G,SAAe,CACxB9C,EAAIykD,SAAStoD,EAAQA,EAAOurC,UAAU9lC,QACtC,MAEA/D,EAAO1B,EACP8Q,GAAU,EAKlBxR,EAAKklB,WAAY,EAEnBw5C,GAAmB1+D,EAAMy+D,KAG3BlD,GAAat1C,eAAiB,SAAUjmB,EAAMsW,GACxCtW,EAAKklB,YACPllB,EAAKklB,WAAY,EACjBllB,EAAKq+D,mBAAqB/nD,EAAM8nD,UAChCM,GAAmB1+D,EAAM,MA4D7B,IAAIk/D,GAAsB/oD,EAAOkhB,IAAMlhB,EAAOgoC,WAAa,IACpDhoC,EAAOooC,KAAOpoC,EAAOyoC,eAAiB,IA0C7C,SAASugB,GAAQn/D,EAAM8M,EAAMya,EAAMje,GACjC,IAAI/H,EAAQ21D,GAAmBl3D,EAAM8M,EAAMya,EAAMvnB,EAAK2W,SAAU3W,EAAKP,MAAME,UAAU6E,OACrF,GAAIxE,EAAKgX,SAAS,eAAe,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsJ,EAAG/H,GAAS,eAAoB,OAAO,EACtG,IAAKA,EAAS,OAAO,EAErB,IAAI69D,EAxBN,SAAyB79D,GACvB,OAA0B,GAAnBA,EAAM46B,WAAmC,GAAjB56B,EAAM66B,SAA4C,GAA5B76B,EAAMN,QAAQyB,WAAkBnB,EAAMN,QAAQsB,WAAa,KAuB/F88D,CAAgB99D,GAC7B1B,EAAKu/D,EAAap/D,EAAKP,MAAMI,GAAG4Z,qBAAqB2lD,EAAYp/D,EAAK2W,UAAY3W,EAAKP,MAAMI,GAAGozC,iBAAiB1xC,GAErH,OADAvB,EAAKN,SAASG,EAAGC,iBAAiB4Z,QAAQ,SAAS,GAAMA,QAAQ,UAAW,WACrE,EAhDT2M,GAAShgB,KAAOk1D,GAAaphC,IAAM,SAAUn6B,EAAMsJ,GACjD,IAAI/E,EAAMvE,EAAKP,MAAME,UAAWw6B,EAAgB,OAAV7wB,EAAE1I,KACxC,IAAI2D,EAAI3E,MAAR,CAGA,IAAI6lB,EAAOy5C,GAAqB,KAAO51D,EAAEke,cAErC5kB,EAAMi0D,GAAsB72D,EADpBuE,EAAItD,WAEZuN,EAAM5L,EAAI4L,IACV1B,EAAOlK,EAAIkK,KACX2Y,GACFnc,EAAE4oB,iBACFzM,EAAK65C,YACL75C,EAAK85C,QAAQ,YAAa/wD,EAAIgW,WAC9BiB,EAAK85C,QAAQ,aAAczyD,IAzC/B,SAAqB9M,EAAMwO,GAGzB,GAAKxO,EAAKwO,IAAI87B,WAAd,CACA,IAAIpkC,EAAOlG,EAAKwO,IAAI87B,WAAW/lB,YAAY9R,SAAS6R,cAAc,QAClEpe,EAAKqe,YAAY/V,GACjBtI,EAAK+iB,MAAM8jC,QAAU,6CACrB,IAAIxoD,EAAMmK,eAAgBpO,EAAQmS,SAASysC,cAC3C5+C,EAAMk/D,mBAAmBhxD,GAIzBxO,EAAKwO,IAAIH,OACT9J,EAAIoK,kBACJpK,EAAIm5B,SAASp9B,GACb4lB,YAAW,WACLhgB,EAAKokC,YAAcpkC,EAAKokC,WAAWijB,YAAYrnD,GACnDlG,EAAKkT,UACJ,KAyBDusD,CAAYz/D,EAAMwO,GAEhB2rB,GAAOn6B,EAAKN,SAASM,EAAKP,MAAMI,GAAGL,kBAAkBM,iBAAiB4Z,QAAQ,UAAW,UAiC/F6hD,GAAaj0C,MAAQ,SAAUtnB,EAAMsJ,GAKnC,IAAItJ,EAAKklB,WAAc/O,EAAOsoC,QAA9B,CACA,IAAIh5B,EAAOy5C,GAAqB,KAAO51D,EAAEke,cACrC/B,GAAQ05C,GAAQn/D,EAAMylB,EAAKgC,QAAQ,cAAehC,EAAKgC,QAAQ,aAAcne,GAAMA,EAAE4oB,iBAjC3F,SAAsBlyB,EAAMsJ,GAC1B,GAAKtJ,EAAKwO,IAAI87B,WAAd,CACA,IAAI6sB,EAAYn3D,EAAK2W,UAAY3W,EAAKP,MAAME,UAAU6E,MAAMxD,OAAOJ,KAAKC,KAAK0C,KACzE/C,EAASR,EAAKwO,IAAI87B,WAAW/lB,YAAY9R,SAAS6R,cAAc6yC,EAAY,WAAa,QACxFA,IAAa32D,EAAOm/C,gBAAkB,QAC3Cn/C,EAAOyoB,MAAM8jC,QAAU,6CACvBvsD,EAAO0S,QACPgT,YAAW,WACTlmB,EAAKkT,QACD1S,EAAO8pC,YAAc9pC,EAAO8pC,WAAWijB,YAAY/sD,GACnD22D,EAAagI,GAAQn/D,EAAMQ,EAAO6J,MAAO,KAAMf,GAC5C61D,GAAQn/D,EAAMQ,EAAO6hB,YAAa7hB,EAAOgkB,UAAWlb,KAC1D,KAsBIo2D,CAAa1/D,EAAMsJ,KAG5B,IAAIq2D,GAAW,SAAkBp+D,EAAO27C,GACtCpxC,KAAKvK,MAAQA,EACbuK,KAAKoxC,KAAOA,GAGV0iB,GAAmBzpD,EAAOihB,IAAM,SAAW,UA0I/C,IAAK,IAAI/e,MAxITgO,GAASw5C,UAAY,SAAU7/D,EAAMsJ,GACnC,IAAImnD,EAAYzwD,EAAKywD,UAErB,GADIA,GAAaA,EAAUmN,OACtBt0D,EAAEgoB,aAAP,CAEA,IAAI/sB,EAAMvE,EAAKP,MAAME,UACjBoC,EAAMwC,EAAI3E,MAAQ,KAAOI,EAAKsjD,YAAYwY,GAAYxyD,IAC1D,GAAIvH,GAAOA,EAAIA,KAAOwC,EAAI9C,MAAQM,EAAIA,MAAQwC,aAAe,KAAgBA,EAAI/C,GAAK,EAAG+C,EAAI/C,UAAY,GAAIivD,GAAaA,EAAUsN,UAClI/9D,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa,YAAqB3B,EAAKP,MAAM4B,IAAKovD,EAAUsN,UAAUh8D,YAC7F,GAAIuH,EAAE9I,QAA+B,GAArB8I,EAAE9I,OAAO6G,SAAe,CAC7C,IAAI+rC,EAAOpzC,EAAKgwB,QAAQk0B,YAAY56C,EAAE9I,QAAQ,GAC1C4yC,GAAQA,EAAKhxC,KAAKxB,KAAKC,KAAKmpB,WAAaopB,GAAQpzC,EAAKgwB,SACtDhwB,EAAKN,SAASM,EAAKP,MAAMI,GAAG8B,aAAa,YAAqB3B,EAAKP,MAAM4B,IAAK+xC,EAAK+Q,aAEzF,IAAI5iD,EAAQvB,EAAKP,MAAME,UAAUsB,UAC7B2B,EAAMi0D,GAAsB72D,EAAMuB,GAClCiN,EAAM5L,EAAI4L,IACV1B,EAAOlK,EAAIkK,KACfxD,EAAEgoB,aAAaguC,YACfh2D,EAAEgoB,aAAaiuC,QAAQL,GAAqB,OAAS,YAAa1wD,EAAIgW,WAEtElb,EAAEgoB,aAAawuC,cAAgB,WAC1BZ,IAAsB51D,EAAEgoB,aAAaiuC,QAAQ,aAAczyD,GAChE9M,EAAK+/D,SAAW,IAAIJ,GAASp+D,GAAQ+H,EAAEs2D,OAGzCv5C,GAAS25C,QAAU,SAAUhgE,GAC3B,IAAI+/D,EAAW//D,EAAK+/D,SACpBtxD,OAAOyX,YAAW,WACZlmB,EAAK+/D,UAAYA,IAAa//D,EAAK+/D,SAAW,QACjD,KAGLxE,GAAa0E,SAAW1E,GAAa2E,UAAY,SAAU1qC,EAAGlsB,GAAK,OAAOA,EAAE4oB,kBAE5EqpC,GAAal0C,KAAO,SAAUrnB,EAAMsJ,GAClC,IAAIy2D,EAAW//D,EAAK+/D,SAGpB,GAFA//D,EAAK+/D,SAAW,KAEXz2D,EAAEgoB,aAAP,CAEA,IAAI6uC,EAAWngE,EAAKsjD,YAAYwY,GAAYxyD,IAC5C,GAAK62D,EAAL,CACA,IAAIC,EAASpgE,EAAKP,MAAM4B,IAAIO,QAAQu+D,EAASp+D,KAC7C,GAAKq+D,EAAL,CACA,IAAI7+D,EAAQw+D,GAAYA,EAASx+D,MAC7BA,EACFvB,EAAKgX,SAAS,mBAAmB,SAAUC,GAAK1V,EAAQ0V,EAAE1V,MAE1DA,EAAQ21D,GAAmBl3D,EAAMsJ,EAAEgoB,aAAa7J,QAAQy3C,GAAqB,OAAS,cAC3DA,GAAqB,KAAO51D,EAAEgoB,aAAa7J,QAAQ,cAAc,EAAO24C,GAErG,IAAIljB,EAAO6iB,IAAaz2D,EAAEs2D,IAC1B,GAAI5/D,EAAKgX,SAAS,cAAc,SAAUC,GAAK,OAAOA,EAAEjX,EAAMsJ,EAAG/H,GAAS,WAAa27C,MACrF5zC,EAAE4oB,sBAGJ,GAAK3wB,EAAL,CAEA+H,EAAE4oB,iBACF,IAAIgnB,EAAY33C,GAAQ,QAAUvB,EAAKP,MAAM4B,IAAK++D,EAAOr+D,IAAKR,GAAS6+D,EAAOr+D,IAC7D,MAAbm3C,IAAqBA,EAAYknB,EAAOr+D,KAE5C,IAAIlC,EAAKG,EAAKP,MAAMI,GAChBq9C,GAAQr9C,EAAGL,kBAEf,IAAIuC,EAAMlC,EAAGgC,QAAQC,IAAIo3C,GACrBmnB,EAA4B,GAAnB9+D,EAAM46B,WAAmC,GAAjB56B,EAAM66B,SAA4C,GAA5B76B,EAAMN,QAAQyB,WACrE49D,EAAezgE,EAAGwB,IAKtB,GAJIg/D,EACAxgE,EAAGmxC,iBAAiBjvC,EAAKA,EAAKR,EAAMN,QAAQsB,YAE5C1C,EAAGkxC,aAAahvC,EAAKA,EAAKR,IAC1B1B,EAAGwB,IAAIiS,GAAGgtD,GAAd,CAEA,IAAIx9D,EAAOjD,EAAGwB,IAAIO,QAAQG,GAC1B,GAAIs+D,GAAU,kBAA2B9+D,EAAMN,QAAQsB,aACnDO,EAAKK,WAAaL,EAAKK,UAAUm2B,WAAW/3B,EAAMN,QAAQsB,YAC5D1C,EAAG8B,aAAa,IAAI,KAAcmB,QAC7B,CACL,IAAI+B,EAAMhF,EAAGgC,QAAQC,IAAIo3C,GACzBr5C,EAAGgC,QAAQuT,KAAKvV,EAAGgC,QAAQuT,KAAKjP,OAAS,GAAG8E,SAAQ,SAAUoK,EAAOC,EAAKC,EAAUC,GAAS,OAAO3Q,EAAM2Q,KAC1G3V,EAAG8B,aAAayuD,GAAiBpwD,EAAM8C,EAAMjD,EAAGwB,IAAIO,QAAQiD,KAE9D7E,EAAKkT,QACLlT,EAAKN,SAASG,EAAG6Z,QAAQ,UAAW,eAGtC2M,GAASnT,MAAQ,SAAUlT,GACpBA,EAAKm8D,UACRn8D,EAAK4wD,YAAYnH,OACjBzpD,EAAKwO,IAAIg7C,UAAUja,IAAI,uBACvBvvC,EAAK4wD,YAAY3pD,QACjBjH,EAAKm8D,SAAU,EACfj2C,YAAW,WACLlmB,EAAKgwB,SAAWhwB,EAAKoT,aAAepT,EAAK4wD,YAAYC,iBAAiBv9C,GAAGtT,EAAK8jD,KAAKp1C,iBACnF6hD,GAAevwD,KAClB,MAIPqmB,GAAShY,KAAO,SAAUrO,EAAMsJ,GAC1BtJ,EAAKm8D,UACPn8D,EAAK4wD,YAAYnH,OACjBzpD,EAAKwO,IAAIg7C,UAAU9wB,OAAO,uBAC1B14B,EAAK4wD,YAAY3pD,QACbqC,EAAEi3D,eAAiBvgE,EAAKwO,IAAIyY,SAAS3d,EAAEi3D,gBACvCvgE,EAAK4wD,YAAYC,iBAAiBn1B,IAAI,IAC1C17B,EAAKm8D,SAAU,IAInB91C,GAASm6C,YAAc,SAAUxgE,EAAMsW,GAMrC,GAAIH,EAAO6gB,QAAU7gB,EAAOsoC,SAA8B,yBAAnBnoC,EAAMmqD,UAAsC,CACjFzgE,EAAK4wD,YAAYsJ,YACjB,IAAI5E,EAAiBt1D,EAAKs1D,eAC1BpvC,YAAW,WACT,GAAIlmB,EAAKs1D,gBAAkBA,IAE3Bt1D,EAAKwO,IAAIH,OACTrO,EAAKkT,SACDlT,EAAKgX,SAAS,iBAAiB,SAAUC,GAAK,OAAOA,EAAEjX,EAAMmgD,EAAS,EAAG,kBAA7E,CACA,IACIlgD,EADMD,EAAKP,MAAME,UACHM,QAEdA,GAAWA,EAAQ8B,IAAM,GAAK/B,EAAKN,SAASM,EAAKP,MAAMI,GAAGsC,OAAOlC,EAAQ8B,IAAM,EAAG9B,EAAQ8B,KAAKjC,qBAClG,MAKUy7D,GAAgBl1C,GAAShO,IAAQkjD,GAAaljD,IAE/D,SAASqoD,GAAYv0C,EAAGrE,GACtB,GAAIqE,GAAKrE,EAAK,OAAO,EACrB,IAAK,IAAI2S,KAAKtO,EAAK,GAAIA,EAAEsO,KAAO3S,EAAE2S,GAAM,OAAO,EAC/C,IAAK,IAAIY,KAAOvT,EAAK,KAAMuT,KAAOlP,GAAM,OAAO,EAC/C,OAAO,EAGT,IAAIw0C,GAAa,SAAoBx2C,EAAOtpB,GAC1CiL,KAAKjL,KAAOA,GAAQ+/D,GACpB90D,KAAKzJ,KAAOyJ,KAAKjL,KAAKwB,MAAQ,EAC9ByJ,KAAKqe,MAAQA,GAGfw2C,GAAWp2D,UAAUzI,IAAM,SAAcD,EAASg/D,EAAMrvD,EAAQsvD,GAC9D,IAAIl+D,EAAMf,EAAQ+wB,UAAUiuC,EAAKp/D,KAAOq/D,EAAWh1D,KAAKzJ,KAAO,GAAK,EAAI,GAClEN,EAAMa,EAAIb,IAEhB,OADgBa,EAAI8vB,QACH,KAAO,IAAIquC,GAAWh/D,EAAMyP,EAAQzP,EAAMyP,EAAQ1F,OAGrE60D,GAAWp2D,UAAUy2D,MAAQ,WAAoB,OAAO,GAExDL,GAAWp2D,UAAU+I,GAAK,SAAa2mB,GACrC,OAAOnuB,MAAQmuB,GACZA,aAAiB0mC,KAChB70D,KAAKjL,KAAKqH,KAAO4D,KAAKjL,KAAKqH,KAAO+xB,EAAMp5B,KAAKqH,KAC7C4D,KAAKqe,OAAS8P,EAAM9P,OAASu2C,GAAY50D,KAAKjL,KAAMo5B,EAAMp5B,QAGhE8/D,GAAWp2D,UAAU4c,QAAU,SAAkB/kB,GAC3C0J,KAAKjL,KAAKsmB,SAAWrb,KAAKjL,KAAKsmB,QAAQ/kB,IAG7C,IAAI6+D,GAAa,SAAoB35D,EAAOzG,GAC1CiL,KAAKjL,KAAOA,GAAQ+/D,GACpB90D,KAAKxE,MAAQA,GAGf25D,GAAW12D,UAAUzI,IAAM,SAAcD,EAASg/D,EAAMrvD,EAAQsvD,GAC9D,IAAIr/D,EAAOI,EAAQC,IAAI++D,EAAKp/D,KAAOq/D,EAAWh1D,KAAKjL,KAAKqgE,gBAAkB,EAAI,GAAK1vD,EAC/EhQ,EAAKK,EAAQC,IAAI++D,EAAKr/D,GAAKs/D,EAAWh1D,KAAKjL,KAAKsgE,aAAe,GAAK,GAAK3vD,EAC7E,OAAO/P,GAAQD,EAAK,KAAO,IAAIu/D,GAAWt/D,EAAMD,EAAIsK,OAGtDm1D,GAAW12D,UAAUy2D,MAAQ,SAAgBxrC,EAAGqrC,GAAQ,OAAOA,EAAKp/D,KAAOo/D,EAAKr/D,IAEhFy/D,GAAW12D,UAAU+I,GAAK,SAAa2mB,GACrC,OAAOnuB,MAAQmuB,GACZA,aAAiBgnC,IAAcP,GAAY50D,KAAKxE,MAAO2yB,EAAM3yB,QAC7Do5D,GAAY50D,KAAKjL,KAAMo5B,EAAMp5B,OAGlCogE,GAAWG,GAAK,SAAaP,GAAQ,OAAOA,EAAKjgE,gBAAgBqgE,IAEjE,IAAIz8B,GAAW,SAAkBl9B,EAAOzG,GACtCiL,KAAKjL,KAAOA,GAAQ+/D,GACpB90D,KAAKxE,MAAQA,GAGfk9B,GAASj6B,UAAUzI,IAAM,SAAcD,EAASg/D,EAAMrvD,EAAQsvD,GAC5D,IAAIr/D,EAAOI,EAAQ+wB,UAAUiuC,EAAKp/D,KAAOq/D,EAAW,GACpD,GAAIr/D,EAAKixB,QAAW,OAAO,KAC3B,IAAIlxB,EAAKK,EAAQ+wB,UAAUiuC,EAAKr/D,GAAKs/D,GAAY,GACjD,OAAIt/D,EAAGkxB,SAAWlxB,EAAGO,KAAON,EAAKM,IAAc,KACxC,IAAIg/D,GAAWt/D,EAAKM,IAAMyP,EAAQhQ,EAAGO,IAAMyP,EAAQ1F,OAG5D04B,GAASj6B,UAAUy2D,MAAQ,SAAgB5+D,EAAMy+D,GAC/C,IAGMt3D,EAHF3G,EAAMR,EAAKnB,QAAQ05B,UAAUkmC,EAAKp/D,MAChCuB,EAAQJ,EAAII,MACZwO,EAAS5O,EAAI4O,OAEnB,OAAOA,GAAUqvD,EAAKp/D,QAAU8H,EAAQnH,EAAKmH,MAAMvG,IAAQkK,QAAUsE,EAASjI,EAAMvH,UAAY6+D,EAAKr/D,IAGvGgjC,GAASj6B,UAAU+I,GAAK,SAAa2mB,GACnC,OAAOnuB,MAAQmuB,GACZA,aAAiBuK,IAAYk8B,GAAY50D,KAAKxE,MAAO2yB,EAAM3yB,QAC3Do5D,GAAY50D,KAAKjL,KAAMo5B,EAAMp5B,OAMlC,IAAIkgE,GAAa,SAAoBt/D,EAAMD,EAAIZ,GAG7CkL,KAAKrK,KAAOA,EAIZqK,KAAKtK,GAAKA,EACVsK,KAAKlL,KAAOA,GAGVy7B,GAAuB,CAAEx7B,KAAM,CAAEi5B,cAAc,GAAOjQ,OAAQ,CAAEiQ,cAAc,IAElFinC,GAAWx2D,UAAUlE,KAAO,SAAe5E,EAAMD,GAC/C,OAAO,IAAIu/D,GAAWt/D,EAAMD,EAAIsK,KAAKlL,OAGvCmgE,GAAWx2D,UAAU+I,GAAK,SAAa2mB,EAAOzoB,GAG5C,YAFkB,IAAXA,IAAoBA,EAAS,GAE7B1F,KAAKlL,KAAK0S,GAAG2mB,EAAMr5B,OAASkL,KAAKrK,KAAO+P,GAAUyoB,EAAMx4B,MAAQqK,KAAKtK,GAAKgQ,GAAUyoB,EAAMz4B,IAGnGu/D,GAAWx2D,UAAUzI,IAAM,SAAcD,EAAS2P,EAAQsvD,GACxD,OAAOh1D,KAAKlL,KAAKkB,IAAID,EAASiK,KAAM0F,EAAQsvD,IAwD9CC,GAAW/Y,OAAS,SAAiBjmD,EAAKooB,EAAOtpB,GAC/C,OAAO,IAAIkgE,GAAWh/D,EAAKA,EAAK,IAAI4+D,GAAWx2C,EAAOtpB,KAoBxDkgE,GAAWl3C,OAAS,SAAiBpoB,EAAMD,EAAI8F,EAAOzG,GACpD,OAAO,IAAIkgE,GAAWt/D,EAAMD,EAAI,IAAIy/D,GAAW35D,EAAOzG,KAYxDkgE,GAAW3+D,KAAO,SAAeX,EAAMD,EAAI8F,EAAOzG,GAChD,OAAO,IAAIkgE,GAAWt/D,EAAMD,EAAI,IAAIgjC,GAASl9B,EAAOzG,KAMtDw7B,GAAqBx7B,KAAKy3B,IAAM,WAAc,OAAOxsB,KAAKlL,KAAKC,MAE/Dw7B,GAAqBxS,OAAOyO,IAAM,WAAc,OAAOxsB,KAAKlL,gBAAgBqgE,IAE5E32D,OAAO6wB,iBAAkB4lC,GAAWx2D,UAAW8xB,IAkB/C,IAAIJ,GAAO,GAAI2kC,GAAS,GAOpBS,GAAgB,SAAuBC,EAAO5a,GAChD56C,KAAKw1D,MAAQA,GAASA,EAAMn7D,OAASm7D,EAAQrlC,GAC7CnwB,KAAK46C,SAAWA,GAAYA,EAASvgD,OAASugD,EAAWzqB,IAM3DolC,GAAcj7D,OAAS,SAAiB/E,EAAKgsB,GAC3C,OAAOA,EAAYlnB,OAASo7D,GAAUl0C,EAAahsB,EAAK,EAAGu/D,IAAUhhE,IAUvEyhE,GAAc92D,UAAU2G,KAAO,SAAejK,EAAOpC,EAAK+X,GACxD,IAAIzG,EAAS,GAEb,OADArK,KAAK01D,UAAmB,MAATv6D,EAAgB,EAAIA,EAAc,MAAPpC,EAAc,IAAMA,EAAKsR,EAAQ,EAAGyG,GACvEzG,GAGTkrD,GAAc92D,UAAUi3D,UAAY,SAAoBv6D,EAAOpC,EAAKsR,EAAQ3E,EAAQoL,GAClF,IAAK,IAAI7Z,EAAI,EAAGA,EAAI+I,KAAKw1D,MAAMn7D,OAAQpD,IAAK,CAC1C,IAAI89D,EAAO/0D,KAAKw1D,MAAMv+D,GAClB89D,EAAKp/D,MAAQoD,GAAOg8D,EAAKr/D,IAAMyF,KAAW2V,GAAaA,EAAUikD,EAAKhgE,QACtEsV,EAAOzP,KAAKm6D,EAAKx6D,KAAKw6D,EAAKp/D,KAAO+P,EAAQqvD,EAAKr/D,GAAKgQ,IAE1D,IAAK,IAAI1K,EAAM,EAAGA,EAAMgF,KAAK46C,SAASvgD,OAAQW,GAAO,EACnD,GAAIgF,KAAK46C,SAAS5/C,GAAOjC,GAAOiH,KAAK46C,SAAS5/C,EAAM,GAAKG,EAAO,CAC9D,IAAIw6D,EAAW31D,KAAK46C,SAAS5/C,GAAO,EACpCgF,KAAK46C,SAAS5/C,EAAM,GAAG06D,UAAUv6D,EAAQw6D,EAAU58D,EAAM48D,EAAUtrD,EAAQ3E,EAASiwD,EAAU7kD,KAepGykD,GAAc92D,UAAUzI,IAAM,SAAcD,EAASR,EAAK8K,GACxD,OAAIL,MAAQlM,IAAgC,GAAvBiC,EAAQuT,KAAKjP,OAAsB2F,KACjDA,KAAK41D,SAAS7/D,EAASR,EAAK,EAAG,EAAG8K,GAAWy0D,KAGtDS,GAAc92D,UAAUm3D,SAAW,SAAmB7/D,EAASO,EAAMoP,EAAQsvD,EAAW30D,GAEtF,IADA,IAAIw1D,EACK5+D,EAAI,EAAGA,EAAI+I,KAAKw1D,MAAMn7D,OAAQpD,IAAK,CAC1C,IAAIs2C,EAASvtC,KAAKw1D,MAAMv+D,GAAGjB,IAAID,EAAS2P,EAAQsvD,GAC5CznB,GAAUA,EAAOz4C,KAAKogE,MAAM5+D,EAAMi3C,IAAYsoB,IAAaA,EAAW,KAAKj7D,KAAK2yC,GAC3EltC,EAAQy1D,UAAYz1D,EAAQy1D,SAAS91D,KAAKw1D,MAAMv+D,GAAGlC,MAG9D,OAAIiL,KAAK46C,SAASvgD,OAmNpB,SAAqB07D,EAAaF,EAAU9/D,EAASO,EAAMoP,EAAQsvD,EAAW30D,GAiB5E,IAhBA,IAAIu6C,EAAWmb,EAAYtgE,QAIvB0U,EAAQ,SAAU+f,EAAUC,EAAQH,EAAUC,GAChD,IAAK,IAAIhzB,EAAI,EAAGA,EAAI2jD,EAASvgD,OAAQpD,GAAK,EAAG,CAC3C,IAAI8B,EAAM6hD,EAAS3jD,EAAI,GAAI++D,OAAQ,GACvB,GAARj9D,GAAamxB,EAAWnxB,EAAMi8D,IAC9B7qC,GAAUywB,EAAS3jD,GAAK+9D,EAC1Bpa,EAAS3jD,EAAI,IAAM,EACV+yB,GAAYtkB,IAAWswD,EAAS/rC,EAASD,GAAaG,EAASD,MACxE0wB,EAAS3jD,IAAM++D,EACfpb,EAAS3jD,EAAI,IAAM++D,MAIhB/+D,EAAI,EAAGA,EAAIlB,EAAQuT,KAAKjP,OAAQpD,IAAOlB,EAAQuT,KAAKrS,GAAGkI,QAAQgL,GAKxE,IADA,IAAI8rD,GAAc,EACTj7D,EAAM,EAAGA,EAAM4/C,EAASvgD,OAAQW,GAAO,EAAK,IAA0B,GAAtB4/C,EAAS5/C,EAAM,GAAU,CAChF,IAAIrF,EAAOI,EAAQC,IAAI+/D,EAAY/6D,GAAOg6D,GAAYkB,EAAYvgE,EAAO+P,EACzE,GAAIwwD,EAAY,GAAKA,GAAa5/D,EAAKnB,QAAQC,KAAM,CACnD6gE,GAAc,EACd,SAGF,IAA4DE,EAAnDpgE,EAAQC,IAAI+/D,EAAY/6D,EAAM,GAAKg6D,GAAY,GAAmBtvD,EACvE5O,EAAMR,EAAKnB,QAAQ05B,UAAUqnC,GAC7Bh/D,EAAQJ,EAAII,MACZk/D,EAAct/D,EAAI4O,OAClB2wD,EAAY//D,EAAKo4B,WAAWx3B,GAChC,GAAIm/D,GAAaD,GAAeF,GAAaE,EAAcC,EAAUngE,UAAYigE,EAAS,CACxF,IAAI5oB,EAASqN,EAAS5/C,EAAM,GAAG46D,SAAS7/D,EAASsgE,EAAW1gE,EAAO,EAAGogE,EAAY/6D,GAAOg6D,EAAY,EAAG30D,GACpGktC,GAAUz5C,IACZ8mD,EAAS5/C,GAAOk7D,EAChBtb,EAAS5/C,EAAM,GAAKm7D,EACpBvb,EAAS5/C,EAAM,GAAKuyC,IAEpBqN,EAAS5/C,EAAM,IAAM,EACrBi7D,GAAc,QAGhBA,GAAc,EAKlB,GAAIA,EAAa,CACf,IAAI10C,EA4BR,SAA0Cq5B,EAAUmb,EAAax0C,EAAaxrB,EAAS2P,EAAQsvD,EAAW30D,GAExG,SAASi2D,EAAO1mC,EAAKolC,GACnB,IAAK,IAAI/9D,EAAI,EAAGA,EAAI24B,EAAI4lC,MAAMn7D,OAAQpD,IAAK,CACzC,IAAIs2C,EAAS3d,EAAI4lC,MAAMv+D,GAAGjB,IAAID,EAAS2P,EAAQsvD,GAC3CznB,EAAUhsB,EAAY3mB,KAAK2yC,GACtBltC,EAAQy1D,UAAYz1D,EAAQy1D,SAASlmC,EAAI4lC,MAAMv+D,GAAGlC,MAE7D,IAAK,IAAIiG,EAAM,EAAGA,EAAM40B,EAAIgrB,SAASvgD,OAAQW,GAAO,EAChDs7D,EAAO1mC,EAAIgrB,SAAS5/C,EAAM,GAAI40B,EAAIgrB,SAAS5/C,GAAOg6D,EAAY,GAEpE,IAAK,IAAI/9D,EAAI,EAAGA,EAAI2jD,EAASvgD,OAAQpD,GAAK,GAA6B,GAApB2jD,EAAS3jD,EAAI,IAC5Dq/D,EAAO1b,EAAS3jD,EAAI,GAAI8+D,EAAY9+D,GAAK+9D,EAAY,GAEzD,OAAOzzC,EA1Cag1C,CAAiC3b,EAAUmb,EAAaF,GAAY,GAAI9/D,EACvC2P,EAAQsvD,EAAW30D,GAClE+3B,EAAQq9B,GAAUl0C,EAAajrB,EAAM,EAAG+J,GAC5Cw1D,EAAWz9B,EAAMo9B,MACjB,IAAK,IAAIj4D,EAAM,EAAGA,EAAMq9C,EAASvgD,OAAQkD,GAAO,EAASq9C,EAASr9C,EAAM,GAAK,IAC3Eq9C,EAAS/tB,OAAOtvB,EAAK,GACrBA,GAAO,GAET,IAAK,IAAI0iD,EAAM,EAAGvsC,EAAI,EAAGusC,EAAM7nB,EAAMwiB,SAASvgD,OAAQ4lD,GAAO,EAAG,CAE9D,IADA,IAAIuW,EAASp+B,EAAMwiB,SAASqF,GACrBvsC,EAAIknC,EAASvgD,QAAUugD,EAASlnC,GAAK8iD,GAAU9iD,GAAK,EAC3DknC,EAAS/tB,OAAOnZ,EAAG,EAAG0kB,EAAMwiB,SAASqF,GAAM7nB,EAAMwiB,SAASqF,EAAM,GAAI7nB,EAAMwiB,SAASqF,EAAM,KAI7F,OAAO,IAAIsV,GAAcM,GAAYA,EAASl2C,KAAK82C,IAAQ7b,GApRhD8b,CAAY12D,KAAK46C,SAAUib,EAAU9/D,EAASO,EAAMoP,EAAQsvD,EAAW30D,GAEvEw1D,EAAW,IAAIN,GAAcM,EAASl2C,KAAK82C,KAAU3iE,IAOlEyhE,GAAc92D,UAAUglC,IAAM,SAAcluC,EAAKgsB,GAC/C,OAAKA,EAAYlnB,OACb2F,MAAQlM,GAAgByhE,GAAcj7D,OAAO/E,EAAKgsB,GAC/CvhB,KAAK22D,SAASphE,EAAKgsB,EAAa,GAFLvhB,MAKpCu1D,GAAc92D,UAAUk4D,SAAW,SAAmBphE,EAAKgsB,EAAa7b,GACpE,IAEEk1C,EAFE1gB,EAASl6B,KAED62C,EAAa,EAC3BthD,EAAI4J,SAAQ,SAAUk3D,EAAWD,GAC/B,IAAuCh5D,EAAnCw5D,EAAaR,EAAc1wD,EAC/B,GAAMtI,EAAQy5D,GAAiBt1C,EAAa80C,EAAWO,GAAvD,CAGA,IADKhc,IAAYA,EAAW1gB,EAAO0gB,SAASnlD,SACrCohD,EAAa+D,EAASvgD,QAAUugD,EAAS/D,GAAcuf,GAAevf,GAAc,EACvF+D,EAAS/D,IAAeuf,EACxBxb,EAAS/D,EAAa,GAAK+D,EAAS/D,EAAa,GAAG8f,SAASN,EAAWj5D,EAAOw5D,EAAa,GAE5Fhc,EAAS/tB,OAAOgqB,EAAY,EAAGuf,EAAaA,EAAcC,EAAUngE,SAAUu/D,GAAUr4D,EAAOi5D,EAAWO,EAAa,EAAG9B,KAC9Hje,GAAc,MAIhB,IADA,IAAI2e,EAAQsB,GAAUjgB,EAAakgB,GAAax1C,GAAeA,GAAc7b,GACpEzO,EAAI,EAAGA,EAAIu+D,EAAMn7D,OAAQpD,IAAYu+D,EAAMv+D,GAAGnC,KAAKogE,MAAM3/D,EAAKigE,EAAMv+D,KAAOu+D,EAAM3oC,OAAO51B,IAAK,GAEtG,OAAO,IAAIs+D,GAAcC,EAAMn7D,OAAS2F,KAAKw1D,MAAMzoC,OAAOyoC,GAAO71C,KAAK82C,IAASz2D,KAAKw1D,MAC3D5a,GAAY56C,KAAK46C,WAM5C2a,GAAc92D,UAAUmuB,OAAS,SAAiBrL,GAChD,OAA0B,GAAtBA,EAAYlnB,QAAe2F,MAAQlM,GAAgBkM,KAChDA,KAAKg3D,YAAYz1C,EAAa,IAGvCg0C,GAAc92D,UAAUu4D,YAAc,SAAsBz1C,EAAa7b,GAEvE,IADA,IAAIk1C,EAAW56C,KAAK46C,SAAU4a,EAAQx1D,KAAKw1D,MAClCv+D,EAAI,EAAGA,EAAI2jD,EAASvgD,OAAQpD,GAAK,EAAG,CAE3C,IADA,IAAImG,OAAQ,EAAUzH,EAAOilD,EAAS3jD,GAAKyO,EAAQhQ,EAAKklD,EAAS3jD,EAAI,GAAKyO,EACjEgO,EAAI,EAAGqhD,OAAO,EAAUrhD,EAAI6N,EAAYlnB,OAAQqZ,KAAWqhD,EAAOxzC,EAAY7N,KACjFqhD,EAAKp/D,KAAOA,GAAQo/D,EAAKr/D,GAAKA,IAChC6rB,EAAY7N,GAAK,MACftW,IAAUA,EAAQ,KAAKxC,KAAKm6D,IAGlC,GAAK33D,EAAL,CACIw9C,GAAY56C,KAAK46C,WAAYA,EAAW56C,KAAK46C,SAASnlD,SAC1D,IAAIg5C,EAAUmM,EAAS3jD,EAAI,GAAG+/D,YAAY55D,EAAOzH,EAAO,GACpD84C,GAAW36C,GACb8mD,EAAS3jD,EAAI,GAAKw3C,GAElBmM,EAAS/tB,OAAO51B,EAAG,GACnBA,GAAK,IAGT,GAAIu+D,EAAMn7D,OAAU,IAAK,IAAIW,EAAM,EAAGi8D,OAAS,EAAUj8D,EAAMumB,EAAYlnB,OAAQW,IAAS,GAAIi8D,EAAS11C,EAAYvmB,GACnH,IAAK,IAAIyhD,EAAM,EAAGA,EAAM+Y,EAAMn7D,OAAQoiD,IAAa+Y,EAAM/Y,GAAKj1C,GAAGyvD,EAAQvxD,KACnE8vD,GAASx1D,KAAKw1D,QAASA,EAAQx1D,KAAKw1D,MAAM//D,SAC9C+/D,EAAM3oC,OAAO4vB,IAAO,IAGxB,OAAI7B,GAAY56C,KAAK46C,UAAY4a,GAASx1D,KAAKw1D,MAAgBx1D,KACxDw1D,EAAMn7D,QAAUugD,EAASvgD,OAAS,IAAIk7D,GAAcC,EAAO5a,GAAY9mD,IAGhFyhE,GAAc92D,UAAUghD,SAAW,SAAmB/5C,EAAQpP,GAC5D,GAAI0J,MAAQlM,GAAS,OAAOkM,KAC5B,GAAI1J,EAAKiwB,OAAU,OAAOgvC,GAAczhE,MAGxC,IADA,IAAI2J,EAAO+3D,EACFv+D,EAAI,EAAGA,EAAI+I,KAAK46C,SAASvgD,OAAQpD,GAAK,EAAK,GAAI+I,KAAK46C,SAAS3jD,IAAMyO,EAAQ,CAC9E1F,KAAK46C,SAAS3jD,IAAMyO,IAAUjI,EAAQuC,KAAK46C,SAAS3jD,EAAI,IAC5D,MAGF,IADA,IAAIkE,EAAQuK,EAAS,EAAG3M,EAAMoC,EAAQ7E,EAAKnB,QAAQC,KAC1C4F,EAAM,EAAGA,EAAMgF,KAAKw1D,MAAMn7D,OAAQW,IAAO,CAChD,IAAIk8D,EAAMl3D,KAAKw1D,MAAMx6D,GACrB,GAAIk8D,EAAIvhE,KAAOoD,GAAOm+D,EAAIxhE,GAAKyF,GAAU+7D,EAAIpiE,gBAAgBqgE,GAAa,CACxE,IAAIx/D,EAAO0L,KAAKC,IAAInG,EAAO+7D,EAAIvhE,MAAQwF,EAAOzF,EAAK2L,KAAKc,IAAIpJ,EAAKm+D,EAAIxhE,IAAMyF,EACvExF,EAAOD,IAAO8/D,IAAUA,EAAQ,KAAK56D,KAAKs8D,EAAI38D,KAAK5E,EAAMD,KAGjE,GAAI8/D,EAAO,CACT,IAAI2B,EAAW,IAAI5B,GAAcC,EAAM71C,KAAK82C,KAC5C,OAAOh5D,EAAQ,IAAI25D,GAAgB,CAACD,EAAU15D,IAAU05D,EAE1D,OAAO15D,GAAS3J,IAGlByhE,GAAc92D,UAAU+I,GAAK,SAAa2mB,GACxC,GAAInuB,MAAQmuB,EAAS,OAAO,EAC5B,KAAMA,aAAiBonC,KACnBv1D,KAAKw1D,MAAMn7D,QAAU8zB,EAAMqnC,MAAMn7D,QACjC2F,KAAK46C,SAASvgD,QAAU8zB,EAAMysB,SAASvgD,OAAU,OAAO,EAC5D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAKw1D,MAAMn7D,OAAQpD,IACnC,IAAK+I,KAAKw1D,MAAMv+D,GAAGuQ,GAAG2mB,EAAMqnC,MAAMv+D,IAAO,OAAO,EACpD,IAAK,IAAI+D,EAAM,EAAGA,EAAMgF,KAAK46C,SAASvgD,OAAQW,GAAO,EACjD,GAAIgF,KAAK46C,SAAS5/C,IAAQmzB,EAAMysB,SAAS5/C,IACvCgF,KAAK46C,SAAS5/C,EAAM,IAAMmzB,EAAMysB,SAAS5/C,EAAM,KAC9CgF,KAAK46C,SAAS5/C,EAAM,GAAGwM,GAAG2mB,EAAMysB,SAAS5/C,EAAM,IAAO,OAAO,EACpE,OAAO,GAGTu6D,GAAc92D,UAAU+gD,OAAS,SAAiBlpD,GAChD,OAAO+gE,GAAcr3D,KAAKs3D,YAAYhhE,KAGxCi/D,GAAc92D,UAAU64D,YAAc,SAAsBhhE,GAC1D,GAAI0J,MAAQlM,GAAS,OAAOq8B,GAC5B,GAAI75B,EAAKsC,gBAAkBoH,KAAKw1D,MAAMr+C,KAAKg+C,GAAWG,IAAO,OAAOt1D,KAAKw1D,MAEzE,IADA,IAAInrD,EAAS,GACJpT,EAAI,EAAGA,EAAI+I,KAAKw1D,MAAMn7D,OAAQpD,IAC/B+I,KAAKw1D,MAAMv+D,GAAGnC,gBAAgBqgE,IAChC9qD,EAAOzP,KAAKoF,KAAKw1D,MAAMv+D,IAE7B,OAAOoT,GAYT,IAAIvW,GAAQ,IAAIyhE,GAIhBA,GAAczhE,MAAQA,GAEtByhE,GAAc8B,cAAgBA,GAK9B,IAAID,GAAkB,SAAyBG,GAC7Cv3D,KAAKu3D,QAAUA,GAgIjB,SAAST,GAAUU,EAAO9xD,GACxB,IAAKA,IAAW8xD,EAAMn9D,OAAU,OAAOm9D,EAEvC,IADA,IAAIntD,EAAS,GACJpT,EAAI,EAAGA,EAAIugE,EAAMn9D,OAAQpD,IAAK,CACrC,IAAI89D,EAAOyC,EAAMvgE,GACjBoT,EAAOzP,KAAK,IAAIq6D,GAAWF,EAAKp/D,KAAO+P,EAAQqvD,EAAKr/D,GAAKgQ,EAAQqvD,EAAKjgE,OAExE,OAAOuV,EAoBT,SAASwsD,GAAiBW,EAAOlhE,EAAMoP,GACrC,GAAIpP,EAAKiwB,OAAU,OAAO,KAE1B,IADA,IAAIxtB,EAAM2M,EAASpP,EAAKJ,SAAUkH,EAAQ,KACjCnG,EAAI,EAAG89D,OAAO,EAAU99D,EAAIugE,EAAMn9D,OAAQpD,KAC5C89D,EAAOyC,EAAMvgE,KAAO89D,EAAKp/D,KAAO+P,GAAUqvD,EAAKr/D,GAAKqD,KAC5DqE,IAAUA,EAAQ,KAAKxC,KAAKm6D,GACvByC,EAAMvgE,GAAK,MAGf,OAAOmG,EAGT,SAAS25D,GAAa3tC,GAEpB,IADA,IAAI/e,EAAS,GACJpT,EAAI,EAAGA,EAAImyB,EAAM/uB,OAAQpD,IACd,MAAZmyB,EAAMnyB,IAAcoT,EAAOzP,KAAKwuB,EAAMnyB,IAC9C,OAAOoT,EAQT,SAASorD,GAAU+B,EAAOlhE,EAAMoP,EAAQrF,GACtC,IAAIu6C,EAAW,GAAI6c,GAAW,EAC9BnhE,EAAK6I,SAAQ,SAAUk3D,EAAWqB,GAChC,IAAIt6D,EAAQy5D,GAAiBW,EAAOnB,EAAWqB,EAAahyD,GAC5D,GAAItI,EAAO,CACTq6D,GAAW,EACX,IAAI/J,EAAU+H,GAAUr4D,EAAOi5D,EAAW3wD,EAASgyD,EAAa,EAAGr3D,GAC/DqtD,GAAW55D,IACX8mD,EAAShgD,KAAK88D,EAAYA,EAAarB,EAAUngE,SAAUw3D,OAInE,IADA,IAAIlO,EAASsX,GAAUW,EAAWV,GAAaS,GAASA,GAAQ9xD,GAAQia,KAAK82C,IACpEx/D,EAAI,EAAGA,EAAIuoD,EAAOnlD,OAAQpD,IAAYuoD,EAAOvoD,GAAGnC,KAAKogE,MAAM5+D,EAAMkpD,EAAOvoD,MAC3EoJ,EAAQy1D,UAAYz1D,EAAQy1D,SAAStW,EAAOvoD,GAAGlC,MACnDyqD,EAAO3yB,OAAO51B,IAAK,IAErB,OAAOuoD,EAAOnlD,QAAUugD,EAASvgD,OAAS,IAAIk7D,GAAc/V,EAAQ5E,GAAY9mD,GAOlF,SAAS2iE,GAAMp2C,EAAGrE,GAChB,OAAOqE,EAAE1qB,KAAOqmB,EAAErmB,MAAQ0qB,EAAE3qB,GAAKsmB,EAAEtmB,GAQrC,SAAS2hE,GAAcG,GAErB,IADA,IAAIG,EAAUH,EACLvgE,EAAI,EAAGA,EAAI0gE,EAAQt9D,OAAS,EAAGpD,IAAK,CAC3C,IAAI89D,EAAO4C,EAAQ1gE,GACnB,GAAI89D,EAAKp/D,MAAQo/D,EAAKr/D,GAAM,IAAK,IAAIge,EAAIzc,EAAI,EAAGyc,EAAIikD,EAAQt9D,OAAQqZ,IAAK,CACvE,IAAImf,EAAO8kC,EAAQjkD,GACnB,GAAImf,EAAKl9B,MAAQo/D,EAAKp/D,KAAtB,CAUMk9B,EAAKl9B,KAAOo/D,EAAKr/D,KACfiiE,GAAWH,IAASG,EAAUH,EAAM/hE,SAGxCkiE,EAAQ1gE,GAAK89D,EAAKx6D,KAAKw6D,EAAKp/D,KAAMk9B,EAAKl9B,MACvCiiE,GAAYD,EAASjkD,EAAGqhD,EAAKx6D,KAAKs4B,EAAKl9B,KAAMo/D,EAAKr/D,MAEpD,MAhBIm9B,EAAKn9B,IAAMq/D,EAAKr/D,KACdiiE,GAAWH,IAASG,EAAUH,EAAM/hE,SAGxCkiE,EAAQjkD,GAAKmf,EAAKt4B,KAAKs4B,EAAKl9B,KAAMo/D,EAAKr/D,IACvCkiE,GAAYD,EAASjkD,EAAI,EAAGmf,EAAKt4B,KAAKw6D,EAAKr/D,GAAIm9B,EAAKn9B,OAe5D,OAAOiiE,EAGT,SAASC,GAAYxuC,EAAOnyB,EAAGooD,GAC7B,KAAOpoD,EAAImyB,EAAM/uB,QAAUo8D,GAAMpX,EAAMj2B,EAAMnyB,IAAM,GAAKA,IACxDmyB,EAAMyD,OAAO51B,EAAG,EAAGooD,GAKrB,SAASwY,GAAgB3jE,GACvB,IAAIkJ,EAAQ,GAOZ,OANAlJ,EAAKgX,SAAS,eAAe,SAAUC,GACrC,IAAId,EAASc,EAAEjX,EAAKP,OAChB0W,GAAUA,GAAUvW,IAASsJ,EAAMxC,KAAKyP,MAE1CnW,EAAKixD,eACL/nD,EAAMxC,KAAK26D,GAAcj7D,OAAOpG,EAAKP,MAAM4B,IAAK,CAACrB,EAAKixD,cAAc9F,QACjE+X,GAAgBzhE,KAAKyH,GA7P9Bg6D,GAAgB34D,UAAUzI,IAAM,SAAcD,EAASR,GACrD,IAAIuiE,EAAc93D,KAAKu3D,QAAQvhE,KAC7B,SAAU+hE,GAAU,OAAOA,EAAO/hE,IAAID,EAASR,EAAKu/D,OAEtD,OAAOsC,GAAgBzhE,KAAKmiE,IAG9BV,GAAgB34D,UAAUghD,SAAW,SAAmB/5C,EAAQjI,GAC9D,GAAIA,EAAM8oB,OAAU,OAAOgvC,GAAczhE,MAEzC,IADA,IAAIsJ,EAAQ,GACHnG,EAAI,EAAGA,EAAI+I,KAAKu3D,QAAQl9D,OAAQpD,IAAK,CAC5C,IAAIoT,EAASrK,KAAKu3D,QAAQtgE,GAAGwoD,SAAS/5C,EAAQjI,GAC1C4M,GAAUvW,KACVuW,aAAkB+sD,GAAmBh6D,EAAQA,EAAM2vB,OAAO1iB,EAAOktD,SAC9Dn6D,EAAMxC,KAAKyP,IAEpB,OAAO+sD,GAAgBzhE,KAAKyH,IAG9Bg6D,GAAgB34D,UAAU+I,GAAK,SAAa2mB,GAC1C,KAAMA,aAAiBipC,KACnBjpC,EAAMopC,QAAQl9D,QAAU2F,KAAKu3D,QAAQl9D,OAAU,OAAO,EAC1D,IAAK,IAAIpD,EAAI,EAAGA,EAAI+I,KAAKu3D,QAAQl9D,OAAQpD,IACrC,IAAK+I,KAAKu3D,QAAQtgE,GAAGuQ,GAAG2mB,EAAMopC,QAAQtgE,IAAO,OAAO,EACxD,OAAO,GAGTmgE,GAAgB34D,UAAU+gD,OAAS,SAAiBlpD,GAElD,IADA,IAAI+T,EAAQ2tD,GAAS,EACZ/gE,EAAI,EAAGA,EAAI+I,KAAKu3D,QAAQl9D,OAAQpD,IAAK,CAC5C,IAAIuoD,EAASx/C,KAAKu3D,QAAQtgE,GAAGqgE,YAAYhhE,GACzC,GAAKkpD,EAAOnlD,OACZ,GAAKgQ,EAEE,CACD2tD,IACF3tD,EAASA,EAAO5U,QAChBuiE,GAAS,GAEX,IAAK,IAAItkD,EAAI,EAAGA,EAAI8rC,EAAOnlD,OAAQqZ,IAAOrJ,EAAOzP,KAAK4kD,EAAO9rC,SAN7DrJ,EAASm1C,EASb,OAAOn1C,EAASgtD,GAAcW,EAAS3tD,EAASA,EAAOsV,KAAK82C,KAAUtmC,IAMxEinC,GAAgBzhE,KAAO,SAAe4hE,GACpC,OAAQA,EAAQl9D,QACd,KAAK,EAAG,OAAOvG,GACf,KAAK,EAAG,OAAOyjE,EAAQ,GACvB,QAAS,OAAO,IAAIH,GAAgBG,KA+MxC,IAAIU,GAAa,SAAoB/qC,EAAO1tB,GAC1CQ,KAAKk4D,OAAS14D,EAGdQ,KAAKrM,MAAQ6L,EAAM7L,MAEnBqM,KAAKm4D,cAAgB34D,EAAM2T,SAAW,GACtCnT,KAAKm4D,cAAch5D,QAAQi5D,IAE3Bp4D,KAAKpM,SAAWoM,KAAKpM,SAAS6L,KAAKO,MAEnCA,KAAKq4D,MAAQ,KACbr4D,KAAKqwD,SAAU,EAEfrwD,KAAKuiD,YAAc,KAKnBviD,KAAK0C,IAAOwqB,GAASA,EAAMxI,OAAU/d,SAAS6R,cAAc,OACxD0U,IACEA,EAAMzU,YAAeyU,EAAMzU,YAAYzY,KAAK0C,KACvCwqB,EAAMlY,MAASkY,EAAMltB,KAAK0C,KAC1BwqB,EAAMxI,QAAS1kB,KAAKs4D,SAAU,IAKzCt4D,KAAK0U,SAAW6jD,GAAYv4D,MAC5BA,KAAKmzD,WAAa,KAClBnzD,KAAKmlD,cAAgB,KACrBqT,GAAoBx4D,MACpBA,KAAKohB,UAAYq3C,GAAez4D,MAChCA,KAAKkkB,QAAUk+B,EAAYpiD,KAAKrM,MAAM4B,IAAKmjE,GAAe14D,MAAO63D,GAAgB73D,MAAOA,KAAK0C,IAAK1C,MAElGA,KAAKymD,qBAAuB,KAK5BzmD,KAAKi0D,SAAW,KAp8ClB,SAAmB//D,GACjBA,EAAK2W,UAAW,EAChB3W,EAAKywD,UAAY,KACjBzwD,EAAKu0D,YAAc,KACnBv0D,EAAK+0D,gBAAkB,EACvB/0D,EAAKw9D,UAAY,CAAClrB,KAAM,EAAGvhB,EAAG,EAAGC,EAAG,EAAGpwB,KAAM,IAC7CZ,EAAKi0D,oBAAsB,KAC3Bj0D,EAAKg0D,kBAAoB,EAEzBh0D,EAAKm1D,aAAe,EACpBn1D,EAAKi9D,4BAA8B,KACnCj9D,EAAKi2D,kBAAoB,EAEzBj2D,EAAKklB,WAAY,EACjBllB,EAAK4+D,iBAAmB,KACxB5+D,EAAKwtD,iBAAmB,GACxBxtD,EAAKq+D,oBAAsB,IAE3Br+D,EAAK4wD,YAAc,IAAI+I,GAAY35D,GAAM,SAAUyB,EAAMD,EAAIuyD,EAAUvZ,GAAS,OAAOsZ,GAAc9zD,EAAMyB,EAAMD,EAAIuyD,EAAUvZ,MAC/Hx6C,EAAK4wD,YAAY3pD,QAEjBjH,EAAKs1D,eAAiB,EAEtBt1D,EAAK27D,cAAgBrxD,OAAOlE,OAAO,MACnC,IAAI07B,EAAO,SAAWxrB,GACpB,IAAIyO,EAAUsB,GAAS/P,GACvBtW,EAAKwO,IAAI0Y,iBAAiB5Q,EAAOtW,EAAK27D,cAAcrlD,GAAS,SAAUA,IA2C3E,SAA4BtW,EAAMsW,GAChC,IAAKA,EAAMM,QAAW,OAAO,EAC7B,GAAIN,EAAMulD,iBAAoB,OAAO,EACrC,IAAK,IAAIz5D,EAAOkU,EAAM9V,OAAQ4B,GAAQpC,EAAKwO,IAAKpM,EAAOA,EAAKkoC,WACxD,IAAKloC,GAAyB,IAAjBA,EAAKiF,UACfjF,EAAKw9C,YAAcx9C,EAAKw9C,WAAWtvB,UAAUha,GAC9C,OAAO,EACb,OAAO,EAjDCmuD,CAAmBzkE,EAAMsW,IAAWslD,GAAiB57D,EAAMsW,KAC1DtW,EAAKwgB,UAAclK,EAAM1V,QAAQ26D,IAClCx2C,EAAQ/kB,EAAMsW,MAItB,IAAK,IAAIA,KAAS+P,GAAUyb,EAAMxrB,GAI9BH,EAAO8gB,QAAUj3B,EAAKwO,IAAI0Y,iBAAiB,SAAS,WAAc,OAAO,QAE7Eu0C,GAAgBz7D,GA+5ChB0kE,CAAU54D,MAEVA,KAAK64D,kBAAoB,GACzB74D,KAAK84D,YAAc,GACnB94D,KAAK+4D,qBAGHzmC,GAAuB,CAAE9yB,MAAO,CAAEwuB,cAAc,GAAOgqB,KAAM,CAAEhqB,cAAc,GAAOvrB,YAAa,CAAEurB,cAAc,IAmVrH,SAAS0qC,GAAexkE,GACtB,IAAIsH,EAAQgD,OAAOlE,OAAO,MAkB1B,OAjBAkB,EAAMwnD,MAAQ,cACdxnD,EAAMw9D,gBAAkBvtC,OAAOv3B,EAAKwgB,UACpClZ,EAAMy9D,UAAY,KAElB/kE,EAAKgX,SAAS,cAAc,SAAU3M,GAEpC,GADoB,mBAATA,IAAuBA,EAAQA,EAAMrK,EAAKP,QACjD4K,EAAS,IAAK,IAAI05B,KAAQ15B,EAChB,SAAR05B,IACAz8B,EAAMwnD,OAAS,IAAMzkD,EAAM05B,IACnB,SAARA,EACFz8B,EAAM2hB,OAAS3hB,EAAM2hB,MAAQ3hB,EAAM2hB,MAAQ,IAAM,IAAM5e,EAAM05B,GAErDz8B,EAAMy8B,IAAiB,mBAARA,GAAqC,YAARA,IAClDz8B,EAAMy8B,GAAQxM,OAAOltB,EAAM05B,QAI5B,CAACg9B,GAAW3+D,KAAK,EAAGpC,EAAKP,MAAM4B,IAAIJ,QAAQC,KAAMoG,IAG1D,SAASg9D,GAAoBtkE,GAC3B,GAAIA,EAAKi/D,WAAY,CACnB,IAAIzwD,EAAMiE,SAAS6R,cAAc,OACjC9V,EAAI6jD,UAAY,wBAChB7jD,EAAImgB,aAAa,mBAAoB,QACrC3uB,EAAKixD,cAAgB,CAACziD,IAAKA,EAAK28C,KAAM4V,GAAW/Y,OAAOhoD,EAAKP,MAAME,UAAUypC,KAAM56B,EAAK,CAAC+6C,KAAK,EAAM94C,MAAOzQ,EAAKi/D,mBAEhHj/D,EAAKixD,cAAgB,KAIzB,SAASoT,GAAYrkE,GACnB,OAAQA,EAAKgX,SAAS,YAAY,SAAU3M,GAAS,OAA6B,IAAtBA,EAAMrK,EAAKP,UAQzE,SAAS8kE,GAAevkE,GACtB,IAAImW,EAAS,GAKb,OAJAnW,EAAKgX,SAAS,aAAa,SAAUkB,GACnC,IAAK,IAAIG,KAAQH,EAAY5N,OAAOC,UAAU8qB,eAAe5qB,KAAK0L,EAAQkC,KACtElC,EAAOkC,GAAQH,EAAIG,OAElBlC,EAaT,SAAS+tD,GAAoBhlD,GAC3B,GAAIA,EAAOre,KAAKpB,OAASyf,EAAOre,KAAK8yC,mBAAqBz0B,EAAOre,KAAKgiB,kBAClE,MAAM,IAAI0X,WAAW,uEAzY3B6D,GAAqB9yB,MAAMgtB,IAAM,WAC/B,GAAIxsB,KAAKk4D,OAAOvkE,OAASqM,KAAKrM,MAAO,CACnC,IAAIomB,EAAO/Z,KAAKk4D,OAEhB,IAAK,IAAIj4D,KADTD,KAAKk4D,OAAS,GACGn+C,EAAQ/Z,KAAKk4D,OAAOj4D,GAAQ8Z,EAAK9Z,GAClDD,KAAKk4D,OAAOvkE,MAAQqM,KAAKrM,MAE3B,OAAOqM,KAAKk4D,QAMdD,GAAWx5D,UAAUguB,OAAS,SAAiBjtB,GACzCA,EAAMoV,iBAAmB5U,KAAKk4D,OAAOtjD,iBAAmB+6C,GAAgB3vD,MAC5EA,KAAKk4D,OAAS14D,EACVA,EAAM2T,UACR3T,EAAM2T,QAAQhU,QAAQi5D,IACtBp4D,KAAKm4D,cAAgB34D,EAAM2T,SAE7BnT,KAAKk5D,iBAAiB15D,EAAM7L,OAAO,IAOrCskE,GAAWx5D,UAAUukB,SAAW,SAAmBxjB,GACjD,IAAIqnC,EAAU,GACd,IAAK,IAAI5mC,KAAQD,KAAKk4D,OAAUrxB,EAAQ5mC,GAAQD,KAAKk4D,OAAOj4D,GAE5D,IAAK,IAAIk7B,KADT0L,EAAQlzC,MAAQqM,KAAKrM,MACF6L,EAASqnC,EAAQ1L,GAAU37B,EAAM27B,GACpDn7B,KAAKysB,OAAOoa,IAMdoxB,GAAWx5D,UAAUwkB,YAAc,SAAsBtvB,GACvDqM,KAAKk5D,iBAAiBvlE,EAAOqM,KAAKrM,MAAMwf,SAAWxf,EAAMwf,UAG3D8kD,GAAWx5D,UAAUy6D,iBAAmB,SAA2BvlE,EAAOwlE,GACtE,IAAIj/B,EAASl6B,KAEX+Z,EAAO/Z,KAAKrM,MAAOylE,GAAS,EAAOC,GAAY,EAQnD,GALI1lE,EAAM8T,aAAezH,KAAKoZ,YAC5B25C,GAAiB/yD,MACjBq5D,GAAY,GAEdr5D,KAAKrM,MAAQA,EACTwlE,EAAc,CAChB,IAAI/3C,EAAYq3C,GAAez4D,OAuUnC,SAA0BqgB,EAAGrE,GAC3B,IAAIs9C,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAIhtD,KAAQ8T,EAAG,CAClB,GAAIA,EAAE9T,IAASyP,EAAEzP,GAAS,OAAO,EACjC+sD,IAEF,IAAK,IAAI5vC,KAAK1N,EAAKu9C,IACnB,OAAOD,GAAMC,GA7UPC,CAAiBp4C,EAAWphB,KAAKohB,aACnCphB,KAAKohB,UAAYA,EACjBg4C,GAAS,GAEXzJ,GAAgB3vD,MAGlBA,KAAK0U,SAAW6jD,GAAYv4D,MAC5Bw4D,GAAoBx4D,MACpB,IAAIu+C,EAAYsZ,GAAgB73D,MAAOs+C,EAAYoa,GAAe14D,MAE9Dy5D,EAASN,EAAe,QACtBxlE,EAAM+lE,kBAAoB3/C,EAAK2/C,kBAAoB,eAAiB,WACtEC,EAAYP,IAAWp5D,KAAKkkB,QAAQi3B,YAAYxnD,EAAM4B,IAAK+oD,EAAWC,IACtEob,GAAchmE,EAAME,UAAU2T,GAAGuS,EAAKlmB,aAAcwlE,GAAY,GACpE,IA3nF0BnlE,EACtByoD,EACA3I,EAk6F2B4lB,EAAMC,EACjCzjE,EAj+JkBU,EAClBgjE,EACAC,EACA5jB,EAEA6jB,EAkrJAC,EAAyB,YAAVR,GAAwBJ,GAA8C,MAAjCr5D,KAAK0C,IAAIya,MAAM+8C,gBAntJzE,SAAwBhmE,GAGtB,IAFA,IACI4lE,EAAQC,EADRllB,EAAO3gD,EAAKwO,IAAI0iB,wBAAyB0wB,EAASz0C,KAAKC,IAAI,EAAGuzC,EAAKlqB,KAE9D1F,GAAK4vB,EAAKhqB,KAAOgqB,EAAK/pB,OAAS,EAAG5F,EAAI4wB,EAAS,EACnD5wB,EAAI7jB,KAAKc,IAAIg4D,YAAatlB,EAAKjqB,QAAS1F,GAAK,EAAG,CACnD,IAAIxiB,EAAMxO,EAAK8jD,KAAKZ,iBAAiBnyB,EAAGC,GACxC,GAAIxiB,GAAOxO,EAAKwO,KAAQxO,EAAKwO,IAAIyY,SAASzY,GAA1C,CACA,IAAI03D,EAAY13D,EAAI0iB,wBACpB,GAAIg1C,EAAUzvC,KAAOmrB,EAAS,GAAI,CAChCgkB,EAASp3D,EACTq3D,EAASK,EAAUzvC,IACnB,QAGJ,MAAO,CAACmvC,OAAQA,EAAQC,OAAQA,EAAQ5jB,MAAOD,EAAYhiD,EAAKwO,MAqsJiC23D,CAAer6D,MAEhH,GAAIq5D,EAAW,CACbr5D,KAAK8kD,YAAYnH,OAMjB,IAAI2c,EAAiBX,IAActvD,EAAOkhB,IAAMlhB,EAAO6gB,UAAYlrB,KAAKoZ,YACnEW,EAAKlmB,UAAUC,QAAUH,EAAME,UAAUC,QA+RjB8lE,EA/RkD7/C,EAAKlmB,UA+RjDgmE,EA/R4DlmE,EAAME,UAgSnGuC,EAAQiL,KAAKc,IAAIy3D,EAAKpiE,QAAQ8V,YAAYssD,EAAKt8B,MAAOu8B,EAAKriE,QAAQ8V,YAAYusD,EAAKv8B,OACjFs8B,EAAKpiE,QAAQ2D,MAAM/E,IAAUyjE,EAAKriE,QAAQ2D,MAAM/E,IAhSrD,GAAIujE,EAAW,CAKb,IAAIY,EAAelwD,EAAO6gB,OAAUlrB,KAAKuiD,YAAcviD,KAAKg4C,KAAKp1C,eAAew3C,UAAa,MACzFgf,GAAWp5D,KAAKkkB,QAAQuI,OAAO94B,EAAM4B,IAAK+oD,EAAWC,EAAWv+C,QAClEA,KAAKkkB,QAAQ09B,gBAAgB,IAC7B5hD,KAAKkkB,QAAQ7I,UACbrb,KAAKkkB,QAAUk+B,EAAYzuD,EAAM4B,IAAK+oD,EAAWC,EAAWv+C,KAAK0C,IAAK1C,OAEpEu6D,IAAiBv6D,KAAKuiD,cAAe+X,GAAiB,GAMxDA,KACEt6D,KAAK2kD,WAAa3kD,KAAK8kD,YAAYC,iBAAiBv9C,GAAGxH,KAAKg4C,KAAKp1C,kBAxpF/C1O,EAwpFqF8L,KAvpF3G28C,EAAYzoD,EAAKgwB,QAAQ20B,WAAW3kD,EAAKP,MAAME,UAAUgxC,OAAQ,GACjEmP,EAAS9/C,EAAK8jD,KAAKp1C,eAChB2wC,EAAqBoJ,EAAUrmD,KAAMqmD,EAAUj3C,OAAQsuC,EAAO+I,WAAY/I,EAAOgJ,gBAspFpFyH,GAAezkD,KAAMs6D,IAErB5V,GAAkB1kD,KAAMrM,EAAME,WAC9BmM,KAAK8kD,YAAYG,mBAEnBjlD,KAAK8kD,YAAY3pD,QAKnB,GAFA6E,KAAK+4D,kBAAkBh/C,GAET,SAAV0/C,EACFz5D,KAAK0C,IAAIqzC,UAAY,OAChB,GAAc,gBAAV0jB,EAA0B,CACnC,IAAItkB,EAAWn1C,KAAKg4C,KAAKp1C,eAAew3C,UACpCp6C,KAAKkL,SAAS,2BAA2B,SAAUC,GAAK,OAAOA,EAAE+uB,QAE5DvmC,EAAME,qBAAqB,KAChCqhD,EAAmBl1C,KAAMA,KAAKkkB,QAAQu2B,YAAY9mD,EAAME,UAAU8B,MAAMyvB,wBAAyB+vB,GAEjGD,EAAmBl1C,KAAMA,KAAK0qB,YAAY/2B,EAAME,UAAUypC,KAAM,GAAI6X,SAC/D8kB,IAxuJPH,GADkBhjE,EA0uJLmjE,GAzuJAH,OACbC,EAASjjE,EAAIijE,OACb5jB,EAAQr/C,EAAIq/C,MAEZ6jB,EAAYF,EAASA,EAAO10C,wBAAwBuF,IAAM,EAC9DyrB,EAAmBD,EAAoB,GAAb6jB,EAAiB,EAAIA,EAAYD,KAwuJ7D9B,GAAWx5D,UAAU+7D,mBAAqB,WAExC,IADA,IAAItmE,EACGA,EAAO8L,KAAK84D,YAAY1hC,OAAaljC,EAAKmnB,SAAWnnB,EAAKmnB,WAGnE48C,GAAWx5D,UAAUs6D,kBAAoB,SAA4B0B,GACnE,GAAKA,GAAaA,EAAUtnD,SAAWnT,KAAKrM,MAAMwf,SAAWnT,KAAKm4D,eAAiBn4D,KAAK64D,kBAYtF,IAAK,IAAIt7D,EAAM,EAAGA,EAAMyC,KAAK84D,YAAYz+D,OAAQkD,IAAO,CACtD,IAAIm9D,EAAa16D,KAAK84D,YAAYv7D,GAC9Bm9D,EAAWjuC,QAAUiuC,EAAWjuC,OAAOzsB,KAAMy6D,OAdsD,CACzGz6D,KAAK64D,kBAAoB74D,KAAKm4D,cAC9Bn4D,KAAKw6D,qBACL,IAAK,IAAIvjE,EAAI,EAAGA,EAAI+I,KAAKm4D,cAAc99D,OAAQpD,IAAK,CAClD,IAAImc,EAASpT,KAAKm4D,cAAclhE,GAC5Bmc,EAAOre,KAAKb,MAAQ8L,KAAK84D,YAAYl+D,KAAKwY,EAAOre,KAAKb,KAAK8L,OAEjE,IAAK,IAAIhF,EAAM,EAAGA,EAAMgF,KAAKrM,MAAMwf,QAAQ9Y,OAAQW,IAAO,CACxD,IAAI2/D,EAAW36D,KAAKrM,MAAMwf,QAAQnY,GAC9B2/D,EAAS5lE,KAAKb,MAAQ8L,KAAK84D,YAAYl+D,KAAK+/D,EAAS5lE,KAAKb,KAAK8L,UAiBzEi4D,GAAWx5D,UAAUyM,SAAW,SAAmBklD,EAAUjlD,GAC3D,IAAiD5M,EAA7CgO,EAAOvM,KAAKk4D,QAAUl4D,KAAKk4D,OAAO9H,GACtC,GAAY,MAAR7jD,IAAiBhO,EAAQ4M,EAAIA,EAAEoB,GAAQA,GAAS,OAAOhO,EAC3D,IAAK,IAAItH,EAAI,EAAGA,EAAI+I,KAAKm4D,cAAc99D,OAAQpD,IAAK,CAClD,IAAIuiC,EAASx5B,KAAKm4D,cAAclhE,GAAGuI,MAAM4wD,GACzC,GAAc,MAAV52B,IAAmBj7B,EAAQ4M,EAAIA,EAAEquB,GAAUA,GAAW,OAAOj7B,EAEnE,IAAI4U,EAAUnT,KAAKrM,MAAMwf,QACzB,GAAIA,EAAW,IAAK,IAAInY,EAAM,EAAGA,EAAMmY,EAAQ9Y,OAAQW,IAAO,CAC5D,IAAI4+B,EAASzmB,EAAQnY,GAAKwE,MAAM4wD,GAChC,GAAc,MAAVx2B,IAAmBr7B,EAAQ4M,EAAIA,EAAEyuB,GAAUA,GAAW,OAAOr7B,IAMrE05D,GAAWx5D,UAAU6I,SAAW,WAC9B,OAAOtH,KAAKg4C,KAAK0B,eAAiB15C,KAAK0C,KAKzCu1D,GAAWx5D,UAAU2I,MAAQ,WAC3BpH,KAAK8kD,YAAYnH,OACb39C,KAAK0U,UA/wJX,SAA4BhS,GAC1B,GAAIA,EAAIk4D,UAAa,OAAOl4D,EAAIk4D,YAChC,GAAItkB,EAA0B,OAAO5zC,EAAI0E,MAAMkvC,GAE/C,IAAIt8B,EAASk8B,EAAYxzC,GACzBA,EAAI0E,MAAgC,MAA1BkvC,EAAiC,CACrCukB,oBAEF,OADAvkB,EAAyB,CAACukB,eAAe,IAClC,SAEPh7D,GACCy2C,IACHA,GAAyB,EACzBF,EAAmBp8B,EAAQ,IAkwJR8gD,CAAmB96D,KAAK0C,KAC7C+hD,GAAezkD,MACfA,KAAK8kD,YAAY3pD,SAQnBm3B,GAAqB0lB,KAAKxrB,IAAM,WAC9B,IAAI4G,EAASpzB,KAAKq4D,MAClB,GAAc,MAAVjlC,EAAkB,IAAK,IAAI1L,EAAS1nB,KAAK0C,IAAI87B,WAAY9W,EAAQA,EAASA,EAAO8W,WACnF,GAAuB,GAAnB9W,EAAOnsB,UAAqC,IAAnBmsB,EAAOnsB,UAAkBmsB,EAAOurB,KAE3D,OADKvrB,EAAO9kB,eAAgBpE,OAAOM,eAAe4oB,GAAQ9kB,aAAe,WAAc,OAAO+D,SAAS/D,iBAChG5C,KAAKq4D,MAAQ3wC,EAGxB,OAAO0L,GAAUzsB,UAWnBsxD,GAAWx5D,UAAU+4C,YAAc,SAAwBhB,GACzD,OAAOgB,EAAYx3C,KAAMw2C,IAU3ByhB,GAAWx5D,UAAUisB,YAAc,SAAwBz0B,EAAKM,GAG9D,YAFgB,IAATA,IAAkBA,EAAO,GAEzBm0B,EAAY1qB,KAAM/J,EAAKM,IAYhC0hE,GAAWx5D,UAAUs8D,SAAW,SAAmB9kE,EAAKM,GAGtD,YAFgB,IAATA,IAAkBA,EAAO,GAEzByJ,KAAKkkB,QAAQ20B,WAAW5iD,EAAKM,IAYtC0hE,GAAWx5D,UAAUq9C,QAAU,SAAkB7lD,GAC/C,IAAIqxC,EAAOtnC,KAAKkkB,QAAQ63B,OAAO9lD,GAC/B,OAAOqxC,EAAOA,EAAKwU,QAAU,MAY/Bmc,GAAWx5D,UAAUu8D,SAAW,SAAmB1kE,EAAMoP,EAAQyD,QAC/C,IAATA,IAAkBA,GAAQ,GAEjC,IAAIlT,EAAM+J,KAAKkkB,QAAQq0B,WAAWjiD,EAAMoP,EAAQyD,GAChD,GAAW,MAAPlT,EAAe,MAAM,IAAIw4B,WAAW,sCACxC,OAAOx4B,GAUTgiE,GAAWx5D,UAAUrK,eAAiB,SAA2BgxC,EAAKzxC,GACpE,OAAOS,EAAe4L,KAAMrM,GAASqM,KAAKrM,MAAOyxC,IAMnD6yB,GAAWx5D,UAAU4c,QAAU,WACxBrb,KAAKkkB,WAvsDZ,SAAsBhwB,GAEpB,IAAK,IAAIY,KADTZ,EAAK4wD,YAAYnH,OACAzpD,EAAK27D,cAClB37D,EAAKwO,IAAI4Y,oBAAoBxmB,EAAMZ,EAAK27D,cAAc/6D,IAC1D65D,aAAaz6D,EAAK4+D,kBAClBnE,aAAaz6D,EAAKi9D,6BAmsDlB8J,CAAaj7D,MACbA,KAAKw6D,qBACDx6D,KAAKs4D,SACPt4D,KAAKkkB,QAAQuI,OAAOzsB,KAAKrM,MAAM4B,IAAK,GAAIsiE,GAAgB73D,MAAOA,MAC/DA,KAAK0C,IAAI6T,YAAc,IACdvW,KAAK0C,IAAI87B,YAClBx+B,KAAK0C,IAAI87B,WAAWijB,YAAYzhD,KAAK0C,KAEvC1C,KAAKkkB,QAAQ7I,UACbrb,KAAKkkB,QAAU,OAOjBoO,GAAqB7vB,YAAY+pB,IAAM,WACrC,OAAuB,MAAhBxsB,KAAKkkB,SAId+zC,GAAWx5D,UAAUy8D,cAAgB,SAA0B1wD,GAC7D,OA9rDF,SAAuBtW,EAAMsW,GACtBslD,GAAiB57D,EAAMsW,KAAU+P,GAAS/P,EAAM1V,QAChDZ,EAAKwgB,UAAclK,EAAM1V,QAAQ26D,IAClCl1C,GAAS/P,EAAM1V,MAAMZ,EAAMsW,GA2rDxB0wD,CAAcl7D,KAAMwK,IAW7BytD,GAAWx5D,UAAU7K,SAAW,SAAmBG,GACjD,IAAI2vB,EAAsB1jB,KAAKk4D,OAAOx0C,oBAClCA,EAAuBA,EAAoB/kB,KAAKqB,KAAMjM,GACnDiM,KAAKijB,YAAYjjB,KAAKrM,MAAMqhB,MAAMjhB,KAG3CyK,OAAO6wB,iBAAkB4oC,GAAWx5D,UAAW6zB","sources":["webpack://oira.prototype/./node_modules/prosemirror-commands/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-schema-list/dist/index.es.js","webpack://oira.prototype/./node_modules/@tiptap/core/dist/tiptap-core.esm.js","webpack://oira.prototype/./node_modules/w3c-keyname/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-keymap/dist/index.es.js","webpack://oira.prototype/./node_modules/orderedmap/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-model/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-state/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-transform/dist/index.es.js","webpack://oira.prototype/./node_modules/prosemirror-view/dist/index.es.js"],"sourcesContent":["import { liftTarget, replaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, AllSelection, TextSelection } from 'prosemirror-state';\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) { return false }\n  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    { return false }\n\n  var $cut = findCutBefore($cursor);\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    var range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null) { return false }\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  var before = $cut.nodeBefore;\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    { return true }\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n        dispatch(tr.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) { return true }\n    if (only && node.childCount != 1) { return false }\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n  if (!empty) { return false }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) { return false }\n    $cut = findCutBefore($head);\n  }\n  var node = $cut && $cut.nodeBefore;\n  if (!node || !NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }\n    if ($pos.node(i).type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    { return false }\n\n  var $cut = findCutAfter($cursor);\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) { return false }\n\n  var after = $cut.nodeAfter;\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) { return true }\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n  if (!empty) { return false }\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      { return false }\n    $cut = findCutAfter($head);\n  }\n  var node = $cut && $cut.nodeAfter;\n  if (!node || !NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    var parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }\n    if (parent.type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nfunction joinUp(state, dispatch) {\n  var sel = state.selection, nodeSel = sel instanceof NodeSelection, point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) { return false }\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n    if (point == null) { return false }\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point);\n    if (nodeSel) { tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nfunction joinDown(state, dispatch) {\n  var sel = state.selection, point;\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) { return false }\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n    if (point == null) { return false }\n  }\n  if (dispatch)\n    { dispatch(state.tr.join(point).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to), target = range && liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  if (dispatch) { dispatch(state.tr.insertText(\"\\n\").scrollIntoView()); }\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var ref = match.edge(i);\n    var type = ref.type;\n    if (type.isTextblock && !type.hasRequiredAttrs()) { return type }\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n  if (!above.canReplaceWith(after, after, type)) { return false }\n  if (dispatch) {\n    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nfunction createParagraphNear(state, dispatch) {\n  var sel = state.selection;\n  var $from = sel.$from;\n  var $to = sel.$to;\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) { return false }\n  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock) { return false }\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || $cursor.parent.content.size) { return false }\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n    if (canSplit(state.doc, before)) {\n      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }\n      return true\n    }\n  }\n  var range = $cursor.blockRange(), target = range && liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) { return false }\n    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }\n    return true\n  }\n\n  if (!$from.parent.isBlock) { return false }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) { tr.deleteSelection(); }\n    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    var types = atEnd && deflt ? [{type: deflt}] : null;\n    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}];\n      can = true;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }\n      }\n    }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (function (tr) {\n    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n    if (marks) { tr.ensureMarks(marks); }\n    dispatch(tr);\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n  if (same == 0) { return false }\n  pos = $from.before(same);\n  if (dispatch) { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos))); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nfunction selectAll(state, dispatch) {\n  if (dispatch) { dispatch(state.tr.setSelection(new AllSelection(state.doc))); }\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    { return false }\n  if (dispatch)\n    { dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView()); }\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n  if (before.type.spec.isolating || after.type.spec.isolating) { return false }\n  if (joinMaybeClear(state, $cut, dispatch)) { return true }\n\n  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize, wrap = Fragment.empty;\n      for (var i = conn.length - 1; i >= 0; i--)\n        { wrap = Fragment.from(conn[i].create(null, wrap)); }\n      wrap = Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n      if (canJoin(tr.doc, joinAt)) { tr.join(joinAt); }\n      dispatch(tr.scrollIntoView());\n    }\n    return true\n  }\n\n  var selAfter = Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    var at = before, wrap$1 = [];\n    for (;;) {\n      wrap$1.push(at);\n      if (at.isTextblock) { break }\n      at = at.lastChild;\n    }\n    var afterText = after, afterDepth = 1;\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) { afterDepth++; }\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        var end$1 = Fragment.empty;\n        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = Fragment.from(wrap$1[i$1].copy(end$1)); }\n        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end$1, wrap$1.length, 0), 0, true));\n        dispatch(tr$1.scrollIntoView());\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n    var depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth) { return false }\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock) { return false }\n    if (dispatch)\n      { dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth)))); }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the start of current text block.\nvar selectTextblockStart = selectTextblockSide(-1);\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the end of current text block.\nvar selectTextblockEnd = selectTextblockSide(1);\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nfunction wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) { return false }\n    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nfunction setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) { return false }\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos), index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n    if (!applicable) { return false }\n    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function ( i ) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) { return false }\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n    if (can) { return { v: true } }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nfunction toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          { dispatch(state.tr.removeStoredMark(markType)); }\n        else\n          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }\n      } else {\n        var has = false, tr = state.tr;\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n          if (has) {\n            tr.removeMark($from$1.pos, $to$1.pos, markType);\n          } else {\n            var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;\n            var spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) { return dispatch(tr) }\n\n    var ranges = [];\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n      for (var j = 0; j < ranges.length; j++)\n        { ranges[j] = map.map(ranges[j]); }\n      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    var joinable = [];\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1], to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n        if (!after) { break }\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after))\n            { joinable.push(pos); }\n        }\n        pos += after.nodeSize;\n      }\n    }\n    // Join the joinable points\n    joinable.sort(function (a, b) { return a - b; });\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }\n    }\n    dispatch(tr);\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };\n  }\n  return function (state, dispatch, view) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view); }\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nfunction chainCommands() {\n  var commands = [], len = arguments.length;\n  while ( len-- ) commands[ len ] = arguments[ len ];\n\n  return function(state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++)\n      { if (commands[i](state, dispatch, view)) { return true } }\n    return false\n  }\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }\n\npcBaseKeymap.Home = selectTextblockStart;\npcBaseKeymap.End = selectTextblockEnd;\n\n// declare global: os, navigator\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };\n//# sourceMappingURL=index.es.js.map\n","import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\n\nvar olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nvar orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n};\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nvar bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM: function toDOM() { return ulDOM }\n};\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nvar listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM: function toDOM() { return liDOM },\n  defining: true\n};\n\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nfunction wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), doJoin = false, outerRange = range;\n    if (!range) { return false }\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) { return false }\n      var $insert = state.doc.resolve(range.start - 2);\n      outerRange = new NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount)\n        { range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }\n      doJoin = true;\n    }\n    var wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap) { return false }\n    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true));\n\n  var found = 0;\n  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }\n  var splitDepth = wrappers.length - found;\n\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(i$2).nodeSize;\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nfunction splitListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) { return false }\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) { return false }\n      if (dispatch) {\n        var wrap = Fragment.empty;\n        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n          { wrap = Fragment.from($from.node(d).copy(wrap)); }\n        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n            : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        var start = $from.before($from.depth - (depthBefore - 1));\n        var tr$1 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n        var sel = -1;\n        tr$1.doc.nodesBetween(start, tr$1.doc.content.size, function (node, pos) {\n          if (sel > -1) { return false }\n          if (node.isTextblock && node.content.size == 0) { sel = pos + 1; }\n        });\n        if (sel > -1) { tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel))); }\n        dispatch(tr$1.scrollIntoView());\n      }\n      return true\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr.delete($from.pos, $to.pos);\n    var types = nextType && [null, {type: nextType}];\n    if (!canSplit(tr.doc, $from.pos, 2, types)) { return false }\n    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nfunction liftListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    if (!dispatch) { return true }\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      { return liftToOuterList(state, dispatch, itemType, range) }\n    else // Outer list node\n      { return liftOutOfList(state, dispatch, range) }\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr, list = range.parent;\n  // Merge the list items into a single big item\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) { return false }\n  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1), indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n    { return false }\n  var start = $start.pos, end = start + item.nodeSize;\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n                                          .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nfunction sinkListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    var startIndex = range.startIndex;\n    if (startIndex == 0) { return false }\n    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) { return false }\n\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),\n                            nestedBefore ? 3 : 1, 0);\n      var before = range.start, after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView());\n    }\n    return true\n  }\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };\n//# sourceMappingURL=index.es.js.map\n","import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit, canJoin, findWrapping, Transform } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$2, deleteSelection as deleteSelection$2, exitCode as exitCode$2, joinBackward as joinBackward$2, joinForward as joinForward$2, lift as lift$2, liftEmptyBlock as liftEmptyBlock$2, newlineInCode as newlineInCode$2, selectNodeBackward as selectNodeBackward$2, selectNodeForward as selectNodeForward$2, selectParentNode as selectParentNode$2, selectTextblockEnd as selectTextblockEnd$2, selectTextblockStart as selectTextblockStart$2, setBlockType, wrapIn as wrapIn$2 } from 'prosemirror-commands';\nimport { Fragment, DOMParser, Slice, DOMSerializer, Schema, Node as Node$1 } from 'prosemirror-model';\nimport { liftListItem as liftListItem$2, sinkListItem as sinkListItem$2, wrapInList as wrapInList$2 } from 'prosemirror-schema-list';\nimport { EditorView } from 'prosemirror-view';\nimport { keymap } from 'prosemirror-keymap';\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\r\nfunction getType(value) {\r\n    return Object.prototype.toString.call(value).slice(8, -1);\r\n}\r\nfunction isPlainObject(value) {\r\n    if (getType(value) !== 'Object') {\r\n        return false;\r\n    }\r\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\r\n}\n\nfunction mergeDeep(target, source) {\r\n    const output = { ...target };\r\n    if (isPlainObject(target) && isPlainObject(source)) {\r\n        Object.keys(source).forEach(key => {\r\n            if (isPlainObject(source[key])) {\r\n                if (!(key in target)) {\r\n                    Object.assign(output, { [key]: source[key] });\r\n                }\r\n                else {\r\n                    output[key] = mergeDeep(target[key], source[key]);\r\n                }\r\n            }\r\n            else {\r\n                Object.assign(output, { [key]: source[key] });\r\n            }\r\n        });\r\n    }\r\n    return output;\r\n}\n\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\r\nfunction callOrReturn(value, context = undefined, ...props) {\r\n    if (isFunction(value)) {\r\n        if (context) {\r\n            return value.bind(context)(...props);\r\n        }\r\n        return value(...props);\r\n    }\r\n    return value;\r\n}\n\nfunction getExtensionField(extension, field, context) {\r\n    if (extension.config[field] === undefined && extension.parent) {\r\n        return getExtensionField(extension.parent, field, context);\r\n    }\r\n    if (typeof extension.config[field] === 'function') {\r\n        const value = extension.config[field].bind({\r\n            ...context,\r\n            parent: extension.parent\r\n                ? getExtensionField(extension.parent, field, context)\r\n                : null,\r\n        });\r\n        return value;\r\n    }\r\n    return extension.config[field];\r\n}\n\nclass Extension {\r\n    constructor(config = {}) {\r\n        this.type = 'extension';\r\n        this.name = 'extension';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Extension(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Extension(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nfunction getTextBetween(startNode, range, options) {\r\n    const { from, to } = range;\r\n    const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n    let text = '';\r\n    let separated = true;\r\n    startNode.nodesBetween(from, to, (node, pos, parent, index) => {\r\n        var _a;\r\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\r\n        if (textSerializer) {\r\n            if (node.isBlock && !separated) {\r\n                text += blockSeparator;\r\n                separated = true;\r\n            }\r\n            text += textSerializer({\r\n                node,\r\n                pos,\r\n                parent,\r\n                index,\r\n            });\r\n        }\r\n        else if (node.isText) {\r\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\r\n            separated = false;\r\n        }\r\n        else if (node.isBlock && !separated) {\r\n            text += blockSeparator;\r\n            separated = true;\r\n        }\r\n    });\r\n    return text;\r\n}\n\nfunction getTextSeralizersFromSchema(schema) {\r\n    return Object.fromEntries(Object\r\n        .entries(schema.nodes)\r\n        .filter(([, node]) => node.spec.toText)\r\n        .map(([name, node]) => [name, node.spec.toText]));\r\n}\n\nconst ClipboardTextSerializer = Extension.create({\r\n    name: 'clipboardTextSerializer',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('clipboardTextSerializer'),\r\n                props: {\r\n                    clipboardTextSerializer: () => {\r\n                        const { editor } = this;\r\n                        const { state, schema } = editor;\r\n                        const { doc, selection } = state;\r\n                        const { ranges } = selection;\r\n                        const from = Math.min(...ranges.map(range => range.$from.pos));\r\n                        const to = Math.max(...ranges.map(range => range.$to.pos));\r\n                        const textSerializers = getTextSeralizersFromSchema(schema);\r\n                        const range = { from, to };\r\n                        return getTextBetween(doc, range, {\r\n                            textSerializers,\r\n                        });\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst blur = () => ({ editor, view }) => {\r\n    requestAnimationFrame(() => {\r\n        var _a;\r\n        if (!editor.isDestroyed) {\r\n            view.dom.blur();\r\n            // Browsers should remove the caret on blur but safari does not.\r\n            // See: https://github.com/ueberdosis/tiptap/issues/2405\r\n            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n        }\r\n    });\r\n    return true;\r\n};\n\nvar blur$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur\n});\n\nconst clearContent = (emitUpdate = false) => ({ commands }) => {\r\n    return commands.setContent('', emitUpdate);\r\n};\n\nvar clearContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearContent: clearContent\n});\n\nconst clearNodes = () => ({ state, tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    ranges.forEach(({ $from, $to }) => {\r\n        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\r\n            if (node.type.isText) {\r\n                return;\r\n            }\r\n            const { doc, mapping } = tr;\r\n            const $mappedFrom = doc.resolve(mapping.map(pos));\r\n            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\r\n            const nodeRange = $mappedFrom.blockRange($mappedTo);\r\n            if (!nodeRange) {\r\n                return;\r\n            }\r\n            const targetLiftDepth = liftTarget(nodeRange);\r\n            if (node.type.isTextblock) {\r\n                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\r\n                tr.setNodeMarkup(nodeRange.start, defaultType);\r\n            }\r\n            if (targetLiftDepth || targetLiftDepth === 0) {\r\n                tr.lift(nodeRange, targetLiftDepth);\r\n            }\r\n        });\r\n    });\r\n    return true;\r\n};\n\nvar clearNodes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearNodes: clearNodes\n});\n\nconst command = fn => props => {\r\n    return fn(props);\r\n};\n\nvar command$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  command: command\n});\n\nconst createParagraphNear = () => ({ state, dispatch }) => {\r\n    return createParagraphNear$2(state, dispatch);\r\n};\n\nvar createParagraphNear$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createParagraphNear: createParagraphNear\n});\n\nfunction getNodeType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.nodes[nameOrType]) {\r\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.nodes[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nconst deleteNode = typeOrName => ({ tr, state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const $pos = tr.selection.$anchor;\r\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\r\n        const node = $pos.node(depth);\r\n        if (node.type === type) {\r\n            if (dispatch) {\r\n                const from = $pos.before(depth);\r\n                const to = $pos.after(depth);\r\n                tr.delete(from, to).scrollIntoView();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar deleteNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteNode: deleteNode\n});\n\nconst deleteRange = range => ({ tr, dispatch }) => {\r\n    const { from, to } = range;\r\n    if (dispatch) {\r\n        tr.delete(from, to);\r\n    }\r\n    return true;\r\n};\n\nvar deleteRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteRange: deleteRange\n});\n\nconst deleteSelection = () => ({ state, dispatch }) => {\r\n    return deleteSelection$2(state, dispatch);\r\n};\n\nvar deleteSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteSelection: deleteSelection\n});\n\nconst enter = () => ({ commands }) => {\r\n    return commands.keyboardShortcut('Enter');\r\n};\n\nvar enter$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enter: enter\n});\n\nconst exitCode = () => ({ state, dispatch }) => {\r\n    return exitCode$2(state, dispatch);\r\n};\n\nvar exitCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  exitCode: exitCode\n});\n\nfunction getMarkType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.marks[nameOrType]) {\r\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.marks[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nfunction isRegExp(value) {\r\n    return Object.prototype.toString.call(value) === '[object RegExp]';\r\n}\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\r\nfunction objectIncludes(object1, object2, options = { strict: true }) {\r\n    const keys = Object.keys(object2);\r\n    if (!keys.length) {\r\n        return true;\r\n    }\r\n    return keys.every(key => {\r\n        if (options.strict) {\r\n            return object2[key] === object1[key];\r\n        }\r\n        if (isRegExp(object2[key])) {\r\n            return object2[key].test(object1[key]);\r\n        }\r\n        return object2[key] === object1[key];\r\n    });\r\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\r\n    return marks.find(item => {\r\n        return item.type === type && objectIncludes(item.attrs, attributes);\r\n    });\r\n}\r\nfunction isMarkInSet(marks, type, attributes = {}) {\r\n    return !!findMarkInSet(marks, type, attributes);\r\n}\r\nfunction getMarkRange($pos, type, attributes = {}) {\r\n    if (!$pos || !type) {\r\n        return;\r\n    }\r\n    const start = $pos.parent.childAfter($pos.parentOffset);\r\n    if (!start.node) {\r\n        return;\r\n    }\r\n    const mark = findMarkInSet(start.node.marks, type, attributes);\r\n    if (!mark) {\r\n        return;\r\n    }\r\n    let startIndex = $pos.index();\r\n    let startPos = $pos.start() + start.offset;\r\n    let endIndex = startIndex + 1;\r\n    let endPos = startPos + start.node.nodeSize;\r\n    findMarkInSet(start.node.marks, type, attributes);\r\n    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\r\n        startIndex -= 1;\r\n        startPos -= $pos.parent.child(startIndex).nodeSize;\r\n    }\r\n    while (endIndex < $pos.parent.childCount\r\n        && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {\r\n        endPos += $pos.parent.child(endIndex).nodeSize;\r\n        endIndex += 1;\r\n    }\r\n    return {\r\n        from: startPos,\r\n        to: endPos,\r\n    };\r\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { doc, selection } = tr;\r\n    const { $from, from, to } = selection;\r\n    if (dispatch) {\r\n        const range = getMarkRange($from, type, attributes);\r\n        if (range && range.from <= from && range.to >= to) {\r\n            const newSelection = TextSelection.create(doc, range.from, range.to);\r\n            tr.setSelection(newSelection);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar extendMarkRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extendMarkRange: extendMarkRange\n});\n\nconst first = commands => props => {\r\n    const items = typeof commands === 'function'\r\n        ? commands(props)\r\n        : commands;\r\n    for (let i = 0; i < items.length; i += 1) {\r\n        if (items[i](props)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar first$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  first: first\n});\n\nfunction isClass(value) {\r\n    var _a;\r\n    if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nfunction isObject(value) {\r\n    return (value\r\n        && typeof value === 'object'\r\n        && !Array.isArray(value)\r\n        && !isClass(value));\r\n}\n\nfunction isTextSelection(value) {\r\n    return isObject(value) && value instanceof TextSelection;\r\n}\n\nfunction isiOS() {\r\n    return [\r\n        'iPad Simulator',\r\n        'iPhone Simulator',\r\n        'iPod Simulator',\r\n        'iPad',\r\n        'iPhone',\r\n        'iPod',\r\n    ].includes(navigator.platform)\r\n        // iPad on iOS 13 detection\r\n        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\r\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\n\nfunction resolveFocusPosition(doc, position = null) {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n    if (position === 'start' || position === true) {\r\n        return Selection.atStart(doc);\r\n    }\r\n    if (position === 'end') {\r\n        return Selection.atEnd(doc);\r\n    }\r\n    if (position === 'all') {\r\n        return TextSelection.create(doc, 0, doc.content.size);\r\n    }\r\n    // Check if `position` is in bounds of the doc if `position` is a number.\r\n    const minPos = Selection.atStart(doc).from;\r\n    const maxPos = Selection.atEnd(doc).to;\r\n    const resolvedFrom = minMax(position, minPos, maxPos);\r\n    const resolvedEnd = minMax(position, minPos, maxPos);\r\n    return TextSelection.create(doc, resolvedFrom, resolvedEnd);\r\n}\n\nconst focus = (position = null, options) => ({ editor, view, tr, dispatch, }) => {\r\n    options = {\r\n        scrollIntoView: true,\r\n        ...options,\r\n    };\r\n    const delayedFocus = () => {\r\n        // focus within `requestAnimationFrame` breaks focus on iOS\r\n        // so we have to call this\r\n        if (isiOS()) {\r\n            view.dom.focus();\r\n        }\r\n        // For React we have to focus asynchronously. Otherwise wild things happen.\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1520\r\n        requestAnimationFrame(() => {\r\n            if (!editor.isDestroyed) {\r\n                view.focus();\r\n                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\r\n                    editor.commands.scrollIntoView();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    if ((view.hasFocus() && position === null) || position === false) {\r\n        return true;\r\n    }\r\n    // we don’t try to resolve a NodeSelection or CellSelection\r\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\r\n        delayedFocus();\r\n        return true;\r\n    }\r\n    const selection = resolveFocusPosition(editor.state.doc, position) || editor.state.selection;\r\n    const isSameSelection = editor.state.selection.eq(selection);\r\n    if (dispatch) {\r\n        if (!isSameSelection) {\r\n            tr.setSelection(selection);\r\n        }\r\n        // `tr.setSelection` resets the stored marks\r\n        // so we’ll restore them if the selection is the same as before\r\n        if (isSameSelection && tr.storedMarks) {\r\n            tr.setStoredMarks(tr.storedMarks);\r\n        }\r\n        delayedFocus();\r\n    }\r\n    return true;\r\n};\n\nvar focus$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  focus: focus\n});\n\nconst forEach = (items, fn) => props => {\r\n    return items.every((item, index) => fn(item, { ...props, index }));\r\n};\n\nvar forEach$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  forEach: forEach\n});\n\nconst insertContent = (value, options) => ({ tr, commands }) => {\r\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\r\n};\n\nvar insertContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContent: insertContent\n});\n\nfunction elementFromString(value) {\r\n    // add a wrapper to preserve leading and trailing whitespace\r\n    const wrappedValue = `<body>${value}</body>`;\r\n    return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\r\n}\n\nfunction createNodeFromContent(content, schema, options) {\r\n    options = {\r\n        slice: true,\r\n        parseOptions: {},\r\n        ...options,\r\n    };\r\n    if (typeof content === 'object' && content !== null) {\r\n        try {\r\n            if (Array.isArray(content)) {\r\n                return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\r\n            }\r\n            return schema.nodeFromJSON(content);\r\n        }\r\n        catch (error) {\r\n            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\r\n            return createNodeFromContent('', schema, options);\r\n        }\r\n    }\r\n    if (typeof content === 'string') {\r\n        const parser = DOMParser.fromSchema(schema);\r\n        return options.slice\r\n            ? parser.parseSlice(elementFromString(content), options.parseOptions).content\r\n            : parser.parse(elementFromString(content), options.parseOptions);\r\n    }\r\n    return createNodeFromContent('', schema, options);\r\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\r\nfunction selectionToInsertionEnd(tr, startLen, bias) {\r\n    const last = tr.steps.length - 1;\r\n    if (last < startLen) {\r\n        return;\r\n    }\r\n    const step = tr.steps[last];\r\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\r\n        return;\r\n    }\r\n    const map = tr.mapping.maps[last];\r\n    let end = 0;\r\n    map.forEach((_from, _to, _newFrom, newTo) => {\r\n        if (end === 0) {\r\n            end = newTo;\r\n        }\r\n    });\r\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\r\n}\n\nconst isFragment = (nodeOrFragment) => {\r\n    return nodeOrFragment.toString().startsWith('<');\r\n};\r\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\r\n    if (dispatch) {\r\n        options = {\r\n            parseOptions: {},\r\n            updateSelection: true,\r\n            ...options,\r\n        };\r\n        const content = createNodeFromContent(value, editor.schema, {\r\n            parseOptions: {\r\n                preserveWhitespace: 'full',\r\n                ...options.parseOptions,\r\n            },\r\n        });\r\n        // don’t dispatch an empty fragment because this can lead to strange errors\r\n        if (content.toString() === '<>') {\r\n            return true;\r\n        }\r\n        let { from, to } = typeof position === 'number'\r\n            ? { from: position, to: position }\r\n            : position;\r\n        let isOnlyTextContent = true;\r\n        let isOnlyBlockContent = true;\r\n        const nodes = isFragment(content)\r\n            ? content\r\n            : [content];\r\n        nodes.forEach(node => {\r\n            // check if added node is valid\r\n            node.check();\r\n            isOnlyTextContent = isOnlyTextContent\r\n                ? node.isText && node.marks.length === 0\r\n                : false;\r\n            isOnlyBlockContent = isOnlyBlockContent\r\n                ? node.isBlock\r\n                : false;\r\n        });\r\n        // check if we can replace the wrapping node by\r\n        // the newly inserted content\r\n        // example:\r\n        // replace an empty paragraph by an inserted image\r\n        // instead of inserting the image below the paragraph\r\n        if (from === to && isOnlyBlockContent) {\r\n            const { parent } = tr.doc.resolve(from);\r\n            const isEmptyTextBlock = parent.isTextblock\r\n                && !parent.type.spec.code\r\n                && !parent.childCount;\r\n            if (isEmptyTextBlock) {\r\n                from -= 1;\r\n                to += 1;\r\n            }\r\n        }\r\n        // if there is only plain text we have to use `insertText`\r\n        // because this will keep the current marks\r\n        if (isOnlyTextContent) {\r\n            tr.insertText(value, from, to);\r\n        }\r\n        else {\r\n            tr.replaceWith(from, to, content);\r\n        }\r\n        // set cursor at end of inserted content\r\n        if (options.updateSelection) {\r\n            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar insertContentAt$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContentAt: insertContentAt\n});\n\nconst joinBackward = () => ({ state, dispatch }) => {\r\n    return joinBackward$2(state, dispatch);\r\n};\n\nvar joinBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinBackward: joinBackward\n});\n\nconst joinForward = () => ({ state, dispatch }) => {\r\n    return joinForward$2(state, dispatch);\r\n};\n\nvar joinForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinForward: joinForward\n});\n\nfunction isMacOS() {\r\n    return typeof navigator !== 'undefined'\r\n        ? /Mac/.test(navigator.platform)\r\n        : false;\r\n}\n\nfunction normalizeKeyName(name) {\r\n    const parts = name.split(/-(?!$)/);\r\n    let result = parts[parts.length - 1];\r\n    if (result === 'Space') {\r\n        result = ' ';\r\n    }\r\n    let alt;\r\n    let ctrl;\r\n    let shift;\r\n    let meta;\r\n    for (let i = 0; i < parts.length - 1; i += 1) {\r\n        const mod = parts[i];\r\n        if (/^(cmd|meta|m)$/i.test(mod)) {\r\n            meta = true;\r\n        }\r\n        else if (/^a(lt)?$/i.test(mod)) {\r\n            alt = true;\r\n        }\r\n        else if (/^(c|ctrl|control)$/i.test(mod)) {\r\n            ctrl = true;\r\n        }\r\n        else if (/^s(hift)?$/i.test(mod)) {\r\n            shift = true;\r\n        }\r\n        else if (/^mod$/i.test(mod)) {\r\n            if (isiOS() || isMacOS()) {\r\n                meta = true;\r\n            }\r\n            else {\r\n                ctrl = true;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(`Unrecognized modifier name: ${mod}`);\r\n        }\r\n    }\r\n    if (alt) {\r\n        result = `Alt-${result}`;\r\n    }\r\n    if (ctrl) {\r\n        result = `Ctrl-${result}`;\r\n    }\r\n    if (meta) {\r\n        result = `Meta-${result}`;\r\n    }\r\n    if (shift) {\r\n        result = `Shift-${result}`;\r\n    }\r\n    return result;\r\n}\r\nconst keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {\r\n    const keys = normalizeKeyName(name).split(/-(?!$)/);\r\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\r\n    const event = new KeyboardEvent('keydown', {\r\n        key: key === 'Space'\r\n            ? ' '\r\n            : key,\r\n        altKey: keys.includes('Alt'),\r\n        ctrlKey: keys.includes('Ctrl'),\r\n        metaKey: keys.includes('Meta'),\r\n        shiftKey: keys.includes('Shift'),\r\n        bubbles: true,\r\n        cancelable: true,\r\n    });\r\n    const capturedTransaction = editor.captureTransaction(() => {\r\n        view.someProp('handleKeyDown', f => f(view, event));\r\n    });\r\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\r\n        const newStep = step.map(tr.mapping);\r\n        if (newStep && dispatch) {\r\n            tr.maybeStep(newStep);\r\n        }\r\n    });\r\n    return true;\r\n};\n\nvar keyboardShortcut$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  keyboardShortcut: keyboardShortcut\n});\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\r\n    const { from, to, empty } = state.selection;\r\n    const type = typeOrName\r\n        ? getNodeType(typeOrName, state.schema)\r\n        : null;\r\n    const nodeRanges = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (node.isText) {\r\n            return;\r\n        }\r\n        const relativeFrom = Math.max(from, pos);\r\n        const relativeTo = Math.min(to, pos + node.nodeSize);\r\n        nodeRanges.push({\r\n            node,\r\n            from: relativeFrom,\r\n            to: relativeTo,\r\n        });\r\n    });\r\n    const selectionRange = to - from;\r\n    const matchedNodeRanges = nodeRanges\r\n        .filter(nodeRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === nodeRange.node.type.name;\r\n    })\r\n        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\r\n    if (empty) {\r\n        return !!matchedNodeRanges.length;\r\n    }\r\n    const range = matchedNodeRanges\r\n        .reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\r\n    return range >= selectionRange;\r\n}\n\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (!isActive) {\r\n        return false;\r\n    }\r\n    return lift$2(state, dispatch);\r\n};\n\nvar lift$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lift: lift\n});\n\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\r\n    return liftEmptyBlock$2(state, dispatch);\r\n};\n\nvar liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftEmptyBlock: liftEmptyBlock\n});\n\nconst liftListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return liftListItem$2(type)(state, dispatch);\r\n};\n\nvar liftListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftListItem: liftListItem\n});\n\nconst newlineInCode = () => ({ state, dispatch }) => {\r\n    return newlineInCode$2(state, dispatch);\r\n};\n\nvar newlineInCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  newlineInCode: newlineInCode\n});\n\nfunction getSchemaTypeNameByName(name, schema) {\r\n    if (schema.nodes[name]) {\r\n        return 'node';\r\n    }\r\n    if (schema.marks[name]) {\r\n        return 'mark';\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\r\nfunction deleteProps(obj, propOrProps) {\r\n    const props = typeof propOrProps === 'string'\r\n        ? [propOrProps]\r\n        : propOrProps;\r\n    return Object\r\n        .keys(obj)\r\n        .reduce((newObj, prop) => {\r\n        if (!props.includes(prop)) {\r\n            newObj[prop] = obj[prop];\r\n        }\r\n        return newObj;\r\n    }, {});\r\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar resetAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetAttributes: resetAttributes\n});\n\nconst scrollIntoView = () => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar scrollIntoView$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  scrollIntoView: scrollIntoView\n});\n\nconst selectAll = () => ({ tr, commands }) => {\r\n    return commands.setTextSelection({\r\n        from: 0,\r\n        to: tr.doc.content.size,\r\n    });\r\n};\n\nvar selectAll$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectAll: selectAll\n});\n\nconst selectNodeBackward = () => ({ state, dispatch }) => {\r\n    return selectNodeBackward$2(state, dispatch);\r\n};\n\nvar selectNodeBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeBackward: selectNodeBackward\n});\n\nconst selectNodeForward = () => ({ state, dispatch }) => {\r\n    return selectNodeForward$2(state, dispatch);\r\n};\n\nvar selectNodeForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeForward: selectNodeForward\n});\n\nconst selectParentNode = () => ({ state, dispatch }) => {\r\n    return selectParentNode$2(state, dispatch);\r\n};\n\nvar selectParentNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectParentNode: selectParentNode\n});\n\n// @ts-ignore\r\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\r\n    return selectTextblockEnd$2(state, dispatch);\r\n};\n\nvar selectTextblockEnd$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectTextblockEnd: selectTextblockEnd\n});\n\n// @ts-ignore\r\nconst selectTextblockStart = () => ({ state, dispatch }) => {\r\n    return selectTextblockStart$2(state, dispatch);\r\n};\n\nvar selectTextblockStart$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectTextblockStart: selectTextblockStart\n});\n\nfunction createDocument(content, schema, parseOptions = {}) {\r\n    return createNodeFromContent(content, schema, { slice: false, parseOptions });\r\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\r\n    const { doc } = tr;\r\n    const document = createDocument(content, editor.schema, parseOptions);\r\n    const selection = TextSelection.create(doc, 0, doc.content.size);\r\n    if (dispatch) {\r\n        tr.setSelection(selection)\r\n            .replaceSelectionWith(document, false)\r\n            .setMeta('preventUpdate', !emitUpdate);\r\n    }\r\n    return true;\r\n};\n\nvar setContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setContent: setContent\n});\n\nfunction getMarkAttributes(state, typeOrName) {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { from, to, empty } = state.selection;\r\n    const marks = [];\r\n    if (empty) {\r\n        if (state.storedMarks) {\r\n            marks.push(...state.storedMarks);\r\n        }\r\n        marks.push(...state.selection.$head.marks());\r\n    }\r\n    else {\r\n        state.doc.nodesBetween(from, to, node => {\r\n            marks.push(...node.marks);\r\n        });\r\n    }\r\n    const mark = marks.find(markItem => markItem.type.name === type.name);\r\n    if (!mark) {\r\n        return {};\r\n    }\r\n    return { ...mark.attrs };\r\n}\n\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    if (dispatch) {\r\n        if (empty) {\r\n            const oldAttributes = getMarkAttributes(state, type);\r\n            tr.addStoredMark(type.create({\r\n                ...oldAttributes,\r\n                ...attributes,\r\n            }));\r\n        }\r\n        else {\r\n            ranges.forEach(range => {\r\n                const from = range.$from.pos;\r\n                const to = range.$to.pos;\r\n                state.doc.nodesBetween(from, to, (node, pos) => {\r\n                    const trimmedFrom = Math.max(pos, from);\r\n                    const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                    const someHasMark = node.marks.find(mark => mark.type === type);\r\n                    // if there is already a mark of this type\r\n                    // we know that we have to merge its attributes\r\n                    // otherwise we add a fresh new mark\r\n                    if (someHasMark) {\r\n                        node.marks.forEach(mark => {\r\n                            if (type === mark.type) {\r\n                                tr.addMark(trimmedFrom, trimmedTo, type.create({\r\n                                    ...mark.attrs,\r\n                                    ...attributes,\r\n                                }));\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    return true;\r\n};\n\nvar setMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMark: setMark\n});\n\nconst setMeta = (key, value) => ({ tr }) => {\r\n    tr.setMeta(key, value);\r\n    return true;\r\n};\n\nvar setMeta$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMeta: setMeta\n});\n\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    // TODO: use a fallback like insertContent?\r\n    if (!type.isTextblock) {\r\n        console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\r\n        return false;\r\n    }\r\n    return chain()\r\n        // try to convert node to default node if needed\r\n        .command(({ commands }) => {\r\n        const canSetBlock = setBlockType(type, attributes)(state);\r\n        if (canSetBlock) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .command(({ state: updatedState }) => {\r\n        return setBlockType(type, attributes)(updatedState, dispatch);\r\n    })\r\n        .run();\r\n};\n\nvar setNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNode: setNode\n});\n\nconst setNodeSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const minPos = Selection.atStart(doc).from;\r\n        const maxPos = Selection.atEnd(doc).to;\r\n        const resolvedPos = minMax(position, minPos, maxPos);\r\n        const selection = NodeSelection.create(doc, resolvedPos);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nvar setNodeSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNodeSelection: setNodeSelection\n});\n\nconst setTextSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const { from, to } = typeof position === 'number'\r\n            ? { from: position, to: position }\r\n            : position;\r\n        const minPos = 0;\r\n        const maxPos = tr.doc.content.size;\r\n        const resolvedFrom = minMax(from, minPos, maxPos);\r\n        const resolvedEnd = minMax(to, minPos, maxPos);\r\n        const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nvar setTextSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setTextSelection: setTextSelection\n});\n\nconst sinkListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return sinkListItem$2(type)(state, dispatch);\r\n};\n\nvar sinkListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sinkListItem: sinkListItem\n});\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\r\n    return Object.fromEntries(Object\r\n        .entries(attributes)\r\n        .filter(([name]) => {\r\n        const extensionAttribute = extensionAttributes.find(item => {\r\n            return item.type === typeName && item.name === name;\r\n        });\r\n        if (!extensionAttribute) {\r\n            return false;\r\n        }\r\n        return extensionAttribute.attribute.keepOnSplit;\r\n    }));\r\n}\n\nfunction defaultBlockAt$1(match) {\r\n    for (let i = 0; i < match.edgeCount; i += 1) {\r\n        const { type } = match.edge(i);\r\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction ensureMarks(state, splittableMarks) {\r\n    const marks = state.storedMarks\r\n        || (state.selection.$to.parentOffset && state.selection.$from.marks());\r\n    if (marks) {\r\n        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\r\n        state.tr.ensureMarks(filteredMarks);\r\n    }\r\n}\r\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {\r\n    const { selection, doc } = tr;\r\n    const { $from, $to } = selection;\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\r\n        if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            if (keepMarks) {\r\n                ensureMarks(state, editor.extensionManager.splittableMarks);\r\n            }\r\n            tr.split($from.pos).scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    if (!$from.parent.isBlock) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        const atEnd = $to.parentOffset === $to.parent.content.size;\r\n        if (selection instanceof TextSelection) {\r\n            tr.deleteSelection();\r\n        }\r\n        const deflt = $from.depth === 0\r\n            ? undefined\r\n            : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));\r\n        let types = atEnd && deflt\r\n            ? [{\r\n                    type: deflt,\r\n                    attrs: newAttributes,\r\n                }]\r\n            : undefined;\r\n        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\r\n        if (!types\r\n            && !can\r\n            && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\r\n            can = true;\r\n            types = deflt\r\n                ? [{\r\n                        type: deflt,\r\n                        attrs: newAttributes,\r\n                    }]\r\n                : undefined;\r\n        }\r\n        if (can) {\r\n            tr.split(tr.mapping.map($from.pos), 1, types);\r\n            if (deflt\r\n                && !atEnd\r\n                && !$from.parentOffset\r\n                && $from.parent.type !== deflt) {\r\n                const first = tr.mapping.map($from.before());\r\n                const $first = tr.doc.resolve(first);\r\n                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\r\n                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\r\n                }\r\n            }\r\n        }\r\n        if (keepMarks) {\r\n            ensureMarks(state, editor.extensionManager.splittableMarks);\r\n        }\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar splitBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitBlock: splitBlock\n});\n\nconst splitListItem = typeOrName => ({ tr, state, dispatch, editor, }) => {\r\n    var _a;\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { $from, $to } = state.selection;\r\n    // @ts-ignore\r\n    // eslint-disable-next-line\r\n    const node = state.selection.node;\r\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\r\n        return false;\r\n    }\r\n    const grandParent = $from.node(-1);\r\n    if (grandParent.type !== type) {\r\n        return false;\r\n    }\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\r\n        // In an empty block. If this is a nested list, the wrapping\r\n        // list item should be split. Otherwise, bail out and let next\r\n        // command handle lifting.\r\n        if ($from.depth === 2\r\n            || $from.node(-3).type !== type\r\n            || $from.index(-2) !== $from.node(-2).childCount - 1) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            let wrap = Fragment.empty;\r\n            // eslint-disable-next-line\r\n            const depthBefore = $from.index(-1)\r\n                ? 1\r\n                : $from.index(-2)\r\n                    ? 2\r\n                    : 3;\r\n            // Build a fragment containing empty versions of the structure\r\n            // from the outer list item to the parent node of the cursor\r\n            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\r\n                wrap = Fragment.from($from.node(d).copy(wrap));\r\n            }\r\n            // eslint-disable-next-line\r\n            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount\r\n                ? 1\r\n                : $from.indexAfter(-2) < $from.node(-3).childCount\r\n                    ? 2\r\n                    : 3;\r\n            // Add a second list item with an empty default start node\r\n            const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\r\n            wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\r\n            const start = $from.before($from.depth - (depthBefore - 1));\r\n            tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\r\n            let sel = -1;\r\n            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\r\n                if (sel > -1) {\r\n                    return false;\r\n                }\r\n                if (n.isTextblock && n.content.size === 0) {\r\n                    sel = pos + 1;\r\n                }\r\n            });\r\n            if (sel > -1) {\r\n                tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\r\n            }\r\n            tr.scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    const nextType = $to.pos === $from.end()\r\n        ? grandParent.contentMatchAt(0).defaultType\r\n        : null;\r\n    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\r\n    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    tr.delete($from.pos, $to.pos);\r\n    const types = nextType\r\n        ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]\r\n        : [{ type, attrs: newTypeAttributes }];\r\n    if (!canSplit(tr.doc, $from.pos, 2)) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        tr.split($from.pos, 2, types).scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nvar splitListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitListItem: splitListItem\n});\n\nfunction findParentNodeClosestToPos($pos, predicate) {\r\n    for (let i = $pos.depth; i > 0; i -= 1) {\r\n        const node = $pos.node(i);\r\n        if (predicate(node)) {\r\n            return {\r\n                pos: i > 0 ? $pos.before(i) : 0,\r\n                start: $pos.start(i),\r\n                depth: i,\r\n                node,\r\n            };\r\n        }\r\n    }\r\n}\n\nfunction findParentNode(predicate) {\r\n    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\r\n}\n\nfunction splitExtensions(extensions) {\r\n    const baseExtensions = extensions.filter(extension => extension.type === 'extension');\r\n    const nodeExtensions = extensions.filter(extension => extension.type === 'node');\r\n    const markExtensions = extensions.filter(extension => extension.type === 'mark');\r\n    return {\r\n        baseExtensions,\r\n        nodeExtensions,\r\n        markExtensions,\r\n    };\r\n}\n\nfunction isList(name, extensions) {\r\n    const { nodeExtensions } = splitExtensions(extensions);\r\n    const extension = nodeExtensions.find(item => item.name === name);\r\n    if (!extension) {\r\n        return false;\r\n    }\r\n    const context = {\r\n        name: extension.name,\r\n        options: extension.options,\r\n        storage: extension.storage,\r\n    };\r\n    const group = callOrReturn(getExtensionField(extension, 'group', context));\r\n    if (typeof group !== 'string') {\r\n        return false;\r\n    }\r\n    return group.split(' ').includes('list');\r\n}\n\nconst joinListBackwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\r\n    if (before === undefined) {\r\n        return true;\r\n    }\r\n    const nodeBefore = tr.doc.nodeAt(before);\r\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type)\r\n        && canJoin(tr.doc, list.pos);\r\n    if (!canJoinBackwards) {\r\n        return true;\r\n    }\r\n    tr.join(list.pos);\r\n    return true;\r\n};\r\nconst joinListForwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const after = tr.doc.resolve(list.start).after(list.depth);\r\n    if (after === undefined) {\r\n        return true;\r\n    }\r\n    const nodeAfter = tr.doc.nodeAt(after);\r\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type)\r\n        && canJoin(tr.doc, after);\r\n    if (!canJoinForwards) {\r\n        return true;\r\n    }\r\n    tr.join(after);\r\n    return true;\r\n};\r\nconst toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {\r\n    const { extensions } = editor.extensionManager;\r\n    const listType = getNodeType(listTypeOrName, state.schema);\r\n    const itemType = getNodeType(itemTypeOrName, state.schema);\r\n    const { selection } = state;\r\n    const { $from, $to } = selection;\r\n    const range = $from.blockRange($to);\r\n    if (!range) {\r\n        return false;\r\n    }\r\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\r\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\r\n        // remove list\r\n        if (parentList.node.type === listType) {\r\n            return commands.liftListItem(itemType);\r\n        }\r\n        // change list type\r\n        if (isList(parentList.node.type.name, extensions)\r\n            && listType.validContent(parentList.node.content)\r\n            && dispatch) {\r\n            return chain()\r\n                .command(() => {\r\n                tr.setNodeMarkup(parentList.pos, listType);\r\n                return true;\r\n            })\r\n                .command(() => joinListBackwards(tr, listType))\r\n                .command(() => joinListForwards(tr, listType))\r\n                .run();\r\n        }\r\n    }\r\n    return chain()\r\n        // try to convert node to default node if needed\r\n        .command(() => {\r\n        const canWrapInList = can().wrapInList(listType);\r\n        if (canWrapInList) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .wrapInList(listType)\r\n        .command(() => joinListBackwards(tr, listType))\r\n        .command(() => joinListForwards(tr, listType))\r\n        .run();\r\n};\n\nvar toggleList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleList: toggleList\n});\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\r\n    const { empty, ranges } = state.selection;\r\n    const type = typeOrName\r\n        ? getMarkType(typeOrName, state.schema)\r\n        : null;\r\n    if (empty) {\r\n        return !!(state.storedMarks || state.selection.$from.marks())\r\n            .filter(mark => {\r\n            if (!type) {\r\n                return true;\r\n            }\r\n            return type.name === mark.type.name;\r\n        })\r\n            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));\r\n    }\r\n    let selectionRange = 0;\r\n    const markRanges = [];\r\n    ranges.forEach(({ $from, $to }) => {\r\n        const from = $from.pos;\r\n        const to = $to.pos;\r\n        state.doc.nodesBetween(from, to, (node, pos) => {\r\n            if (!node.isText && !node.marks.length) {\r\n                return;\r\n            }\r\n            const relativeFrom = Math.max(from, pos);\r\n            const relativeTo = Math.min(to, pos + node.nodeSize);\r\n            const range = relativeTo - relativeFrom;\r\n            selectionRange += range;\r\n            markRanges.push(...node.marks.map(mark => ({\r\n                mark,\r\n                from: relativeFrom,\r\n                to: relativeTo,\r\n            })));\r\n        });\r\n    });\r\n    if (selectionRange === 0) {\r\n        return false;\r\n    }\r\n    // calculate range of matched mark\r\n    const matchedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === markRange.mark.type.name;\r\n    })\r\n        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // calculate range of marks that excludes the searched mark\r\n    // for example `code` doesn’t allow any other marks\r\n    const excludedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return markRange.mark.type !== type\r\n            && markRange.mark.type.excludes(type);\r\n    })\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // we only include the result of `excludedRange`\r\n    // if there is a match at all\r\n    const range = matchedRange > 0\r\n        ? matchedRange + excludedRange\r\n        : matchedRange;\r\n    return range >= selectionRange;\r\n}\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const isActive = isMarkActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.unsetMark(type, { extendEmptyMarkRange });\r\n    }\r\n    return commands.setMark(type, attributes);\r\n};\n\nvar toggleMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleMark: toggleMark\n});\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.setNode(toggleType);\r\n    }\r\n    return commands.setNode(type, attributes);\r\n};\n\nvar toggleNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleNode: toggleNode\n});\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.lift(type);\r\n    }\r\n    return commands.wrapIn(type, attributes);\r\n};\n\nvar toggleWrap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleWrap: toggleWrap\n});\n\nconst undoInputRule = () => ({ state, dispatch }) => {\r\n    const plugins = state.plugins;\r\n    for (let i = 0; i < plugins.length; i += 1) {\r\n        const plugin = plugins[i];\r\n        let undoable;\r\n        // @ts-ignore\r\n        // eslint-disable-next-line\r\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\r\n            if (dispatch) {\r\n                const tr = state.tr;\r\n                const toUndo = undoable.transform;\r\n                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\r\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\r\n                }\r\n                if (undoable.text) {\r\n                    const marks = tr.doc.resolve(undoable.from).marks();\r\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\r\n                }\r\n                else {\r\n                    tr.delete(undoable.from, undoable.to);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nvar undoInputRule$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  undoInputRule: undoInputRule\n});\n\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    if (empty) {\r\n        return true;\r\n    }\r\n    if (dispatch) {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos);\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar unsetAllMarks$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetAllMarks: unsetAllMarks\n});\n\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\r\n    var _a;\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const { selection } = tr;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { $from, empty, ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    if (empty && extendEmptyMarkRange) {\r\n        let { from, to } = selection;\r\n        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\r\n        const range = getMarkRange($from, type, attrs);\r\n        if (range) {\r\n            from = range.from;\r\n            to = range.to;\r\n        }\r\n        tr.removeMark(from, to, type);\r\n    }\r\n    else {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos, type);\r\n        });\r\n    }\r\n    tr.removeStoredMark(type);\r\n    return true;\r\n};\n\nvar unsetMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetMark: unsetMark\n});\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            const from = range.$from.pos;\r\n            const to = range.$to.pos;\r\n            state.doc.nodesBetween(from, to, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, {\r\n                        ...node.attrs,\r\n                        ...attributes,\r\n                    });\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            const trimmedFrom = Math.max(pos, from);\r\n                            const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\r\n                                ...mark.attrs,\r\n                                ...attributes,\r\n                            }));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nvar updateAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  updateAttributes: updateAttributes\n});\n\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return wrapIn$2(type, attributes)(state, dispatch);\r\n};\n\nvar wrapIn$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapIn: wrapIn\n});\n\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return wrapInList$2(type, attributes)(state, dispatch);\r\n};\n\nvar wrapInList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapInList: wrapInList\n});\n\nconst Commands = Extension.create({\r\n    name: 'commands',\r\n    addCommands() {\r\n        return {\r\n            ...blur$1,\r\n            ...clearContent$1,\r\n            ...clearNodes$1,\r\n            ...command$1,\r\n            ...createParagraphNear$1,\r\n            ...deleteNode$1,\r\n            ...deleteRange$1,\r\n            ...deleteSelection$1,\r\n            ...enter$1,\r\n            ...exitCode$1,\r\n            ...extendMarkRange$1,\r\n            ...first$1,\r\n            ...focus$1,\r\n            ...forEach$1,\r\n            ...insertContent$1,\r\n            ...insertContentAt$1,\r\n            ...joinBackward$1,\r\n            ...joinForward$1,\r\n            ...keyboardShortcut$1,\r\n            ...lift$1,\r\n            ...liftEmptyBlock$1,\r\n            ...liftListItem$1,\r\n            ...newlineInCode$1,\r\n            ...resetAttributes$1,\r\n            ...scrollIntoView$1,\r\n            ...selectAll$1,\r\n            ...selectNodeBackward$1,\r\n            ...selectNodeForward$1,\r\n            ...selectParentNode$1,\r\n            ...selectTextblockEnd$1,\r\n            ...selectTextblockStart$1,\r\n            ...setContent$1,\r\n            ...setMark$1,\r\n            ...setMeta$1,\r\n            ...setNode$1,\r\n            ...setNodeSelection$1,\r\n            ...setTextSelection$1,\r\n            ...sinkListItem$1,\r\n            ...splitBlock$1,\r\n            ...splitListItem$1,\r\n            ...toggleList$1,\r\n            ...toggleMark$1,\r\n            ...toggleNode$1,\r\n            ...toggleWrap$1,\r\n            ...undoInputRule$1,\r\n            ...unsetAllMarks$1,\r\n            ...unsetMark$1,\r\n            ...updateAttributes$1,\r\n            ...wrapIn$1,\r\n            ...wrapInList$1,\r\n        };\r\n    },\r\n});\n\nconst Editable = Extension.create({\r\n    name: 'editable',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('editable'),\r\n                props: {\r\n                    editable: () => this.editor.options.editable,\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst FocusEvents = Extension.create({\r\n    name: 'focusEvents',\r\n    addProseMirrorPlugins() {\r\n        const { editor } = this;\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('focusEvents'),\r\n                props: {\r\n                    handleDOMEvents: {\r\n                        focus: (view, event) => {\r\n                            editor.isFocused = true;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('focus', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                        blur: (view, event) => {\r\n                            editor.isFocused = false;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('blur', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nfunction createChainableState(config) {\r\n    const { state, transaction } = config;\r\n    let { selection } = transaction;\r\n    let { doc } = transaction;\r\n    let { storedMarks } = transaction;\r\n    return {\r\n        ...state,\r\n        schema: state.schema,\r\n        plugins: state.plugins,\r\n        apply: state.apply.bind(state),\r\n        applyTransaction: state.applyTransaction.bind(state),\r\n        reconfigure: state.reconfigure.bind(state),\r\n        toJSON: state.toJSON.bind(state),\r\n        get storedMarks() {\r\n            return storedMarks;\r\n        },\r\n        get selection() {\r\n            return selection;\r\n        },\r\n        get doc() {\r\n            return doc;\r\n        },\r\n        get tr() {\r\n            selection = transaction.selection;\r\n            doc = transaction.doc;\r\n            storedMarks = transaction.storedMarks;\r\n            return transaction;\r\n        },\r\n    };\r\n}\n\nclass CommandManager {\r\n    constructor(props) {\r\n        this.editor = props.editor;\r\n        this.rawCommands = this.editor.extensionManager.commands;\r\n        this.customState = props.state;\r\n    }\r\n    get hasCustomState() {\r\n        return !!this.customState;\r\n    }\r\n    get state() {\r\n        return this.customState || this.editor.state;\r\n    }\r\n    get commands() {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const { tr } = state;\r\n        const props = this.buildProps(tr);\r\n        return Object.fromEntries(Object\r\n            .entries(rawCommands)\r\n            .map(([name, command]) => {\r\n            const method = (...args) => {\r\n                const callback = command(...args)(props);\r\n                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\r\n                    view.dispatch(tr);\r\n                }\r\n                return callback;\r\n            };\r\n            return [name, method];\r\n        }));\r\n    }\r\n    get chain() {\r\n        return () => this.createChain();\r\n    }\r\n    get can() {\r\n        return () => this.createCan();\r\n    }\r\n    createChain(startTr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const callbacks = [];\r\n        const hasStartTransaction = !!startTr;\r\n        const tr = startTr || state.tr;\r\n        const run = () => {\r\n            if (!hasStartTransaction\r\n                && shouldDispatch\r\n                && !tr.getMeta('preventDispatch')\r\n                && !this.hasCustomState) {\r\n                view.dispatch(tr);\r\n            }\r\n            return callbacks.every(callback => callback === true);\r\n        };\r\n        const chain = {\r\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n                const chainedCommand = (...args) => {\r\n                    const props = this.buildProps(tr, shouldDispatch);\r\n                    const callback = command(...args)(props);\r\n                    callbacks.push(callback);\r\n                    return chain;\r\n                };\r\n                return [name, chainedCommand];\r\n            })),\r\n            run,\r\n        };\r\n        return chain;\r\n    }\r\n    createCan(startTr) {\r\n        const { rawCommands, state } = this;\r\n        const dispatch = undefined;\r\n        const tr = startTr || state.tr;\r\n        const props = this.buildProps(tr, dispatch);\r\n        const formattedCommands = Object.fromEntries(Object\r\n            .entries(rawCommands)\r\n            .map(([name, command]) => {\r\n            return [name, (...args) => command(...args)({ ...props, dispatch })];\r\n        }));\r\n        return {\r\n            ...formattedCommands,\r\n            chain: () => this.createChain(tr, dispatch),\r\n        };\r\n    }\r\n    buildProps(tr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        if (state.storedMarks) {\r\n            tr.setStoredMarks(state.storedMarks);\r\n        }\r\n        const props = {\r\n            tr,\r\n            editor,\r\n            view,\r\n            state: createChainableState({\r\n                state,\r\n                transaction: tr,\r\n            }),\r\n            dispatch: shouldDispatch\r\n                ? () => undefined\r\n                : undefined,\r\n            chain: () => this.createChain(tr),\r\n            can: () => this.createCan(tr),\r\n            get commands() {\r\n                return Object.fromEntries(Object\r\n                    .entries(rawCommands)\r\n                    .map(([name, command]) => {\r\n                    return [name, (...args) => command(...args)(props)];\r\n                }));\r\n            },\r\n        };\r\n        return props;\r\n    }\r\n}\n\nconst Keymap = Extension.create({\r\n    name: 'keymap',\r\n    addKeyboardShortcuts() {\r\n        const handleBackspace = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.undoInputRule(),\r\n            // maybe convert first text block node to default node\r\n            () => commands.command(({ tr }) => {\r\n                const { selection, doc } = tr;\r\n                const { empty, $anchor } = selection;\r\n                const { pos, parent } = $anchor;\r\n                const isAtStart = Selection.atStart(doc).from === pos;\r\n                if (!empty\r\n                    || !isAtStart\r\n                    || !parent.type.isTextblock\r\n                    || parent.textContent.length) {\r\n                    return false;\r\n                }\r\n                return commands.clearNodes();\r\n            }),\r\n            () => commands.deleteSelection(),\r\n            () => commands.joinBackward(),\r\n            () => commands.selectNodeBackward(),\r\n        ]);\r\n        const handleDelete = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.deleteSelection(),\r\n            () => commands.joinForward(),\r\n            () => commands.selectNodeForward(),\r\n        ]);\r\n        const handleEnter = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.newlineInCode(),\r\n            () => commands.createParagraphNear(),\r\n            () => commands.liftEmptyBlock(),\r\n            () => commands.splitBlock(),\r\n        ]);\r\n        const baseKeymap = {\r\n            Enter: handleEnter,\r\n            'Mod-Enter': () => this.editor.commands.exitCode(),\r\n            Backspace: handleBackspace,\r\n            'Mod-Backspace': handleBackspace,\r\n            'Shift-Backspace': handleBackspace,\r\n            Delete: handleDelete,\r\n            'Mod-Delete': handleDelete,\r\n            'Mod-a': () => this.editor.commands.selectAll(),\r\n        };\r\n        const pcKeymap = {\r\n            ...baseKeymap,\r\n            Home: () => this.editor.commands.selectTextblockStart(),\r\n            End: () => this.editor.commands.selectTextblockEnd(),\r\n        };\r\n        const macKeymap = {\r\n            ...baseKeymap,\r\n            'Ctrl-h': handleBackspace,\r\n            'Alt-Backspace': handleBackspace,\r\n            'Ctrl-d': handleDelete,\r\n            'Ctrl-Alt-Backspace': handleDelete,\r\n            'Alt-Delete': handleDelete,\r\n            'Alt-d': handleDelete,\r\n            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\r\n            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\r\n        };\r\n        if (isiOS() || isMacOS()) {\r\n            return macKeymap;\r\n        }\r\n        return pcKeymap;\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            // With this plugin we check if the whole document was selected and deleted.\r\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\r\n            // to a paragraph if necessary.\r\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\r\n            // with many other commands.\r\n            new Plugin({\r\n                key: new PluginKey('clearDocument'),\r\n                appendTransaction: (transactions, oldState, newState) => {\r\n                    const docChanges = transactions.some(transaction => transaction.docChanged)\r\n                        && !oldState.doc.eq(newState.doc);\r\n                    if (!docChanges) {\r\n                        return;\r\n                    }\r\n                    const { empty, from, to } = oldState.selection;\r\n                    const allFrom = Selection.atStart(oldState.doc).from;\r\n                    const allEnd = Selection.atEnd(oldState.doc).to;\r\n                    const allWasSelected = from === allFrom && to === allEnd;\r\n                    const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\r\n                    if (empty || !allWasSelected || !isEmpty) {\r\n                        return;\r\n                    }\r\n                    const tr = newState.tr;\r\n                    const state = createChainableState({\r\n                        state: newState,\r\n                        transaction: tr,\r\n                    });\r\n                    const { commands } = new CommandManager({\r\n                        editor: this.editor,\r\n                        state,\r\n                    });\r\n                    commands.clearNodes();\r\n                    if (!tr.steps.length) {\r\n                        return;\r\n                    }\r\n                    return tr;\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst Tabindex = Extension.create({\r\n    name: 'tabindex',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new Plugin({\r\n                key: new PluginKey('tabindex'),\r\n                props: {\r\n                    attributes: {\r\n                        tabindex: '0',\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\n\nfunction getNodeAttributes(state, typeOrName) {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { from, to } = state.selection;\r\n    const nodes = [];\r\n    state.doc.nodesBetween(from, to, node => {\r\n        nodes.push(node);\r\n    });\r\n    const node = nodes\r\n        .reverse()\r\n        .find(nodeItem => nodeItem.type.name === type.name);\r\n    if (!node) {\r\n        return {};\r\n    }\r\n    return { ...node.attrs };\r\n}\n\nfunction getAttributes(state, typeOrName) {\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'\r\n        ? typeOrName\r\n        : typeOrName.name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return getNodeAttributes(state, typeOrName);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return getMarkAttributes(state, typeOrName);\r\n    }\r\n    return {};\r\n}\n\nfunction isActive(state, name, attributes = {}) {\r\n    if (!name) {\r\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\r\n    }\r\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return isNodeActive(state, name, attributes);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return isMarkActive(state, name, attributes);\r\n    }\r\n    return false;\r\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\r\n    const documentFragment = DOMSerializer\r\n        .fromSchema(schema)\r\n        .serializeFragment(fragment);\r\n    const temporaryDocument = document.implementation.createHTMLDocument();\r\n    const container = temporaryDocument.createElement('div');\r\n    container.appendChild(documentFragment);\r\n    return container.innerHTML;\r\n}\n\nfunction getText(node, options) {\r\n    const range = {\r\n        from: 0,\r\n        to: node.content.size,\r\n    };\r\n    return getTextBetween(node, range, options);\r\n}\n\nfunction isNodeEmpty(node) {\r\n    var _a;\r\n    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\r\n    const content = node.toJSON();\r\n    return JSON.stringify(defaultContent) === JSON.stringify(content);\r\n}\n\nfunction createStyleTag(style) {\r\n    const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\r\n    if (tipTapStyleTag !== null) {\r\n        return tipTapStyleTag;\r\n    }\r\n    const styleNode = document.createElement('style');\r\n    styleNode.setAttribute('data-tiptap-style', '');\r\n    styleNode.innerHTML = style;\r\n    document.getElementsByTagName('head')[0].appendChild(styleNode);\r\n    return styleNode;\r\n}\n\nclass InputRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst inputRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return find.exec(text);\r\n    }\r\n    const inputRuleMatch = find(text);\r\n    if (!inputRuleMatch) {\r\n        return null;\r\n    }\r\n    const result = [];\r\n    result.push(inputRuleMatch.text);\r\n    result.index = inputRuleMatch.index;\r\n    result.input = text;\r\n    result.data = inputRuleMatch.data;\r\n    if (inputRuleMatch.replaceWith) {\r\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\r\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\r\n        }\r\n        result.push(inputRuleMatch.replaceWith);\r\n    }\r\n    return result;\r\n};\r\nfunction run$1(config) {\r\n    var _a;\r\n    const { editor, from, to, text, rules, plugin, } = config;\r\n    const { view } = editor;\r\n    if (view.composing) {\r\n        return false;\r\n    }\r\n    const $from = view.state.doc.resolve(from);\r\n    if (\r\n    // check for code node\r\n    $from.parent.type.spec.code\r\n        // check for code mark\r\n        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\r\n        return false;\r\n    }\r\n    let matched = false;\r\n    const maxMatch = 500;\r\n    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, undefined, ' ') + text;\r\n    rules.forEach(rule => {\r\n        if (matched) {\r\n            return;\r\n        }\r\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\r\n        if (!match) {\r\n            return;\r\n        }\r\n        const tr = view.state.tr;\r\n        const state = createChainableState({\r\n            state: view.state,\r\n            transaction: tr,\r\n        });\r\n        const range = {\r\n            from: from - (match[0].length - text.length),\r\n            to,\r\n        };\r\n        const { commands, chain, can } = new CommandManager({\r\n            editor,\r\n            state,\r\n        });\r\n        const handler = rule.handler({\r\n            state,\r\n            range,\r\n            match,\r\n            commands,\r\n            chain,\r\n            can,\r\n        });\r\n        // stop if there are no changes\r\n        if (handler === null || !tr.steps.length) {\r\n            return;\r\n        }\r\n        // store transform as meta data\r\n        // so we can undo input rules within the `undoInputRules` command\r\n        tr.setMeta(plugin, {\r\n            transform: tr,\r\n            from,\r\n            to,\r\n            text,\r\n        });\r\n        view.dispatch(tr);\r\n        matched = true;\r\n    });\r\n    return matched;\r\n}\r\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction inputRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    const plugin = new Plugin({\r\n        state: {\r\n            init() {\r\n                return null;\r\n            },\r\n            apply(tr, prev) {\r\n                const stored = tr.getMeta(this);\r\n                if (stored) {\r\n                    return stored;\r\n                }\r\n                return tr.selectionSet || tr.docChanged\r\n                    ? null\r\n                    : prev;\r\n            },\r\n        },\r\n        props: {\r\n            handleTextInput(view, from, to, text) {\r\n                return run$1({\r\n                    editor,\r\n                    from,\r\n                    to,\r\n                    text,\r\n                    rules,\r\n                    plugin,\r\n                });\r\n            },\r\n            handleDOMEvents: {\r\n                compositionend: view => {\r\n                    setTimeout(() => {\r\n                        const { $cursor } = view.state.selection;\r\n                        if ($cursor) {\r\n                            run$1({\r\n                                editor,\r\n                                from: $cursor.pos,\r\n                                to: $cursor.pos,\r\n                                text: '',\r\n                                rules,\r\n                                plugin,\r\n                            });\r\n                        }\r\n                    });\r\n                    return false;\r\n                },\r\n            },\r\n            // add support for input rules to trigger on enter\r\n            // this is useful for example for code blocks\r\n            handleKeyDown(view, event) {\r\n                if (event.key !== 'Enter') {\r\n                    return false;\r\n                }\r\n                const { $cursor } = view.state.selection;\r\n                if ($cursor) {\r\n                    return run$1({\r\n                        editor,\r\n                        from: $cursor.pos,\r\n                        to: $cursor.pos,\r\n                        text: '\\n',\r\n                        rules,\r\n                        plugin,\r\n                    });\r\n                }\r\n                return false;\r\n            },\r\n        },\r\n        // @ts-ignore\r\n        isInputRules: true,\r\n    });\r\n    return plugin;\r\n}\n\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\n\nclass PasteRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst pasteRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return [...text.matchAll(find)];\r\n    }\r\n    const matches = find(text);\r\n    if (!matches) {\r\n        return [];\r\n    }\r\n    return matches.map(pasteRuleMatch => {\r\n        const result = [];\r\n        result.push(pasteRuleMatch.text);\r\n        result.index = pasteRuleMatch.index;\r\n        result.input = text;\r\n        result.data = pasteRuleMatch.data;\r\n        if (pasteRuleMatch.replaceWith) {\r\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\r\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\r\n            }\r\n            result.push(pasteRuleMatch.replaceWith);\r\n        }\r\n        return result;\r\n    });\r\n};\r\nfunction run(config) {\r\n    const { editor, state, from, to, rule, } = config;\r\n    const { commands, chain, can } = new CommandManager({\r\n        editor,\r\n        state,\r\n    });\r\n    const handlers = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (!node.isTextblock || node.type.spec.code) {\r\n            return;\r\n        }\r\n        const resolvedFrom = Math.max(from, pos);\r\n        const resolvedTo = Math.min(to, pos + node.content.size);\r\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\r\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\r\n        matches.forEach(match => {\r\n            if (match.index === undefined) {\r\n                return;\r\n            }\r\n            const start = resolvedFrom + match.index + 1;\r\n            const end = start + match[0].length;\r\n            const range = {\r\n                from: state.tr.mapping.map(start),\r\n                to: state.tr.mapping.map(end),\r\n            };\r\n            const handler = rule.handler({\r\n                state,\r\n                range,\r\n                match,\r\n                commands,\r\n                chain,\r\n                can,\r\n            });\r\n            handlers.push(handler);\r\n        });\r\n    });\r\n    const success = handlers.every(handler => handler !== null);\r\n    return success;\r\n}\r\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction pasteRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    let dragSourceElement = null;\r\n    let isPastedFromProseMirror = false;\r\n    let isDroppedFromProseMirror = false;\r\n    const plugins = rules.map(rule => {\r\n        return new Plugin({\r\n            // we register a global drag handler to track the current drag source element\r\n            view(view) {\r\n                const handleDragstart = (event) => {\r\n                    var _a;\r\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))\r\n                        ? view.dom.parentElement\r\n                        : null;\r\n                };\r\n                window.addEventListener('dragstart', handleDragstart);\r\n                return {\r\n                    destroy() {\r\n                        window.removeEventListener('dragstart', handleDragstart);\r\n                    },\r\n                };\r\n            },\r\n            props: {\r\n                handleDOMEvents: {\r\n                    drop: view => {\r\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\r\n                        return false;\r\n                    },\r\n                    paste: (view, event) => {\r\n                        var _a;\r\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\r\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\r\n                        return false;\r\n                    },\r\n                },\r\n            },\r\n            appendTransaction: (transactions, oldState, state) => {\r\n                const transaction = transactions[0];\r\n                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\r\n                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\r\n                if (!isPaste && !isDrop) {\r\n                    return;\r\n                }\r\n                // stop if there is no changed range\r\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\r\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\r\n                if (!isNumber(from) || !to || from === to.b) {\r\n                    return;\r\n                }\r\n                // build a chainable state\r\n                // so we can use a single transaction for all paste rules\r\n                const tr = state.tr;\r\n                const chainableState = createChainableState({\r\n                    state,\r\n                    transaction: tr,\r\n                });\r\n                const handler = run({\r\n                    editor,\r\n                    state: chainableState,\r\n                    from: Math.max(from - 1, 0),\r\n                    to: to.b,\r\n                    rule,\r\n                });\r\n                // stop if there are no changes\r\n                if (!handler || !tr.steps.length) {\r\n                    return;\r\n                }\r\n                return tr;\r\n            },\r\n        });\r\n    });\r\n    return plugins;\r\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\r\nfunction getAttributesFromExtensions(extensions) {\r\n    const extensionAttributes = [];\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\r\n    const defaultAttribute = {\r\n        default: null,\r\n        rendered: true,\r\n        renderHTML: null,\r\n        parseHTML: null,\r\n        keepOnSplit: true,\r\n    };\r\n    extensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\r\n        if (!addGlobalAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as GlobalAttributes`\r\n        const globalAttributes = addGlobalAttributes();\r\n        globalAttributes.forEach(globalAttribute => {\r\n            globalAttribute.types.forEach(type => {\r\n                Object\r\n                    .entries(globalAttribute.attributes)\r\n                    .forEach(([name, attribute]) => {\r\n                    extensionAttributes.push({\r\n                        type,\r\n                        name,\r\n                        attribute: {\r\n                            ...defaultAttribute,\r\n                            ...attribute,\r\n                        },\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    });\r\n    nodeAndMarkExtensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addAttributes = getExtensionField(extension, 'addAttributes', context);\r\n        if (!addAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as Attributes`\r\n        const attributes = addAttributes();\r\n        Object\r\n            .entries(attributes)\r\n            .forEach(([name, attribute]) => {\r\n            extensionAttributes.push({\r\n                type: extension.name,\r\n                name,\r\n                attribute: {\r\n                    ...defaultAttribute,\r\n                    ...attribute,\r\n                },\r\n            });\r\n        });\r\n    });\r\n    return extensionAttributes;\r\n}\n\nfunction mergeAttributes(...objects) {\r\n    return objects\r\n        .filter(item => !!item)\r\n        .reduce((items, item) => {\r\n        const mergedAttributes = { ...items };\r\n        Object.entries(item).forEach(([key, value]) => {\r\n            const exists = mergedAttributes[key];\r\n            if (!exists) {\r\n                mergedAttributes[key] = value;\r\n                return;\r\n            }\r\n            if (key === 'class') {\r\n                mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\r\n            }\r\n            else if (key === 'style') {\r\n                mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\r\n            }\r\n            else {\r\n                mergedAttributes[key] = value;\r\n            }\r\n        });\r\n        return mergedAttributes;\r\n    }, {});\r\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\r\n    return extensionAttributes\r\n        .filter(item => item.attribute.rendered)\r\n        .map(item => {\r\n        if (!item.attribute.renderHTML) {\r\n            return {\r\n                [item.name]: nodeOrMark.attrs[item.name],\r\n            };\r\n        }\r\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\r\n    })\r\n        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\r\n}\n\nfunction isEmptyObject(value = {}) {\r\n    return Object.keys(value).length === 0 && value.constructor === Object;\r\n}\n\nfunction fromString(value) {\r\n    if (typeof value !== 'string') {\r\n        return value;\r\n    }\r\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\r\n        return Number(value);\r\n    }\r\n    if (value === 'true') {\r\n        return true;\r\n    }\r\n    if (value === 'false') {\r\n        return false;\r\n    }\r\n    return value;\r\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\r\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\r\n    if (parseRule.style) {\r\n        return parseRule;\r\n    }\r\n    return {\r\n        ...parseRule,\r\n        getAttrs: node => {\r\n            const oldAttributes = parseRule.getAttrs\r\n                ? parseRule.getAttrs(node)\r\n                : parseRule.attrs;\r\n            if (oldAttributes === false) {\r\n                return false;\r\n            }\r\n            const newAttributes = extensionAttributes.reduce((items, item) => {\r\n                const value = item.attribute.parseHTML\r\n                    ? item.attribute.parseHTML(node)\r\n                    : fromString(node.getAttribute(item.name));\r\n                if (value === null || value === undefined) {\r\n                    return items;\r\n                }\r\n                return {\r\n                    ...items,\r\n                    [item.name]: value,\r\n                };\r\n            }, {});\r\n            return { ...oldAttributes, ...newAttributes };\r\n        },\r\n    };\r\n}\n\nfunction cleanUpSchemaItem(data) {\r\n    return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\r\n        if (key === 'attrs' && isEmptyObject(value)) {\r\n            return false;\r\n        }\r\n        return value !== null && value !== undefined;\r\n    }));\r\n}\r\nfunction getSchemaByResolvedExtensions(extensions) {\r\n    var _a;\r\n    const allAttributes = getAttributesFromExtensions(extensions);\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\r\n    const nodes = Object.fromEntries(nodeExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const extraNodeFields = extensions.reduce((fields, e) => {\r\n            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraNodeFields,\r\n            content: callOrReturn(getExtensionField(extension, 'content', context)),\r\n            marks: callOrReturn(getExtensionField(extension, 'marks', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            inline: callOrReturn(getExtensionField(extension, 'inline', context)),\r\n            atom: callOrReturn(getExtensionField(extension, 'atom', context)),\r\n            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\r\n            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            defining: callOrReturn(getExtensionField(extension, 'defining', context)),\r\n            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML\r\n                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = node => renderHTML({\r\n                node,\r\n                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\r\n            });\r\n        }\r\n        const renderText = getExtensionField(extension, 'renderText', context);\r\n        if (renderText) {\r\n            schema.toText = renderText;\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    const marks = Object.fromEntries(markExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const extraMarkFields = extensions.reduce((fields, e) => {\r\n            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraMarkFields,\r\n            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\r\n            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML\r\n                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = mark => renderHTML({\r\n                mark,\r\n                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\r\n            });\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    return new Schema({\r\n        topNode,\r\n        nodes,\r\n        marks,\r\n    });\r\n}\n\nfunction getSchemaTypeByName(name, schema) {\r\n    return schema.nodes[name] || schema.marks[name] || null;\r\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\r\n    if (Array.isArray(enabled)) {\r\n        return enabled.some(enabledExtension => {\r\n            const name = typeof enabledExtension === 'string'\r\n                ? enabledExtension\r\n                : enabledExtension.name;\r\n            return name === extension.name;\r\n        });\r\n    }\r\n    return enabled;\r\n}\n\nfunction findDuplicates(items) {\r\n    const filtered = items.filter((el, index) => items.indexOf(el) !== index);\r\n    return [...new Set(filtered)];\r\n}\n\nclass ExtensionManager {\r\n    constructor(extensions, editor) {\r\n        this.splittableMarks = [];\r\n        this.editor = editor;\r\n        this.extensions = ExtensionManager.resolve(extensions);\r\n        this.schema = getSchemaByResolvedExtensions(this.extensions);\r\n        this.extensions.forEach(extension => {\r\n            var _a;\r\n            // store extension storage in editor\r\n            this.editor.extensionStorage[extension.name] = extension.storage;\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            if (extension.type === 'mark') {\r\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\r\n                if (keepOnSplit) {\r\n                    this.splittableMarks.push(extension.name);\r\n                }\r\n            }\r\n            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\r\n            if (onBeforeCreate) {\r\n                this.editor.on('beforeCreate', onBeforeCreate);\r\n            }\r\n            const onCreate = getExtensionField(extension, 'onCreate', context);\r\n            if (onCreate) {\r\n                this.editor.on('create', onCreate);\r\n            }\r\n            const onUpdate = getExtensionField(extension, 'onUpdate', context);\r\n            if (onUpdate) {\r\n                this.editor.on('update', onUpdate);\r\n            }\r\n            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\r\n            if (onSelectionUpdate) {\r\n                this.editor.on('selectionUpdate', onSelectionUpdate);\r\n            }\r\n            const onTransaction = getExtensionField(extension, 'onTransaction', context);\r\n            if (onTransaction) {\r\n                this.editor.on('transaction', onTransaction);\r\n            }\r\n            const onFocus = getExtensionField(extension, 'onFocus', context);\r\n            if (onFocus) {\r\n                this.editor.on('focus', onFocus);\r\n            }\r\n            const onBlur = getExtensionField(extension, 'onBlur', context);\r\n            if (onBlur) {\r\n                this.editor.on('blur', onBlur);\r\n            }\r\n            const onDestroy = getExtensionField(extension, 'onDestroy', context);\r\n            if (onDestroy) {\r\n                this.editor.on('destroy', onDestroy);\r\n            }\r\n        });\r\n    }\r\n    static resolve(extensions) {\r\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\r\n        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\r\n        if (duplicatedNames.length) {\r\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\r\n        }\r\n        return resolvedExtensions;\r\n    }\r\n    static flatten(extensions) {\r\n        return extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n            };\r\n            const addExtensions = getExtensionField(extension, 'addExtensions', context);\r\n            if (addExtensions) {\r\n                return [\r\n                    extension,\r\n                    ...this.flatten(addExtensions()),\r\n                ];\r\n            }\r\n            return extension;\r\n        })\r\n            // `Infinity` will break TypeScript so we set a number that is probably high enough\r\n            .flat(10);\r\n    }\r\n    static sort(extensions) {\r\n        const defaultPriority = 100;\r\n        return extensions.sort((a, b) => {\r\n            const priorityA = getExtensionField(a, 'priority') || defaultPriority;\r\n            const priorityB = getExtensionField(b, 'priority') || defaultPriority;\r\n            if (priorityA > priorityB) {\r\n                return -1;\r\n            }\r\n            if (priorityA < priorityB) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n    get commands() {\r\n        return this.extensions.reduce((commands, extension) => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const addCommands = getExtensionField(extension, 'addCommands', context);\r\n            if (!addCommands) {\r\n                return commands;\r\n            }\r\n            return {\r\n                ...commands,\r\n                ...addCommands(),\r\n            };\r\n        }, {});\r\n    }\r\n    get plugins() {\r\n        const { editor } = this;\r\n        // With ProseMirror, first plugins within an array are executed first.\r\n        // In tiptap, we provide the ability to override plugins,\r\n        // so it feels more natural to run plugins at the end of an array first.\r\n        // That’s why we have to reverse the `extensions` array and sort again\r\n        // based on the `priority` option.\r\n        const extensions = ExtensionManager.sort([...this.extensions].reverse());\r\n        const inputRules = [];\r\n        const pasteRules = [];\r\n        const allPlugins = extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const plugins = [];\r\n            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\r\n            if (addKeyboardShortcuts) {\r\n                const bindings = Object.fromEntries(Object\r\n                    .entries(addKeyboardShortcuts())\r\n                    .map(([shortcut, method]) => {\r\n                    return [shortcut, () => method({ editor })];\r\n                }));\r\n                const keyMapPlugin = keymap(bindings);\r\n                plugins.push(keyMapPlugin);\r\n            }\r\n            const addInputRules = getExtensionField(extension, 'addInputRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\r\n                inputRules.push(...addInputRules());\r\n            }\r\n            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\r\n                pasteRules.push(...addPasteRules());\r\n            }\r\n            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\r\n            if (addProseMirrorPlugins) {\r\n                const proseMirrorPlugins = addProseMirrorPlugins();\r\n                plugins.push(...proseMirrorPlugins);\r\n            }\r\n            return plugins;\r\n        })\r\n            .flat();\r\n        return [\r\n            inputRulesPlugin({\r\n                editor,\r\n                rules: inputRules,\r\n            }),\r\n            ...pasteRulesPlugin({\r\n                editor,\r\n                rules: pasteRules,\r\n            }),\r\n            ...allPlugins,\r\n        ];\r\n    }\r\n    get attributes() {\r\n        return getAttributesFromExtensions(this.extensions);\r\n    }\r\n    get nodeViews() {\r\n        const { editor } = this;\r\n        const { nodeExtensions } = splitExtensions(this.extensions);\r\n        return Object.fromEntries(nodeExtensions\r\n            .filter(extension => !!getExtensionField(extension, 'addNodeView'))\r\n            .map(extension => {\r\n            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getNodeType(extension.name, this.schema),\r\n            };\r\n            const addNodeView = getExtensionField(extension, 'addNodeView', context);\r\n            if (!addNodeView) {\r\n                return [];\r\n            }\r\n            const nodeview = (node, view, getPos, decorations) => {\r\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\r\n                return addNodeView()({\r\n                    editor,\r\n                    node,\r\n                    getPos,\r\n                    decorations,\r\n                    HTMLAttributes,\r\n                    extension,\r\n                });\r\n            };\r\n            return [extension.name, nodeview];\r\n        }));\r\n    }\r\n}\n\nclass EventEmitter {\r\n    constructor() {\r\n        this.callbacks = {};\r\n    }\r\n    on(event, fn) {\r\n        if (!this.callbacks[event]) {\r\n            this.callbacks[event] = [];\r\n        }\r\n        this.callbacks[event].push(fn);\r\n        return this;\r\n    }\r\n    emit(event, ...args) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            callbacks.forEach(callback => callback.apply(this, args));\r\n        }\r\n        return this;\r\n    }\r\n    off(event, fn) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            if (fn) {\r\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\r\n            }\r\n            else {\r\n                delete this.callbacks[event];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    removeAllListeners() {\r\n        this.callbacks = {};\r\n    }\r\n}\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nclass Editor extends EventEmitter {\r\n    constructor(options = {}) {\r\n        super();\r\n        this.isFocused = false;\r\n        this.extensionStorage = {};\r\n        this.options = {\r\n            element: document.createElement('div'),\r\n            content: '',\r\n            injectCSS: true,\r\n            extensions: [],\r\n            autofocus: false,\r\n            editable: true,\r\n            editorProps: {},\r\n            parseOptions: {},\r\n            enableInputRules: true,\r\n            enablePasteRules: true,\r\n            enableCoreExtensions: true,\r\n            onBeforeCreate: () => null,\r\n            onCreate: () => null,\r\n            onUpdate: () => null,\r\n            onSelectionUpdate: () => null,\r\n            onTransaction: () => null,\r\n            onFocus: () => null,\r\n            onBlur: () => null,\r\n            onDestroy: () => null,\r\n        };\r\n        this.isCapturingTransaction = false;\r\n        this.capturedTransaction = null;\r\n        this.setOptions(options);\r\n        this.createExtensionManager();\r\n        this.createCommandManager();\r\n        this.createSchema();\r\n        this.on('beforeCreate', this.options.onBeforeCreate);\r\n        this.emit('beforeCreate', { editor: this });\r\n        this.createView();\r\n        this.injectCSS();\r\n        this.on('create', this.options.onCreate);\r\n        this.on('update', this.options.onUpdate);\r\n        this.on('selectionUpdate', this.options.onSelectionUpdate);\r\n        this.on('transaction', this.options.onTransaction);\r\n        this.on('focus', this.options.onFocus);\r\n        this.on('blur', this.options.onBlur);\r\n        this.on('destroy', this.options.onDestroy);\r\n        window.setTimeout(() => {\r\n            if (this.isDestroyed) {\r\n                return;\r\n            }\r\n            this.commands.focus(this.options.autofocus);\r\n            this.emit('create', { editor: this });\r\n        }, 0);\r\n    }\r\n    /**\r\n     * Returns the editor storage.\r\n     */\r\n    get storage() {\r\n        return this.extensionStorage;\r\n    }\r\n    /**\r\n     * An object of all registered commands.\r\n     */\r\n    get commands() {\r\n        return this.commandManager.commands;\r\n    }\r\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */\r\n    chain() {\r\n        return this.commandManager.chain();\r\n    }\r\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */\r\n    can() {\r\n        return this.commandManager.can();\r\n    }\r\n    /**\r\n     * Inject CSS styles.\r\n     */\r\n    injectCSS() {\r\n        if (this.options.injectCSS && document) {\r\n            this.css = createStyleTag(style);\r\n        }\r\n    }\r\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */\r\n    setOptions(options = {}) {\r\n        this.options = {\r\n            ...this.options,\r\n            ...options,\r\n        };\r\n        if (!this.view || !this.state || this.isDestroyed) {\r\n            return;\r\n        }\r\n        if (this.options.editorProps) {\r\n            this.view.setProps(this.options.editorProps);\r\n        }\r\n        this.view.updateState(this.state);\r\n    }\r\n    /**\r\n     * Update editable state of the editor.\r\n     */\r\n    setEditable(editable) {\r\n        this.setOptions({ editable });\r\n    }\r\n    /**\r\n     * Returns whether the editor is editable.\r\n     */\r\n    get isEditable() {\r\n        // since plugins are applied after creating the view\r\n        // `editable` is always `true` for one tick.\r\n        // that’s why we also have to check for `options.editable`\r\n        return this.options.editable\r\n            && this.view\r\n            && this.view.editable;\r\n    }\r\n    /**\r\n     * Returns the editor state.\r\n     */\r\n    get state() {\r\n        return this.view.state;\r\n    }\r\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */\r\n    registerPlugin(plugin, handlePlugins) {\r\n        const plugins = isFunction(handlePlugins)\r\n            ? handlePlugins(plugin, this.state.plugins)\r\n            : [...this.state.plugins, plugin];\r\n        const state = this.state.reconfigure({ plugins });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param nameOrPluginKey The plugins name\r\n     */\r\n    unregisterPlugin(nameOrPluginKey) {\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n        const name = typeof nameOrPluginKey === 'string'\r\n            ? `${nameOrPluginKey}$`\r\n            // @ts-ignore\r\n            : nameOrPluginKey.key;\r\n        const state = this.state.reconfigure({\r\n            // @ts-ignore\r\n            plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\r\n        });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Creates an extension manager.\r\n     */\r\n    createExtensionManager() {\r\n        const coreExtensions = this.options.enableCoreExtensions\r\n            ? Object.values(extensions)\r\n            : [];\r\n        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\r\n            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\r\n        });\r\n        this.extensionManager = new ExtensionManager(allExtensions, this);\r\n    }\r\n    /**\r\n     * Creates an command manager.\r\n     */\r\n    createCommandManager() {\r\n        this.commandManager = new CommandManager({\r\n            editor: this,\r\n        });\r\n    }\r\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */\r\n    createSchema() {\r\n        this.schema = this.extensionManager.schema;\r\n    }\r\n    /**\r\n     * Creates a ProseMirror view.\r\n     */\r\n    createView() {\r\n        const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\r\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\r\n        this.view = new EditorView(this.options.element, {\r\n            ...this.options.editorProps,\r\n            dispatchTransaction: this.dispatchTransaction.bind(this),\r\n            state: EditorState.create({\r\n                doc,\r\n                selection,\r\n            }),\r\n        });\r\n        // `editor.view` is not yet available at this time.\r\n        // Therefore we will add all plugins and node views directly afterwards.\r\n        const newState = this.state.reconfigure({\r\n            plugins: this.extensionManager.plugins,\r\n        });\r\n        this.view.updateState(newState);\r\n        this.createNodeViews();\r\n        // Let’s store the editor instance in the DOM element.\r\n        // So we’ll have access to it for tests.\r\n        const dom = this.view.dom;\r\n        dom.editor = this;\r\n    }\r\n    /**\r\n     * Creates all node views.\r\n     */\r\n    createNodeViews() {\r\n        this.view.setProps({\r\n            nodeViews: this.extensionManager.nodeViews,\r\n        });\r\n    }\r\n    captureTransaction(fn) {\r\n        this.isCapturingTransaction = true;\r\n        fn();\r\n        this.isCapturingTransaction = false;\r\n        const tr = this.capturedTransaction;\r\n        this.capturedTransaction = null;\r\n        return tr;\r\n    }\r\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */\r\n    dispatchTransaction(transaction) {\r\n        if (this.isCapturingTransaction) {\r\n            if (!this.capturedTransaction) {\r\n                this.capturedTransaction = transaction;\r\n                return;\r\n            }\r\n            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });\r\n            return;\r\n        }\r\n        const state = this.state.apply(transaction);\r\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\r\n        this.view.updateState(state);\r\n        this.emit('transaction', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n        if (selectionHasChanged) {\r\n            this.emit('selectionUpdate', {\r\n                editor: this,\r\n                transaction,\r\n            });\r\n        }\r\n        const focus = transaction.getMeta('focus');\r\n        const blur = transaction.getMeta('blur');\r\n        if (focus) {\r\n            this.emit('focus', {\r\n                editor: this,\r\n                event: focus.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (blur) {\r\n            this.emit('blur', {\r\n                editor: this,\r\n                event: blur.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\r\n            return;\r\n        }\r\n        this.emit('update', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n    }\r\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */\r\n    getAttributes(nameOrType) {\r\n        return getAttributes(this.state, nameOrType);\r\n    }\r\n    isActive(nameOrAttributes, attributesOrUndefined) {\r\n        const name = typeof nameOrAttributes === 'string'\r\n            ? nameOrAttributes\r\n            : null;\r\n        const attributes = typeof nameOrAttributes === 'string'\r\n            ? attributesOrUndefined\r\n            : nameOrAttributes;\r\n        return isActive(this.state, name, attributes);\r\n    }\r\n    /**\r\n     * Get the document as JSON.\r\n     */\r\n    getJSON() {\r\n        return this.state.doc.toJSON();\r\n    }\r\n    /**\r\n     * Get the document as HTML.\r\n     */\r\n    getHTML() {\r\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\r\n    }\r\n    /**\r\n     * Get the document as text.\r\n     */\r\n    getText(options) {\r\n        const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n        return getText(this.state.doc, {\r\n            blockSeparator,\r\n            textSerializers: {\r\n                ...textSerializers,\r\n                ...getTextSeralizersFromSchema(this.schema),\r\n            },\r\n        });\r\n    }\r\n    /**\r\n     * Check if there is no content.\r\n     */\r\n    get isEmpty() {\r\n        return isNodeEmpty(this.state.doc);\r\n    }\r\n    /**\r\n     * Get the number of characters for the current document.\r\n     *\r\n     * @deprecated\r\n     */\r\n    getCharacterCount() {\r\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\r\n        return this.state.doc.content.size - 2;\r\n    }\r\n    /**\r\n     * Destroy the editor.\r\n     */\r\n    destroy() {\r\n        this.emit('destroy');\r\n        if (this.view) {\r\n            this.view.destroy();\r\n        }\r\n        this.removeAllListeners();\r\n    }\r\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */\r\n    get isDestroyed() {\r\n        var _a;\r\n        // @ts-ignore\r\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\r\n    }\r\n}\n\nclass Node {\r\n    constructor(config = {}) {\r\n        this.type = 'node';\r\n        this.name = 'node';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Node(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Node(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nclass Mark {\r\n    constructor(config = {}) {\r\n        this.type = 'mark';\r\n        this.name = 'mark';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Mark(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Mark(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name\r\n            ? extendedConfig.name\r\n            : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nclass NodeView {\r\n    constructor(component, props, options) {\r\n        this.isDragging = false;\r\n        this.component = component;\r\n        this.editor = props.editor;\r\n        this.options = {\r\n            stopEvent: null,\r\n            ignoreMutation: null,\r\n            ...options,\r\n        };\r\n        this.extension = props.extension;\r\n        this.node = props.node;\r\n        this.decorations = props.decorations;\r\n        this.getPos = props.getPos;\r\n        this.mount();\r\n    }\r\n    mount() {\r\n        // eslint-disable-next-line\r\n        return;\r\n    }\r\n    get dom() {\r\n        return null;\r\n    }\r\n    get contentDOM() {\r\n        return null;\r\n    }\r\n    onDragStart(event) {\r\n        var _a, _b, _c;\r\n        const { view } = this.editor;\r\n        const target = event.target;\r\n        // get the drag handle element\r\n        // `closest` is not available for text nodes so we may have to use its parent\r\n        const dragHandle = target.nodeType === 3\r\n            ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')\r\n            : target.closest('[data-drag-handle]');\r\n        if (!this.dom\r\n            || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target))\r\n            || !dragHandle) {\r\n            return;\r\n        }\r\n        let x = 0;\r\n        let y = 0;\r\n        // calculate offset for drag element if we use a different drag handle element\r\n        if (this.dom !== dragHandle) {\r\n            const domBox = this.dom.getBoundingClientRect();\r\n            const handleBox = dragHandle.getBoundingClientRect();\r\n            x = handleBox.x - domBox.x + event.offsetX;\r\n            y = handleBox.y - domBox.y + event.offsetY;\r\n        }\r\n        (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y);\r\n        // we need to tell ProseMirror that we want to move the whole node\r\n        // so we create a NodeSelection\r\n        const selection = NodeSelection.create(view.state.doc, this.getPos());\r\n        const transaction = view.state.tr.setSelection(selection);\r\n        view.dispatch(transaction);\r\n    }\r\n    stopEvent(event) {\r\n        var _a;\r\n        if (!this.dom) {\r\n            return false;\r\n        }\r\n        if (typeof this.options.stopEvent === 'function') {\r\n            return this.options.stopEvent({ event });\r\n        }\r\n        const target = event.target;\r\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\r\n        // any event from child nodes should be handled by ProseMirror\r\n        if (!isInElement) {\r\n            return false;\r\n        }\r\n        const isDropEvent = event.type === 'drop';\r\n        const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)\r\n            || target.isContentEditable;\r\n        // any input event within node views should be ignored by ProseMirror\r\n        if (isInput && !isDropEvent) {\r\n            return true;\r\n        }\r\n        const { isEditable } = this.editor;\r\n        const { isDragging } = this;\r\n        const isDraggable = !!this.node.type.spec.draggable;\r\n        const isSelectable = NodeSelection.isSelectable(this.node);\r\n        const isCopyEvent = event.type === 'copy';\r\n        const isPasteEvent = event.type === 'paste';\r\n        const isCutEvent = event.type === 'cut';\r\n        const isClickEvent = event.type === 'mousedown';\r\n        const isDragEvent = event.type.startsWith('drag');\r\n        // ProseMirror tries to drag selectable nodes\r\n        // even if `draggable` is set to `false`\r\n        // this fix prevents that\r\n        if (!isDraggable && isSelectable && isDragEvent) {\r\n            event.preventDefault();\r\n        }\r\n        if (isDraggable && isDragEvent && !isDragging) {\r\n            event.preventDefault();\r\n            return false;\r\n        }\r\n        // we have to store that dragging started\r\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\r\n            const dragHandle = target.closest('[data-drag-handle]');\r\n            const isValidDragHandle = dragHandle\r\n                && (this.dom === dragHandle || (this.dom.contains(dragHandle)));\r\n            if (isValidDragHandle) {\r\n                this.isDragging = true;\r\n                document.addEventListener('dragend', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n                document.addEventListener('mouseup', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n            }\r\n        }\r\n        // these events are handled by prosemirror\r\n        if (isDragging\r\n            || isDropEvent\r\n            || isCopyEvent\r\n            || isPasteEvent\r\n            || isCutEvent\r\n            || (isClickEvent && isSelectable)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        if (!this.dom || !this.contentDOM) {\r\n            return true;\r\n        }\r\n        if (typeof this.options.ignoreMutation === 'function') {\r\n            return this.options.ignoreMutation({ mutation });\r\n        }\r\n        // a leaf/atom node is like a black box for ProseMirror\r\n        // and should be fully handled by the node view\r\n        if (this.node.isLeaf || this.node.isAtom) {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any selections\r\n        if (mutation.type === 'selection') {\r\n            return false;\r\n        }\r\n        // try to prevent a bug on iOS that will break node views on enter\r\n        // this is because ProseMirror can’t preventDispatch on enter\r\n        // this will lead to a re-render of the node view on enter\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\r\n        if (this.dom.contains(mutation.target)\r\n            && mutation.type === 'childList'\r\n            && isiOS()\r\n            && this.editor.isFocused) {\r\n            const changedNodes = [\r\n                ...Array.from(mutation.addedNodes),\r\n                ...Array.from(mutation.removedNodes),\r\n            ];\r\n            // we’ll check if every changed node is contentEditable\r\n            // to make sure it’s probably mutated by ProseMirror\r\n            if (changedNodes.every(node => node.isContentEditable)) {\r\n                return false;\r\n            }\r\n        }\r\n        // we will allow mutation contentDOM with attributes\r\n        // so we can for example adding classes within our node view\r\n        if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any changes within contentDOM\r\n        if (this.contentDOM.contains(mutation.target)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    updateAttributes(attributes) {\r\n        this.editor.commands.command(({ tr }) => {\r\n            const pos = this.getPos();\r\n            tr.setNodeMarkup(pos, undefined, {\r\n                ...this.node.attrs,\r\n                ...attributes,\r\n            });\r\n            return true;\r\n        });\r\n    }\r\n    deleteNode() {\r\n        const from = this.getPos();\r\n        const to = from + this.node.nodeSize;\r\n        this.editor.commands.deleteRange({ from, to });\r\n    }\r\n}\n\nclass Tracker {\r\n    constructor(transaction) {\r\n        this.transaction = transaction;\r\n        this.currentStep = this.transaction.steps.length;\r\n    }\r\n    map(position) {\r\n        let deleted = false;\r\n        const mappedPosition = this.transaction.steps\r\n            .slice(this.currentStep)\r\n            .reduce((newPosition, step) => {\r\n            const mapResult = step\r\n                .getMap()\r\n                .mapResult(newPosition);\r\n            if (mapResult.deleted) {\r\n                deleted = true;\r\n            }\r\n            return mapResult.pos;\r\n        }, position);\r\n        return {\r\n            position: mappedPosition,\r\n            deleted,\r\n        };\r\n    }\r\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\r\nfunction nodeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const { tr } = state;\r\n            const start = range.from;\r\n            let end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                let matchStart = start + offset;\r\n                if (matchStart > end) {\r\n                    matchStart = end;\r\n                }\r\n                else {\r\n                    end = matchStart + match[1].length;\r\n                }\r\n                // insert last typed character\r\n                const lastChar = match[0][match[0].length - 1];\r\n                tr.insertText(lastChar, start + match[0].length - 1);\r\n                // insert node from input rule\r\n                tr.replaceWith(matchStart, end, config.type.create(attributes));\r\n            }\r\n            else if (match[0]) {\r\n                tr.replaceWith(start, end, config.type.create(attributes));\r\n            }\r\n        },\r\n    });\r\n}\n\nfunction getMarksBetween(from, to, doc) {\r\n    const marks = [];\r\n    // get all inclusive marks on empty selection\r\n    if (from === to) {\r\n        doc\r\n            .resolve(from)\r\n            .marks()\r\n            .forEach(mark => {\r\n            const $pos = doc.resolve(from - 1);\r\n            const range = getMarkRange($pos, mark.type);\r\n            if (!range) {\r\n                return;\r\n            }\r\n            marks.push({\r\n                mark,\r\n                ...range,\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        doc.nodesBetween(from, to, (node, pos) => {\r\n            marks.push(...node.marks.map(mark => ({\r\n                from: pos,\r\n                to: pos + node.nodeSize,\r\n                mark,\r\n            })));\r\n        });\r\n    }\r\n    return marks;\r\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\r\nfunction markInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            let markEnd = range.to;\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\r\nfunction textblockTypeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const $start = state.doc.resolve(range.from);\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\r\n                return null;\r\n            }\r\n            state.tr\r\n                .delete(range.from, range.to)\r\n                .setBlockType(range.from, range.from, config.type, attributes);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\r\nfunction textInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\r\nfunction wrappingInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const tr = state.tr.delete(range.from, range.to);\r\n            const $start = tr.doc.resolve(range.from);\r\n            const blockRange = $start.blockRange();\r\n            const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\r\n            if (!wrapping) {\r\n                return null;\r\n            }\r\n            tr.wrap(blockRange, wrapping);\r\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\r\n            if (before\r\n                && before.type === config.type\r\n                && canJoin(tr.doc, range.from - 1)\r\n                && (!config.joinPredicate || config.joinPredicate(match, before))) {\r\n                tr.join(range.from - 1);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\r\nfunction markPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            let markEnd = range.to;\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\r\nfunction textPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\n// source: https://stackoverflow.com/a/6969486\r\nfunction escapeForRegEx(string) {\r\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\r\nfunction combineTransactionSteps(oldDoc, transactions) {\r\n    const transform = new Transform(oldDoc);\r\n    transactions.forEach(transaction => {\r\n        transaction.steps.forEach(step => {\r\n            transform.step(step);\r\n        });\r\n    });\r\n    return transform;\r\n}\n\nfunction defaultBlockAt(match) {\r\n    for (let i = 0; i < match.edgeCount; i += 1) {\r\n        const { type } = match.edge(i);\r\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}\n\nfunction findChildren(node, predicate) {\r\n    const nodesWithPos = [];\r\n    node.descendants((child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\r\nfunction findChildrenInRange(node, range, predicate) {\r\n    const nodesWithPos = [];\r\n    // if (range.from === range.to) {\r\n    //   const nodeAt = node.nodeAt(range.from)\r\n    //   if (nodeAt) {\r\n    //     nodesWithPos.push({\r\n    //       node: nodeAt,\r\n    //       pos: range.from,\r\n    //     })\r\n    //   }\r\n    // }\r\n    node.nodesBetween(range.from, range.to, (child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\nfunction getSchema(extensions) {\r\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\r\n    return getSchemaByResolvedExtensions(resolvedExtensions);\r\n}\n\nfunction generateHTML(doc, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const contentNode = Node$1.fromJSON(schema, doc);\r\n    return getHTMLFromFragment(contentNode.content, schema);\r\n}\n\nfunction generateJSON(html, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const dom = elementFromString(html);\r\n    return DOMParser.fromSchema(schema)\r\n        .parse(dom)\r\n        .toJSON();\r\n}\n\nfunction generateText(doc, extensions, options) {\r\n    const { blockSeparator = '\\n\\n', textSerializers = {}, } = options || {};\r\n    const schema = getSchema(extensions);\r\n    const contentNode = Node$1.fromJSON(schema, doc);\r\n    return getText(contentNode, {\r\n        blockSeparator,\r\n        textSerializers: {\r\n            ...textSerializers,\r\n            ...getTextSeralizersFromSchema(schema),\r\n        },\r\n    });\r\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\r\nfunction removeDuplicates(array, by = JSON.stringify) {\r\n    const seen = {};\r\n    return array.filter(item => {\r\n        const key = by(item);\r\n        return Object.prototype.hasOwnProperty.call(seen, key)\r\n            ? false\r\n            : (seen[key] = true);\r\n    });\r\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\r\nfunction simplifyChangedRanges(changes) {\r\n    const uniqueChanges = removeDuplicates(changes);\r\n    return uniqueChanges.length === 1\r\n        ? uniqueChanges\r\n        : uniqueChanges.filter((change, index) => {\r\n            const rest = uniqueChanges.filter((_, i) => i !== index);\r\n            return !rest.some(otherChange => {\r\n                return change.oldRange.from >= otherChange.oldRange.from\r\n                    && change.oldRange.to <= otherChange.oldRange.to\r\n                    && change.newRange.from >= otherChange.newRange.from\r\n                    && change.newRange.to <= otherChange.newRange.to;\r\n            });\r\n        });\r\n}\r\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\r\nfunction getChangedRanges(transform) {\r\n    const { mapping, steps } = transform;\r\n    const changes = [];\r\n    mapping.maps.forEach((stepMap, index) => {\r\n        const ranges = [];\r\n        // This accounts for step changes where no range was actually altered\r\n        // e.g. when setting a mark, node attribute, etc.\r\n        // @ts-ignore\r\n        if (!stepMap.ranges.length) {\r\n            const { from, to } = steps[index];\r\n            if (from === undefined || to === undefined) {\r\n                return;\r\n            }\r\n            ranges.push({ from, to });\r\n        }\r\n        else {\r\n            stepMap.forEach((from, to) => {\r\n                ranges.push({ from, to });\r\n            });\r\n        }\r\n        ranges.forEach(({ from, to }) => {\r\n            const newStart = mapping.slice(index).map(from, -1);\r\n            const newEnd = mapping.slice(index).map(to);\r\n            const oldStart = mapping.invert().map(newStart, -1);\r\n            const oldEnd = mapping.invert().map(newEnd);\r\n            changes.push({\r\n                oldRange: {\r\n                    from: oldStart,\r\n                    to: oldEnd,\r\n                },\r\n                newRange: {\r\n                    from: newStart,\r\n                    to: newEnd,\r\n                },\r\n            });\r\n        });\r\n    });\r\n    return simplifyChangedRanges(changes);\r\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\r\n    const isTopNode = node.type === node.type.schema.topNodeType;\r\n    const increment = isTopNode ? 0 : 1;\r\n    const from = startOffset;\r\n    const to = from + node.nodeSize;\r\n    const marks = node.marks.map(mark => {\r\n        const output = {\r\n            type: mark.type.name,\r\n        };\r\n        if (Object.keys(mark.attrs).length) {\r\n            output.attrs = { ...mark.attrs };\r\n        }\r\n        return output;\r\n    });\r\n    const attrs = { ...node.attrs };\r\n    const output = {\r\n        type: node.type.name,\r\n        from,\r\n        to,\r\n    };\r\n    if (Object.keys(attrs).length) {\r\n        output.attrs = attrs;\r\n    }\r\n    if (marks.length) {\r\n        output.marks = marks;\r\n    }\r\n    if (node.content.childCount) {\r\n        output.content = [];\r\n        node.forEach((child, offset) => {\r\n            var _a;\r\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\r\n        });\r\n    }\r\n    if (node.text) {\r\n        output.text = node.text;\r\n    }\r\n    return output;\r\n}\n\nfunction isNodeSelection(value) {\r\n    return isObject(value) && value instanceof NodeSelection;\r\n}\n\nfunction posToDOMRect(view, from, to) {\r\n    const minPos = 0;\r\n    const maxPos = view.state.doc.content.size;\r\n    const resolvedFrom = minMax(from, minPos, maxPos);\r\n    const resolvedEnd = minMax(to, minPos, maxPos);\r\n    const start = view.coordsAtPos(resolvedFrom);\r\n    const end = view.coordsAtPos(resolvedEnd, -1);\r\n    const top = Math.min(start.top, end.top);\r\n    const bottom = Math.max(start.bottom, end.bottom);\r\n    const left = Math.min(start.left, end.left);\r\n    const right = Math.max(start.right, end.right);\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n    const x = left;\r\n    const y = top;\r\n    const data = {\r\n        top,\r\n        bottom,\r\n        left,\r\n        right,\r\n        width,\r\n        height,\r\n        x,\r\n        y,\r\n    };\r\n    return {\r\n        ...data,\r\n        toJSON: () => data,\r\n    };\r\n}\n\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, defaultBlockAt, escapeForRegEx, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, generateText, getAttributes, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getSchema, getText, getTextBetween, inputRulesPlugin, isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, pasteRulesPlugin, posToDOMRect, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };\n//# sourceMappingURL=tiptap-core.esm.js.map\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\n\n// declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n  if (result == \"Space\") { result = \" \"; }\n  var alt, ctrl, shift, meta;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { result = \"Alt-\" + result; }\n  if (ctrl) { result = \"Ctrl-\" + result; }\n  if (meta) { result = \"Meta-\" + result; }\n  if (shift) { result = \"Shift-\" + result; }\n  return result\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) { name = \"Alt-\" + name; }\n  if (event.ctrlKey) { name = \"Ctrl-\" + name; }\n  if (event.metaKey) { name = \"Meta-\" + name; }\n  if (shift !== false && event.shiftKey) { name = \"Shift-\" + name; }\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nfunction keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap)), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function(view, event) {\n    var name = keyName(event), isChar = name.length == 1 && name != \" \", baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n    if (direct && direct(view.state, view.dispatch, view)) { return true }\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      var fromCode = map[modifiers(baseName, event, true)];\n      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      var withShift = map[modifiers(name, event, true)];\n      if (withShift && withShift(view.state, view.dispatch, view)) { return true }\n    }\n    return false\n  }\n}\n\nexport { keydownHandler, keymap };\n//# sourceMappingURL=index.es.js.map\n","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node): leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                       (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this.eq(other)) { return set }\n    if (this.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (this.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = { size: { configurable: true } };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n};\n\n// :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$1 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\nprototypeAccessors$2.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$2.doc.get = function () { return this.node(0) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\nResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }\n  return pos\n};\n\n// :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n      { return new NodeRange(this, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );\n\nvar resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors$3.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted to separate text\n// from different block nodes. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node allows inline content.\nprototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors$3.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors$3.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  var copy = Mark.none;\n  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }\n  if (!Mark.sameSet(copy, this.marks))\n    { throw new RangeError((\"Invalid collection of marks for node \" + (this.type.name) + \": \" + (this.marks.map(function (m) { return m.type.name; })))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n  var obj = {type: this.type.name};\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$3 );\n\nvar TextNode = /*@__PURE__*/(function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this.next[i] == type) { return this.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i >= this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.shift(); }\n};\n\nvar prototypeAccessors$1$2 = { next: { configurable: true } };\n\nprototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true },whitespace: { configurable: true } };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$5.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\n// :: union<\"pre\", \"normal\">\n// The node type's [whitespace](#view.NodeSpec.whitespace) option.\nprototypeAccessors$5.whitespace.get = function () { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") };\n\n// :: () → bool\n// Tells you whether this node type has any required attributes.\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {\n  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$5 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = { isRequired: { configurable: true } };\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {\n    set = set.slice(0, i).concat(set.slice(i + 1));\n    i--;\n  } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this) { return set[i] } }\n};\n\n// :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n\n  // Only normalize list elements when lists in the schema can't directly contain themselves\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) { return false }\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node)\n  });\n};\n\n// :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema) → [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1();\n  return result\n};\n\n// :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) { return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0) }\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  // Marks applied to this node itself\n  this.marks = marks;\n  // Marks applied to its children\n  this.activeMarks = Mark.none;\n  // Marks that can't apply here, but will be used in children if possible\n  this.pendingMarks = pendingMarks;\n  // Nested Marks with same type\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--)\n    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }\n};\n\nNodeContext.prototype.applyPending = function applyPending (nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n        !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext (node) {\n  if (this.type) { return this.type.inlineContent }\n  if (this.content.length) { return this.content[0].isInline }\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if (top.options & OPT_PRESERVE_WS_FULL ||\n      top.inlineContext(dom) ||\n      /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(), ruleID;\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n      (ruleID = this.parser.matchTag(dom, this, matchAfter));\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }\n    else if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n};\n\n// Called for leaf DOM nodes that would otherwise be ignored\nParseContext.prototype.leafFallback = function leafFallback (dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n    { this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\")); }\n};\n\n// Called for ignored nodes\nParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n    { this.findPlace(this.parser.schema.text(\"-\")); }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n  var marks = Mark.none;\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n      if (!rule) { continue style }\n      if (rule.ignore) { return null }\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n      if (rule.consuming === false) { after = rule; }\n      else { break }\n    }\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark, startIn); }\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n    return true\n  }\n  return false\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) { this.enterInner(type, attrs, true, preserveWS); }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = wsOptionsFor(type, preserveWS, top.options);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {\n    this.open = i;\n    return\n  } }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == parent && this.find[i].offset == offset)\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n      { this.find[i].pos = this.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n      var pos = content.compareDocumentPosition(this.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this.find[i].pos = this.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this.find[i].node == textNode)\n      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }\n  } }\n};\n\n// : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n  if (found) { this.top.stashMarks.push(found); }\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n        { level.activeMarks = stashMark.addToSet(level.activeMarks); }\n    }\n    if (level == upto) { break }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var loop = function ( name ) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) { return }\n    var seen = [], scan = function (match) {\n      seen.push(match);\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n        if (type == nodeType) { return true }\n        if (seen.indexOf(next) < 0 && scan(next)) { return true }\n      }\n    };\n    if (scan(parent.contentMatch)) { return { v: true } }\n  };\n\n  for (var name in nodes) {\n    var returned = loop( name );\n\n    if ( returned ) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) { return set[i] }\n  }\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n\n  return target\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\n// :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNodeInner(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n(wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {\n    if ( xmlNS === void 0 ) xmlNS = null;\n\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  if (structure.dom && structure.dom.nodeType != null)\n    { return structure }\n  var tagName = structure[0], space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) { if (attrs[name] != null) {\n      var space$1 = name.indexOf(\" \");\n      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }\n      else { dom.setAttribute(name, attrs[name]); }\n    } }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };\n//# sourceMappingURL=index.es.js.map\n","import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nvar classesById = Object.create(null);\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nvar Selection = function Selection($anchor, $head, ranges) {\n  // :: [SelectionRange]\n  // The ranges covered by the selection.\n  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  // :: ResolvedPos\n  // The resolved anchor of the selection (the side that stays in\n  // place when the selection is modified).\n  this.$anchor = $anchor;\n  // :: ResolvedPos\n  // The resolved head of the selection (the side that moves when\n  // the selection is modified).\n  this.$head = $head;\n};\n\nvar prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };\n\n// :: number\n// The selection's anchor, as an unresolved position.\nprototypeAccessors.anchor.get = function () { return this.$anchor.pos };\n\n// :: number\n// The selection's head.\nprototypeAccessors.head.get = function () { return this.$head.pos };\n\n// :: number\n// The lower bound of the selection's main range.\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection's main range.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\n// :: ResolvedPos\n// The resolved lowerbound of the selection's main range.\nprototypeAccessors.$from.get = function () {\n  return this.ranges[0].$from\n};\n\n// :: ResolvedPos\n// The resolved upper bound of the selection's main range.\nprototypeAccessors.$to.get = function () {\n  return this.ranges[0].$to\n};\n\n// :: bool\n// Indicates whether the selection contains any content.\nprototypeAccessors.empty.get = function () {\n  var ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++)\n    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }\n  return true\n};\n\n// eq:: (Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document to which we are mapping.\n\n// :: () → Slice\n// Get the content of this selection as a slice.\nSelection.prototype.content = function content () {\n  return this.$from.node(0).slice(this.from, this.to, true)\n};\n\n// :: (Transaction, ?Slice)\n// Replace the selection with a slice or, if no slice is given,\n// delete the selection. Will append to the given transaction.\nSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n  // Put the new selection at the position after the inserted\n  // content. When that ended in an inline node, search backwards,\n  // to get the position after that node. If not, search forward.\n  var lastNode = content.content.lastChild, lastParent = null;\n  for (var i = 0; i < content.openEnd; i++) {\n    lastParent = lastNode;\n    lastNode = lastNode.lastChild;\n  }\n\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n    var ref = ranges[i$1];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content);\n    if (i$1 == 0)\n      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }\n  }\n};\n\n// :: (Transaction, Node)\n// Replace the selection with the given node, appending the changes\n// to the given transaction.\nSelection.prototype.replaceWith = function replaceWith (tr, node) {\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++) {\n    var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    var from = mapping.map($from.pos), to = mapping.map($to.pos);\n    if (i) {\n      tr.deleteRange(from, to);\n    } else {\n      tr.replaceRangeWith(from, to, node);\n      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n    }\n  }\n};\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation. When implementing\n// this for a custom selection class, make sure to give the object a\n// `type` property whose value matches the ID under which you\n// [registered](#state.Selection^jsonID) your class.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// positive. When `textOnly` is true, only consider cursor\n// selections. Will return null when no valid selection position is\n// found.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.inlineContent ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. Will return an\n// [`AllSelection`](#state.AllSelection) if no valid position\n// exists.\nSelection.atStart = function atStart (doc) {\n  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the end of the\n// given document.\nSelection.atEnd = function atEnd (doc) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n};\n\n// :: (Node, Object) → Selection\n// Deserialize the JSON representation of a selection. Must be\n// implemented for custom classes (as a static class method).\nSelection.fromJSON = function fromJSON (doc, json) {\n  if (!json || !json.type) { throw new RangeError(\"Invalid input for Selection.fromJSON\") }\n  var cls = classesById[json.type];\n  if (!cls) { throw new RangeError((\"No selection type \" + (json.type) + \" defined\")) }\n  return cls.fromJSON(doc, json)\n};\n\n// :: (string, constructor<Selection>)\n// To be able to deserialize selections from JSON, custom selection\n// classes must register themselves with an ID string, so that they\n// can be disambiguated. Try to pick something that's unlikely to\n// clash with classes from other modules.\nSelection.jsonID = function jsonID (id, selectionClass) {\n  if (id in classesById) { throw new RangeError(\"Duplicate use of selection JSON ID \" + id) }\n  classesById[id] = selectionClass;\n  selectionClass.prototype.jsonID = id;\n  return selectionClass\n};\n\n// :: () → SelectionBookmark\n// Get a [bookmark](#state.SelectionBookmark) for this selection,\n// which is a value that can be mapped without having access to a\n// current document, and later resolved to a real selection for a\n// given document again. (This is used mostly by the history to\n// track and restore old selections.) The default implementation of\n// this method just converts the selection to a text selection and\n// returns the bookmark for that.\nSelection.prototype.getBookmark = function getBookmark () {\n  return TextSelection.between(this.$anchor, this.$head).getBookmark()\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true;\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nvar SelectionRange = function SelectionRange($from, $to) {\n  // :: ResolvedPos\n  // The lower bound of the range.\n  this.$from = $from;\n  // :: ResolvedPos\n  // The upper bound of the range.\n  this.$to = $to;\n};\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nvar TextSelection = /*@__PURE__*/(function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    Selection.call(this, $anchor, $head);\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { $cursor: { configurable: true } };\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    Selection.prototype.replace.call(this, tr, content);\n    if (content == Slice.empty) {\n      var marks = this.$from.marksAcross(this.$to);\n      if (marks) { tr.ensureMarks(marks); }\n    }\n  };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  };\n\n  TextSelection.prototype.getBookmark = function getBookmark () {\n    return new TextBookmark(this.anchor, this.head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  };\n\n  TextSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      { throw new RangeError(\"Invalid input for TextSelection.fromJSON\") }\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  TextSelection.between = function between ($anchor, $head, bias) {\n    var dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }\n    if (!$head.parent.inlineContent) {\n      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) { $head = found.$head; }\n      else { return Selection.near($head, bias) }\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }\n      }\n    }\n    return new TextSelection($anchor, $head)\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function TextBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nTextBookmark.prototype.map = function map (mapping) {\n  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nTextBookmark.prototype.resolve = function resolve (doc) {\n  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n};\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nvar NodeSelection = /*@__PURE__*/(function (Selection) {\n  function NodeSelection($pos) {\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    Selection.call(this, $pos, $end);\n    // :: Node The selected node.\n    this.node = node;\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n    var $pos = doc.resolve(pos);\n    if (deleted) { return Selection.near($pos) }\n    return new NodeSelection($pos)\n  };\n\n  NodeSelection.prototype.content = function content () {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  };\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {type: \"node\", anchor: this.anchor}\n  };\n\n  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };\n\n  NodeSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\")\n      { throw new RangeError(\"Invalid input for NodeSelection.fromJSON\") }\n    return new NodeSelection(doc.resolve(json.anchor))\n  };\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\n\nNodeSelection.prototype.visible = false;\n\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function NodeBookmark(anchor) {\n  this.anchor = anchor;\n};\nNodeBookmark.prototype.map = function map (mapping) {\n  var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n};\nNodeBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }\n  return Selection.near($pos)\n};\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nvar AllSelection = /*@__PURE__*/(function (Selection) {\n  function AllSelection(doc) {\n    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  if ( Selection ) AllSelection.__proto__ = Selection;\n  AllSelection.prototype = Object.create( Selection && Selection.prototype );\n  AllSelection.prototype.constructor = AllSelection;\n\n  AllSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = Slice.empty;\n\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      var sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }\n    } else {\n      Selection.prototype.replace.call(this, tr, content);\n    }\n  };\n\n  AllSelection.prototype.toJSON = function toJSON () { return {type: \"all\"} };\n\n  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };\n\n  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };\n\n  return AllSelection;\n}(Selection));\n\nSelection.jsonID(\"all\", AllSelection);\n\nvar AllBookmark = {\n  map: function map() { return this },\n  resolve: function resolve(doc) { return new AllSelection(doc) }\n};\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) { return }\n  var step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) { return }\n  var map = tr.mapping.maps[last], end;\n  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nvar Transaction = /*@__PURE__*/(function (Transform) {\n  function Transaction(state) {\n    Transform.call(this, state.doc);\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n  }\n\n  if ( Transform ) Transaction.__proto__ = Transform;\n  Transaction.prototype = Object.create( Transform && Transform.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    if (selection.$from.doc != this.doc)\n      { throw new RangeError(\"Selection passed to setSelection must point at the current document\") }\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return (this.updated & UPDATED_SEL) > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this\n  };\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  Transaction.prototype.ensureMarks = function ensureMarks (marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      { this.setStoredMarks(marks); }\n    return this\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return (this.updated & UPDATED_MARKS) > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform.prototype.addStep.call(this, step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time;\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    this.selection.replace(this, slice);\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var selection = this.selection;\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none))); }\n    selection.replaceWith(this, node);\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    this.selection.replace(this);\n    return this\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var marks = this.storedMarks;\n      if (!marks) {\n        var $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }\n      return this\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  prototypeAccessors.isGeneric.get = function () {\n    for (var _ in this.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL;\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return (this.updated & UPDATED_SCROLL) > 0\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(Transform));\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init(config) { return config.storedMarks || null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n];\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1 = this;\n\n  this.schema = schema;\n  this.fields = baseFields.concat();\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1.plugins.push(plugin);\n    this$1.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state)\n      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }\n  }); }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nvar EditorState = function EditorState(config) {\n  this.config = config;\n};\n\nvar prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next input. Will be null when\n// no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors$1.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors$1.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → bool\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this.config.plugins[i];\n    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](#state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](#state.PluginSpec.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (rootTr) {\n  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }\n\n  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n   for (;;) {\n    var haveNew = false;\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this.config.plugins[i];\n      if (plugin.spec.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n        var tr = n < trs.length &&\n            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n        if (tr && newState.filterTransaction(tr, i)) {\n          tr.setMeta(\"appendedTransaction\", rootTr);\n          if (!seen) {\n            seen = [];\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }\n          }\n          trs.push(tr);\n          newState = newState.applyInner(tr);\n          haveNew = true;\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length}; }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields;\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors$1.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a new state.\n//\n// config::- Configuration options. Must contain `schema` or `doc` (or both).\n//\n//    schema:: ?Schema\n//    The schema to use (only relevant if no `doc` is specified).\n//\n//    doc:: ?Node\n//    The starting document.\n//\n//    selection:: ?Selection\n//    A valid selection in the document.\n//\n//    storedMarks:: ?[Mark]\n//    The initial set of [stored marks](#state.EditorState.storedMarks).\n//\n//    plugins:: ?[Plugin]\n//    The plugins that should be active in this state.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n  var instance = new EditorState($config);\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\n//\n// config::- configuration options\n//\n//   plugins:: [Plugin]\n//   New set of active plugins.\nEditorState.prototype.reconfigure = function reconfigure (config) {\n  var $config = new Configuration(this.schema, config.plugins);\n  var fields = $config.fields, instance = new EditorState($config);\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name;\n    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n  }\n  return instance\n};\n\n// :: (?union<Object<Plugin>, string, number>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects. The argument may also be\n// a string or number, in which case it is ignored, to support the\n// way `JSON.stringify` calls `toString` methods.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};\n  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }\n  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.spec.state;\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\n//\n// config::- configuration options\n//\n//   schema:: Schema\n//   The schema to use.\n//\n//   plugins:: ?[Plugin]\n//   The set of active plugins.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!json) { throw new RangeError(\"Invalid input for EditorState.fromJSON\") }\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins);\n  var instance = new EditorState($config);\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = Node.fromJSON(config.schema, json.doc);\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection);\n    } else if (field.name == \"storedMarks\") {\n      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.spec.state;\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance);\n    }\n  });\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\n//\n// FIXME this is no longer needed as of prosemirror-view 1.9.0,\n// though due to backwards-compat we should probably keep it around\n// for a while (if only as a no-op)\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f);\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f);\n  if (found > -1) { applyListeners.splice(found, 1); }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors$1 );\n\nvar applyListeners = [];\n\n// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) { val = val.bind(self); }\n    else if (prop == \"handleDOMEvents\") { val = bindProps(val, self, {}); }\n    target[prop] = val;\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nvar Plugin = function Plugin(spec) {\n  // :: EditorProps\n  // The [props](#view.EditorProps) exported by this plugin.\n  this.props = {};\n  if (spec.props) { bindProps(spec.props, this, this.props); }\n  // :: Object\n  // The plugin's [spec object](#state.PluginSpec).\n  this.spec = spec;\n  this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n};\n\n// :: (EditorState) → any\n// Extract the plugin's state field from an editor state.\nPlugin.prototype.getState = function getState (state) { return state[this.key] };\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nvar keys = Object.create(null);\n\nfunction createKey(name) {\n  if (name in keys) { return name + \"$\" + ++keys[name] }\n  keys[name] = 0;\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nvar PluginKey = function PluginKey(name) {\nif ( name === void 0 ) name = \"key\";\n this.key = createKey(name); };\n\n// :: (EditorState) → ?Plugin\n// Get the active plugin with this key, if any, from an editor\n// state.\nPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\n// :: (EditorState) → ?any\n// Get the plugin's state from an editor state.\nPluginKey.prototype.getState = function getState (state) { return state[this.key] };\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n//# sourceMappingURL=index.es.js.map\n","import { ReplaceError, Slice, Fragment, MarkType } from 'prosemirror-model';\n\n// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  if (!ranges.length && StepMap.empty) { return StepMap.empty }\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover (value) {\n  var diff = 0, index = recoverIndex(value);\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// : (number, ?number) → MapResult\nStepMap.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\n// : (number, ?number) → number\nStepMap.prototype.map = function map (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n      if (simple) { return result }\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize;\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n  var diff = 0, index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n    if (pos <= end && i == index * 3) { return true }\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\n\n// :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\nStepMap.offset = function offset (n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n};\n\nStepMap.empty = new StepMap([]);\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || [];\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0;\n  // :: number\n  // The end position in the `maps` array.\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n};\n\n// :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map);\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n};\n\n// :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\nMapping.prototype.getMirror = function getMirror (n) {\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = []; }\n  this.mirror.push(n, m);\n};\n\n// :: (Mapping)\n// Append the inverse of the given mapping to this one.\nMapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n};\n\n// :: () → Mapping\n// Create an inverted version of this mapping.\nMapping.prototype.invert = function invert () {\n  var inverse = new Mapping;\n  inverse.appendMappingInverted(this);\n  return inverse\n};\n\n// : (number, ?number) → number\n// Map a position through this mapping.\nMapping.prototype.map = function map (pos, assoc) {\n    if ( assoc === void 0 ) assoc = 1;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this.maps[i].map(pos, assoc); }\n  return pos\n};\n\n// : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i], result = map.mapResult(pos, assoc);\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue\n      }\n    }\n\n    if (result.deleted) { deleted = true; }\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc;\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = [];\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = [];\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping;\n};\n\nvar prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };\n\n// :: Node The starting document.\nprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object);\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc);\n  if (!result.failed) { this.addStep(step, result.doc); }\n  return result\n};\n\n// :: bool\n// True when the document has been changed (when there are any\n// steps).\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors );\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null);\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\nStep.prototype.toJSON = function toJSON () { return mustOverride() };\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  if (!json || !json.stepType) { throw new RangeError(\"Invalid input for Step.fromJSON\") }\n  var type = stepsByID[json.stepType];\n  if (!type) { throw new RangeError((\"No step type \" + (json.stepType) + \" defined\")) }\n  return type.fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass\n};\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc;\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed;\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = /*@__PURE__*/(function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\") }\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\n\nStep.jsonID(\"replace\", ReplaceStep);\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = /*@__PURE__*/(function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this);\n    // :: number\n    // The start position of the replaced range.\n    this.from = from;\n    // :: number\n    // The end position of the replaced range.\n    this.to = to;\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom;\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo;\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice;\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if ( Step ) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\") }\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      { return depth }\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  var start = gapStart, end = gapEnd;\n\n  var before = Fragment.empty, openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    } }\n  var after = Fragment.empty, openEnd = 0;\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n};\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if ( innerRange === void 0 ) innerRange = range;\n\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) { return null }\n  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type: type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) { return null }\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) { return null }\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++)\n    { innerMatch = innerMatch.matchType(parent.child(i).type); }\n  if (!innerMatch || !innerMatch.validEnd) { return null }\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd)\n        { throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\") }\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  var start = range.start, end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n};\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false\n    }\n  });\n  return this\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type; }\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }\n\n  if (!type.validContent(node.content))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n};\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = doc.resolve(pos), base = $pos.depth - depth;\n  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    { return false }\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d), index$1 = $pos.index(d);\n    if (node.type.spec.isolating) { return false }\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = (typesAfter && typesAfter[i]) || node;\n    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))\n      { return false }\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n};\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos, dir) {\n  if ( dir === void 0 ) dir = -1;\n\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = (void 0), after = (void 0), index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) { return pos }\n    if (d == 0) { break }\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step)\n};\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) { return pos }\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d), fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits)\n        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n    }\n  }\n  return null\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }\n    if (child.isInline) { child = f(child, parent, i); }\n    mapped.push(child);\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = /*@__PURE__*/(function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the marked range.\n    this.from = from;\n    // :: number\n    // The end of the marked range.\n    this.to = to;\n    // :: Mark\n    // The mark to add.\n    this.mark = mark;\n  }\n\n  if ( Step ) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create( Step && Step.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }\n      return node.mark(this$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\") }\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = /*@__PURE__*/(function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this);\n    // :: number\n    // The start of the unmarked range.\n    this.from = from;\n    // :: number\n    // The end of the unmarked range.\n    this.to = to;\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark;\n  }\n\n  if ( Step ) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\") }\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) { return }\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            { removing.to = end; }\n          else\n            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }\n        }\n      }\n\n      if (adding && adding.to == start)\n        { adding.to = end; }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)); }\n    }\n  });\n\n  removed.forEach(function (s) { return this$1.step(s); });\n  added.forEach(function (s) { return this$1.step(s); });\n  return this\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++;\n    var toRemove = null;\n    if (mark instanceof MarkType) {\n      var set = node.marks, found;\n      while (found = mark.isInSet(set)) {\n(toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark]; }\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0);\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }\n        }\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n  return this\n};\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match) {\n  if ( match === void 0 ) match = parentType.contentMatch;\n\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [], cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))\n        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }\n  return this\n};\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice);\n  if (step) { this.step(step); }\n  return this\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n\n  this.frontier = [];\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n  for (var i$1 = $from.depth; i$1 > 0; i$1--)\n    { this.placed = Fragment.from($from.node(i$1).copy(this.placed)); }\n};\n\nvar prototypeAccessors$1 = { depth: { configurable: true } };\n\nprototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };\n\nFitter.prototype.fit = function fit () {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n    if (fit) { this.placeNodes(fit); }\n    else { this.openMore() || this.dropNode(); }\n  }\n  // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n  if (!$to) { return null }\n\n  // If closing to `$to` succeeded, create a step\n  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--; openEnd--;\n  }\n  var slice = new Slice(content, openStart, openEnd);\n  if (moveInline > -1)\n    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    { return new ReplaceStep($from.pos, $to.pos, slice) }\n};\n\n// Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\nFitter.prototype.findFittable = function findFittable () {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = (void 0), parent = (void 0);\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n      var first = fragment.firstChild;\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n          var type = ref.type;\n          var match = ref.match;\n          var wrap = (void 0), inject = (void 0);\n        // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                          : type.compatibleContent(parent.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }\n        // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }\n        // Don't continue looking further up if the parent node\n        // would fit here.\n        if (parent && match.matchType(parent.type)) { break }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (!inner.childCount || inner.firstChild.isLeaf) { return false }\n  this.unplaced = new Slice(content, openStart + 1,\n                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true\n};\n\nFitter.prototype.dropNode = function dropNode () {\n  var ref = this.unplaced;\n    var content = ref.content;\n    var openStart = ref.openStart;\n    var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                              openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n};\n\n// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\nFitter.prototype.placeNodes = function placeNodes (ref) {\n    var sliceDepth = ref.sliceDepth;\n    var frontierDepth = ref.frontierDepth;\n    var parent = ref.parent;\n    var inject = ref.inject;\n    var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) { this.closeFrontierNode(); }\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }\n\n  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0, add = [];\n  var ref$1 = this.frontier[frontierDepth];\n    var match = ref$1.match;\n    var type = ref$1.type;\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }\n    match = match.matchFragment(inject);\n  }\n  // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n  // Scan over the fragment, fitting as many child nodes as\n  // possible.\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken), matches = match.matchType(next.type);\n    if (!matches) { break }\n    taken++;\n    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                              taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n  var toEnd = taken == fragment.childCount;\n  if (!toEnd) { openEndCount = -1; }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match;\n\n  // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n    { this.closeFrontierNode(); }\n\n  // Add new frontier nodes for any open nodes at the end.\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});\n    cur = node.content;\n  }\n\n  // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n    : sliceDepth == 0 ? Slice.empty\n    : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline () {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }\n  var top = this.frontier[this.depth], level;\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }\n\n  var ref = this.$to;\n    var depth = ref.depth;\n    var after = this.$to.after(depth);\n  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }\n  return after\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel ($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n      var match = ref.match;\n      var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n    if (!fit) { continue }\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n        var match$1 = ref$1.match;\n        var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n      if (!matches || matches.childCount) { continue scan }\n    }\n    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n  }\n};\n\nFitter.prototype.close = function close ($to) {\n  var close = this.findCloseLevel($to);\n  if (!close) { return null }\n\n  while (this.depth > close.depth) { this.closeFrontierNode(); }\n  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }\n  $to = close.move;\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n  return $to\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({type: type, match: type.contentMatch});\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode () {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }\n};\n\nObject.defineProperties( Fitter.prototype, prototypeAccessors$1 );\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) { return fragment.cutByIndex(count) }\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) { return fragment.append(content) }\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) { return node }\n  var frag = node.content;\n  if (openStart > 1)\n    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true)); }\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++)\n    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.isolating) { break }\n    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }\n    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n\n  var leftNodes = [], preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) { break }\n    content = node.content;\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    { preferredDepth -= 1; }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    { preferredDepth -= 2; }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }\n      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd)) }\n    }\n  }\n\n  var startSteps = this.steps.length;\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n    if (this.steps.length > startSteps) { break }\n    var depth = targetDepths[i$2];\n    if (depth < 0) { continue }\n    from = $from.before(depth); to = $to.after(depth);\n  }\n  return this\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n    if (point != null) { from = to = point; }\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i], last = i == covered.length - 1;\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      { return this.delete($from.start(depth), $to.end(depth)) }\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      { return this.delete($from.before(depth), $to.after(depth)) }\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      { return this.delete($from.before(d), to) }\n  }\n  return this.delete(from, to)\n};\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) { break }\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      { result.push(d); }\n  }\n  return result\n}\n\nexport { AddMarkStep, MapResult, Mapping, RemoveMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep };\n//# sourceMappingURL=index.es.js.map\n","import { TextSelection, NodeSelection, Selection, AllSelection } from 'prosemirror-state';\nimport { DOMSerializer, Fragment, Mark, DOMParser, Slice } from 'prosemirror-model';\nimport { dropPoint } from 'prosemirror-transform';\n\nvar result = {};\n\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  var ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent);\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\n  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent);\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n  var chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\n  result.chrome = !!chrome;\n  result.chrome_version = chrome && +chrome[1];\n  // Is true for both iOS and iPadOS for convenience\n  result.safari = !ie && /Apple Computer/.test(navigator.vendor);\n  result.ios = result.safari && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\n  result.mac = result.ios || /Mac/.test(navigator.platform);\n  result.android = /Android \\d/.test(navigator.userAgent);\n  result.webkit = \"webkitFontSmoothing\" in document.documentElement.style;\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n}\n\nvar domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) { return index }\n  }\n};\n\nvar parentNode = function(node) {\n  var parent = node.assignedSlot || node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent\n};\n\nvar reusedRange = null;\n\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nvar textRange = function(node, from, to) {\n  var range = reusedRange || (reusedRange = document.createRange());\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range\n};\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nvar isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n};\n\nvar atomElements = /^(img|br|input|textarea|hr)$/i;\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) { return true }\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      var parent = node.parentNode;\n      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        { return false }\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.contentEditable == \"false\") { return false }\n      off = dir < 0 ? nodeSize(node) : 0;\n    } else {\n      return false\n    }\n  }\n}\n\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isOnEdge(node, offset, parent) {\n  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) { return true }\n    var index = domIndex(node);\n    node = node.parentNode;\n    if (!node) { return false }\n    atStart = atStart && index == 0;\n    atEnd = atEnd && index == nodeSize(node);\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  var desc;\n  for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nvar selectionCollapsed = function(domSel) {\n  var collapsed = domSel.isCollapsed;\n  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    { collapsed = false; }\n  return collapsed\n};\n\nfunction keyEvent(keyCode, key) {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event\n}\n\nfunction windowRect(doc) {\n  return {left: 0, right: doc.documentElement.clientWidth,\n          top: 0, bottom: doc.documentElement.clientHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction clientRect(node) {\n  var rect = node.getBoundingClientRect();\n  // Adjust for elements with style \"transform: scale()\"\n  var scaleX = (rect.width / node.offsetWidth) || 1;\n  var scaleY = (rect.height / node.offsetHeight) || 1;\n  // Make sure scrollbar width isn't included in the rectangle\n  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,\n          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}\n}\n\nfunction scrollRectIntoView(view, rect, startDOM) {\n  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  var doc = view.dom.ownerDocument;\n  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) { break }\n    if (parent.nodeType != 1) { continue }\n    var atTop = parent == doc.body || parent.nodeType != 1;\n    var bounding = atTop ? windowRect(doc) : clientRect(parent);\n    var moveX = 0, moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\")); }\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\"); }\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\")); }\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      { moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\"); }\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY);\n      } else {\n        var startX = parent.scrollLeft, startY = parent.scrollTop;\n        if (moveY) { parent.scrollTop += moveY; }\n        if (moveX) { parent.scrollLeft += moveX; }\n        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;\n        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};\n      }\n    }\n    if (atTop) { break }\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n  var refDOM, refTop;\n  for (var x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    var dom = view.root.elementFromPoint(x, y);\n    if (dom == view.dom || !view.dom.contains(dom)) { continue }\n    var localRect = dom.getBoundingClientRect();\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break\n    }\n  }\n  return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}\n}\n\nfunction scrollStack(dom) {\n  var stack = [], doc = dom.ownerDocument;\n  for (; dom; dom = parentNode(dom)) {\n    stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});\n    if (dom == doc) { break }\n  }\n  return stack\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos(ref) {\n  var refDOM = ref.refDOM;\n  var refTop = ref.refTop;\n  var stack = ref.stack;\n\n  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (var i = 0; i < stack.length; i++) {\n    var ref = stack[i];\n    var dom = ref.dom;\n    var top = ref.top;\n    var left = ref.left;\n    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }\n    if (dom.scrollLeft != left) { dom.scrollLeft = left; }\n  }\n}\n\nvar preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) { return dom.setActive() } // in IE\n  if (preventScrollSupported) { return dom.focus(preventScrollSupported) }\n\n  var stored = scrollStack(dom);\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {preventScroll: true};\n      return true\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    restoreScrollStack(stored, 0);\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  var closest, dxClosest = 2e8, coordsClosest, offset = 0;\n  var rowBot = coords.top, rowTop = coords.top;\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = (void 0);\n    if (child.nodeType == 1) { rects = child.getClientRects(); }\n    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }\n    else { continue }\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        var dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;\n          if (child.nodeType == 1 && dx)\n            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        { offset = childIndex + 1; }\n    }\n  }\n  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }\n  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = singleRect(range, 1);\n    if (rect.top == rect.bottom) { continue }\n    if (inRect(coords, rect))\n      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }\n  }\n  return {node: node, offset: 0}\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&\n    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1\n}\n\nfunction targetKludge(dom, coords) {\n  var parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    { return parent }\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  var ref = findOffsetInNode(elt, coords);\n  var node = ref.node;\n  var offset = ref.offset;\n  var bias = -1;\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  var outside = -1;\n  for (var cur = node;;) {\n    if (cur == view.dom) { break }\n    var desc = view.docView.nearestDesc(cur, true);\n    if (!desc) { return null }\n    if (desc.node.isBlock && desc.parent) {\n      var rect = desc.dom.getBoundingClientRect();\n      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }\n      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }\n      else { break }\n    }\n    cur = desc.dom.parentNode;\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\nfunction elementFromPoint(element, coords, box) {\n  var len = element.childNodes.length;\n  if (len && box.top < box.bottom) {\n    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      var child = element.childNodes[i];\n      if (child.nodeType == 1) {\n        var rects = child.getClientRects();\n        for (var j = 0; j < rects.length; j++) {\n          var rect = rects[j];\n          if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }\n        }\n      }\n      if ((i = (i + 1) % len) == startI) { break }\n    }\n  }\n  return element\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n  var assign, assign$1;\n\n  var doc = view.dom.ownerDocument, node, offset;\n  if (doc.caretPositionFromPoint) {\n    try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n      var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);\n      if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }\n    } catch (_) {}\n  }\n  if (!node && doc.caretRangeFromPoint) {\n    var range = doc.caretRangeFromPoint(coords.left, coords.top);\n    if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }\n  }\n\n  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    var box = view.dom.getBoundingClientRect();\n    if (!inRect(coords, box)) { return null }\n    elt = elementFromPoint(view.dom, coords, box);\n    if (!elt) { return null }\n  }\n  // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n  if (result.safari) {\n    for (var p = elt; node && p; p = parentNode(p))\n      { if (p.draggable) { node = offset = null; } }\n  }\n  elt = targetKludge(elt, coords);\n  if (node) {\n    if (result.gecko && node.nodeType == 1) {\n      // Firefox will sometimes return offsets into <input> nodes, which\n      // have no actual children, from caretPositionFromPoint (#953)\n      offset = Math.min(offset, node.childNodes.length);\n      // It'll also move the returned position before image nodes,\n      // even if those are behind it.\n      if (offset < node.childNodes.length) {\n        var next = node.childNodes[offset], box$1;\n        if (next.nodeName == \"IMG\" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&\n            box$1.bottom > coords.top)\n          { offset++; }\n      }\n    }\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      { pos = view.state.doc.content.size; }\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately placed\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      { pos = posFromCaret(view, node, offset, coords); }\n  }\n  if (pos == null) { pos = posFromElement(view, elt, coords); }\n\n  var desc = view.docView.nearestDesc(elt, true);\n  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects();\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\nvar BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\n// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n  var node = ref.node;\n  var offset = ref.offset;\n\n  var supportEmptyRange = result.webkit || result.gecko;\n  if (node.nodeType == 3) {\n    // These browsers support querying empty text ranges. Prefer that in\n    // bidi context or when at the end of a node.\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      var rect = singleRect(textRange(node, offset, offset), side);\n      // Firefox returns bad results (the position before the space)\n      // when querying a position directly after line-broken\n      // whitespace. Detect this situation and and kludge around it\n      if (result.gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n        if (rectBefore.top == rect.top) {\n          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n          if (rectAfter.top != rect.top)\n            { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }\n        }\n      }\n      return rect\n    } else {\n      var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n      if (side < 0 && !offset) { to++; takeSide = -1; }\n      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }\n      else if (side < 0) { from--; }\n      else { to ++; }\n      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)\n    }\n  }\n\n  // Return a horizontal line in block context\n  if (!view.state.doc.resolve(pos).parent.inlineContent) {\n    if (offset && (side < 0 || offset == nodeSize(node))) {\n      var before = node.childNodes[offset - 1];\n      if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }\n    }\n    if (offset < nodeSize(node)) {\n      var after = node.childNodes[offset];\n      if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0)\n  }\n\n  // Inline, not in text node (this is not Bidi-safe)\n  if (offset && (side < 0 || offset == nodeSize(node))) {\n    var before$1 = node.childNodes[offset - 1];\n    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))\n        // BR nodes tend to only return the rectangle before them.\n        // Only use them if they are the last element in their parent\n        : before$1.nodeType == 1 && (before$1.nodeName != \"BR\" || !before$1.nextSibling) ? before$1 : null;\n    if (target) { return flattenV(singleRect(target, 1), false) }\n  }\n  if (offset < nodeSize(node)) {\n    var after$1 = node.childNodes[offset];\n    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) { after$1 = after$1.nextSibling; }\n    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))\n        : after$1.nodeType == 1 ? after$1 : null;\n    if (target$1) { return flattenV(singleRect(target$1, -1), true) }\n  }\n  // All else failed, just try to get a rectangle for the target node\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) { return rect }\n  var x = left ? rect.left : rect.right;\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) { return rect }\n  var y = top ? rect.top : rect.bottom;\n  return {top: y, bottom: y, left: rect.left, right: rect.right}\n}\n\nfunction withFlushedState(view, state, f) {\n  var viewState = view.state, active = view.root.activeElement;\n  if (viewState != state) { view.updateState(state); }\n  if (active != view.dom) { view.focus(); }\n  try {\n    return f()\n  } finally {\n    if (viewState != state) { view.updateState(viewState); }\n    if (active != view.dom && active) { active.focus(); }\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  var sel = state.selection;\n  var $pos = dir == \"up\" ? sel.$from : sel.$to;\n  return withFlushedState(view, state, function () {\n    var ref = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n    var dom = ref.node;\n    for (;;) {\n      var nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest) { break }\n      if (nearest.node.isBlock) { dom = nearest.dom; break }\n      dom = nearest.dom.parentNode;\n    }\n    var coords = coordsAtPos(view, $pos.pos, 1);\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      var boxes = (void 0);\n      if (child.nodeType == 1) { boxes = child.getClientRects(); }\n      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }\n      else { continue }\n      for (var i = 0; i < boxes.length; i++) {\n        var box = boxes[i];\n        if (box.bottom > box.top + 1 &&\n            (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2\n             : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n          { return false }\n      }\n    }\n    return true\n  })\n}\n\nvar maybeRTL = /[\\u0590-\\u08ac]/;\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  if (!$head.parent.isTextblock) { return false }\n  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n  var sel = view.root.getSelection();\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    { return dir == \"left\" || dir == \"backward\" ? atStart : atEnd }\n\n  return withFlushedState(view, state, function () {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;\n    var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox\n    sel.modify(\"move\", dir, \"character\");\n    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset);\n    // Restore the previous selection\n    sel.removeAllRanges();\n    sel.addRange(oldRange);\n    if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }\n    return result\n  })\n}\n\nvar cachedState = null, cachedDir = null, cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) { return cachedResult }\n  cachedState = state; cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Mark views only support `dom` and `contentDOM`, and don't support\n// any of the node view methods.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), an array\n//   of active decorations around the node (which are automatically\n//   drawn, and the node view may ignore if it isn't interested in\n//   them), and a [decoration source](#view.DecorationSource) that\n//   represents any decorations that apply to the content of the node\n//   (which again may be ignored). It should return true if it was\n//   able to update to that node, and false otherwise. If the node\n//   view has a `contentDOM` property (or no `dom` property), updating\n//   its child nodes will be handled by ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   or a selection change happens within the view. When the change is\n//   a selection change, the record will have a `type` property of\n//   `\"selection\"` (which doesn't occur for native mutation records).\n//   Return false if the editor should re-read the selection or\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed. (Not available for marks.)\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nvar NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nvar ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {\n  this.parent = parent;\n  this.children = children;\n  this.dom = dom;\n  // An expando property on the DOM node provides a link back to its\n  // description.\n  dom.pmViewDesc = this;\n  // This is the node that holds the child views. It may be null for\n  // descs that don't have children.\n  this.contentDOM = contentDOM;\n  this.dirty = NOT_DIRTY;\n};\n\nvar prototypeAccessors = { size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true },ignoreForCoords: { configurable: true } };\n\n// Used to check whether a given description corresponds to a\n// widget/mark/node.\nViewDesc.prototype.matchesWidget = function matchesWidget () { return false };\nViewDesc.prototype.matchesMark = function matchesMark () { return false };\nViewDesc.prototype.matchesNode = function matchesNode () { return false };\nViewDesc.prototype.matchesHack = function matchesHack (_nodeName) { return false };\n\n// : () → ?ParseRule\n// When parsing in-editor content (in domchange.js), we allow\n// descriptions to determine the parse rules that should be used to\n// parse them.\nViewDesc.prototype.parseRule = function parseRule () { return null };\n\n// : (dom.Event) → bool\n// Used by the editor's event handler to ignore events that come\n// from certain descs.\nViewDesc.prototype.stopEvent = function stopEvent () { return false };\n\n// The size of the content represented by this desc.\nprototypeAccessors.size.get = function () {\n  var size = 0;\n  for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }\n  return size\n};\n\n// For block nodes, this represents the space taken up by their\n// start/end tokens.\nprototypeAccessors.border.get = function () { return 0 };\n\nViewDesc.prototype.destroy = function destroy () {\n  this.parent = null;\n  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }\n  for (var i = 0; i < this.children.length; i++)\n    { this.children[i].destroy(); }\n};\n\nViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {\n  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n    var cur = this.children[i];\n    if (cur == child) { return pos }\n    pos += cur.size;\n  }\n};\n\nprototypeAccessors.posBefore.get = function () {\n  return this.parent.posBeforeChild(this)\n};\n\nprototypeAccessors.posAtStart.get = function () {\n  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n};\n\nprototypeAccessors.posAfter.get = function () {\n  return this.posBefore + this.size\n};\n\nprototypeAccessors.posAtEnd.get = function () {\n  return this.posAtStart + this.size - 2 * this.border\n};\n\n// : (dom.Node, number, ?number) → number\nViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n  // If the DOM position is in the content, use the child desc after\n  // it to figure out a position.\n  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n    if (bias < 0) {\n      var domBefore, desc;\n      if (dom == this.contentDOM) {\n        domBefore = dom.childNodes[offset - 1];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domBefore = dom.previousSibling;\n      }\n      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }\n      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n    } else {\n      var domAfter, desc$1;\n      if (dom == this.contentDOM) {\n        domAfter = dom.childNodes[offset];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domAfter = dom.nextSibling;\n      }\n      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }\n      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd\n    }\n  }\n  // Otherwise, use various heuristics, falling back on the bias\n  // parameter, to determine whether to return the position at the\n  // start or at the end of this view desc.\n  var atEnd;\n  if (dom == this.dom && this.contentDOM) {\n    atEnd = offset > domIndex(this.contentDOM);\n  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n  } else if (this.dom.firstChild) {\n    if (offset == 0) { for (var search = dom;; search = search.parentNode) {\n      if (search == this.dom) { atEnd = false; break }\n      if (search.parentNode.firstChild != search) { break }\n    } }\n    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {\n      if (search$1 == this.dom) { atEnd = true; break }\n      if (search$1.parentNode.lastChild != search$1) { break }\n    } }\n  }\n  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n};\n\n// Scan up the dom finding the first desc that is a descendant of\n// this one.\nViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {\n  for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n    var desc = this.getDesc(cur);\n    if (desc && (!onlyNodes || desc.node)) {\n      // If dom is outside of this desc's nodeDOM, don't count it.\n      if (first && desc.nodeDOM &&\n          !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))\n        { first = false; }\n      else\n        { return desc }\n    }\n  }\n};\n\nViewDesc.prototype.getDesc = function getDesc (dom) {\n  var desc = dom.pmViewDesc;\n  for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }\n};\n\nViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {\n  for (var scan = dom; scan; scan = scan.parentNode) {\n    var desc = this.getDesc(scan);\n    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }\n  }\n  return -1\n};\n\n// : (number) → ?NodeViewDesc\n// Find the desc for the node after the given pos, if any. (When a\n// parent node overrode rendering, there might not be one.)\nViewDesc.prototype.descAt = function descAt (pos) {\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (offset == pos && end != offset) {\n      while (!child.border && child.children.length) { child = child.children[0]; }\n      return child\n    }\n    if (pos < end) { return child.descAt(pos - offset - child.border) }\n    offset = end;\n  }\n};\n\n// : (number, number) → {node: dom.Node, offset: number}\nViewDesc.prototype.domFromPos = function domFromPos (pos, side) {\n  if (!this.contentDOM) { return {node: this.dom, offset: 0} }\n  // First find the position in the child array\n  var i = 0, offset = 0;\n  for (var curPos = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = curPos + child.size;\n    if (end > pos || child instanceof TrailingHackViewDesc) { offset = pos - curPos; break }\n    curPos = end;\n  }\n  // If this points into the middle of a child, call through\n  if (offset) { return this.children[i].domFromPos(offset - this.children[i].border, side) }\n  // Go back if there were any zero-length widgets with side >= 0 before this point\n  for (var prev = (void 0); i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {}\n  // Scan towards the first useable node\n  if (side <= 0) {\n    var prev$1, enter = true;\n    for (;; i--, enter = false) {\n      prev$1 = i ? this.children[i - 1] : null;\n      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) { break }\n    }\n    if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) { return prev$1.domFromPos(prev$1.size, side) }\n    return {node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0}\n  } else {\n    var next, enter$1 = true;\n    for (;; i++, enter$1 = false) {\n      next = i < this.children.length ? this.children[i] : null;\n      if (!next || next.dom.parentNode == this.contentDOM) { break }\n    }\n    if (next && enter$1 && !next.border && !next.domAtom) { return next.domFromPos(0, side) }\n    return {node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length}\n  }\n};\n\n// Used to find a DOM range in a single parent for a given changed\n// range.\nViewDesc.prototype.parseRange = function parseRange (from, to, base) {\n    if ( base === void 0 ) base = 0;\n\n  if (this.children.length == 0)\n    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }\n\n  var fromOffset = -1, toOffset = -1;\n  for (var offset = base, i = 0;; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (fromOffset == -1 && from <= end) {\n      var childBase = offset + child.border;\n      // FIXME maybe descend mark views to parse a narrower range?\n      if (from >= childBase && to <= end - child.border && child.node &&\n          child.contentDOM && this.contentDOM.contains(child.contentDOM))\n        { return child.parseRange(from, to, childBase) }\n\n      from = offset;\n      for (var j = i; j > 0; j--) {\n        var prev = this.children[j - 1];\n        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n          fromOffset = domIndex(prev.dom) + 1;\n          break\n        }\n        from -= prev.size;\n      }\n      if (fromOffset == -1) { fromOffset = 0; }\n    }\n    if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n      to = end;\n      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {\n        var next = this.children[j$1];\n        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n          toOffset = domIndex(next.dom);\n          break\n        }\n        to += next.size;\n      }\n      if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }\n      break\n    }\n    offset = end;\n  }\n  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}\n};\n\nViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {\n  if (this.border || !this.contentDOM || !this.children.length) { return false }\n  var child = this.children[side < 0 ? 0 : this.children.length - 1];\n  return child.size == 0 || child.emptyChildAt(side)\n};\n\n// : (number) → dom.Node\nViewDesc.prototype.domAfterPos = function domAfterPos (pos) {\n  var ref = this.domFromPos(pos, 0);\n    var node = ref.node;\n    var offset = ref.offset;\n  if (node.nodeType != 1 || offset == node.childNodes.length)\n    { throw new RangeError(\"No node after pos \" + pos) }\n  return node.childNodes[offset]\n};\n\n// : (number, number, dom.Document)\n// View descs are responsible for setting any selection that falls\n// entirely inside of them, so that custom implementations can do\n// custom things with the selection. Note that this falls apart when\n// a selection starts in such a node and ends in another, in which\n// case we just use whatever domFromPos produces as a best effort.\nViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n  // If the selection falls entirely in a child, give it to that child\n  var from = Math.min(anchor, head), to = Math.max(anchor, head);\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (from > offset && to < end)\n      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }\n    offset = end;\n  }\n\n  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n  var domSel = root.getSelection();\n\n  var brKludge = false;\n  // On Firefox, using Selection.collapse to put the cursor after a\n  // BR node for some reason doesn't always work (#1073). On Safari,\n  // the cursor sometimes inexplicable visually lags behind its\n  // reported position in such situations (#1092).\n  if ((result.gecko || result.safari) && anchor == head) {\n    var node = anchorDOM.node;\n      var offset$1 = anchorDOM.offset;\n    if (node.nodeType == 3) {\n      brKludge = offset$1 && node.nodeValue[offset$1 - 1] == \"\\n\";\n      // Issue #1128\n      if (brKludge && offset$1 == node.nodeValue.length) {\n        for (var scan = node, after = (void 0); scan; scan = scan.parentNode) {\n          if (after = scan.nextSibling) {\n            if (after.nodeName == \"BR\")\n              { anchorDOM = headDOM = {node: after.parentNode, offset: domIndex(after) + 1}; }\n            break\n          }\n          var desc = scan.pmViewDesc;\n          if (desc && desc.node && desc.node.isBlock) { break }\n        }\n      }\n    } else {\n      var prev = node.childNodes[offset$1 - 1];\n      brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n    }\n  }\n  // Firefox can act strangely when the selection is in front of an\n  // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];\n    if (after$1 && after$1.contentEditable == \"false\") { force = true; }\n  }\n\n  if (!(force || brKludge && result.safari) &&\n      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n    { return }\n\n  // Selection.extend can be used to create an 'inverted' selection\n  // (one where the focus is before the anchor), but not all\n  // browsers support it yet.\n  var domSelExtended = false;\n  if ((domSel.extend || anchor == head) && !brKludge) {\n    domSel.collapse(anchorDOM.node, anchorDOM.offset);\n    try {\n      if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }\n      domSelExtended = true;\n    } catch (err) {\n      // In some cases with Chrome the selection is empty after calling\n      // collapse, even when it should be valid. This appears to be a bug, but\n      // it is difficult to isolate. If this happens fallback to the old path\n      // without using extend.\n      if (!(err instanceof DOMException)) { throw err }\n      // declare global: DOMException\n    }\n  }\n  if (!domSelExtended) {\n    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }\n    var range = document.createRange();\n    range.setEnd(headDOM.node, headDOM.offset);\n    range.setStart(anchorDOM.node, anchorDOM.offset);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n  }\n};\n\n// : (dom.MutationRecord) → bool\nViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n  return !this.contentDOM && mutation.type != \"selection\"\n};\n\nprototypeAccessors.contentLost.get = function () {\n  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n};\n\n// Remove a subtree of the element tree that has been touched\n// by a DOM change, so that the next update will redraw it.\nViewDesc.prototype.markDirty = function markDirty (from, to) {\n  for (var offset = 0, i = 0; i < this.children.length; i++) {\n    var child = this.children[i], end = offset + child.size;\n    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n      var startInside = offset + child.border, endInside = end - child.border;\n      if (from >= startInside && to <= endInside) {\n        this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (from == startInside && to == endInside &&\n            (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }\n        else { child.markDirty(from - startInside, to - startInside); }\n        return\n      } else {\n        child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n          ? CONTENT_DIRTY : NODE_DIRTY;\n      }\n    }\n    offset = end;\n  }\n  this.dirty = CONTENT_DIRTY;\n};\n\nViewDesc.prototype.markParentsDirty = function markParentsDirty () {\n  var level = 1;\n  for (var node = this.parent; node; node = node.parent, level++) {\n    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n    if (node.dirty < dirty) { node.dirty = dirty; }\n  }\n};\n\nprototypeAccessors.domAtom.get = function () { return false };\n\nprototypeAccessors.ignoreForCoords.get = function () { return false };\n\nObject.defineProperties( ViewDesc.prototype, prototypeAccessors );\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nvar nothing = [];\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nvar WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function WidgetViewDesc(parent, widget, view, pos) {\n    var self, dom = widget.type.toDOM;\n    if (typeof dom == \"function\") { dom = dom(view, function () {\n      if (!self) { return pos }\n      if (self.parent) { return self.parent.posBeforeChild(self) }\n    }); }\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        var wrap = document.createElement(\"span\");\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n      dom.contentEditable = false;\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n    ViewDesc.call(this, parent, nothing, dom, null);\n    this.widget = widget;\n    self = this;\n  }\n\n  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;\n  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  WidgetViewDesc.prototype.constructor = WidgetViewDesc;\n\n  var prototypeAccessors$1 = { domAtom: { configurable: true } };\n\n  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  };\n\n  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n\n  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {\n    var stop = this.widget.spec.stopEvent;\n    return stop ? stop(event) : false\n  };\n\n  WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection\n  };\n\n  WidgetViewDesc.prototype.destroy = function destroy () {\n    this.widget.type.destroy(this.dom);\n    ViewDesc.prototype.destroy.call(this);\n  };\n\n  prototypeAccessors$1.domAtom.get = function () { return true };\n\n  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );\n\n  return WidgetViewDesc;\n}(ViewDesc));\n\nvar CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function CompositionViewDesc(parent, dom, textDOM, text) {\n    ViewDesc.call(this, parent, nothing, dom, null);\n    this.textDOM = textDOM;\n    this.text = text;\n  }\n\n  if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;\n  CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  CompositionViewDesc.prototype.constructor = CompositionViewDesc;\n\n  var prototypeAccessors$2 = { size: { configurable: true } };\n\n  prototypeAccessors$2.size.get = function () { return this.text.length };\n\n  CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {\n    if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }\n    return this.posAtStart + offset\n  };\n\n  CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    return {node: this.textDOM, offset: pos}\n  };\n\n  CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {\n    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue\n   };\n\n  Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );\n\n  return CompositionViewDesc;\n}(ViewDesc));\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nvar MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function MarkViewDesc(parent, mark, dom, contentDOM) {\n    ViewDesc.call(this, parent, [], dom, contentDOM);\n    this.mark = mark;\n  }\n\n  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;\n  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  MarkViewDesc.prototype.constructor = MarkViewDesc;\n\n  MarkViewDesc.create = function create (parent, mark, inline, view) {\n    var custom = view.nodeViews[mark.type.name];\n    var spec = custom && custom(mark, view, inline);\n    if (!spec || !spec.dom)\n      { spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  };\n\n  MarkViewDesc.prototype.parseRule = function parseRule () {\n    if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView) { return null }\n    return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM}\n  };\n\n  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };\n\n  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {\n    ViewDesc.prototype.markDirty.call(this, from, to);\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      var parent = this.parent;\n      while (!parent.node) { parent = parent.parent; }\n      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }\n      this.dirty = NOT_DIRTY;\n    }\n  };\n\n  MarkViewDesc.prototype.slice = function slice (from, to, view) {\n    var copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n    var nodes = this.children, size = this.size;\n    if (to < size) { nodes = replaceNodes(nodes, to, size, view); }\n    if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }\n    for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }\n    copy.children = nodes;\n    return copy\n  };\n\n  return MarkViewDesc;\n}(ViewDesc));\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nvar NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);\n    this.nodeDOM = nodeDOM;\n    this.node = node;\n    this.outerDeco = outerDeco;\n    this.innerDeco = innerDeco;\n    if (contentDOM) { this.updateChildren(view, pos); }\n  }\n\n  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;\n  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  NodeViewDesc.prototype.constructor = NodeViewDesc;\n\n  var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {\n    var assign;\n\n    var custom = view.nodeViews[node.type.name], descObj;\n    var spec = custom && custom(node, view, function () {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) { return pos }\n      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }\n    }, outerDeco, innerDeco);\n\n    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n    if (node.isText) {\n      if (!dom) { dom = document.createTextNode(node.text); }\n      else if (dom.nodeType != 3) { throw new RangeError(\"Text must be rendered as a DOM text node\") }\n    } else if (!dom) {\n((assign = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      if (!dom.hasAttribute(\"contenteditable\")) { dom.contentEditable = false; }\n      if (node.type.spec.draggable) { dom.draggable = true; }\n    }\n\n    var nodeDOM = dom;\n    dom = applyOuterDeco(dom, outerDeco, node);\n\n    if (spec)\n      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,\n                                              spec, view, pos + 1) }\n    else if (node.isText)\n      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }\n    else\n      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }\n  };\n\n  NodeViewDesc.prototype.parseRule = function parseRule () {\n    var this$1 = this;\n\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) { return null }\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    var rule = {node: this.node.type.name, attrs: this.node.attrs};\n    if (this.node.type.whitespace == \"pre\") { rule.preserveWhitespace = \"full\"; }\n    if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }\n    else { rule.getContent = function () { return this$1.contentDOM ? Fragment.empty : this$1.node.content; }; }\n    return rule\n  };\n\n  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  };\n\n  prototypeAccessors$3.size.get = function () { return this.node.nodeSize };\n\n  prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {\n    var this$1 = this;\n\n    var inline = this.node.inlineContent, off = pos;\n    var composition = view.composing && this.localCompositionInfo(view, pos);\n    var localComposition = composition && composition.pos > -1 ? composition : null;\n    var compositionInChild = composition && composition.pos < 0;\n    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);\n    iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {\n      if (widget.spec.marks)\n        { updater.syncToMarks(widget.spec.marks, inline, view); }\n      else if (widget.type.side >= 0 && !insideNode)\n        { updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline, view); }\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, off);\n    }, function (child, outerDeco, innerDeco, i) {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view);\n      // Try several strategies for drawing this node\n      var compIndex;\n      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ; else if (compositionInChild && view.state.selection.from > off &&\n                 view.state.selection.to < off + child.nodeSize &&\n                 (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                 updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ; else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ; else {\n        // Add it as a new view\n        updater.addNode(child, outerDeco, innerDeco, view, off);\n      }\n      off += child.nodeSize;\n    });\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view);\n    if (this.node.isTextblock) { updater.addTextblockHacks(); }\n    updater.destroyRest();\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      // May have to protect focused DOM from being changed if a composition is active\n      if (localComposition) { this.protectLocalComposition(view, localComposition); }\n      renderDescs(this.contentDOM, this.children, view);\n      if (result.ios) { iosHacks(this.dom); }\n    }\n  };\n\n  NodeViewDesc.prototype.localCompositionInfo = function localCompositionInfo (view, pos) {\n    // Only do something if both the selection and a focused text node\n    // are inside of this node\n    var ref = view.state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) { return }\n    var sel = view.root.getSelection();\n    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode || !this.dom.contains(textNode.parentNode)) { return }\n\n    if (this.node.inlineContent) {\n      // Find the text in the focused node in the node, stop if it's not\n      // there (may have been modified through other means, in which\n      // case it should overwritten)\n      var text = textNode.nodeValue;\n      var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n      return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}\n    } else {\n      return {node: textNode, pos: -1}\n    }\n  };\n\n  NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {\n    var node = ref.node;\n    var pos = ref.pos;\n    var text = ref.text;\n\n    // The node is already part of a local view desc, leave it there\n    if (this.getDesc(node)) { return }\n\n    // Create a composition view for the orphaned nodes\n    var topNode = node;\n    for (;; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM) { break }\n      while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }\n      while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }\n      if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }\n    }\n    var desc = new CompositionViewDesc(this, topNode, node, text);\n    view.compositionNodes.push(desc);\n\n    // Patch up this.children to contain the composition view\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n  };\n\n  // : (Node, [Decoration], DecorationSource, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateInner(node, outerDeco, innerDeco, view);\n    return true\n  };\n\n  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco);\n    this.node = node;\n    this.innerDeco = innerDeco;\n    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }\n    this.dirty = NOT_DIRTY;\n  };\n\n  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }\n    var needsWrap = this.nodeDOM.nodeType != 1;\n    var oldDOM = this.dom;\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap));\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null;\n      this.dom.pmViewDesc = this;\n    }\n    this.outerDeco = outerDeco;\n  };\n\n  // Mark this node as being the selected node.\n  NodeViewDesc.prototype.selectNode = function selectNode () {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }\n  };\n\n  // Remove selected node marking from this node.\n  NodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute(\"draggable\"); }\n  };\n\n  prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };\n\n  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );\n\n  return NodeViewDesc;\n}(ViewDesc));\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc);\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nvar TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {\n  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);\n  }\n\n  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;\n  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  TextViewDesc.prototype.constructor = TextViewDesc;\n\n  var prototypeAccessors$4 = { domAtom: { configurable: true } };\n\n  TextViewDesc.prototype.parseRule = function parseRule () {\n    var skip = this.nodeDOM.parentNode;\n    while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }\n    return {skip: skip || true}\n  };\n\n  TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateOuterDeco(outerDeco);\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text;\n      if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }\n    }\n    this.node = node;\n    this.dirty = NOT_DIRTY;\n    return true\n  };\n\n  TextViewDesc.prototype.inParent = function inParent () {\n    var parentDOM = this.parent.contentDOM;\n    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }\n    return false\n  };\n\n  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    return {node: this.nodeDOM, offset: pos}\n  };\n\n  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }\n    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)\n  };\n\n  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\"\n  };\n\n  TextViewDesc.prototype.slice = function slice (from, to, view) {\n    var node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)\n  };\n\n  TextViewDesc.prototype.markDirty = function markDirty (from, to) {\n    NodeViewDesc.prototype.markDirty.call(this, from, to);\n    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n      { this.dirty = NODE_DIRTY; }\n  };\n\n  prototypeAccessors$4.domAtom.get = function () { return false };\n\n  Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );\n\n  return TextViewDesc;\n}(NodeViewDesc));\n\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nvar TrailingHackViewDesc = /*@__PURE__*/(function (ViewDesc) {\n  function TrailingHackViewDesc () {\n    ViewDesc.apply(this, arguments);\n  }\n\n  if ( ViewDesc ) TrailingHackViewDesc.__proto__ = ViewDesc;\n  TrailingHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  TrailingHackViewDesc.prototype.constructor = TrailingHackViewDesc;\n\n  var prototypeAccessors$5 = { domAtom: { configurable: true },ignoreForCoords: { configurable: true } };\n\n  TrailingHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n  TrailingHackViewDesc.prototype.matchesHack = function matchesHack (nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName };\n  prototypeAccessors$5.domAtom.get = function () { return true };\n  prototypeAccessors$5.ignoreForCoords.get = function () { return this.dom.nodeName == \"IMG\" };\n\n  Object.defineProperties( TrailingHackViewDesc.prototype, prototypeAccessors$5 );\n\n  return TrailingHackViewDesc;\n}(ViewDesc));\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nvar CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {\n  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n    this.spec = spec;\n  }\n\n  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;\n  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) { return false }\n    if (this.spec.update) {\n      var result = this.spec.update(node, outerDeco, innerDeco);\n      if (result) { this.updateInner(node, outerDeco, innerDeco, view); }\n      return result\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)\n    }\n  };\n\n  CustomNodeViewDesc.prototype.selectNode = function selectNode () {\n    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);\n  };\n\n  CustomNodeViewDesc.prototype.destroy = function destroy () {\n    if (this.spec.destroy) { this.spec.destroy(); }\n    NodeViewDesc.prototype.destroy.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  };\n\n  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)\n  };\n\n  return CustomNodeViewDesc;\n}(NodeViewDesc));\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n  var dom = parentDOM.firstChild, written = false;\n  for (var i = 0; i < descs.length; i++) {\n    var desc = descs[i], childDOM = desc.dom;\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); written = true; }\n      dom = dom.nextSibling;\n    } else {\n      written = true;\n      parentDOM.insertBefore(childDOM, dom);\n    }\n    if (desc instanceof MarkViewDesc) {\n      var pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children, view);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n  while (dom) { dom = rm(dom); written = true; }\n  if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) { this.nodeName = nodeName; }\n}\nOuterDecoLevel.prototype = Object.create(null);\n\nvar noDeco = [new OuterDecoLevel];\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) { return noDeco }\n\n  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n\n  for (var i = 0; i < outerDeco.length; i++) {\n    var attrs = outerDeco[i].type.attrs;\n    if (!attrs) { continue }\n    if (attrs.nodeName)\n      { result.push(top = new OuterDecoLevel(attrs.nodeName)); }\n\n    for (var name in attrs) {\n      var val = attrs[name];\n      if (val == null) { continue }\n      if (needsWrap && result.length == 1)\n        { result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\")); }\n      if (name == \"class\") { top.class = (top.class ? top.class + \" \" : \"\") + val; }\n      else if (name == \"style\") { top.style = (top.style ? top.style + \";\" : \"\") + val; }\n      else if (name != \"nodeName\") { top[name] = val; }\n    }\n  }\n\n  return result\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }\n\n  var curDOM = nodeDOM;\n  for (var i = 0; i < curComputed.length; i++) {\n    var deco = curComputed[i], prev = prevComputed[i];\n    if (i) {\n      var parent = (void 0);\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.pmIsDeco = true;\n        parent.appendChild(curDOM);\n        prev = noDeco[0];\n        curDOM = parent;\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (var name in prev)\n    { if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      { dom.removeAttribute(name); } }\n  for (var name$1 in cur)\n    { if (name$1 != \"class\" && name$1 != \"style\" && name$1 != \"nodeName\" && cur[name$1] != prev[name$1])\n      { dom.setAttribute(name$1, cur[name$1]); } }\n  if (prev.class != cur.class) {\n    var prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : nothing;\n    var curList = cur.class ? cur.class.split(\" \").filter(Boolean) : nothing;\n    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)\n      { dom.classList.remove(prevList[i]); } }\n    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)\n      { dom.classList.add(curList[i$1]); } }\n    if (dom.classList.length == 0)\n      { dom.removeAttribute(\"class\"); }\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      var prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n      while (m = prop.exec(prev.style))\n        { dom.style.removeProperty(m[1]); }\n    }\n    if (cur.style)\n      { dom.style.cssText += cur.style; }\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nvar ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {\n  this.top = top;\n  this.lock = lockedNode;\n  // Index into `this.top`'s child array, represents the current\n  // update position.\n  this.index = 0;\n  // When entering a mark, the current top and index are pushed\n  // onto this.\n  this.stack = [];\n  // Tracks whether anything was changed\n  this.changed = false;\n\n  this.preMatch = preMatch(top.node.content, top);\n};\n\n// Destroy and remove the children between the given indices in\n// `this.top`.\nViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {\n  if (start == end) { return }\n  for (var i = start; i < end; i++) { this.top.children[i].destroy(); }\n  this.top.children.splice(start, end - start);\n  this.changed = true;\n};\n\n// Destroy all remaining children in `this.top`.\nViewTreeUpdater.prototype.destroyRest = function destroyRest () {\n  this.destroyBetween(this.index, this.top.children.length);\n};\n\n// : ([Mark], EditorView)\n// Sync the current stack of mark descs with the given array of\n// marks, reusing existing mark descs when possible.\nViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {\n  var keep = 0, depth = this.stack.length >> 1;\n  var maxKeep = Math.min(depth, marks.length);\n  while (keep < maxKeep &&\n         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n    { keep++; }\n\n  while (keep < depth) {\n    this.destroyRest();\n    this.top.dirty = NOT_DIRTY;\n    this.index = this.stack.pop();\n    this.top = this.stack.pop();\n    depth--;\n  }\n  while (depth < marks.length) {\n    this.stack.push(this.top, this.index + 1);\n    var found = -1;\n    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n      if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }\n    }\n    if (found > -1) {\n      if (found > this.index) {\n        this.changed = true;\n        this.destroyBetween(this.index, found);\n      }\n      this.top = this.top.children[this.index];\n    } else {\n      var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n      this.top.children.splice(this.index, 0, markDesc);\n      this.top = markDesc;\n      this.changed = true;\n    }\n    this.index = 0;\n    depth++;\n  }\n};\n\n// : (Node, [Decoration], DecorationSource) → bool\n// Try to find a node desc matching the given data. Skip over it and\n// return true when successful.\nViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {\n  var found = -1, targetDesc;\n  if (index >= this.preMatch.index &&\n      (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n      targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n    found = this.top.children.indexOf(targetDesc, this.index);\n  } else {\n    for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n      var child = this.top.children[i];\n      if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n        found = i;\n        break\n      }\n    }\n  }\n  if (found < 0) { return false }\n  this.destroyBetween(this.index, found);\n  this.index++;\n  return true\n};\n\nViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt (node, outerDeco, innerDeco, index, view) {\n  var child = this.top.children[index];\n  if (!child.update(node, outerDeco, innerDeco, view)) { return false }\n  this.destroyBetween(this.index, index);\n  this.index = index + 1;\n  return true\n};\n\nViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild (domNode) {\n  for (;;) {\n    var parent = domNode.parentNode;\n    if (!parent) { return -1 }\n    if (parent == this.top.contentDOM) {\n      var desc = domNode.pmViewDesc;\n      if (desc) { for (var i = this.index; i < this.top.children.length; i++) {\n        if (this.top.children[i] == desc) { return i }\n      } }\n      return -1\n    }\n    domNode = parent;\n  }\n};\n\n// : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool\n// Try to update the next node, if any, to the given data. Checks\n// pre-matches to avoid overwriting nodes that could still be used.\nViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {\n  for (var i = this.index; i < this.top.children.length; i++) {\n    var next = this.top.children[i];\n    if (next instanceof NodeViewDesc) {\n      var preMatch = this.preMatch.matched.get(next);\n      if (preMatch != null && preMatch != index) { return false }\n      var nextDOM = next.dom;\n\n      // Can't update if nextDOM is or contains this.lock, except if\n      // it's a text node whose content already matches the new text\n      // and whose decorations match the new ones.\n      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&\n          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n      if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n        this.destroyBetween(this.index, i);\n        if (next.dom != nextDOM) { this.changed = true; }\n        this.index++;\n        return true\n      }\n      break\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSource, EditorView)\n// Insert the node as a newly created node desc.\nViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {\n  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));\n  this.changed = true;\n};\n\nViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {\n  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n  if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n    this.index++;\n  } else {\n    var desc = new WidgetViewDesc(this.top, widget, view, pos);\n    this.top.children.splice(this.index++, 0, desc);\n    this.changed = true;\n  }\n};\n\n// Make sure a textblock looks and behaves correctly in\n// contentEditable.\nViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {\n  var lastChild = this.top.children[this.index - 1];\n  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }\n\n  if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) ||\n      /\\n$/.test(lastChild.node.text)) {\n    // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n      { this.addHackNode(\"IMG\"); }\n    this.addHackNode(\"BR\");\n  }\n};\n\nViewTreeUpdater.prototype.addHackNode = function addHackNode (nodeName) {\n  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {\n    this.index++;\n  } else {\n    var dom = document.createElement(nodeName);\n    if (nodeName == \"IMG\") { dom.className = \"ProseMirror-separator\"; }\n    if (nodeName == \"BR\") { dom.className = \"ProseMirror-trailingBreak\"; }\n    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));\n    this.changed = true;\n  }\n};\n\n// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>, matches: ViewDesc[]}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n  var curDesc = parentDesc, descI = curDesc.children.length;\n  var fI = frag.childCount, matched = new Map, matches = [];\n  outer: while (fI > 0) {\n    var desc = (void 0);\n    for (;;) {\n      if (descI) {\n        var next = curDesc.children[descI - 1];\n        if (next instanceof MarkViewDesc) {\n          curDesc = next;\n          descI = next.children.length;\n        } else {\n          desc = next;\n          descI--;\n          break\n        }\n      } else if (curDesc == parentDesc) {\n        break outer\n      } else {\n        // FIXME\n        descI = curDesc.parent.children.indexOf(curDesc);\n        curDesc = curDesc.parent;\n      }\n    }\n    var node = desc.node;\n    if (!node) { continue }\n    if (node != frag.child(fI - 1)) { break }\n    --fI;\n    matched.set(desc, fI);\n    matches.push(desc);\n  }\n  return {index: fI, matched: matched, matches: matches.reverse()}\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  var locals = deco.locals(parent), offset = 0;\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (var i = 0; i < parent.childCount; i++) {\n      var child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n    return\n  }\n\n  var decoIndex = 0, active = [], restNode = null;\n  for (var parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      var widget = locals[decoIndex++], widgets = (void 0);\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }\n      if (widgets) {\n        widgets.sort(compareSide);\n        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }\n      } else {\n        onWidget(widget, parentIndex, !!restNode);\n      }\n    }\n\n    var child$1 = (void 0), index = (void 0);\n    if (restNode) {\n      index = -1;\n      child$1 = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex;\n      child$1 = parent.child(parentIndex++);\n    } else {\n      break\n    }\n\n    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      { active.push(locals[decoIndex++]); }\n\n    var end = offset + child$1.nodeSize;\n    if (child$1.isText) {\n      var cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }\n      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }\n      if (cutAt < end) {\n        restNode = child$1.cut(cutAt - offset);\n        child$1 = child$1.cut(0, cutAt - offset);\n        end = cutAt;\n        index = -1;\n      }\n    }\n\n    var outerDeco = !active.length ? nothing\n        : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })\n        : active.slice();\n    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);\n    offset = end;\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) { return node }\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        { return node.childNodes[offset] }\n      node = node.childNodes[offset - 1];\n      offset = nodeSize(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null\n    }\n  }\n}\n\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    var child = frag.child(i++), childStart = pos;\n    pos += child.nodeSize;\n    if (!child.isText) { continue }\n    var str = child.text;\n    while (i < frag.childCount) {\n      var next = frag.child(i++);\n      pos += next.nodeSize;\n      if (!next.isText) { break }\n      str += next.text;\n    }\n    if (pos >= from && childStart < to) {\n      var found = str.lastIndexOf(text, to - childStart - 1);\n      if (found >= 0 && found + text.length + childStart >= from)\n        { return childStart + found }\n    }\n  }\n  return -1\n}\n\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  var result = [];\n  for (var i = 0, off = 0; i < nodes.length; i++) {\n    var child = nodes[i], start = off, end = off += child.size;\n    if (start >= to || end <= from) {\n      result.push(child);\n    } else {\n      if (start < from) { result.push(child.slice(0, from - start, view)); }\n      if (replacement) {\n        result.push(replacement);\n        replacement = null;\n      }\n      if (end > to) { result.push(child.slice(to - start, child.size, view)); }\n    }\n  }\n  return result\n}\n\nfunction selectionFromDOM(view, origin) {\n  var domSel = view.root.getSelection(), doc = view.state.doc;\n  if (!domSel.focusNode) { return null }\n  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n  if (head < 0) { return null }\n  var $head = doc.resolve(head), $anchor, selection;\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head;\n    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }\n    if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent\n        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      var pos = nearestDesc.posBefore;\n      selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));\n    }\n  } else {\n    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n    if (anchor < 0) { return null }\n    $anchor = doc.resolve(anchor);\n  }\n\n  if (!selection) {\n    var bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n    selection = selectionBetween(view, $anchor, $head, bias);\n  }\n  return selection\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() :\n    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)\n}\n\nfunction selectionToDOM(view, force) {\n  var sel = view.state.selection;\n  syncNodeSelection(view, sel);\n\n  if (!editorOwnsSelection(view)) { return }\n\n  // The delayed drag selection causes issues with Cell Selections\n  // in Safari. And the drag selection delay is to workarond issues\n  // which only present in Chrome.\n  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {\n    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;\n    if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset,\n                                                  curSel.anchorNode, curSel.anchorOffset)) {\n      view.mouseDown.delayedSelectionSync = true;\n      view.domObserver.setCurSelection();\n      return\n    }\n  }\n\n  view.domObserver.disconnectSelection();\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    var anchor = sel.anchor;\n    var head = sel.head;\n    var resetEditableFrom, resetEditableTo;\n    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        { resetEditableTo = temporarilyEditableNear(view, sel.to); }\n    }\n    view.docView.setSelection(anchor, head, view.root, force);\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) { resetEditable(resetEditableFrom); }\n      if (resetEditableTo) { resetEditable(resetEditableTo); }\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document) { removeClassOnSelectionChange(view); }\n    }\n  }\n\n  view.domObserver.setCurSelection();\n  view.domObserver.connectSelection();\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nvar brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;\n\nfunction temporarilyEditableNear(view, pos) {\n  var ref = view.docView.domFromPos(pos, 0);\n  var node = ref.node;\n  var offset = ref.offset;\n  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  var before = offset ? node.childNodes[offset - 1] : null;\n  if (result.safari && after && after.contentEditable == \"false\") { return setEditable(after) }\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) { return setEditable(after) }\n    else if (before) { return setEditable(before) }\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\";\n  if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }\n  return element\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\";\n  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  var doc = view.dom.ownerDocument;\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n  var domSel = view.root.getSelection();\n  var node = domSel.anchorNode, offset = domSel.anchorOffset;\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = function () {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n      setTimeout(function () {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          { view.dom.classList.remove(\"ProseMirror-hideselection\"); }\n      }, 20);\n    }\n  });\n}\n\nfunction selectCursorWrapper(view) {\n  var domSel = view.root.getSelection(), range = document.createRange();\n  var node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n  if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }\n  else { range.setEnd(node, 0); }\n  range.collapse(false);\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\n\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof NodeSelection) {\n    var desc = view.docView.descAt(sel.from);\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc) { desc.selectNode(); }\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      { view.lastSelectedViewDesc.deselectNode(); }\n    view.lastSelectedViewDesc = null;\n  }\n}\n\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", function (f) { return f(view, $anchor, $head); })\n    || TextSelection.between($anchor, $head, bias)\n}\n\nfunction hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) { return false }\n  return hasSelection(view)\n}\n\nfunction hasSelection(view) {\n  var sel = view.root.getSelection();\n  if (!sel.anchorNode) { return false }\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nfunction anchorInRightPlace(view) {\n  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n  var domSel = view.root.getSelection();\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)\n}\n\nfunction moveSelectionBlock(state, dir) {\n  var ref = state.selection;\n  var $anchor = ref.$anchor;\n  var $head = ref.$head;\n  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  var sel = view.state.selection;\n  if (sel instanceof TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      var next = moveSelectionBlock(view.state, dir);\n      if (next && (next instanceof NodeSelection)) { return apply(view, next) }\n      return false\n    } else if (!(result.mac && mods.indexOf(\"m\") > -1)) {\n      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n      if (!node || node.isText) { return false }\n      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }\n      if (NodeSelection.isSelectable(node)) {\n        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))\n      } else if (result.webkit) {\n        // Chrome and Safari will introduce extra pointless cursor\n        // positions around inline uneditable nodes, so we have to\n        // take over and move the cursor past them (#937)\n        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))\n      } else {\n        return false\n      }\n    }\n  } else if (sel instanceof NodeSelection && sel.node.isInline) {\n    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    var next$1 = moveSelectionBlock(view.state, dir);\n    if (next$1) { return apply(view, next$1) }\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var moveNode, moveOffset, force = false;\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break\n      } else {\n        var before = node.childNodes[offset - 1];\n        if (isIgnorable(before)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else { break }\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var prev = node.previousSibling;\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n  if (force) { setSelFocus(view, sel, node, offset); }\n  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var len = nodeLen(node);\n  var moveNode, moveOffset;\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) { break }\n      var after = node.childNodes[offset];\n      if (isIgnorable(after)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      }\n      else { break }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var next = node.nextSibling;\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\nfunction isBlockNode(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    var range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n  view.domObserver.setCurSelection();\n  var state = view.state;\n  // If no state update ends up happening, reset the selection.\n  setTimeout(function () {\n    if (view.state == state) { selectionToDOM(view); }\n  }, 50);\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n  var sel = view.state.selection;\n  if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) { return false }\n  if (result.mac && mods.indexOf(\"m\") > -1) { return false }\n  var $from = sel.$from;\n  var $to = sel.$to;\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    var next = moveSelectionBlock(view.state, dir);\n    if (next && (next instanceof NodeSelection))\n      { return apply(view, next) }\n  }\n  if (!$from.parent.inlineContent) {\n    var side = dir < 0 ? $from : $to;\n    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);\n    return beyond ? apply(view, beyond) : false\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof TextSelection)) { return true }\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  var empty = ref.empty;\n  if (!$head.sameParent($anchor)) { return true }\n  if (!empty) { return false }\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) { return true }\n  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n  if (nextNode && !nextNode.isText) {\n    var tr = view.state.tr;\n    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }\n    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }\n    view.dispatch(tr);\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\n\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n  if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }\n  var ref = view.root.getSelection();\n  var focusNode = ref.focusNode;\n  var focusOffset = ref.focusOffset;\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    var child = focusNode.firstChild;\n    switchEditable(view, child, true);\n    setTimeout(function () { return switchEditable(view, child, false); }, 20);\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  var result = \"\";\n  if (event.ctrlKey) { result += \"c\"; }\n  if (event.metaKey) { result += \"m\"; }\n  if (event.altKey) { result += \"a\"; }\n  if (event.shiftKey) { result += \"s\"; }\n  return result\n}\n\nfunction captureKeyDown(view, event) {\n  var code = event.keyCode, mods = getMods(event);\n  if (code == 8 || (result.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (result.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)\n  } else if (mods == (result.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, from_, to_) {\n  var ref = view.docView.parseRange(from_, to_);\n  var parent = ref.node;\n  var fromOffset = ref.fromOffset;\n  var toOffset = ref.toOffset;\n  var from = ref.from;\n  var to = ref.to;\n\n  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}];\n    if (!selectionCollapsed(domSel))\n      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (result.chrome && view.lastKeyCode === 8) {\n    for (var off = toOffset; off > fromOffset; off--) {\n      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n      if (node.nodeName == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) { break }\n    }\n  }\n  var startDoc = view.state.doc;\n  var parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n  var $from = startDoc.resolve(from);\n\n  var sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode: ruleFromNode,\n    context: $from\n  });\n  if (find && find[0].pos != null) {\n    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;\n    if (head == null) { head = anchor$1; }\n    sel = {anchor: anchor$1 + from, head: head + from};\n  }\n  return {doc: doc, sel: sel, from: from, to: to}\n}\n\nfunction ruleFromNode(dom) {\n  var desc = dom.pmViewDesc;\n  if (desc) {\n    return desc.parseRule()\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    // Safari replaces the list item or table cell with a BR\n    // directly in the list node (?!) if you delete the last\n    // character in a list item or table cell (#708, #862)\n    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      var skip = document.createElement(\"div\");\n      skip.appendChild(document.createElement(\"li\"));\n      return {skip: skip}\n    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {ignore: true}\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {ignore: true}\n  }\n}\n\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;\n    var newSel = selectionFromDOM(view, origin);\n    if (newSel && !view.state.selection.eq(newSel)) {\n      var tr$1 = view.state.tr.setSelection(newSel);\n      if (origin == \"pointer\") { tr$1.setMeta(\"pointer\", true); }\n      else if (origin == \"key\") { tr$1.scrollIntoView(); }\n      view.dispatch(tr$1);\n    }\n    return\n  }\n\n  var $before = view.state.doc.resolve(from);\n  var shared = $before.sharedDepth(to);\n  from = $before.before(shared + 1);\n  to = view.state.doc.resolve(to).after(shared + 1);\n\n  var sel = view.state.selection;\n  var parse = parseBetween(view, from, to);\n  // Chrome sometimes leaves the cursor before the inserted text when\n  // composing after a cursor wrapper. This moves it forward.\n  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {\n    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;\n    var size = text && text.nodeValue ? text.nodeValue.length : 1;\n    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};\n  }\n\n  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n  var preferredPos, preferredSide;\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = view.state.selection.from;\n    preferredSide = \"start\";\n  }\n  view.lastKeyCode = null;\n\n  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n  if (!change) {\n    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {start: sel.from, endA: sel.to, endB: sel.to};\n    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) &&\n               addedNodes.some(function (n) { return n.nodeName == \"DIV\" || n.nodeName == \"P\"; }) &&\n               view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })) {\n      view.lastIOSEnter = 0;\n      return\n    } else {\n      if (parse.sel) {\n        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);\n        if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }\n      }\n      return\n    }\n  }\n  view.domChangeCount++;\n  // Handle the case where overwriting a selection by typing matches\n  // the start or end of the selected content, creating a change\n  // that's smaller than what was actually overwritten.\n  if (view.state.selection.from < view.state.selection.to &&\n      change.start == change.endB &&\n      view.state.selection instanceof TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {\n      change.start = view.state.selection.from;\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {\n      change.endB += (view.state.selection.to - change.endA);\n      change.endA = view.state.selection.to;\n    }\n  }\n\n  // IE11 will insert a non-breaking space _ahead_ of the space after\n  // the cursor space when adding a space before another space. When\n  // that happened, adjust the change to cover the space instead.\n  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&\n      change.endA == change.start && change.start > parse.from &&\n      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n    change.start--;\n    change.endA--;\n    change.endB--;\n  }\n\n  var $from = parse.doc.resolveNoCache(change.start - parse.from);\n  var $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;\n  var nextSel;\n  // If this looks like the effect of pressing Enter (or was recorded\n  // as being an iOS enter press), just dispatch an Enter key instead.\n  if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(function (n) { return n.nodeName == \"DIV\" || n.nodeName == \"P\"; }))) ||\n       (!inlineChange && $from.pos < parse.doc.content.size &&\n        (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n        nextSel.head == $to.pos)) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); })) {\n    view.lastIOSEnter = 0;\n    return\n  }\n  // Same for backspace\n  if (view.state.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); })) {\n    if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820\n    return\n  }\n\n  // Chrome Android will occasionally, during composition, delete the\n  // entire composition and then immediately insert it again. This is\n  // used to detect that situation.\n  if (result.chrome && result.android && change.toB == change.from)\n    { view.lastAndroidDelete = Date.now(); }\n\n  // This tries to detect Android virtual keyboard\n  // enter-and-pick-suggestion action. That sometimes (see issue\n  // #1059) first fires a DOM mutation, before moving the selection to\n  // the newly created block. And then, because ProseMirror cleans up\n  // the DOM selection, it gives up moving the selection entirely,\n  // leaving the cursor in the wrong place. When that happens, we drop\n  // the new paragraph from the initial change, and fire a simulated\n  // enter key afterwards.\n  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2;\n    $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    setTimeout(function () {\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n    }, 20);\n  }\n\n  var chFrom = change.start, chTo = change.endA;\n\n  var tr, storedMarks, markChange, $from1;\n  if (inlineChange) {\n    if ($from.pos == $to.pos) { // Deletion\n      // IE11 sometimes weirdly moves the DOM selection around after\n      // backspacing out the first element in a textblock\n      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates();\n        setTimeout(function () { return selectionToDOM(view); }, 20);\n      }\n      tr = view.state.tr.delete(chFrom, chTo);\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr;\n      if (markChange.type == \"add\") { tr.addMark(chFrom, chTo, markChange.mark); }\n      else { tr.removeMark(chFrom, chTo, markChange.mark); }\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      if (view.someProp(\"handleTextInput\", function (f) { return f(view, chFrom, chTo, text$1); })) { return }\n      tr = view.state.tr.insertText(text$1, chFrom, chTo);\n    }\n  }\n\n  if (!tr)\n    { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }\n  if (parse.sel) {\n    var sel$2 = resolveSelection(view, tr.doc, parse.sel);\n    // Chrome Android will sometimes, during composition, report the\n    // selection in the wrong place. If it looks like that is\n    // happening, don't update the selection.\n    // Edge just doesn't move the cursor forward when you start typing\n    // in an empty block or between br nodes.\n    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&\n                 (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) &&\n                 (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||\n                 result.ie && sel$2.empty && sel$2.head == chFrom))\n      { tr.setSelection(sel$2); }\n  }\n  if (storedMarks) { tr.ensureMarks(storedMarks); }\n  view.dispatch(tr.scrollIntoView());\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n  var added = curMarks, removed = prevMarks, type, mark, update;\n  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }\n  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n    update = function (node) { return node.mark(mark.addToSet(node.marks)); };\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };\n  } else {\n    return null\n  }\n  var updated = [];\n  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }\n  if (Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    { return false }\n\n  var $start = old.resolve(start);\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    { return false }\n  var $next = old.resolve(skipClosingAndOpening($start, true, true));\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    { return false }\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n  if (mayOpen) {\n    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  var start = a.findDiffStart(b, pos);\n  if (start == null) { return null }\n  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  var endA = ref.a;\n  var endB = ref.b;\n  if (preferredSide == \"end\") {\n    var adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n  if (endA < start && a.size < b.size) {\n    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n    start -= move$1;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return {start: start, endA: endA, endB: endB}\n}\n\nfunction serializeForClipboard(view, slice) {\n  var context = [];\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    var node = content.firstChild;\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n    content = node.content;\n  }\n\n  var serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema);\n  var doc = detachedDoc(), wrap = doc.createElement(\"div\");\n  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));\n\n  var firstChild = wrap.firstChild, needsWrap;\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (var i = needsWrap.length - 1; i >= 0; i--) {\n      var wrapper = doc.createElement(needsWrap[i]);\n      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }\n      wrap.appendChild(wrapper);\n      if (needsWrap[i] != \"tbody\") {\n        openStart++;\n        openEnd++;\n      }\n    }\n    firstChild = wrap.firstChild;\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    { firstChild.setAttribute(\"data-pm-slice\", (openStart + \" \" + openEnd + \" \" + (JSON.stringify(context)))); }\n\n  var text = view.someProp(\"clipboardTextSerializer\", function (f) { return f(slice); }) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n\n  return {dom: wrap, text: text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  var dom, inCode = $context.parent.type.spec.code, slice;\n  if (!html && !text) { return null }\n  var asText = text && (plainText || inCode || !html);\n  if (asText) {\n    view.someProp(\"transformPastedText\", function (f) { text = f(text, inCode || plainText); });\n    if (inCode) { return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : Slice.empty }\n    var parsed = view.someProp(\"clipboardTextParser\", function (f) { return f(text, $context, plainText); });\n    if (parsed) {\n      slice = parsed;\n    } else {\n      var marks = $context.marks();\n      var ref = view.state;\n      var schema = ref.schema;\n      var serializer = DOMSerializer.fromSchema(schema);\n      dom = document.createElement(\"div\");\n      text.split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n        var p = dom.appendChild(document.createElement(\"p\"));\n        if (block) { p.appendChild(serializer.serializeNode(schema.text(block, marks))); }\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", function (f) { html = f(html); });\n    dom = readHTML(html);\n    if (result.webkit) { restoreReplacedSpaces(dom); }\n  }\n\n  var contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  var sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"));\n  if (!slice) {\n    var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {\n      preserveWhitespace: !!(asText || sliceData),\n      context: $context,\n      ruleFromNode: function ruleFromNode(dom) {\n        if (dom.nodeName == \"BR\" && !dom.nextSibling &&\n            dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) { return {ignore: true} }\n      }\n    });\n  }\n  if (sliceData) {\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);\n  } else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n    if (slice.openStart || slice.openEnd) {\n      var openStart = 0, openEnd = 0;\n      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating;\n           openStart++, node = node.firstChild) {}\n      for (var node$1 = slice.content.lastChild; openEnd < slice.openEnd && !node$1.type.spec.isolating;\n           openEnd++, node$1 = node$1.lastChild) {}\n      slice = closeSlice(slice, openStart, openEnd);\n    }\n  }\n\n  view.someProp(\"transformPasted\", function (f) { slice = f(slice); });\n  return slice\n}\n\nvar inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) { return fragment }\n  var loop = function ( d ) {\n    var parent = $context.node(d);\n    var match = parent.contentMatchAt($context.index(d));\n    var lastWrap = (void 0), result = [];\n    fragment.forEach(function (node) {\n      if (!result) { return }\n      var wrap = match.findWrapping(node.type), inLast;\n      if (!wrap) { return result = null }\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }\n        var wrapped = withWrappers(node, wrap);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type, wrapped.attrs);\n        lastWrap = wrap;\n      }\n    });\n    if (result) { return { v: Fragment.from(result) } }\n  };\n\n  for (var d = $context.depth; d >= 0; d--) {\n    var returned = loop( d );\n\n    if ( returned ) return returned.v;\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from) {\n  if ( from === void 0 ) from = 0;\n\n  for (var i = wrap.length - 1; i >= from; i--)\n    { node = wrap[i].create(null, Fragment.from(node)); }\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }\n    var match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      { return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1)))) }\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) { return node }\n  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);\n  return node.copy(fragment.append(fill))\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n  if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }\n  if (depth >= from)\n    { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n      : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)); }\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    { slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }\n  if (openEnd < slice.openEnd)\n    { slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }\n  return slice\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nvar wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n};\n\nvar _detachedDoc = null;\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n}\n\nfunction readHTML(html) {\n  var metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas) { html = html.slice(metas[0].length); }\n  var elt = detachedDoc().createElement(\"div\");\n  var firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    { html = wrap.map(function (n) { return \"<\" + n + \">\"; }).join(\"\") + html + wrap.map(function (n) { return \"</\" + n + \">\"; }).reverse().join(\"\"); }\n  elt.innerHTML = html;\n  if (wrap) { for (var i = 0; i < wrap.length; i++) { elt = elt.querySelector(wrap[i]) || elt; } }\n  return elt\n}\n\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n  var nodes = dom.querySelectorAll(result.chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (node.childNodes.length == 1 && node.textContent == \"\\u00a0\" && node.parentNode)\n      { node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node); }\n  }\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) { return slice }\n  var schema = slice.content.firstChild.type.schema, array;\n  try { array = JSON.parse(context); }\n  catch(e) { return slice }\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  for (var i = array.length - 2; i >= 0; i -= 2) {\n    var type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs()) { break }\n    content = Fragment.from(type.create(array[i + 1], content));\n    openStart++; openEnd++;\n  }\n  return new Slice(content, openStart, openEnd)\n}\n\nvar observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nvar useCharData = result.ie && result.ie_version <= 11;\n\nvar SelectionState = function SelectionState() {\n  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;\n};\n\nSelectionState.prototype.set = function set (sel) {\n  this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;\n  this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;\n};\n\nSelectionState.prototype.eq = function eq (sel) {\n  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n    sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset\n};\n\nvar DOMObserver = function DOMObserver(view, handleDOMChange) {\n  var this$1 = this;\n\n  this.view = view;\n  this.handleDOMChange = handleDOMChange;\n  this.queue = [];\n  this.flushingSoon = -1;\n  this.observer = window.MutationObserver &&\n    new window.MutationObserver(function (mutations) {\n      for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }\n      // IE11 will sometimes (on backspacing out a single character\n      // text node after a BR node) call the observer callback\n      // before actually updating the DOM, which will cause\n      // ProseMirror to miss the change (see #930)\n      if (result.ie && result.ie_version <= 11 && mutations.some(\n        function (m) { return m.type == \"childList\" && m.removedNodes.length ||\n             m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length; }))\n        { this$1.flushSoon(); }\n      else\n        { this$1.flush(); }\n    });\n  this.currentSelection = new SelectionState;\n  if (useCharData) {\n    this.onCharData = function (e) {\n      this$1.queue.push({target: e.target, type: \"characterData\", oldValue: e.prevValue});\n      this$1.flushSoon();\n    };\n  }\n  this.onSelectionChange = this.onSelectionChange.bind(this);\n  this.suppressingSelectionUpdates = false;\n};\n\nDOMObserver.prototype.flushSoon = function flushSoon () {\n    var this$1 = this;\n\n  if (this.flushingSoon < 0)\n    { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }\n};\n\nDOMObserver.prototype.forceFlush = function forceFlush () {\n  if (this.flushingSoon > -1) {\n    window.clearTimeout(this.flushingSoon);\n    this.flushingSoon = -1;\n    this.flush();\n  }\n};\n\nDOMObserver.prototype.start = function start () {\n  if (this.observer)\n    { this.observer.observe(this.view.dom, observeOptions); }\n  if (useCharData)\n    { this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n  this.connectSelection();\n};\n\nDOMObserver.prototype.stop = function stop () {\n    var this$1 = this;\n\n  if (this.observer) {\n    var take = this.observer.takeRecords();\n    if (take.length) {\n      for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }\n      window.setTimeout(function () { return this$1.flush(); }, 20);\n    }\n    this.observer.disconnect();\n  }\n  if (useCharData) { this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n  this.disconnectSelection();\n};\n\nDOMObserver.prototype.connectSelection = function connectSelection () {\n  this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n};\n\nDOMObserver.prototype.disconnectSelection = function disconnectSelection () {\n  this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n};\n\nDOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {\n    var this$1 = this;\n\n  this.suppressingSelectionUpdates = true;\n  setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);\n};\n\nDOMObserver.prototype.onSelectionChange = function onSelectionChange () {\n  if (!hasFocusAndSelection(this.view)) { return }\n  if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }\n  // Deletions on IE11 fire their events in the wrong order, giving\n  // us a selection change event before the DOM changes are\n  // reported.\n  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {\n    var sel = this.view.root.getSelection();\n    // Selection.isCollapsed isn't reliable on IE\n    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n      { return this.flushSoon() }\n  }\n  this.flush();\n};\n\nDOMObserver.prototype.setCurSelection = function setCurSelection () {\n  this.currentSelection.set(this.view.root.getSelection());\n};\n\nDOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {\n  if (sel.rangeCount == 0) { return true }\n  var container = sel.getRangeAt(0).commonAncestorContainer;\n  var desc = this.view.docView.nearestDesc(container);\n  if (desc && desc.ignoreMutation({type: \"selection\", target: container.nodeType == 3 ? container.parentNode : container})) {\n    this.setCurSelection();\n    return true\n  }\n};\n\nDOMObserver.prototype.flush = function flush () {\n  if (!this.view.docView || this.flushingSoon > -1) { return }\n  var mutations = this.observer ? this.observer.takeRecords() : [];\n  if (this.queue.length) {\n    mutations = this.queue.concat(mutations);\n    this.queue.length = 0;\n  }\n\n  var sel = this.view.root.getSelection();\n  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);\n\n  var from = -1, to = -1, typeOver = false, added = [];\n  if (this.view.editable) {\n    for (var i = 0; i < mutations.length; i++) {\n      var result$1 = this.registerMutation(mutations[i], added);\n      if (result$1) {\n        from = from < 0 ? result$1.from : Math.min(result$1.from, from);\n        to = to < 0 ? result$1.to : Math.max(result$1.to, to);\n        if (result$1.typeOver) { typeOver = true; }\n      }\n    }\n  }\n\n  if (result.gecko && added.length > 1) {\n    var brs = added.filter(function (n) { return n.nodeName == \"BR\"; });\n    if (brs.length == 2) {\n      var a = brs[0];\n        var b = brs[1];\n      if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }\n      else { a.remove(); }\n    }\n  }\n\n  if (from > -1 || newSel) {\n    if (from > -1) {\n      this.view.docView.markDirty(from, to);\n      checkCSS(this.view);\n    }\n    this.handleDOMChange(from, to, typeOver, added);\n    if (this.view.docView.dirty) { this.view.updateState(this.view.state); }\n    else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }\n    this.currentSelection.set(sel);\n  }\n};\n\nDOMObserver.prototype.registerMutation = function registerMutation (mut, added) {\n  // Ignore mutations inside nodes that were already noted as inserted\n  if (added.indexOf(mut.target) > -1) { return null }\n  var desc = this.view.docView.nearestDesc(mut.target);\n  if (mut.type == \"attributes\" &&\n      (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n       // Firefox sometimes fires spurious events for null/empty styles\n       (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n    { return null }\n  if (!desc || desc.ignoreMutation(mut)) { return null }\n\n  if (mut.type == \"childList\") {\n    for (var i = 0; i < mut.addedNodes.length; i++) { added.push(mut.addedNodes[i]); }\n    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n      { return {from: desc.posBefore, to: desc.posAfter} }\n    var prev = mut.previousSibling, next = mut.nextSibling;\n    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {\n      // IE11 gives us incorrect next/prev siblings for some\n      // insertions, so if there are added nodes, recompute those\n      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {\n        var ref = mut.addedNodes[i$1];\n          var previousSibling = ref.previousSibling;\n          var nextSibling = ref.nextSibling;\n        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }\n        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }\n      }\n    }\n    var fromOffset = prev && prev.parentNode == mut.target\n        ? domIndex(prev) + 1 : 0;\n    var from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n    var toOffset = next && next.parentNode == mut.target\n        ? domIndex(next) : mut.target.childNodes.length;\n    var to = desc.localPosFromDOM(mut.target, toOffset, 1);\n    return {from: from, to: to}\n  } else if (mut.type == \"attributes\") {\n    return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}\n  } else { // \"characterData\"\n    return {\n      from: desc.posAtStart,\n      to: desc.posAtEnd,\n      // An event was generated for a text change that didn't change\n      // any text. Mark the dom change to fall back to assuming the\n      // selection was typed over with an identical value if it can't\n      // find another change.\n      typeOver: mut.target.nodeValue == mut.oldValue\n    }\n  }\n};\n\nvar cssChecked = false;\n\nfunction checkCSS(view) {\n  if (cssChecked) { return }\n  cssChecked = true;\n  if (getComputedStyle(view.dom).whiteSpace == \"normal\")\n    { console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\"); }\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nvar handlers = {}, editHandlers = {};\n\nfunction initInput(view) {\n  view.shiftKey = false;\n  view.mouseDown = null;\n  view.lastKeyCode = null;\n  view.lastKeyCodeTime = 0;\n  view.lastClick = {time: 0, x: 0, y: 0, type: \"\"};\n  view.lastSelectionOrigin = null;\n  view.lastSelectionTime = 0;\n\n  view.lastIOSEnter = 0;\n  view.lastIOSEnterFallbackTimeout = null;\n  view.lastAndroidDelete = 0;\n\n  view.composing = false;\n  view.composingTimeout = null;\n  view.compositionNodes = [];\n  view.compositionEndedAt = -2e8;\n\n  view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });\n  view.domObserver.start();\n  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM\n  view.domChangeCount = 0;\n\n  view.eventHandlers = Object.create(null);\n  var loop = function ( event ) {\n    var handler = handlers[event];\n    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        { handler(view, event); }\n    });\n  };\n\n  for (var event in handlers) loop( event );\n  // On Safari, for reasons beyond my understanding, adding an input\n  // event handler makes an issue where the composition vanishes when\n  // you press enter go away.\n  if (result.safari) { view.dom.addEventListener(\"input\", function () { return null; }); }\n\n  ensureListeners(view);\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.lastSelectionOrigin = origin;\n  view.lastSelectionTime = Date.now();\n}\n\nfunction destroyInput(view) {\n  view.domObserver.stop();\n  for (var type in view.eventHandlers)\n    { view.dom.removeEventListener(type, view.eventHandlers[type]); }\n  clearTimeout(view.composingTimeout);\n  clearTimeout(view.lastIOSEnterFallbackTimeout);\n}\n\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", function (currentHandlers) {\n    for (var type in currentHandlers) { if (!view.eventHandlers[type])\n      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }\n  });\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", function (handlers) {\n    var handler = handlers[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) { return true }\n  if (event.defaultPrevented) { return false }\n  for (var node = event.target; node != view.dom; node = node.parentNode)\n    { if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      { return false } }\n  return true\n}\n\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    { handlers[event.type](view, event); }\n}\n\neditHandlers.keydown = function (view, event) {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (inOrNearComposition(view, event)) { return }\n  view.lastKeyCode = event.keyCode;\n  view.lastKeyCodeTime = Date.now();\n  // Suppress enter key events on Chrome Android, because those tend\n  // to be part of a confused sequence of composition events fired,\n  // and handling them eagerly tends to corrupt the input.\n  if (result.android && result.chrome && event.keyCode == 13) { return }\n  if (event.keyCode != 229) { view.domObserver.forceFlush(); }\n\n  // On iOS, if we preventDefault enter key presses, the virtual\n  // keyboard gets confused. So the hack here is to set a flag that\n  // makes the DOM change code recognize that what just happens should\n  // be replaced by whatever the Enter key handlers do.\n  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    var now = Date.now();\n    view.lastIOSEnter = now;\n    view.lastIOSEnterFallbackTimeout = setTimeout(function () {\n      if (view.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n        view.lastIOSEnter = 0;\n      }\n    }, 200);\n  } else if (view.someProp(\"handleKeyDown\", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"key\");\n  }\n};\n\neditHandlers.keyup = function (view, e) {\n  if (e.keyCode == 16) { view.shiftKey = false; }\n};\n\neditHandlers.keypress = function (view, event) {\n  if (inOrNearComposition(view, event) || !event.charCode ||\n      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }\n\n  if (view.someProp(\"handleKeyPress\", function (f) { return f(view, event); })) {\n    event.preventDefault();\n    return\n  }\n\n  var sel = view.state.selection;\n  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    var text = String.fromCharCode(event.charCode);\n    if (!view.someProp(\"handleTextInput\", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))\n      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }\n    event.preventDefault();\n  }\n};\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nfunction isNear(event, click) {\n  var dx = click.x - event.clientX, dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside);\n  var loop = function ( i ) {\n    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))\n      { return { v: true } }\n  };\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) { view.focus(); }\n  var tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true); }\n  view.dispatch(tr);\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n  if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n    updateSelection(view, new NodeSelection($pos), \"pointer\");\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) { return false }\n  var sel = view.state.selection, selectedNode, selectAt;\n  if (sel instanceof NodeSelection) { selectedNode = sel.node; }\n\n  var $pos = view.state.doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    if (NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        { selectAt = $pos.before(sel.$from.depth); }\n      else\n        { selectAt = $pos.before(i); }\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", function (f) { return f(view, pos, event); }) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", function (f) { return f(view, pos, event); })\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", function (f) { return f(view, pos, event); }) ||\n    defaultTripleClick(view, inside, event)\n}\n\nfunction defaultTripleClick(view, inside, event) {\n  if (event.button != 0) { return false }\n  var doc = view.state.doc;\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n      return true\n    }\n    return false\n  }\n\n  var $pos = doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    var nodePos = $pos.before(i);\n    if (node.inlineContent)\n      { updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\"); }\n    else if (NodeSelection.isSelectable(node))\n      { updateSelection(view, NodeSelection.create(doc, nodePos), \"pointer\"); }\n    else\n      { continue }\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view)\n}\n\nvar selectNodeModifier = result.mac ? \"metaKey\" : \"ctrlKey\";\n\nhandlers.mousedown = function (view, event) {\n  view.shiftKey = event.shiftKey;\n  var flushed = forceDOMFlush(view);\n  var now = Date.now(), type = \"singleClick\";\n  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {\n    if (view.lastClick.type == \"singleClick\") { type = \"doubleClick\"; }\n    else if (view.lastClick.type == \"doubleClick\") { type = \"tripleClick\"; }\n  }\n  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};\n\n  var pos = view.posAtCoords(eventCoords(event));\n  if (!pos) { return }\n\n  if (type == \"singleClick\") {\n    if (view.mouseDown) { view.mouseDown.done(); }\n    view.mouseDown = new MouseDown(view, pos, event, flushed);\n  } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"pointer\");\n  }\n};\n\nvar MouseDown = function MouseDown(view, pos, event, flushed) {\n  var this$1 = this;\n\n  this.view = view;\n  this.startDoc = view.state.doc;\n  this.pos = pos;\n  this.event = event;\n  this.flushed = flushed;\n  this.selectNode = event[selectNodeModifier];\n  this.allowDefault = event.shiftKey;\n  this.delayedSelectionSync = false;\n\n  var targetNode, targetPos;\n  if (pos.inside > -1) {\n    targetNode = view.state.doc.nodeAt(pos.inside);\n    targetPos = pos.inside;\n  } else {\n    var $pos = view.state.doc.resolve(pos.pos);\n    targetNode = $pos.parent;\n    targetPos = $pos.depth ? $pos.before() : 0;\n  }\n\n  this.mightDrag = null;\n\n  var target = flushed ? null : event.target;\n  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n  this.target = targetDesc ? targetDesc.dom : null;\n\n  var ref = view.state;\n  var selection = ref.selection;\n  if (event.button == 0 &&\n      targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n      selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n    { this.mightDrag = {node: targetNode,\n                      pos: targetPos,\n                      addAttr: this.target && !this.target.draggable,\n                      setUneditable: this.target && result.gecko && !this.target.hasAttribute(\"contentEditable\")}; }\n\n  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.draggable = true; }\n    if (this.mightDrag.setUneditable)\n      { setTimeout(function () {\n        if (this$1.view.mouseDown == this$1) { this$1.target.setAttribute(\"contentEditable\", \"false\"); }\n      }, 20); }\n    this.view.domObserver.start();\n  }\n\n  view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n  view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n  setSelectionOrigin(view, \"pointer\");\n};\n\nMouseDown.prototype.done = function done () {\n    var this$1 = this;\n\n  this.view.root.removeEventListener(\"mouseup\", this.up);\n  this.view.root.removeEventListener(\"mousemove\", this.move);\n  if (this.mightDrag && this.target) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.removeAttribute(\"draggable\"); }\n    if (this.mightDrag.setUneditable) { this.target.removeAttribute(\"contentEditable\"); }\n    this.view.domObserver.start();\n  }\n  if (this.delayedSelectionSync) { setTimeout(function () { return selectionToDOM(this$1.view); }); }\n  this.view.mouseDown = null;\n};\n\nMouseDown.prototype.up = function up (event) {\n  this.done();\n\n  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n    { return }\n\n  var pos = this.pos;\n  if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }\n\n  if (this.allowDefault || !pos) {\n    setSelectionOrigin(this.view, \"pointer\");\n  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n    event.preventDefault();\n  } else if (event.button == 0 &&\n             (this.flushed ||\n              // Safari ignores clicks on draggable elements\n              (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n              // Chrome will sometimes treat a node selection as a\n              // cursor, but still report that the node is selected\n              // when asked through getSelection. You'll then get a\n              // situation where clicking at the point where that\n              // (hidden) cursor is doesn't change the selection, and\n              // thus doesn't get a reaction from ProseMirror. This\n              // works around that.\n              (result.chrome && !(this.view.state.selection instanceof TextSelection) &&\n               Math.min(Math.abs(pos.pos - this.view.state.selection.from),\n                        Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n    updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(this.view, \"pointer\");\n  }\n};\n\nMouseDown.prototype.move = function move (event) {\n  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                             Math.abs(this.event.y - event.clientY) > 4))\n    { this.allowDefault = true; }\n  setSelectionOrigin(this.view, \"pointer\");\n  if (event.buttons == 0) { this.done(); }\n};\n\nhandlers.touchdown = function (view) {\n  forceDOMFlush(view);\n  setSelectionOrigin(view, \"pointer\");\n};\n\nhandlers.contextmenu = function (view) { return forceDOMFlush(view); };\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) { return true }\n  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n  // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n  // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n  // emitted. The keydown event triggers newline insertion, which we don't want.\n  // This method returns true if the keydown event should be ignored.\n  // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n  // This guards against the case where compositionend is triggered without the keyboard\n  // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n  // afterwards- we wouldn't want to ignore the keydown event in this case.\n  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {\n    view.compositionEndedAt = -2e8;\n    return true\n  }\n  return false\n}\n\n// Drop active composition after 5 seconds of inactivity on Android\nvar timeoutComposition = result.android ? 5000 : -1;\n\neditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n  if (!view.composing) {\n    view.domObserver.flush();\n    var state = view.state;\n    var $pos = state.selection.$from;\n    if (state.selection.empty &&\n        (state.storedMarks ||\n         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {\n      // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n      view.markCursor = view.state.storedMarks || $pos.marks();\n      endComposition(view, true);\n      view.markCursor = null;\n    } else {\n      endComposition(view);\n      // In firefox, if the cursor is after but outside a marked node,\n      // the inserted text won't inherit the marks. So this moves it\n      // inside if necessary.\n      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        var sel = view.root.getSelection();\n        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n          if (!before) { break }\n          if (before.nodeType == 3) {\n            sel.collapse(before, before.nodeValue.length);\n            break\n          } else {\n            node = before;\n            offset = -1;\n          }\n        }\n      }\n    }\n    view.composing = true;\n  }\n  scheduleComposeEnd(view, timeoutComposition);\n};\n\neditHandlers.compositionend = function (view, event) {\n  if (view.composing) {\n    view.composing = false;\n    view.compositionEndedAt = event.timeStamp;\n    scheduleComposeEnd(view, 20);\n  }\n};\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.composingTimeout);\n  if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }\n}\n\nfunction clearComposition(view) {\n  if (view.composing) {\n    view.composing = false;\n    view.compositionEndedAt = timestampFromCustomEvent();\n  }\n  while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }\n}\n\nfunction timestampFromCustomEvent() {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"event\", true, true);\n  return event.timeStamp\n}\n\nfunction endComposition(view, forceUpdate) {\n  if (result.android && view.domObserver.flushingSoon >= 0) { return }\n  view.domObserver.forceFlush();\n  clearComposition(view);\n  if (forceUpdate || view.docView.dirty) {\n    var sel = selectionFromDOM(view);\n    if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }\n    else { view.updateState(view.state); }\n    return true\n  }\n  return false\n}\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  if (!view.dom.parentNode) { return }\n  var wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n  wrap.appendChild(dom);\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  var sel = getSelection(), range = document.createRange();\n  range.selectNodeContents(dom);\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(function () {\n    if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }\n    view.focus();\n  }, 50);\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nvar brokenClipboardAPI = (result.ie && result.ie_version < 15) ||\n      (result.ios && result.webkit_version < 604);\n\nhandlers.copy = editHandlers.cut = function (view, e) {\n  var sel = view.state.selection, cut = e.type == \"cut\";\n  if (sel.empty) { return }\n\n  // IE and Edge's clipboard interface is completely broken\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  var slice = sel.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  if (data) {\n    e.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\")); }\n};\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  if (!view.dom.parentNode) { return }\n  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText) { target.contentEditable = \"true\"; }\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(function () {\n    view.focus();\n    if (target.parentNode) { target.parentNode.removeChild(target); }\n    if (plainText) { doPaste(view, target.value, null, e); }\n    else { doPaste(view, target.textContent, target.innerHTML, e); }\n  }, 50);\n}\n\nfunction doPaste(view, text, html, e) {\n  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);\n  if (view.someProp(\"handlePaste\", function (f) { return f(view, e, slice || Slice.empty); })) { return true }\n  if (!slice) { return false }\n\n  var singleNode = sliceSingleNode(slice);\n  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true\n}\n\neditHandlers.paste = function (view, e) {\n  // Handling paste from JavaScript during composition is very poorly\n  // handled by browsers, so as a dodgy but preferable kludge, we just\n  // let the browser do its native thing there, except on Android,\n  // where the editor is almost always composing.\n  if (view.composing && !result.android) { return }\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e)) { e.preventDefault(); }\n  else { capturePaste(view, e); }\n};\n\nvar Dragging = function Dragging(slice, move) {\n  this.slice = slice;\n  this.move = move;\n};\n\nvar dragCopyModifier = result.mac ? \"altKey\" : \"ctrlKey\";\n\nhandlers.dragstart = function (view, e) {\n  var mouseDown = view.mouseDown;\n  if (mouseDown) { mouseDown.done(); }\n  if (!e.dataTransfer) { return }\n\n  var sel = view.state.selection;\n  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n  } else if (e.target && e.target.nodeType == 1) {\n    var desc = view.docView.nearestDesc(e.target, true);\n    if (desc && desc.node.type.spec.draggable && desc != view.docView)\n      { view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore))); }\n  }\n  var slice = view.state.selection.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  e.dataTransfer.clearData();\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  // See https://github.com/ProseMirror/prosemirror/issues/1156\n  e.dataTransfer.effectAllowed = \"copyMove\";\n  if (!brokenClipboardAPI) { e.dataTransfer.setData(\"text/plain\", text); }\n  view.dragging = new Dragging(slice, !e[dragCopyModifier]);\n};\n\nhandlers.dragend = function (view) {\n  var dragging = view.dragging;\n  window.setTimeout(function () {\n    if (view.dragging == dragging)  { view.dragging = null; }\n  }, 50);\n};\n\neditHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };\n\neditHandlers.drop = function (view, e) {\n  var dragging = view.dragging;\n  view.dragging = null;\n\n  if (!e.dataTransfer) { return }\n\n  var eventPos = view.posAtCoords(eventCoords(e));\n  if (!eventPos) { return }\n  var $mouse = view.state.doc.resolve(eventPos.pos);\n  if (!$mouse) { return }\n  var slice = dragging && dragging.slice;\n  if (slice) {\n    view.someProp(\"transformPasted\", function (f) { slice = f(slice); });\n  } else {\n    slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                               brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse);\n  }\n  var move = dragging && !e[dragCopyModifier];\n  if (view.someProp(\"handleDrop\", function (f) { return f(view, e, slice || Slice.empty, move); })) {\n    e.preventDefault();\n    return\n  }\n  if (!slice) { return }\n\n  e.preventDefault();\n  var insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null) { insertPos = $mouse.pos; }\n\n  var tr = view.state.tr;\n  if (move) { tr.deleteSelection(); }\n\n  var pos = tr.mapping.map(insertPos);\n  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  var beforeInsert = tr.doc;\n  if (isNode)\n    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }\n  else\n    { tr.replaceRange(pos, pos, slice); }\n  if (tr.doc.eq(beforeInsert)) { return }\n\n  var $pos = tr.doc.resolve(pos);\n  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new NodeSelection($pos));\n  } else {\n    var end = tr.mapping.map(insertPos);\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n  }\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\n\nhandlers.focus = function (view) {\n  if (!view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.domObserver.start();\n    view.focused = true;\n    setTimeout(function () {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))\n        { selectionToDOM(view); }\n    }, 20);\n  }\n};\n\nhandlers.blur = function (view, e) {\n  if (view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.domObserver.start();\n    if (e.relatedTarget && view.dom.contains(e.relatedTarget))\n      { view.domObserver.currentSelection.set({}); }\n    view.focused = false;\n  }\n};\n\nhandlers.beforeinput = function (view, event) {\n  // We should probably do more with beforeinput events, but support\n  // is so spotty that I'm still waiting to see where they are going.\n\n  // Very specific hack to deal with backspace sometimes failing on\n  // Chrome Android when after an uneditable node.\n  if (result.chrome && result.android && event.inputType == \"deleteContentBackward\") {\n    view.domObserver.flushSoon();\n    var domChangeCount = view.domChangeCount;\n    setTimeout(function () {\n      if (view.domChangeCount != domChangeCount) { return } // Event already had some effect\n      // This bug tends to close the virtual keyboard, so we refocus\n      view.dom.blur();\n      view.focus();\n      if (view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); })) { return }\n      var ref = view.state.selection;\n      var $cursor = ref.$cursor;\n      // Crude approximation of backspace behavior when no command handled it\n      if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }\n    }, 50);\n  }\n};\n\n// Make sure all handlers get registered\nfor (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }\n\nfunction compareObjs(a, b) {\n  if (a == b) { return true }\n  for (var p in a) { if (a[p] !== b[p]) { return false } }\n  for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  return true\n}\n\nvar WidgetType = function WidgetType(toDOM, spec) {\n  this.spec = spec || noSpec;\n  this.side = this.spec.side || 0;\n  this.toDOM = toDOM;\n};\n\nWidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n    var pos = ref.pos;\n    var deleted = ref.deleted;\n  return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n};\n\nWidgetType.prototype.valid = function valid () { return true };\n\nWidgetType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof WidgetType &&\n     (this.spec.key && this.spec.key == other.spec.key ||\n      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n};\n\nWidgetType.prototype.destroy = function destroy (node) {\n  if (this.spec.destroy) { this.spec.destroy(node); }\n};\n\nvar InlineType = function InlineType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nInlineType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n  return from >= to ? null : new Decoration(from, to, this)\n};\n\nInlineType.prototype.valid = function valid (_, span) { return span.from < span.to };\n\nInlineType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\nInlineType.is = function is (span) { return span.type instanceof InlineType };\n\nvar NodeType = function NodeType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nNodeType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.mapResult(span.from + oldOffset, 1);\n  if (from.deleted) { return null }\n  var to = mapping.mapResult(span.to + oldOffset, -1);\n  if (to.deleted || to.pos <= from.pos) { return null }\n  return new Decoration(from.pos - offset, to.pos - offset, this)\n};\n\nNodeType.prototype.valid = function valid (node, span) {\n  var ref = node.content.findIndex(span.from);\n    var index = ref.index;\n    var offset = ref.offset;\n    var child;\n  return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to\n};\n\nNodeType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nvar Decoration = function Decoration(from, to, type) {\n  // :: number\n  // The start position of the decoration.\n  this.from = from;\n  // :: number\n  // The end position. Will be the same as `from` for [widget\n  // decorations](#view.Decoration^widget).\n  this.to = to;\n  this.type = type;\n};\n\nvar prototypeAccessors$1 = { spec: { configurable: true },inline: { configurable: true } };\n\nDecoration.prototype.copy = function copy (from, to) {\n  return new Decoration(from, to, this.type)\n};\n\nDecoration.prototype.eq = function eq (other, offset) {\n    if ( offset === void 0 ) offset = 0;\n\n  return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to\n};\n\nDecoration.prototype.map = function map (mapping, offset, oldOffset) {\n  return this.type.map(mapping, this, offset, oldOffset)\n};\n\n// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n// Creates a widget decoration, which is a DOM node that's shown in\n// the document at the given position. It is recommended that you\n// delay rendering the widget by passing a function that will be\n// called when the widget is actually drawn in a view, but you can\n// also directly pass a DOM node. `getPos` can be used to find the\n// widget's current document position.\n//\n// spec::- These options are supported:\n//\n//   side:: ?number\n//   Controls which side of the document position this widget is\n//   associated with. When negative, it is drawn before a cursor\n//   at its position, and content inserted at that position ends\n//   up after the widget. When zero (the default) or positive, the\n//   widget is drawn after the cursor and content inserted there\n//   ends up before the widget.\n//\n//   When there are multiple widgets at a given position, their\n//   `side` values determine the order in which they appear. Those\n//   with lower values appear first. The ordering of widgets with\n//   the same `side` value is unspecified.\n//\n//   When `marks` is null, `side` also determines the marks that\n//   the widget is wrapped in—those of the node before when\n//   negative, those of the node after when positive.\n//\n//   marks:: ?[Mark]\n//   The precise set of marks to draw around the widget.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to control which DOM events, when they bubble out\n//   of this widget, the editor view should ignore.\n//\n//   ignoreSelection:: ?bool\n//   When set (defaults to false), selection changes inside the\n//   widget are ignored, and don't cause ProseMirror to try and\n//   re-sync the selection with its selection state.\n//\n//   key:: ?string\n//   When comparing decorations of this type (in order to decide\n//   whether it needs to be redrawn), ProseMirror will by default\n//   compare the widget DOM node by identity. If you pass a key,\n//   that key will be compared instead, which can be useful when\n//   you generate decorations on the fly and don't want to store\n//   and reuse DOM nodes. Make sure that any widgets with the same\n//   key are interchangeable—if widgets differ in, for example,\n//   the behavior of some event handler, they should get\n//   different keys.\n//\n//   destroy:: ?(node: dom.Node)\n//   Called when the widget decoration is removed as a result of\n//   mapping\nDecoration.widget = function widget (pos, toDOM, spec) {\n  return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates an inline decoration, which adds the given attributes to\n// each inline node between `from` and `to`.\n//\n// spec::- These options are recognized:\n//\n//   inclusiveStart:: ?bool\n//   Determines how the left side of the decoration is\n//   [mapped](#transform.Position_Mapping) when content is\n//   inserted directly at that position. By default, the decoration\n//   won't include the new content, but you can set this to `true`\n//   to make it inclusive.\n//\n//   inclusiveEnd:: ?bool\n//   Determines how the right side of the decoration is mapped.\n//   See\n//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\nDecoration.inline = function inline (from, to, attrs, spec) {\n  return new Decoration(from, to, new InlineType(attrs, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates a node decoration. `from` and `to` should point precisely\n// before and after a node in the document. That node, and only that\n// node, will receive the given attributes.\n//\n// spec::-\n//\n// Optional information to store with the decoration. It\n// is also used when comparing decorators for equality.\nDecoration.node = function node (from, to, attrs, spec) {\n  return new Decoration(from, to, new NodeType(attrs, spec))\n};\n\n// :: Object\n// The spec provided when creating this decoration. Can be useful\n// if you've stored extra information in that object.\nprototypeAccessors$1.spec.get = function () { return this.type.spec };\n\nprototypeAccessors$1.inline.get = function () { return this.type instanceof InlineType };\n\nObject.defineProperties( Decoration.prototype, prototypeAccessors$1 );\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nvar none = [], noSpec = {};\n\n// :: class extends DecorationSource\n// A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nvar DecorationSet = function DecorationSet(local, children) {\n  this.local = local && local.length ? local : none;\n  this.children = children && children.length ? children : none;\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Create a set of decorations, using the structure of the given\n// document.\nDecorationSet.create = function create (doc, decorations) {\n  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n};\n\n// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n// Find all decorations in this set which touch the given range\n// (including decorations that start or end directly at the\n// boundaries) and match the given predicate on their spec. When\n// `start` and `end` are omitted, all decorations in the set are\n// considered. When `predicate` isn't given, all decorations are\n// assumed to match.\nDecorationSet.prototype.find = function find (start, end, predicate) {\n  var result = [];\n  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n  return result\n};\n\nDecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {\n  for (var i = 0; i < this.local.length; i++) {\n    var span = this.local[i];\n    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n      { result.push(span.copy(span.from + offset, span.to + offset)); }\n  }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {\n    if (this.children[i$1] < end && this.children[i$1 + 1] > start) {\n      var childOff = this.children[i$1] + 1;\n      this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n    }\n  }\n};\n\n// :: (Mapping, Node, ?Object) → DecorationSet\n// Map the set of decorations in response to a change in the\n// document.\n//\n// options::- An optional set of options.\n//\n//   onRemove:: ?(decorationSpec: Object)\n//   When given, this function will be called for each decoration\n//   that gets dropped as a result of the mapping, passing the\n//   spec of that decoration.\nDecorationSet.prototype.map = function map (mapping, doc, options) {\n  if (this == empty || mapping.maps.length == 0) { return this }\n  return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n};\n\nDecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {\n  var newLocal;\n  for (var i = 0; i < this.local.length; i++) {\n    var mapped = this.local[i].map(mapping, offset, oldOffset);\n    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }\n    else if (options.onRemove) { options.onRemove(this.local[i].spec); }\n  }\n\n  if (this.children.length)\n    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }\n  else\n    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Add the given array of decorations to the ones in the set,\n// producing a new set. Needs access to the current document to\n// create the appropriate tree structure.\nDecorationSet.prototype.add = function add (doc, decorations) {\n  if (!decorations.length) { return this }\n  if (this == empty) { return DecorationSet.create(doc, decorations) }\n  return this.addInner(doc, decorations, 0)\n};\n\nDecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {\n    var this$1 = this;\n\n  var children, childIndex = 0;\n  doc.forEach(function (childNode, childOffset) {\n    var baseOffset = childOffset + offset, found;\n    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }\n\n    if (!children) { children = this$1.children.slice(); }\n    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }\n    if (children[childIndex] == childOffset)\n      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }\n    else\n      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }\n    childIndex += 3;\n  });\n\n  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n  for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }\n\n  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                           children || this.children)\n};\n\n// :: ([Decoration]) → DecorationSet\n// Create a new set that contains the decorations in this set, minus\n// the ones in the given array.\nDecorationSet.prototype.remove = function remove (decorations) {\n  if (decorations.length == 0 || this == empty) { return this }\n  return this.removeInner(decorations, 0)\n};\n\nDecorationSet.prototype.removeInner = function removeInner (decorations, offset) {\n  var children = this.children, local = this.local;\n  for (var i = 0; i < children.length; i += 3) {\n    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;\n    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {\n      if (span.from > from && span.to < to) {\n        decorations[j] = null\n        ;(found || (found = [])).push(span);\n      }\n    } }\n    if (!found) { continue }\n    if (children == this.children) { children = this.children.slice(); }\n    var removed = children[i + 2].removeInner(found, from + 1);\n    if (removed != empty) {\n      children[i + 2] = removed;\n    } else {\n      children.splice(i, 3);\n      i -= 3;\n    }\n  }\n  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {\n    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {\n      if (local == this.local) { local = this.local.slice(); }\n      local.splice(j$1--, 1);\n    } }\n  } } }\n  if (children == this.children && local == this.local) { return this }\n  return local.length || children.length ? new DecorationSet(local, children) : empty\n};\n\nDecorationSet.prototype.forChild = function forChild (offset, node) {\n  if (this == empty) { return this }\n  if (node.isLeaf) { return DecorationSet.empty }\n\n  var child, local;\n  for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {\n    if (this.children[i] == offset) { child = this.children[i + 2]; }\n    break\n  } }\n  var start = offset + 1, end = start + node.content.size;\n  for (var i$1 = 0; i$1 < this.local.length; i$1++) {\n    var dec = this.local[i$1];\n    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }\n    }\n  }\n  if (local) {\n    var localSet = new DecorationSet(local.sort(byPos));\n    return child ? new DecorationGroup([localSet, child]) : localSet\n  }\n  return child || empty\n};\n\nDecorationSet.prototype.eq = function eq (other) {\n  if (this == other) { return true }\n  if (!(other instanceof DecorationSet) ||\n      this.local.length != other.local.length ||\n      this.children.length != other.children.length) { return false }\n  for (var i = 0; i < this.local.length; i++)\n    { if (!this.local[i].eq(other.local[i])) { return false } }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)\n    { if (this.children[i$1] != other.children[i$1] ||\n        this.children[i$1 + 1] != other.children[i$1 + 1] ||\n        !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }\n  return true\n};\n\nDecorationSet.prototype.locals = function locals (node) {\n  return removeOverlap(this.localsInner(node))\n};\n\nDecorationSet.prototype.localsInner = function localsInner (node) {\n  if (this == empty) { return none }\n  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }\n  var result = [];\n  for (var i = 0; i < this.local.length; i++) {\n    if (!(this.local[i].type instanceof InlineType))\n      { result.push(this.local[i]); }\n  }\n  return result\n};\n\n// DecorationSource:: interface\n// An object that can [provide](#view.EditorProps.decorations)\n// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),\n// and passed to [node views](#view.EditorProps.nodeViews).\n//\n//   map:: (Mapping, Node) → DecorationSource\n//   Map the set of decorations in response to a change in the\n//   document.\n\nvar empty = new DecorationSet();\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty;\n\nDecorationSet.removeOverlap = removeOverlap;\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nvar DecorationGroup = function DecorationGroup(members) {\n  this.members = members;\n};\n\nDecorationGroup.prototype.map = function map (mapping, doc) {\n  var mappedDecos = this.members.map(\n    function (member) { return member.map(mapping, doc, noSpec); }\n  );\n  return DecorationGroup.from(mappedDecos)\n};\n\nDecorationGroup.prototype.forChild = function forChild (offset, child) {\n  if (child.isLeaf) { return DecorationSet.empty }\n  var found = [];\n  for (var i = 0; i < this.members.length; i++) {\n    var result = this.members[i].forChild(offset, child);\n    if (result == empty) { continue }\n    if (result instanceof DecorationGroup) { found = found.concat(result.members); }\n    else { found.push(result); }\n  }\n  return DecorationGroup.from(found)\n};\n\nDecorationGroup.prototype.eq = function eq (other) {\n  if (!(other instanceof DecorationGroup) ||\n      other.members.length != this.members.length) { return false }\n  for (var i = 0; i < this.members.length; i++)\n    { if (!this.members[i].eq(other.members[i])) { return false } }\n  return true\n};\n\nDecorationGroup.prototype.locals = function locals (node) {\n  var result, sorted = true;\n  for (var i = 0; i < this.members.length; i++) {\n    var locals = this.members[i].localsInner(node);\n    if (!locals.length) { continue }\n    if (!result) {\n      result = locals;\n    } else {\n      if (sorted) {\n        result = result.slice();\n        sorted = false;\n      }\n      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }\n    }\n  }\n  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n};\n\n// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n// Create a group for the given array of decoration sets, or return\n// a single set when possible.\nDecorationGroup.from = function from (members) {\n  switch (members.length) {\n    case 0: return empty\n    case 1: return members[0]\n    default: return new DecorationGroup(members)\n  }\n};\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  var children = oldChildren.slice();\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  var shift = function (oldStart, oldEnd, newStart, newEnd) {\n    for (var i = 0; i < children.length; i += 3) {\n      var end = children[i + 1], dSize = (void 0);\n      if (end == -1 || oldStart > end + oldOffset) { continue }\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1;\n      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {\n        children[i] += dSize;\n        children[i + 1] += dSize;\n      }\n    }\n  };\n  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  var mustRebuild = false;\n  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes\n    var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true;\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;\n    var ref = node.content.findIndex(fromLocal);\n    var index = ref.index;\n    var childOffset = ref.offset;\n    var childNode = node.maybeChild(index);\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);\n      if (mapped != empty) {\n        children[i$1] = fromLocal;\n        children[i$1 + 1] = toLocal;\n        children[i$1 + 2] = mapped;\n      } else {\n        children[i$1 + 1] = -2;\n        mustRebuild = true;\n      }\n    } else {\n      mustRebuild = true;\n    }\n  } }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options);\n    var built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {\n      children.splice(i$2, 3);\n      i$2 -= 3;\n    } }\n    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {\n      var from$1 = built.children[i$3];\n      while (j < children.length && children[j] < from$1) { j += 3; }\n      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) { return spans }\n  var result = [];\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (var i = 0; i < set.local.length; i++) {\n      var mapped = set.local[i].map(mapping, offset, oldOffset);\n      if (mapped) { decorations.push(mapped); }\n      else if (options.onRemove) { options.onRemove(set.local[i].spec); }\n    }\n    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)\n      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }\n  }\n  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)\n    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) { return null }\n  var end = offset + node.nodeSize, found = null;\n  for (var i = 0, span = (void 0); i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n(found || (found = [])).push(span);\n      spans[i] = null;\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  var result = [];\n  for (var i = 0; i < array.length; i++)\n    { if (array[i] != null) { result.push(array[i]); } }\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  var children = [], hasNulls = false;\n  node.forEach(function (childNode, localStart) {\n    var found = takeSpansForNode(spans, childNode, localStart + offset);\n    if (found) {\n      hasNulls = true;\n      var subtree = buildTree(found, childNode, offset + localStart + 1, options);\n      if (subtree != empty)\n        { children.push(localStart, localStart + childNode.nodeSize, subtree); }\n    }\n  });\n  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) { options.onRemove(locals[i].spec); }\n    locals.splice(i--, 1);\n  } }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  var working = spans;\n  for (var i = 0; i < working.length - 1; i++) {\n    var span = working[i];\n    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {\n      var next = working[j];\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to);\n          insertAhead(working, j + 1, next.copy(span.to, next.to));\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from);\n          insertAhead(working, j, span.copy(next.from, span.to));\n        }\n        break\n      }\n    } }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }\n  array.splice(i, 0, deco);\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n  var found = [];\n  view.someProp(\"decorations\", function (f) {\n    var result = f(view.state);\n    if (result && result != empty) { found.push(result); }\n  });\n  if (view.cursorWrapper)\n    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }\n  return DecorationGroup.from(found)\n}\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nvar EditorView = function EditorView(place, props) {\n  this._props = props;\n  // :: EditorState\n  // The view's current [state](#state.EditorState).\n  this.state = props.state;\n\n  this.directPlugins = props.plugins || [];\n  this.directPlugins.forEach(checkStateComponent);\n\n  this.dispatch = this.dispatch.bind(this);\n\n  this._root = null;\n  this.focused = false;\n  // Kludge used to work around a Chrome bug\n  this.trackWrites = null;\n\n  // :: dom.Element\n  // An editable DOM node containing the document. (You probably\n  // should not directly interfere with its content.)\n  this.dom = (place && place.mount) || document.createElement(\"div\");\n  if (place) {\n    if (place.appendChild) { place.appendChild(this.dom); }\n    else if (place.apply) { place(this.dom); }\n    else if (place.mount) { this.mounted = true; }\n  }\n\n  // :: bool\n  // Indicates whether the editor is currently [editable](#view.EditorProps.editable).\n  this.editable = getEditable(this);\n  this.markCursor = null;\n  this.cursorWrapper = null;\n  updateCursorWrapper(this);\n  this.nodeViews = buildNodeViews(this);\n  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n\n  this.lastSelectedViewDesc = null;\n  // :: ?{slice: Slice, move: bool}\n  // When editor content is being dragged, this object contains\n  // information about the dragged slice and whether it is being\n  // copied or moved. At any other time, it is null.\n  this.dragging = null;\n\n  initInput(this);\n\n  this.prevDirectPlugins = [];\n  this.pluginViews = [];\n  this.updatePluginViews();\n};\n\nvar prototypeAccessors$2 = { props: { configurable: true },root: { configurable: true },isDestroyed: { configurable: true } };\n\n// composing:: boolean\n// Holds `true` when a\n// [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)\n// is active.\n\n// :: DirectEditorProps\n// The view's current [props](#view.EditorProps).\nprototypeAccessors$2.props.get = function () {\n  if (this._props.state != this.state) {\n    var prev = this._props;\n    this._props = {};\n    for (var name in prev) { this._props[name] = prev[name]; }\n    this._props.state = this.state;\n  }\n  return this._props\n};\n\n// :: (DirectEditorProps)\n// Update the view's props. Will immediately cause an update to\n// the DOM.\nEditorView.prototype.update = function update (props) {\n  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }\n  this._props = props;\n  if (props.plugins) {\n    props.plugins.forEach(checkStateComponent);\n    this.directPlugins = props.plugins;\n  }\n  this.updateStateInner(props.state, true);\n};\n\n// :: (DirectEditorProps)\n// Update the view by updating existing props object with the object\n// given as argument. Equivalent to `view.update(Object.assign({},\n// view.props, props))`.\nEditorView.prototype.setProps = function setProps (props) {\n  var updated = {};\n  for (var name in this._props) { updated[name] = this._props[name]; }\n  updated.state = this.state;\n  for (var name$1 in props) { updated[name$1] = props[name$1]; }\n  this.update(updated);\n};\n\n// :: (EditorState)\n// Update the editor's `state` prop, without touching any of the\n// other props.\nEditorView.prototype.updateState = function updateState (state) {\n  this.updateStateInner(state, this.state.plugins != state.plugins);\n};\n\nEditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {\n    var this$1 = this;\n\n  var prev = this.state, redraw = false, updateSel = false;\n  // When stored marks are added, stop composition, so that they can\n  // be displayed.\n  if (state.storedMarks && this.composing) {\n    clearComposition(this);\n    updateSel = true;\n  }\n  this.state = state;\n  if (reconfigured) {\n    var nodeViews = buildNodeViews(this);\n    if (changedNodeViews(nodeViews, this.nodeViews)) {\n      this.nodeViews = nodeViews;\n      redraw = true;\n    }\n    ensureListeners(this);\n  }\n\n  this.editable = getEditable(this);\n  updateCursorWrapper(this);\n  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n\n  var scroll = reconfigured ? \"reset\"\n      : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n  if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }\n  var oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n\n  if (updateSel) {\n    this.domObserver.stop();\n    // Work around an issue in Chrome, IE, and Edge where changing\n    // the DOM around an active selection puts it into a broken\n    // state where the thing the user sees differs from the\n    // selection reported by the Selection object (#710, #973,\n    // #1011, #1013, #1035).\n    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&\n        !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n    if (updateDoc) {\n      // If the node that the selection points into is written to,\n      // Chrome sometimes starts misreporting the selection, so this\n      // tracks that and forces a selection reset when our update\n      // did write to the node.\n      var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;\n      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n        this.docView.updateOuterDeco([]);\n        this.docView.destroy();\n        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n      }\n      if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }\n    }\n    // Work around for an issue where an update arriving right between\n    // a DOM selection change and the \"selectionchange\" event for it\n    // can cause a spurious DOM selection update, disrupting mouse\n    // drag selection.\n    if (forceSelUpdate ||\n        !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {\n      selectionToDOM(this, forceSelUpdate);\n    } else {\n      syncNodeSelection(this, state.selection);\n      this.domObserver.setCurSelection();\n    }\n    this.domObserver.start();\n  }\n\n  this.updatePluginViews(prev);\n\n  if (scroll == \"reset\") {\n    this.dom.scrollTop = 0;\n  } else if (scroll == \"to selection\") {\n    var startDOM = this.root.getSelection().focusNode;\n    if (this.someProp(\"handleScrollToSelection\", function (f) { return f(this$1); }))\n      ; // Handled\n    else if (state.selection instanceof NodeSelection)\n      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }\n    else\n      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }\n  } else if (oldScrollPos) {\n    resetScrollPos(oldScrollPos);\n  }\n};\n\nEditorView.prototype.destroyPluginViews = function destroyPluginViews () {\n  var view;\n  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }\n};\n\nEditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {\n  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n    this.prevDirectPlugins = this.directPlugins;\n    this.destroyPluginViews();\n    for (var i = 0; i < this.directPlugins.length; i++) {\n      var plugin = this.directPlugins[i];\n      if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }\n    }\n    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {\n      var plugin$1 = this.state.plugins[i$1];\n      if (plugin$1.spec.view) { this.pluginViews.push(plugin$1.spec.view(this)); }\n    }\n  } else {\n    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {\n      var pluginView = this.pluginViews[i$2];\n      if (pluginView.update) { pluginView.update(this, prevState); }\n    }\n  }\n};\n\n// :: (string, ?(prop: *) → *) → *\n// Goes over the values of a prop, first those provided directly,\n// then those from plugins given to the view, then from plugins in\n// the state (in order), and calls `f` every time a non-undefined\n// value is found. When `f` returns a truthy value, that is\n// immediately returned. When `f` isn't provided, it is treated as\n// the identity function (the prop value is returned directly).\nEditorView.prototype.someProp = function someProp (propName, f) {\n  var prop = this._props && this._props[propName], value;\n  if (prop != null && (value = f ? f(prop) : prop)) { return value }\n  for (var i = 0; i < this.directPlugins.length; i++) {\n    var prop$1 = this.directPlugins[i].props[propName];\n    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }\n  }\n  var plugins = this.state.plugins;\n  if (plugins) { for (var i$1 = 0; i$1 < plugins.length; i$1++) {\n    var prop$2 = plugins[i$1].props[propName];\n    if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) { return value }\n  } }\n};\n\n// :: () → bool\n// Query whether the view has focus.\nEditorView.prototype.hasFocus = function hasFocus () {\n  return this.root.activeElement == this.dom\n};\n\n// :: ()\n// Focus the editor.\nEditorView.prototype.focus = function focus () {\n  this.domObserver.stop();\n  if (this.editable) { focusPreventScroll(this.dom); }\n  selectionToDOM(this);\n  this.domObserver.start();\n};\n\n// :: union<dom.Document, dom.DocumentFragment>\n// Get the document root in which the editor exists. This will\n// usually be the top-level `document`, but might be a [shadow\n// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n// root if the editor is inside one.\nprototypeAccessors$2.root.get = function () {\n  var cached = this._root;\n  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {\n    if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n      if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }\n      return this._root = search\n    }\n  } }\n  return cached || document\n};\n\n// :: ({left: number, top: number}) → ?{pos: number, inside: number}\n// Given a pair of viewport coordinates, return the document\n// position that corresponds to them. May return null if the given\n// coordinates aren't inside of the editor. When an object is\n// returned, its `pos` property is the position nearest to the\n// coordinates, and its `inside` property holds the position of the\n// inner node that the position falls inside of, or -1 if it is at\n// the top level, not in any node.\nEditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {\n  return posAtCoords(this, coords)\n};\n\n// :: (number, number) → {left: number, right: number, top: number, bottom: number}\n// Returns the viewport rectangle at a given document position.\n// `left` and `right` will be the same number, as this returns a\n// flat cursor-ish rectangle. If the position is between two things\n// that aren't directly adjacent, `side` determines which element is\n// used. When < 0, the element before the position is used,\n// otherwise the element after.\nEditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {\n    if ( side === void 0 ) side = 1;\n\n  return coordsAtPos(this, pos, side)\n};\n\n// :: (number, number) → {node: dom.Node, offset: number}\n// Find the DOM position that corresponds to the given document\n// position. When `side` is negative, find the position as close as\n// possible to the content before the position. When positive,\n// prefer positions close to the content after the position. When\n// zero, prefer as shallow a position as possible.\n//\n// Note that you should **not** mutate the editor's internal DOM,\n// only inspect it (and even that is usually not necessary).\nEditorView.prototype.domAtPos = function domAtPos (pos, side) {\n    if ( side === void 0 ) side = 0;\n\n  return this.docView.domFromPos(pos, side)\n};\n\n// :: (number) → ?dom.Node\n// Find the DOM node that represents the document node after the\n// given position. May return `null` when the position doesn't point\n// in front of a node or if the node is inside an opaque node view.\n//\n// This is intended to be able to call things like\n// `getBoundingClientRect` on that DOM node. Do **not** mutate the\n// editor DOM directly, or add styling this way, since that will be\n// immediately overriden by the editor as it redraws the node.\nEditorView.prototype.nodeDOM = function nodeDOM (pos) {\n  var desc = this.docView.descAt(pos);\n  return desc ? desc.nodeDOM : null\n};\n\n// :: (dom.Node, number, ?number) → number\n// Find the document position that corresponds to a given DOM\n// position. (Whenever possible, it is preferable to inspect the\n// document structure directly, rather than poking around in the\n// DOM, but sometimes—for example when interpreting an event\n// target—you don't have a choice.)\n//\n// The `bias` parameter can be used to influence which side of a DOM\n// node to use when the position is inside a leaf node.\nEditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {\n    if ( bias === void 0 ) bias = -1;\n\n  var pos = this.docView.posFromDOM(node, offset, bias);\n  if (pos == null) { throw new RangeError(\"DOM position not inside the editor\") }\n  return pos\n};\n\n// :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n// Find out whether the selection is at the end of a textblock when\n// moving in a given direction. When, for example, given `\"left\"`,\n// it will return true if moving left from the current cursor\n// position would leave that position's parent textblock. Will apply\n// to the view's current state by default, but it is possible to\n// pass a different state.\nEditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {\n  return endOfTextblock(this, state || this.state, dir)\n};\n\n// :: ()\n// Removes the editor from the DOM and destroys all [node\n// views](#view.NodeView).\nEditorView.prototype.destroy = function destroy () {\n  if (!this.docView) { return }\n  destroyInput(this);\n  this.destroyPluginViews();\n  if (this.mounted) {\n    this.docView.update(this.state.doc, [], viewDecorations(this), this);\n    this.dom.textContent = \"\";\n  } else if (this.dom.parentNode) {\n    this.dom.parentNode.removeChild(this.dom);\n  }\n  this.docView.destroy();\n  this.docView = null;\n};\n\n// :: boolean\n// This is true when the view has been\n// [destroyed](#view.EditorView.destroy) (and thus should not be\n// used anymore).\nprototypeAccessors$2.isDestroyed.get = function () {\n  return this.docView == null\n};\n\n// Used for testing.\nEditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {\n  return dispatchEvent(this, event)\n};\n\n// :: (Transaction)\n// Dispatch a transaction. Will call\n// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n// when given, and otherwise defaults to applying the transaction to\n// the current state and calling\n// [`updateState`](#view.EditorView.updateState) with the result.\n// This method is bound to the view instance, so that it can be\n// easily passed around.\nEditorView.prototype.dispatch = function dispatch (tr) {\n  var dispatchTransaction = this._props.dispatchTransaction;\n  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }\n  else { this.updateState(this.state.apply(tr)); }\n};\n\nObject.defineProperties( EditorView.prototype, prototypeAccessors$2 );\n\nfunction computeDocDeco(view) {\n  var attrs = Object.create(null);\n  attrs.class = \"ProseMirror\";\n  attrs.contenteditable = String(view.editable);\n  attrs.translate = \"no\";\n\n  view.someProp(\"attributes\", function (value) {\n    if (typeof value == \"function\") { value = value(view.state); }\n    if (value) { for (var attr in value) {\n      if (attr == \"class\")\n        { attrs.class += \" \" + value[attr]; }\n      if (attr == \"style\") {\n        attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n      }\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        { attrs[attr] = String(value[attr]); }\n    } }\n  });\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    var dom = document.createElement(\"img\");\n    dom.className = \"ProseMirror-separator\";\n    dom.setAttribute(\"mark-placeholder\", \"true\");\n    view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};\n  } else {\n    view.cursorWrapper = null;\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", function (value) { return value(view.state) === false; })\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)\n}\n\nfunction buildNodeViews(view) {\n  var result = {};\n  view.someProp(\"nodeViews\", function (obj) {\n    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))\n      { result[prop] = obj[prop]; } }\n  });\n  return result\n}\n\nfunction changedNodeViews(a, b) {\n  var nA = 0, nB = 0;\n  for (var prop in a) {\n    if (a[prop] != b[prop]) { return true }\n    nA++;\n  }\n  for (var _ in b) { nB++; }\n  return nA != nB\n}\n\nfunction checkStateComponent(plugin) {\n  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n    { throw new RangeError(\"Plugins passed directly to the view must not have a state component\") }\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string, plain: bool) → string\n//   Transform pasted plain text. The `plain` flag will be true when\n//   the text is pasted as plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//   The `plain` flag will be true when the text is pasted as plain text.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   `innerDecorations` holds the decorations for the node's content.\n//   You can safely ignore this if your view has no content or a\n//   `contentDOM` property, since the editor will draw the decorations\n//   on the content. But if you, for example, want to create a nested\n//   editor with the content, it may make sense to provide it with the\n//   inner decorations.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSource\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   plugins:: [Plugin]\n//   A set of plugins to use in the view, applying their [plugin\n//   view](#state.PluginSpec.view) and\n//   [props](#state.PluginSpec.props). Passing plugins with a state\n//   component (a [state field](#state.PluginSpec.state) field or a\n//   [transaction](#state.PluginSpec.filterTransaction) filter or\n//   appender) will result in an error, since such plugins must be\n//   present in the state to work.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n\nexport { Decoration, DecorationSet, EditorView, endComposition as __endComposition, parseFromClipboard as __parseFromClipboard, serializeForClipboard as __serializeForClipboard };\n//# sourceMappingURL=index.es.js.map\n"],"names":["deleteSelection","state","dispatch","selection","empty","tr","scrollIntoView","joinBackward","view","$cursor","endOfTextblock","parentOffset","$cut","findCutBefore","range","blockRange","target","lift","before","nodeBefore","type","spec","isolating","deleteBarrier","parent","content","size","textblockAt","delStep","doc","after","slice","to","from","step","setSelection","resolve","mapping","map","pos","nodeSize","isAtom","depth","delete","node","side","only","firstChild","lastChild","isTextblock","childCount","selectNodeBackward","ref","$head","$pos","i","index","joinForward","findCutAfter","nodeAfter","selectNodeForward","newlineInCode","$anchor","code","sameParent","insertText","defaultBlockAt","match","edgeCount","edge","hasRequiredAttrs","exitCode","above","indexAfter","contentMatchAt","canReplaceWith","replaceWith","createAndFill","createParagraphNear","sel","$from","$to","inlineContent","insert","liftEmptyBlock","end","split","splitBlock","isBlock","atEnd","deflt","types","can","first","$first","setNodeMarkup","conn","compatibleContent","canReplace","clearIncompatible","join","joinMaybeClear","canDelAfter","findWrapping","matchType","validEnd","wrap","length","create","copy","joinAt","selAfter","at","wrap$1","push","afterText","afterDepth","end$1","i$1","selectTextblockSide","isInline","start","selectTextblockStart","selectTextblockEnd","setBlockType","nodeType","attrs","applicable","nodesBetween","hasMarkup","chainCommands","commands","len","arguments","backspace","del","pcBaseKeymap","macBaseKeymap","key","Home","End","navigator","test","platform","os","wrapInList","listType","doJoin","outerRange","startIndex","$insert","endIndex","wrappers","joinBefore","found","splitDepth","splitPos","i$2","e","child","doWrapInList","liftListItem","itemType","endOfList","liftToOuterList","list","$start","item","atStart","indexBefore","append","liftOutOfList","isPlainObject","value","Object","prototype","toString","call","getType","constructor","getPrototypeOf","mergeDeep","source","output","keys","forEach","assign","isFunction","callOrReturn","context","props","bind","getExtensionField","extension","field","undefined","config","Extension","this","name","defaultOptions","console","warn","options","addOptions","storage","static","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","text","separated","_a","textSerializer","isText","Math","max","getTextSeralizersFromSchema","schema","fromEntries","entries","nodes","filter","toText","ClipboardTextSerializer","addProseMirrorPlugins","clipboardTextSerializer","editor","ranges","min","blur$1","freeze","__proto__","blur","requestAnimationFrame","isDestroyed","dom","window","getSelection","removeAllRanges","clearContent$1","clearContent","emitUpdate","setContent","clearNodes$1","clearNodes","$mappedFrom","$mappedTo","nodeRange","targetLiftDepth","defaultType","command$1","command","fn","createParagraphNear$1","getNodeType","nameOrType","Error","deleteNode$1","deleteNode","typeOrName","deleteRange$1","deleteRange","deleteSelection$1","enter$1","enter","keyboardShortcut","exitCode$1","getMarkType","marks","isRegExp","objectIncludes","object1","object2","strict","every","findMarkInSet","attributes","find","isMarkInSet","getMarkRange","childAfter","mark","startPos","offset","endPos","isInSet","extendMarkRange$1","extendMarkRange","newSelection","first$1","items","isObject","Array","isArray","substring","isClass","isTextSelection","isiOS","includes","userAgent","document","minMax","resolveFocusPosition","position","minPos","maxPos","resolvedFrom","resolvedEnd","focus$1","focus","delayedFocus","hasFocus","isSameSelection","eq","storedMarks","setStoredMarks","forEach$1","insertContent$1","insertContent","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","nodeFromJSON","error","parser","parseSlice","parse","insertContentAt$1","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","startsWith","check","startLen","bias","last","steps","maps","_from","_to","_newFrom","newTo","selectionToInsertionEnd","joinBackward$1","joinForward$1","isMacOS","keyboardShortcut$1","parts","alt","ctrl","shift","meta","result","mod","normalizeKeyName","event","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","reduce","sum","lift$1","liftEmptyBlock$1","liftListItem$1","newlineInCode$1","getSchemaTypeNameByName","deleteProps","obj","propOrProps","newObj","prop","resetAttributes$1","resetAttributes","markType","schemaType","addMark","scrollIntoView$1","selectAll$1","selectAll","setTextSelection","selectNodeBackward$1","selectNodeForward$1","selectParentNode$1","selectParentNode","same","sharedDepth","selectTextblockEnd$1","selectTextblockStart$1","createDocument","setContent$1","replaceSelectionWith","setMeta","getMarkAttributes","markItem","setMark$1","setMark","oldAttributes","addStoredMark","trimmedFrom","trimmedTo","setMeta$1","setNode$1","setNode","chain","updatedState","run","setNodeSelection$1","setNodeSelection","resolvedPos","setTextSelection$1","sinkListItem$1","sinkListItem","nestedBefore","inner","getSplittedAttributes","extensionAttributes","typeName","extensionAttribute","attribute","keepOnSplit","ensureMarks","splittableMarks","filteredMarks","splitBlock$1","keepMarks","newAttributes","extensionManager","defaultBlockAt$1","splitListItem$1","splitListItem","grandParent","depthBefore","d","depthAfter","newNextTypeAttributes","nextType","contentMatch","replace","n","newTypeAttributes","findParentNodeClosestToPos","predicate","findParentNode","splitExtensions","extensions","baseExtensions","nodeExtensions","markExtensions","isList","group","joinListBackwards","nodeAt","joinListForwards","toggleList$1","toggleList","listTypeOrName","itemTypeOrName","parentList","validContent","isMarkActive","markRanges","matchedRange","markRange","excludedRange","excludes","toggleMark$1","toggleMark","extendEmptyMarkRange","unsetMark","toggleNode$1","toggleNode","toggleTypeOrName","toggleType","toggleWrap$1","toggleWrap","wrapIn","undoInputRule$1","undoInputRule","plugins","plugin","undoable","isInputRules","getState","toUndo","transform","j","invert","docs","unsetAllMarks$1","unsetAllMarks","removeMark","unsetMark$1","removeStoredMark","updateAttributes$1","updateAttributes","wrapIn$1","wrapping","wrapInList$1","Commands","addCommands","Editable","editable","FocusEvents","handleDOMEvents","isFocused","transaction","createChainableState","apply","applyTransaction","reconfigure","toJSON","CommandManager","rawCommands","customState","hasCustomState","buildProps","args","callback","getMeta","createChain","createCan","startTr","shouldDispatch","callbacks","hasStartTransaction","formattedCommands","Keymap","addKeyboardShortcuts","handleBackspace","isAtStart","textContent","handleDelete","baseKeymap","Enter","Backspace","Delete","pcKeymap","macKeymap","appendTransaction","transactions","oldState","newState","some","docChanged","allFrom","allEnd","allWasSelected","isEmpty","textBetween","Tabindex","tabindex","getNodeAttributes","reverse","nodeItem","getAttributes","isActive","getHTMLFromFragment","fragment","documentFragment","serializeFragment","container","implementation","createHTMLDocument","createElement","appendChild","innerHTML","getText","isNodeEmpty","defaultContent","JSON","stringify","InputRule","handler","run$1","rules","composing","matched","textBefore","rule","exec","inputRuleMatch","input","data","inputRuleMatcherHandler","inputRulesPlugin","init","prev","stored","selectionSet","handleTextInput","compositionend","setTimeout","handleKeyDown","PasteRule","handlers","resolvedTo","matchAll","matches","pasteRuleMatch","pasteRuleMatcherHandler","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","parentElement","contains","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","getAttributesFromExtensions","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","addGlobalAttributes","globalAttribute","addAttributes","mergeAttributes","objects","mergedAttributes","getRenderedAttributes","nodeOrMark","injectExtensionAttributesToParseRule","parseRule","style","getAttrs","Number","fromString","getAttribute","cleanUpSchemaItem","isEmptyObject","getSchemaByResolvedExtensions","allAttributes","topNode","fields","extendNodeSchema","inline","atom","selectable","draggable","defining","parseDOM","toDOM","HTMLAttributes","renderText","extendMarkSchema","inclusive","spanning","getSchemaTypeByName","isExtensionRulesEnabled","enabled","enabledExtension","ExtensionManager","extensionStorage","onBeforeCreate","on","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","filtered","el","indexOf","Set","findDuplicates","addExtensions","flat","a","priorityA","priorityB","inputRules","pasteRules","allPlugins","bindings","shortcut","method","keyMapPlugin","addInputRules","enableInputRules","addPasteRules","enablePasteRules","proseMirrorPlugins","nodeViews","addNodeView","getPos","decorations","Editor","emit","off","removeAllListeners","super","element","injectCSS","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","tipTapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","createStyleTag","setProps","updateState","setEditable","isEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","allExtensions","values","dispatchTransaction","createNodeViews","selectionHasChanged","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getCharacterCount","docView","Node","Mark","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","_b","_c","dragHandle","closest","x","y","domBox","getBoundingClientRect","handleBox","offsetX","offsetY","dataTransfer","setDragImage","isDropEvent","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","isDragEvent","preventDefault","once","mutation","isLeaf","addedNodes","removedNodes","Tracker","currentStep","deleted","newPosition","mapResult","getMap","nodeInputRule","matchStart","lastIndexOf","lastChar","getMarksBetween","markInputRule","captureGroup","fullMatch","markEnd","startSpaces","search","textStart","textEnd","excluded","textblockTypeInputRule","textInputRule","cutOff","wrappingInputRule","joinPredicate","markPasteRule","textPasteRule","escapeForRegEx","string","combineTransactionSteps","oldDoc","findChildren","nodesWithPos","descendants","findChildrenInRange","getSchema","generateHTML","generateJSON","generateText","simplifyChangedRanges","changes","uniqueChanges","array","by","seen","hasOwnProperty","removeDuplicates","change","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","newStart","newEnd","oldStart","oldEnd","getDebugJSON","startOffset","increment","topNodeType","isNodeSelection","posToDOMRect","coordsAtPos","top","bottom","left","right","width","height","base","chrome","safari","vendor","gecko","mac","ie","brokenModifierNames","String","fromCharCode","modifiers","keymap","keydownHandler","normalize","baseName","keyCode","keyName","isChar","direct","charCodeAt","fromCode","withShift","OrderedMap","get","update","newKey","self","remove","splice","addToStart","concat","addToEnd","addBefore","place","without","prepend","subtract","childA","childB","sameMarkup","posA","posB","iA","iB","minSize","Fragment","prototypeAccessors","configurable","nodeStart","leafText","other","withText","cut","cutByIndex","replaceChild","current","RangeError","maybeChild","p","otherPos","findIndex","round","retIndex","curPos","toStringInner","fromJSON","fromArray","joined","defineProperties","compareDeep","p$1","ReplaceError","message","err","addToSet","set","placed","rank","removeFromSet","json","sameSet","setFrom","none","Slice","openStart","openEnd","prototypeAccessors$1","removeRange","ref$1","indexTo","offsetTo","insertInto","dist","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","replaceThreeWay","replaceTwoWay","checkJoin","main","sub","joinable","$before","$after","addNode","addRange","$end","textOffset","insertAt","removeBetween","maxOpen","openIsolating","n$1","ResolvedPos","path","prototypeAccessors$2","resolveDepth","val","dOff","posAtIndex","tmp","marksAcross","next","pred","NodeRange","str","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1$1","emptyAttrs","prototypeAccessors$3","defaultAttrs","includeParents","childBefore","rangeHasMark","toDebugString","wrapMarks","matchFragment","replacement","one","two","allowsMarks","canAppend","m","markFromJSON","TextNode","ContentMatch","wrapCache","prototypeAccessors$4","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","nullFrom","states","out","term","known","states$1","cmp","dfa","connect","compile","edges","exprs","loop","loop$1","cur","next$1","next$2","work","dead","checkForDeadEnds","frag","compatible","fillBefore","toEnd","finished","tp","computed","computeWrapping","active","via","scan","tokens","pop","prototypeAccessors$1$2","parseExprSeq","eat","parseExprSubscript","type$1","groups","resolveName","parseExprAtom","parseExprRange","parseNum","defaults","attrName","attr","hasDefault","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","markSet","prototypeAccessors$5","whitespace","isRequired","createChecked","allowsMarkType","allowedMarks","topType","prototypeAccessors$1$3","MarkType","instance","Schema","contentExprCache","prop$1","contentExpr","markExpr","gatherMarks","prop$2","excl","wrappings","ok","mark$1","text$1","this$1","tags","styles","tag","normalizeLists","r","ParseContext","addAll","finish","matchTag","namespace","namespaceURI","matchesContext","matchStyle","schemaRules","priority","rules$1","name$1","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","wsOptionsFor","OPT_PRESERVE_WS","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","popFromStashMark","applyPending","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","prototypeAccessors$6","currentPos","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","v","returned","addDOM","addTextNode","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","prevItem","nextSibling","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","startIn","getContent","contentElement","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","compareDocumentPosition","textNode","option","useRoot","minDepth","part","$context","findSameMarkInSet","upto","level","stashMark","DOMSerializer","gatherToDOM","createDocumentFragment","keep","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","structure","xmlNS","space","createElementNS","space$1","setAttributeNS","innerContent","domSerializer","nodesFromSchema","marksFromSchema","classesById","Selection","SelectionRange","anchor","lastNode","lastParent","mapFrom","replaceRange","replaceRangeWith","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","AllSelection","cls","jsonID","id","selectionClass","getBookmark","between","visible","TextBookmark","dPos","NodeSelection","NodeBookmark","AllBookmark","Transaction","Transform","time","Date","now","curSelection","curSelectionFor","updated","storedMarksSet","isGeneric","scrolledIntoView","addStep","setTime","replaceSelection","inheritMarks","FieldDesc","desc","baseFields","_marks","_old","Configuration","pluginsByKey","EditorState","filterTransaction","rootTr","trs","applyInner","haveNew","newInstance","applyListeners","$config","pluginFields","addApplyListener","removeApplyListener","bindProps","Function","Plugin","createKey","PluginKey","factor16","pow","recoverIndex","MapResult","recover","StepMap","inverted","diff","recoverOffset","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","Mapping","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","mustOverride","failed","stepsByID","Step","_doc","_mapping","merge","_other","stepType","stepClass","StepResult","fail","fromReplace","ReplaceStep","contentBetween","slice$1","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","canCut","liftTarget","innerRange","around","outer","findWrappingOutside","inside","innerMatch","findWrappingInside","withAttrs","canSplit","typesAfter","innerType","index$1","rest","baseType","canJoin","dropPoint","pass","insertPos","fits","mapFragment","mapped","gapStart","gapEnd","splitting","d$1","splitting$1","canChangeType","startM","endM","newNode","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","replaceStep","fitsTrivially","Fitter","fit","removed","added","removing","adding","newSet","s","toRemove","found$1","parentType","delSteps","allowed","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","close","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","match$1","move","targetDepths","preferredTarget","unshift","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","point","insertPoint","covered","ie_edge","ie_upto10","ie_11up","ie_version","documentMode","gecko_version","chrome_version","ios","maxTouchPoints","android","webkit","documentElement","webkit_version","domIndex","assignedSlot","host","reusedRange","textRange","createRange","setEnd","setStart","isEquivalentPosition","targetNode","targetOff","scanFor","atomElements","hasBlockDesc","contentEditable","pmViewDesc","selectionCollapsed","domSel","collapsed","isCollapsed","rangeCount","getRangeAt","keyEvent","createEvent","initEvent","windowRect","clientWidth","clientHeight","getSide","clientRect","rect","scaleX","offsetWidth","scaleY","offsetHeight","scrollRectIntoView","startDOM","scrollThreshold","scrollMargin","atTop","bounding","moveX","moveY","defaultView","scrollBy","startX","scrollLeft","startY","scrollTop","dX","dY","scrollStack","stack","restoreScrollStack","dTop","preventScrollSupported","findOffsetInNode","coords","coordsClosest","dxClosest","rowBot","rowTop","childIndex","rects","getClientRects","dx","singleRect","inRect","findOffsetInText","elementFromPoint","box","startI","floor","posAtCoords","assign$1","caretPositionFromPoint","pos$1","offsetNode","caretRangeFromPoint","startContainer","elt","root","targetKludge","box$1","outside","nearestDesc","posBefore","posAfter","posFromDOM","posFromCaret","posFromElement","posAtStart","border","BIDI","domFromPos","supportEmptyRange","takeSide","flattenV","rectBefore","rectAfter","flattenH","before$1","after$1","ignoreForCoords","target$1","withFlushedState","viewState","activeElement","maybeRTL","cachedState","cachedDir","cachedResult","nearest","boxes","endOfTextblockVertical","modify","oldNode","focusNode","oldOff","focusOffset","oldBidiLevel","caretBidiLevel","domAfterPos","endOfTextblockHorizontal","ViewDesc","children","dirty","posAtEnd","contentLost","domAtom","matchesWidget","matchesMark","matchesNode","matchesHack","_nodeName","posBeforeChild","localPosFromDOM","domBefore","domAfter","desc$1","search$1","onlyNodes","getDesc","nodeDOM","descAt","TrailingHackViewDesc","WidgetViewDesc","widget","prev$1","parseRange","fromOffset","toOffset","childBase","emptyChildAt","j$1","force","anchorDOM","headDOM","brKludge","offset$1","anchorNode","anchorOffset","domSelExtended","collapse","DOMException","markDirty","startInside","endInside","markParentsDirty","nothing","raw","classList","stop","ignoreSelection","CompositionViewDesc","textDOM","mut","oldValue","MarkViewDesc","custom","reparseInView","replaceNodes","NodeViewDesc","outerDeco","innerDeco","updateChildren","descObj","hasAttribute","applyOuterDeco","CustomNodeViewDesc","TextViewDesc","sameOuterDeco","composition","localCompositionInfo","localComposition","compositionInChild","updater","ViewTreeUpdater","deco","onWidget","onNode","locals","forChild","decoIndex","restNode","parentIndex","widgets","compareSide","child$1","cutAt","i$3","iterDeco","insideNode","syncToMarks","placeWidget","compIndex","findNodeMatch","findIndexWithChild","updateNodeAt","updateNextNode","addTextblockHacks","destroyRest","changed","protectLocalComposition","renderDescs","oldCSS","cssText","getComputedStyle","listStyle","iosHacks","nearbyTextNode","textPos","childStart","findTextInFragment","removeChild","compositionNodes","updateInner","updateOuterDeco","needsWrap","oldDOM","patchOuterDeco","computeOuterDeco","selectNode","deselectNode","removeAttribute","docViewDesc","pmIsDeco","inParent","trackWrites","parentDOM","descs","written","childDOM","rm","insertBefore","OuterDecoLevel","noDeco","class","outerDOM","prevComputed","curComputed","curDOM","patchAttributes","prevList","Boolean","curList","removeProperty","lockedNode","lock","preMatch","parentDesc","curDesc","descI","fI","Map","selectionFromDOM","origin","inWidget","isOnEdge","selectionBetween","editorOwnsSelection","hasSelection","selectionToDOM","syncNodeSelection","mouseDown","allowDefault","curSel","domObserver","currentSelection","delayedSelectionSync","setCurSelection","disconnectSelection","cursorWrapper","img","disabled","selectCursorWrapper","resetEditableFrom","resetEditableTo","brokenSelectBetweenUneditable","temporarilyEditableNear","resetEditable","hideSelectionGuard","removeClassOnSelectionChange","connectSelection","destroyBetween","maxKeep","markDesc","targetDesc","has","domNode","nextDOM","addHackNode","className","wasDraggable","lastSelectedViewDesc","clearNodeSelection","moveSelectionBlock","$side","selectHorizontally","mods","nodePos","nodeLen","isIgnorable","skipIgnoredNodesLeft","moveNode","moveOffset","isBlockNode","setSelFocus","skipIgnoredNodesRight","selectVertically","beyond","stopNativeHorizontalDelete","nextNode","switchEditable","captureKeyDown","getMods","safariDownArrowBug","readDOMChange","typeOver","lastSelectionTime","lastSelectionOrigin","newSel","tr$1","shared","from_","to_","lastKeyCode","startDoc","editableContent","anchor$1","parseBetween","preferredPos","preferredSide","compare","lastKeyCodeTime","endA","endB","findDiff","lastIOSEnter","sel$1","resolveSelection","domChangeCount","nextSel","inlineChange","old","$newStart","$newEnd","skipClosingAndOpening","$next","looksLikeJoin","suppressSelectionUpdates","toB","lastAndroidDelete","markChange","$from1","chFrom","chTo","curMarks","prevMarks","isMarkChange","sel$2","parsedSel","fromEnd","mayOpen","serializeForClipboard","serializer","detachedDoc","wrapMap","wrapper","parseFromClipboard","plainText","inCode","asText","parsed","metas","firstTag","readHTML","querySelectorAll","restoreReplacedSpaces","contextNode","sliceData","inlineParents","addContext","closeSlice","lastWrap","inLast","addToSibling","closeRight","wrapped","withWrappers","normalizeSiblings","node$1","sibling","closeRange","thead","tbody","caption","colgroup","col","td","th","_detachedDoc","observeOptions","childList","characterData","characterDataOldValue","attributeOldValue","subtree","useCharData","SelectionState","DOMObserver","handleDOMChange","queue","flushingSoon","observer","MutationObserver","mutations","flushSoon","flush","onCharData","prevValue","onSelectionChange","suppressingSelectionUpdates","forceFlush","clearTimeout","observe","take","takeRecords","disconnect","ignoreSelectionChange","commonAncestorContainer","result$1","registerMutation","brs","cssChecked","whiteSpace","checkCSS","attributeName","editHandlers","setSelectionOrigin","ensureListeners","currentHandlers","eventHandlers","runCustomHandler","defaultPrevented","eventCoords","clientX","clientY","runHandlerOnContext","propName","focused","handleSingleClick","selectedNode","selectAt","selectClickedNode","selectClickedLeaf","handleDoubleClick","handleTripleClick","button","defaultTripleClick","forceDOMFlush","endComposition","keydown","inOrNearComposition","lastIOSEnterFallbackTimeout","keyup","keypress","charCode","selectNodeModifier","mousedown","flushed","lastClick","click","dy","isNear","done","MouseDown","targetPos","mightDrag","addAttr","setUneditable","up","abs","timeStamp","compositionEndedAt","buttons","touchdown","contextmenu","timeoutComposition","scheduleComposeEnd","delay","composingTimeout","clearComposition","forceUpdate","compositionstart","compositionupdate","markCursor","brokenClipboardAPI","doPaste","singleNode","sliceSingleNode","clearData","setData","selectNodeContents","captureCopy","capturePaste","Dragging","dragCopyModifier","dragstart","effectAllowed","dragging","dragend","dragover","dragenter","eventPos","$mouse","isNode","beforeInsert","relatedTarget","beforeinput","inputType","compareObjs","WidgetType","noSpec","span","oldOffset","Decoration","valid","InlineType","inclusiveStart","inclusiveEnd","is","DecorationSet","local","buildTree","findInner","childOff","mapInner","newLocal","onRemove","oldChildren","dSize","mustRebuild","fromLocal","toLocal","childOffset","childNode","gather","mapAndGatherRemainingDecorations","from$1","byPos","mapChildren","addInner","baseOffset","takeSpansForNode","moveSpans","withoutNulls","removeInner","span$1","dec","localSet","DecorationGroup","removeOverlap","localsInner","members","spans","hasNulls","localStart","working","insertAhead","viewDecorations","mappedDecos","member","sorted","EditorView","_props","directPlugins","checkStateComponent","_root","mounted","getEditable","updateCursorWrapper","buildNodeViews","computeDocDeco","eventBelongsToView","initInput","prevDirectPlugins","pluginViews","updatePluginViews","contenteditable","translate","updateStateInner","reconfigured","redraw","updateSel","nA","nB","changedNodeViews","scroll","scrollToSelection","updateDoc","sel1","sel2","refDOM","refTop","newRefTop","oldScrollPos","overflowAnchor","innerHeight","localRect","storeScrollPos","forceSelUpdate","chromeKludge","destroyPluginViews","prevState","pluginView","plugin$1","setActive","preventScroll","focusPreventScroll","domAtPos","posAtDOM","destroyInput","dispatchEvent"],"sourceRoot":""}